; ModuleID = './aircrack/aircrack-ng_added.bc'
source_filename = "llvm-link"
target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

%struct.options = type { i32, i32, i32, [33 x i8], [6 x i8], i32, i32, [64 x i8], [64 x i32], [6 x i8], i32, i32, float, i32, i32, i32, i32, i32, i32, i32, i32, [128 x i8*], %struct._IO_FILE*, i32, i32, [128 x i32], i32, i32, i32, i32, [17 x i32], [64 x i32], i32, i32, i8*, i8*, %struct.mergeBSSID*, %struct.AP_info*, i32, i32, i32, i32, i8* }
%struct._IO_FILE = type { i32, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, %struct._IO_marker*, %struct._IO_FILE*, i32, i32, i64, i16, i8, [1 x i8], i8*, i64, i8*, i8*, i8*, i8*, i64, i32, [20 x i8] }
%struct._IO_marker = type { %struct._IO_marker*, %struct._IO_FILE*, i32 }
%struct.mergeBSSID = type { [6 x i8], [2 x i8], i32, %struct.mergeBSSID* }
%struct.AP_info = type { %struct.AP_info*, [6 x i8], [33 x i8], [4 x i8], i8*, i8**, i64, i64, i64, i64, i32, i32, i32, %struct.ST_info*, %struct.WPA_hdsk, %struct.PTW_attackstate*, %struct.PTW_attackstate* }
%struct.ST_info = type { %struct.AP_info*, %struct.ST_info*, %struct.WPA_hdsk, [6 x i8] }
%struct.WPA_hdsk = type { [6 x i8], [32 x i8], [32 x i8], [16 x i8], [256 x i8], i32, i32, i32 }
%struct.PTW_attackstate = type { i32, [2097152 x i8], i32, [10000 x %struct.PTW_session], [29 x [256 x %struct.PTW_tableentry]], %struct.PTW_session*, i32 }
%struct.PTW_session = type { [3 x i8], [32 x i8], i32 }
%struct.PTW_tableentry = type { i32, i8 }
%struct.WEP_data = type { [64 x i8], i8*, i32, i64, i64, [64 x i32], [64 x i32], [64 x [256 x %struct.vote]] }
%struct.vote = type { i32, i32 }
%union.pthread_mutex_t = type { %struct.__pthread_mutex_s }
%struct.__pthread_mutex_s = type { i32, i32, i32, i32, i32, i16, i16, %struct.__pthread_internal_list }
%struct.__pthread_internal_list = type { %struct.__pthread_internal_list*, %struct.__pthread_internal_list* }
%union.pthread_cond_t = type { %struct.__pthread_cond_s }
%struct.__pthread_cond_s = type { %union.anon, %union.anon, [2 x i32], [2 x i32], i32, i32, [2 x i32] }
%union.anon = type { i64 }
%struct.timeval = type { i64, i64 }
%struct.WPA_data = type { %struct.AP_info*, i32, i32, i8*, i32, i32, [128 x i8], %union.pthread_cond_t, %union.pthread_mutex_t }
%struct.option = type { i8*, i32, i32*, i32 }
%struct.env_md_st = type { i32, i32, i32, i64, i32 (%struct.env_md_ctx_st*)*, i32 (%struct.env_md_ctx_st*, i8*, i64)*, i32 (%struct.env_md_ctx_st*, i8*)*, i32 (%struct.env_md_ctx_st*, %struct.env_md_ctx_st*)*, i32 (%struct.env_md_ctx_st*)*, i32 (i32, i8*, i32, i8*, i32*, i8*)*, i32 (i32, i8*, i32, i8*, i32, i8*)*, [5 x i32], i32, i32, i32 (%struct.env_md_ctx_st*, i32, i32, i8*)* }
%struct.env_md_ctx_st = type { %struct.env_md_st*, %struct.engine_st*, i64, i8*, %struct.evp_pkey_ctx_st*, i32 (%struct.env_md_ctx_st*, i8*, i64)* }
%struct.engine_st = type opaque
%struct.evp_pkey_ctx_st = type opaque
%struct.read_buf = type { i32, i32, i8*, i8* }
%struct.ivs2_pkthdr = type { i16, i16 }
%struct.ivs2_filehdr = type { i16 }
%struct.pcap_pkthdr = type { i32, i32, i32, i32 }
%struct.pcap_file_header = type { i32, i16, i16, i32, i32, i32, i32 }
%struct.winsize = type { i16, i16, i16, i16 }
%union.pthread_mutexattr_t = type { i32 }
%union.pthread_attr_t = type { i64, [48 x i8] }
%struct.rc4_key_st = type { i32, i32, [256 x i32] }
%struct.SHAstate_st = type { i32, i32, i32, i32, i32, i32, i32, [16 x i32], i32 }
%struct.hmac_ctx_st = type { %struct.env_md_st*, %struct.env_md_ctx_st, %struct.env_md_ctx_st, %struct.env_md_ctx_st, i32, [128 x i8] }
%struct.WPA_ST_info = type { %struct.WPA_ST_info*, [6 x i8], [6 x i8], [32 x i8], [32 x i8], [20 x i8], [256 x i8], [80 x i8], i32, i64, i64, i32, i32 }
%struct.Michael = type { i64, i64, i64, i64, i64, i64, [8 x i8] }
%struct.aes_key_st = type { [60 x i32], i32 }
%struct.doublesorthelper = type { i32, double }
%struct.sorthelper = type { i32, i8, i32 }
%struct.rc4state = type { i8, i8, [256 x i8] }

@nb_eof = dso_local global i32 0, align 4
@nb_pkt = dso_local global i64 0, align 8
@wepkey_crack_success = dso_local global i32 0, align 4
@close_aircrack = dso_local global i32 0, align 4
@id = dso_local global i32 0, align 4
@wpa_wordlists_done = dso_local global i32 0, align 4
@K_COEFF = dso_local global [17 x i32] [i32 15, i32 13, i32 12, i32 12, i32 12, i32 5, i32 5, i32 5, i32 3, i32 4, i32 3, i32 4, i32 3, i32 13, i32 4, i32 4, i32 -20], align 16, !track !0
@PTW_DEFAULTWEIGHT = dso_local global [1 x i32] [i32 256], align 4
@PTW_DEFAULTBF = dso_local global [29 x i32] zeroinitializer, align 16
@R = dso_local constant [256 x i8] c"\00\01\02\03\04\05\06\07\08\09\0A\0B\0C\0D\0E\0F\10\11\12\13\14\15\16\17\18\19\1A\1B\1C\1D\1E\1F !\22#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\5C]^_`abcdefghijklmnopqrstuvwxyz{|}~\7F\80\81\82\83\84\85\86\87\88\89\8A\8B\8C\8D\8E\8F\90\91\92\93\94\95\96\97\98\99\9A\9B\9C\9D\9E\9F\A0\A1\A2\A3\A4\A5\A6\A7\A8\A9\AA\AB\AC\AD\AE\AF\B0\B1\B2\B3\B4\B5\B6\B7\B8\B9\BA\BB\BC\BD\BE\BF\C0\C1\C2\C3\C4\C5\C6\C7\C8\C9\CA\CB\CC\CD\CE\CF\D0\D1\D2\D3\D4\D5\D6\D7\D8\D9\DA\DB\DC\DD\DE\DF\E0\E1\E2\E3\E4\E5\E6\E7\E8\E9\EA\EB\EC\ED\EE\EF\F0\F1\F2\F3\F4\F5\F6\F7\F8\F9\FA\FB\FC\FD\FE\FF", align 16
@usage = dso_local global [1799 x i8] c"\0A  %s - (C) 2006, 2007, 2008, 2009 Thomas d'Otreppe\0A  Original work: Christophe Devine\0A  http://www.aircrack-ng.org\0A\0A  usage: aircrack-ng [options] <.cap / .ivs file(s)>\0A\0A  Common options:\0A\0A      -a <amode> : force attack mode (1/WEP, 2/WPA-PSK)\0A      -e <essid> : target selection: network identifier\0A      -b <bssid> : target selection: access point's MAC\0A      -p <nbcpu> : # of CPU to use  (default: all CPUs)\0A      -q         : enable quiet mode (no status output)\0A      -C <macs>  : merge the given APs to a virtual one\0A      -l <file>  : write key to file\0A\0A  Static WEP cracking options:\0A\0A      -c         : search alpha-numeric characters only\0A      -t         : search binary coded decimal chr only\0A      -h         : search the numeric key for Fritz!BOX\0A      -d <mask>  : use masking of the key (A1:XX:CF:YY)\0A      -m <maddr> : MAC address to filter usable packets\0A      -n <nbits> : WEP key length :  64/128/152/256/512\0A      -i <index> : WEP key index (1 to 4), default: any\0A      -f <fudge> : bruteforce fudge factor,  default: 2\0A      -k <korek> : disable one attack method  (1 to 17)\0A      -x or -x0  : disable bruteforce for last keybytes\0A      -x1        : last keybyte bruteforcing  (default)\0A      -x2        : enable last  2 keybytes bruteforcing%s      -y         : experimental  single bruteforce mode\0A      -K         : use only old KoreK attacks (pre-PTW)\0A      -s         : show the key in ASCII while cracking\0A      -M <num>   : specify maximum number of IVs to use\0A      -D         : WEP decloak, skips broken keystreams\0A      -P <num>   : PTW debug:  1: disable Klein, 2: PTW\0A      -1         : run only 1 try to crack key with PTW\0A\0A  WEP and WPA-PSK cracking options:\0A\0A      -w <words> : path to wordlist(s) filename(s)\0A\0A      --help     : Displays this usage screen\0A\0A\00", align 16, !track !1
@intr_read = dso_local global i32 0, align 4
@opt = common dso_local global %struct.options zeroinitializer, align 8, !track !2
@mc_pipe = common dso_local global [256 x [2 x i32]] zeroinitializer, align 16
@bf_pipe = common dso_local global [256 x [2 x i32]] zeroinitializer, align 16
@tid = common dso_local global [128 x i64] zeroinitializer, align 16, !track !3
@wep = common dso_local global %struct.WEP_data zeroinitializer, align 8, !track !4
@ap_1st = common dso_local global %struct.AP_info* null, align 8, !track !5
@mx_eof = common dso_local global %union.pthread_mutex_t zeroinitializer, align 8
@cv_eof = common dso_local global %union.pthread_cond_t zeroinitializer, align 8
@mx_apl = common dso_local global %union.pthread_mutex_t zeroinitializer, align 8
@mx_ivb = common dso_local global %union.pthread_mutex_t zeroinitializer, align 8
@cm_pipe = common dso_local global [256 x [2 x i32]] zeroinitializer, align 16
@t_stats = common dso_local global %struct.timeval zeroinitializer, align 8
@t_begin = common dso_local global %struct.timeval zeroinitializer, align 8
@progname = common dso_local global i8* null, align 8, !track !6
@nb_tried = common dso_local global i64 0, align 8
@bf_nkeys = common dso_local global [256 x i32] zeroinitializer, align 16, !track !7
@bf_wepkey = common dso_local global [64 x i8] zeroinitializer, align 16, !track !8
@t_kprev = common dso_local global %struct.timeval zeroinitializer, align 8
@nb_kprev = common dso_local global i64 0, align 8
@wpa_data = common dso_local global [128 x %struct.WPA_data] zeroinitializer, align 16, !track !9
@.str = private unnamed_addr constant [7 x i8] c"%-14s \00", align 1
@.str.1 = private unnamed_addr constant [5 x i8] c"%.2X\00", align 1
@.str.2 = private unnamed_addr constant [2 x i8] c"\0A\00", align 1
@.str.3 = private unnamed_addr constant [26 x i8] c"\0AQuitting aircrack-ng...\0A\00", align 1
@stdout = external dso_local global %struct._IO_FILE*, align 8
@.str.4 = private unnamed_addr constant [6 x i8] c"EXIT\0D\00", align 1
@.str.5 = private unnamed_addr constant [6 x i8] c"\1B[2J\0A\00", align 1
@.str.6 = private unnamed_addr constant [2 x i8] c",\00", align 1
@.str.7 = private unnamed_addr constant [14 x i8] c"malloc failed\00", align 1
@.str.8 = private unnamed_addr constant [30 x i8] c"%02X:%02X:%02X:%02X:%02X:%02X\00", align 1
@.str.9 = private unnamed_addr constant [12 x i8] c"Opening %s\0A\00", align 1
@.str.10 = private unnamed_addr constant [2 x i8] c"-\00", align 1
@.str.11 = private unnamed_addr constant [12 x i8] c"open failed\00", align 1
@.str.12 = private unnamed_addr constant [25 x i8] c"read(file header) failed\00", align 1
@.str.13 = private unnamed_addr constant [5 x i8] c"\BF\CA\84\D4\00", align 1
@.str.14 = private unnamed_addr constant [5 x i8] c"\AEx\D1\FF\00", align 1
@stderr = external dso_local global %struct._IO_FILE*, align 8
@.str.15 = private unnamed_addr constant [51 x i8] c"Unsupported file format (not a pcap or IVs file).\0A\00", align 1
@.str.16 = private unnamed_addr constant [55 x i8] c"This file is not a regular 802.11 (wireless) capture.\0A\00", align 1
@.str.17 = private unnamed_addr constant [37 x i8] c"Can't use decloak wep mode with ivs\0A\00", align 1
@.str.18 = private unnamed_addr constant [58 x i8] c"Error, wrong %s version: %d. Supported up to version %d.\0A\00", align 1
@.str.19 = private unnamed_addr constant [4 x i8] c"ivs\00", align 1
@.str.20 = private unnamed_addr constant [84 x i8] c"Can't do PTW with old IVS files, recapture without --ivs or use airodump-ng >= 1.0\0A\00", align 1
@.str.21 = private unnamed_addr constant [25 x i8] c"fcntl(O_NONBLOCK) failed\00", align 1
@.str.22 = private unnamed_addr constant [53 x i8] c"\0AInvalid packet capture length %d - corrupted file?\0A\00", align 1
@.str.23 = private unnamed_addr constant [7 x i8] c"\FF\FF\FF\FF\FF\FF\00", align 1
@ZERO = internal global [32 x i8] zeroinitializer, align 16, !track !10
@.str.24 = private unnamed_addr constant [21 x i8] c"PTW_newattackstate()\00", align 1
@.str.25 = private unnamed_addr constant [15 x i8] c"realloc failed\00", align 1
@.str.26 = private unnamed_addr constant [7 x i8] c"\01\80\C2\00\00\00\00", align 1
@.str.27 = private unnamed_addr constant [12 x i8] c"read failed\00", align 1
@.str.28 = private unnamed_addr constant [13 x i8] c"write failed\00", align 1
@show_wep_stats.is_cleared = internal global i32 0, align 4
@.str.29 = private unnamed_addr constant [6 x i8] c"\1B[40m\00", align 1
@.str.30 = private unnamed_addr constant [5 x i8] c"\1B[2J\00", align 1
@.str.31 = private unnamed_addr constant [8 x i8] c"\1B[34;1m\00", align 1
@.str.32 = private unnamed_addr constant [12 x i8] c"\1B[2;%dH%s\0A\0A\00", align 1
@.str.33 = private unnamed_addr constant [8 x i8] c"\1B[33;1m\00", align 1
@.str.34 = private unnamed_addr constant [56 x i8] c"\1B[5;%dH[%02d:%02d:%02d] Tested %d keys (got %ld IVs)\1B[K\00", align 1
@.str.35 = private unnamed_addr constant [58 x i8] c"\1B[5;%dH[%02d:%02d:%02d] Tested %lld keys (got %ld IVs)\1B[K\00", align 1
@.str.36 = private unnamed_addr constant [9 x i8] c"\1B[32;22m\00", align 1
@.str.37 = private unnamed_addr constant [32 x i8] c"\1B[7;4HKB    depth   byte(vote)\0A\00", align 1
@.str.38 = private unnamed_addr constant [28 x i8] c"   %2d  \1B[1m%3d\1B[22m/%3d   \00", align 1
@.str.39 = private unnamed_addr constant [19 x i8] c"   %2d  %3d/%3d   \00", align 1
@.str.40 = private unnamed_addr constant [20 x i8] c"\1B[1m%02X\1B[22m(%4d) \00", align 1
@.str.41 = private unnamed_addr constant [11 x i8] c"%02X(%4d) \00", align 1
@.str.42 = private unnamed_addr constant [21 x i8] c"\1B[1m%02X\1B[22m(+inf) \00", align 1
@.str.43 = private unnamed_addr constant [12 x i8] c"%02X(+inf) \00", align 1
@.str.44 = private unnamed_addr constant [5 x i8] c"  %c\00", align 1
@.str.45 = private unnamed_addr constant [4 x i8] c"\1B[J\00", align 1
@.str.150 = private unnamed_addr constant [14 x i8] c"KEY FOUND! [ \00", align 1
@.str.62 = private unnamed_addr constant [8 x i8] c"\1B[31;1m\00", align 1
@.str.151 = private unnamed_addr constant [22 x i8] c"\1B[K\1B[%dCKEY FOUND! [ \00", align 1
@.str.152 = private unnamed_addr constant [6 x i8] c"%02X:\00", align 1
@.str.153 = private unnamed_addr constant [8 x i8] c"%02X ] \00", align 1
@.str.154 = private unnamed_addr constant [9 x i8] c"(ASCII: \00", align 1
@.str.155 = private unnamed_addr constant [3 x i8] c"%c\00", align 1
@.str.156 = private unnamed_addr constant [3 x i8] c" )\00", align 1
@.str.157 = private unnamed_addr constant [29 x i8] c"\0A\09Decrypted correctly: %d%%\0A\00", align 1
@.str.64 = private unnamed_addr constant [2 x i8] c"w\00", align 1
@.str.158 = private unnamed_addr constant [5 x i8] c"%02X\00", align 1
@.str.46 = private unnamed_addr constant [125 x i8] c"Not enough IVs available. You need about 250.000 IVs to crack\0A40-bit WEP, and more than 800.000 IVs to crack a 104-bit key.\0A\00", align 1
@.str.47 = private unnamed_addr constant [34 x i8] c"Read %ld packets, got %ld IVs...\0D\00", align 1
@.str.48 = private unnamed_addr constant [69 x i8] c"On which keybyte do you want to remove votes (Hit Enter when done)? \00", align 1
@.str.49 = private unnamed_addr constant [81 x i8] c"From which keybyte value do you want to remove the votes (Hit Enter to cancel)? \00", align 1
@do_wep_crack1.k = internal global i32 0, align 4
@.str.50 = private unnamed_addr constant [17 x i8] c"write pmk failed\00", align 1
@.str.51 = private unnamed_addr constant [123 x i8] c"Not enough IVs available. This option is only meant to be used\0Aif the standard attack method fails with more than %d IVs.\0A\00", align 1
@mx_wpastats = internal global %union.pthread_mutex_t zeroinitializer, align 8
@.str.52 = private unnamed_addr constant [53 x i8] c"\1B[5;20H[%02d:%02d:%02d] %lld keys tested (%2.2f k/s)\00", align 1
@.str.53 = private unnamed_addr constant [8 x i8] c"\1B[37;1m\00", align 1
@.str.54 = private unnamed_addr constant [31 x i8] c"\1B[8;24HCurrent passphrase: %s\0A\00", align 1
@.str.55 = private unnamed_addr constant [25 x i8] c"\1B[11;7HMaster Key     : \00", align 1
@.str.56 = private unnamed_addr constant [8 x i8] c"\1B[32;1m\00", align 1
@.str.57 = private unnamed_addr constant [7 x i8] c"\0A\1B[23C\00", align 1
@.str.58 = private unnamed_addr constant [6 x i8] c"%02X \00", align 1
@.str.59 = private unnamed_addr constant [25 x i8] c"\1B[14;7HTransient Key  : \00", align 1
@.str.60 = private unnamed_addr constant [25 x i8] c"\1B[19;7HEAPOL HMAC     : \00", align 1
@.str.61 = private unnamed_addr constant [23 x i8] c"Pairwise key expansion\00", align 1
@mx_nb = internal global %union.pthread_mutex_t zeroinitializer, align 8
@.str.63 = private unnamed_addr constant [35 x i8] c"\1B[8;%dH\1B[2KKEY FOUND! [ %s ]\1B[11B\0A\00", align 1
@.str.65 = private unnamed_addr constant [3 x i8] c"%s\00", align 1
@stdin = external dso_local global %struct._IO_FILE*, align 8
@.str.66 = private unnamed_addr constant [2 x i8] c"r\00", align 1
@.str.67 = private unnamed_addr constant [25 x i8] c"fopen(dictionary) failed\00", align 1
@.str.68 = private unnamed_addr constant [18 x i8] c"Empty dictionary\0A\00", align 1
@.str.69 = private unnamed_addr constant [9 x i8] c"\1B[37;40m\00", align 1
@.str.70 = private unnamed_addr constant [10 x i8] c"\1B[2;34H%s\00", align 1
@.str.71 = private unnamed_addr constant [2 x i8] c":\00", align 1
@.str.72 = private unnamed_addr constant [3 x i8] c"%x\00", align 1
@.str.73 = private unnamed_addr constant [19 x i8] c"allocation failed!\00", align 1
@.str.74 = private unnamed_addr constant [3 x i8] c"h:\00", align 1
@.str.75 = private unnamed_addr constant [79 x i8] c"\0A%ld IVs is below the minimum required for a dictionary attack (%d IVs min.)!\0A\00", align 1
@.str.76 = private unnamed_addr constant [12 x i8] c"Aircrack-ng\00", align 1
@.str.86 = private unnamed_addr constant [50 x i8] c"r:a:e:b:p:qcthd:l:m:n:i:f:k:x::Xysw:0HKC:M:DP:zV1\00", align 1
@main.long_options = internal global [10 x %struct.option] [%struct.option { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.77, i32 0, i32 0), i32 1, i32* null, i32 98 }, %struct.option { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.78, i32 0, i32 0), i32 1, i32* null, i32 100 }, %struct.option { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.79, i32 0, i32 0), i32 0, i32* null, i32 67 }, %struct.option { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.80, i32 0, i32 0), i32 0, i32* null, i32 72 }, %struct.option { i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.81, i32 0, i32 0), i32 0, i32* null, i32 68 }, %struct.option { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.82, i32 0, i32 0), i32 0, i32* null, i32 80 }, %struct.option { i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.83, i32 0, i32 0), i32 0, i32* null, i32 86 }, %struct.option { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.84, i32 0, i32 0), i32 0, i32* null, i32 49 }, %struct.option { i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.85, i32 0, i32 0), i32 0, i32* null, i32 117 }, %struct.option zeroinitializer], align 16
@.str.87 = private unnamed_addr constant [23 x i8] c"\22%s --help\22 for help.\0A\00", align 1
@.str.88 = private unnamed_addr constant [21 x i8] c"Nb CPU detected: %d \00", align 1
@.str.89 = private unnamed_addr constant [17 x i8] c" (MMX available)\00", align 1
@.str.90 = private unnamed_addr constant [18 x i8] c" (SSE2 available)\00", align 1
@.str.91 = private unnamed_addr constant [47 x i8] c"Visual inspection can only be used with KoreK\0A\00", align 1
@.str.92 = private unnamed_addr constant [27 x i8] c"Use \22%s --help\22 for help.\0A\00", align 1
@optarg = external dso_local global i8*, align 8
@.str.93 = private unnamed_addr constant [3 x i8] c"%d\00", align 1
@.str.94 = private unnamed_addr constant [4 x i8] c"wep\00", align 1
@.str.95 = private unnamed_addr constant [4 x i8] c"wpa\00", align 1
@.str.96 = private unnamed_addr constant [41 x i8] c"Invalid attack mode. [1,2] or [wep,wpa]\0A\00", align 1
@.str.97 = private unnamed_addr constant [28 x i8] c"Invalid BSSID (not a MAC).\0A\00", align 1
@.str.98 = private unnamed_addr constant [47 x i8] c"Invalid number of processes (recommended: %d)\0A\00", align 1
@.str.99 = private unnamed_addr constant [20 x i8] c"Invalid debug key.\0A\00", align 1
@.str.100 = private unnamed_addr constant [29 x i8] c"Invalid MAC address filter.\0A\00", align 1
@.str.101 = private unnamed_addr constant [46 x i8] c"Invalid WEP key length. [64,128,152,256,512]\0A\00", align 1
@.str.102 = private unnamed_addr constant [30 x i8] c"Invalid WEP key index. [1-4]\0A\00", align 1
@.str.103 = private unnamed_addr constant [3 x i8] c"%f\00", align 1
@.str.104 = private unnamed_addr constant [29 x i8] c"Invalid fudge factor. [>=1]\0A\00", align 1
@.str.105 = private unnamed_addr constant [39 x i8] c"Invalid KoreK attack strategy. [1-%d]\0A\00", align 1
@.str.106 = private unnamed_addr constant [25 x i8] c"Error allocating memory\0A\00", align 1
@.str.107 = private unnamed_addr constant [33 x i8] c"Invalid number of max. ivs [>1]\0A\00", align 1
@.str.108 = private unnamed_addr constant [36 x i8] c"Invalid number for ptw debug [0-2]\0A\00", align 1
@.str.109 = private unnamed_addr constant [28 x i8] c"Invalid option -x%s. [0-4]\0A\00", align 1
@.str.110 = private unnamed_addr constant [56 x i8] c"Error: Aircrack-ng wasn't compiled with sqlite support\0A\00", align 1
@.str.111 = private unnamed_addr constant [44 x i8] c"Invalid bssids (-C).\0A\22%s --help\22 for help.\0A\00", align 1
@.str.112 = private unnamed_addr constant [50 x i8] c"Merging BSSID disabled, only one BSSID specified\0A\00", align 1
@optind = external dso_local global i32, align 4
@.str.113 = private unnamed_addr constant [58 x i8] c"\0A      -X         : disable  bruteforce   multithreading\0A\00", align 1
@.str.114 = private unnamed_addr constant [29 x i8] c"No file to crack specified.\0A\00", align 1
@.str.115 = private unnamed_addr constant [42 x i8] c"Please specify a dictionary (option -w).\0A\00", align 1
@.str.116 = private unnamed_addr constant [35 x i8] c"Please specify an ESSID or BSSID.\0A\00", align 1
@.str.117 = private unnamed_addr constant [22 x i8] c"pthread_create failed\00", align 1
@.str.118 = private unnamed_addr constant [51 x i8] c"Only using the first %d files, ignoring the rest.\0A\00", align 1
@.str.119 = private unnamed_addr constant [33 x i8] c"Reading packets, please wait...\0D\00", align 1
@.str.120 = private unnamed_addr constant [23 x i8] c"\1B[KRead %ld packets.\0A\0A\00", align 1
@.str.121 = private unnamed_addr constant [29 x i8] c"No networks found, exiting.\0A\00", align 1
@.str.122 = private unnamed_addr constant [37 x i8] c"   #  BSSID%14sESSID%21sEncryption\0A\0A\00", align 1
@.str.123 = private unnamed_addr constant [1 x i8] zeroinitializer, align 1
@.str.124 = private unnamed_addr constant [44 x i8] c"%4d  %02X:%02X:%02X:%02X:%02X:%02X  %-24s  \00", align 1
@.str.125 = private unnamed_addr constant [7 x i8] c"EAPOL+\00", align 1
@.str.126 = private unnamed_addr constant [20 x i8] c"None (%d.%d.%d.%d)\0A\00", align 1
@.str.127 = private unnamed_addr constant [22 x i8] c"No data - WEP or WPA\0A\00", align 1
@.str.128 = private unnamed_addr constant [15 x i8] c"WEP (%ld IVs)\0A\00", align 1
@.str.129 = private unnamed_addr constant [20 x i8] c"WPA (%d handshake)\0A\00", align 1
@.str.130 = private unnamed_addr constant [9 x i8] c"Unknown\0A\00", align 1
@.str.131 = private unnamed_addr constant [34 x i8] c"Index number of target network ? \00", align 1
@.str.132 = private unnamed_addr constant [6 x i8] c"%127s\00", align 1
@.str.133 = private unnamed_addr constant [35 x i8] c"Choosing first network as target.\0A\00", align 1
@.str.135 = private unnamed_addr constant [6 x i8] c"essid\00", align 1
@.str.77 = private unnamed_addr constant [6 x i8] c"bssid\00", align 1
@.str.134 = private unnamed_addr constant [44 x i8] c"No matching network found - check your %s.\0A\00", align 1
@.str.136 = private unnamed_addr constant [40 x i8] c"Target network doesn't seem encrypted.\0A\00", align 1
@.str.137 = private unnamed_addr constant [42 x i8] c"Got no data packets from target network!\0A\00", align 1
@.str.138 = private unnamed_addr constant [61 x i8] c"Bruteforcing more then 4 bytes will take too long, aborting!\00", align 1
@.str.139 = private unnamed_addr constant [49 x i8] c"Attack will be restarted every %d captured ivs.\0A\00", align 1
@.str.140 = private unnamed_addr constant [35 x i8] c"Starting PTW attack with %ld ivs.\0A\00", align 1
@.str.141 = private unnamed_addr constant [211 x i8] c"   Attack failed. Possible reasons:\0A\0A     * Out of luck: you must capture more IVs. Usually, 104-bit WEP\0A       can be cracked with about 80.000 IVs, sometimes more.\0A\0A     * Try to raise the fudge factor (-f).\0A\00", align 1
@.str.142 = private unnamed_addr constant [31 x i8] c"Failed. Next try with %d IVs.\0A\00", align 1
@.str.143 = private unnamed_addr constant [461 x i8] c"   Attack failed. Possible reasons:\0A\0A     * Out of luck: you must capture more IVs. Usually, 104-bit WEP\0A       can be cracked with about one million IVs, sometimes more.\0A\0A     * If all votes seem equal, or if there are many negative votes,\0A       then the capture file is corrupted, or the key is not static.\0A\0A     * A false positive prevented the key from being found.  Try to\0A       disable each korek attack (-k 1 .. 17), raise the fudge factor\0A       (-f)\00", align 1
@.str.144 = private unnamed_addr constant [50 x i8] c"and try the experimental bruteforce attacks (-y).\00", align 1
@.str.145 = private unnamed_addr constant [56 x i8] c"or try the standard attack mode instead (no -y option).\00", align 1
@.str.146 = private unnamed_addr constant [32 x i8] c"No valid WPA handshakes found.\0A\00", align 1
@.str.147 = private unnamed_addr constant [38 x i8] c"An ESSID is required. Try option -e.\0A\00", align 1
@.str.148 = private unnamed_addr constant [19 x i8] c"KEY FOUND! [ %s ]\0A\00", align 1
@.str.149 = private unnamed_addr constant [32 x i8] c"\0APassphrase not in dictionary \0A\00", align 1
@.str.78 = private unnamed_addr constant [6 x i8] c"debug\00", align 1
@.str.79 = private unnamed_addr constant [8 x i8] c"combine\00", align 1
@.str.80 = private unnamed_addr constant [5 x i8] c"help\00", align 1
@.str.81 = private unnamed_addr constant [12 x i8] c"wep-decloak\00", align 1
@.str.82 = private unnamed_addr constant [10 x i8] c"ptw-debug\00", align 1
@.str.83 = private unnamed_addr constant [18 x i8] c"visual-inspection\00", align 1
@.str.84 = private unnamed_addr constant [8 x i8] c"oneshot\00", align 1
@.str.85 = private unnamed_addr constant [11 x i8] c"cpu-detect\00", align 1
@crc_tbl = dso_local constant [256 x i64] [i64 0, i64 1996959894, i64 3993919788, i64 2567524794, i64 124634137, i64 1886057615, i64 3915621685, i64 2657392035, i64 249268274, i64 2044508324, i64 3772115230, i64 2547177864, i64 162941995, i64 2125561021, i64 3887607047, i64 2428444049, i64 498536548, i64 1789927666, i64 4089016648, i64 2227061214, i64 450548861, i64 1843258603, i64 4107580753, i64 2211677639, i64 325883990, i64 1684777152, i64 4251122042, i64 2321926636, i64 335633487, i64 1661365465, i64 4195302755, i64 2366115317, i64 997073096, i64 1281953886, i64 3579855332, i64 2724688242, i64 1006888145, i64 1258607687, i64 3524101629, i64 2768942443, i64 901097722, i64 1119000684, i64 3686517206, i64 2898065728, i64 853044451, i64 1172266101, i64 3705015759, i64 2882616665, i64 651767980, i64 1373503546, i64 3369554304, i64 3218104598, i64 565507253, i64 1454621731, i64 3485111705, i64 3099436303, i64 671266974, i64 1594198024, i64 3322730930, i64 2970347812, i64 795835527, i64 1483230225, i64 3244367275, i64 3060149565, i64 1994146192, i64 31158534, i64 2563907772, i64 4023717930, i64 1907459465, i64 112637215, i64 2680153253, i64 3904427059, i64 2013776290, i64 251722036, i64 2517215374, i64 3775830040, i64 2137656763, i64 141376813, i64 2439277719, i64 3865271297, i64 1802195444, i64 476864866, i64 2238001368, i64 4066508878, i64 1812370925, i64 453092731, i64 2181625025, i64 4111451223, i64 1706088902, i64 314042704, i64 2344532202, i64 4240017532, i64 1658658271, i64 366619977, i64 2362670323, i64 4224994405, i64 1303535960, i64 984961486, i64 2747007092, i64 3569037538, i64 1256170817, i64 1037604311, i64 2765210733, i64 3554079995, i64 1131014506, i64 879679996, i64 2909243462, i64 3663771856, i64 1141124467, i64 855842277, i64 2852801631, i64 3708648649, i64 1342533948, i64 654459306, i64 3188396048, i64 3373015174, i64 1466479909, i64 544179635, i64 3110523913, i64 3462522015, i64 1591671054, i64 702138776, i64 2966460450, i64 3352799412, i64 1504918807, i64 783551873, i64 3082640443, i64 3233442989, i64 3988292384, i64 2596254646, i64 62317068, i64 1957810842, i64 3939845945, i64 2647816111, i64 81470997, i64 1943803523, i64 3814918930, i64 2489596804, i64 225274430, i64 2053790376, i64 3826175755, i64 2466906013, i64 167816743, i64 2097651377, i64 4027552580, i64 2265490386, i64 503444072, i64 1762050814, i64 4150417245, i64 2154129355, i64 426522225, i64 1852507879, i64 4275313526, i64 2312317920, i64 282753626, i64 1742555852, i64 4189708143, i64 2394877945, i64 397917763, i64 1622183637, i64 3604390888, i64 2714866558, i64 953729732, i64 1340076626, i64 3518719985, i64 2797360999, i64 1068828381, i64 1219638859, i64 3624741850, i64 2936675148, i64 906185462, i64 1090812512, i64 3747672003, i64 2825379669, i64 829329135, i64 1181335161, i64 3412177804, i64 3160834842, i64 628085408, i64 1382605366, i64 3423369109, i64 3138078467, i64 570562233, i64 1426400815, i64 3317316542, i64 2998733608, i64 733239954, i64 1555261956, i64 3268935591, i64 3050360625, i64 752459403, i64 1541320221, i64 2607071920, i64 3965973030, i64 1969922972, i64 40735498, i64 2617837225, i64 3943577151, i64 1913087877, i64 83908371, i64 2512341634, i64 3803740692, i64 2075208622, i64 213261112, i64 2463272603, i64 3855990285, i64 2094854071, i64 198958881, i64 2262029012, i64 4057260610, i64 1759359992, i64 534414190, i64 2176718541, i64 4139329115, i64 1873836001, i64 414664567, i64 2282248934, i64 4279200368, i64 1711684554, i64 285281116, i64 2405801727, i64 4167216745, i64 1634467795, i64 376229701, i64 2685067896, i64 3608007406, i64 1308918612, i64 956543938, i64 2808555105, i64 3495958263, i64 1231636301, i64 1047427035, i64 2932959818, i64 3654703836, i64 1088359270, i64 936918000, i64 2847714899, i64 3736837829, i64 1202900863, i64 817233897, i64 3183342108, i64 3401237130, i64 1404277552, i64 615818150, i64 3134207493, i64 3453421203, i64 1423857449, i64 601450431, i64 3009837614, i64 3294710456, i64 1567103746, i64 711928724, i64 3020668471, i64 3272380065, i64 1510334235, i64 755167117], align 16
@crc_chop_tbl = dso_local constant [256 x [4 x i8]] [[4 x i8] c"&pj\0F", [4 x i8] c"gv\1B\D4", [4 x i8] c"\E5z\F9b", [4 x i8] c"\A4|\88\B9", [4 x i8] c"\A0eL\D4", [4 x i8] c"\E1c=\0F", [4 x i8] c"co\DF\B9", [4 x i8] c"\22i\AEb", [4 x i8] c"k]Wb", [4 x i8] c"*[&\B9", [4 x i8] c"\A8W\C4\0F", [4 x i8] c"\E9Q\B5\D4", [4 x i8] c"\EDHq\B9", [4 x i8] c"\ACN\00b", [4 x i8] c".B\E2\D4", [4 x i8] c"oD\93\0F", [4 x i8] c"\BC*\10\D5", [4 x i8] c"\FD,a\0E", [4 x i8] c"\7F \83\B8", [4 x i8] c">&\F2c", [4 x i8] c":?6\0E", [4 x i8] c"{9G\D5", [4 x i8] c"\F95\A5c", [4 x i8] c"\B83\D4\B8", [4 x i8] c"\F1\07-\B8", [4 x i8] c"\B0\01\5Cc", [4 x i8] c"2\0D\BE\D5", [4 x i8] c"s\0B\CF\0E", [4 x i8] c"w\12\0Bc", [4 x i8] c"6\14z\B8", [4 x i8] c"\B4\18\98\0E", [4 x i8] c"\F5\1E\E9\D5", [4 x i8] c"S\C3\EF`", [4 x i8] c"\12\C5\9E\BB", [4 x i8] c"\90\C9|\0D", [4 x i8] c"\D1\CF\0D\D6", [4 x i8] c"\D5\D6\C9\BB", [4 x i8] c"\94\D0\B8`", [4 x i8] c"\16\DCZ\D6", [4 x i8] c"W\DA+\0D", [4 x i8] c"\1E\EE\D2\0D", [4 x i8] c"_\E8\A3\D6", [4 x i8] c"\DD\E4A`", [4 x i8] c"\9C\E20\BB", [4 x i8] c"\98\FB\F4\D6", [4 x i8] c"\D9\FD\85\0D", [4 x i8] c"[\F1g\BB", [4 x i8] c"\1A\F7\16`", [4 x i8] c"\C9\99\95\BA", [4 x i8] c"\88\9F\E4a", [4 x i8] c"\0A\93\06\D7", [4 x i8] c"K\95w\0C", [4 x i8] c"O\8C\B3a", [4 x i8] c"\0E\8A\C2\BA", [4 x i8] c"\8C\86 \0C", [4 x i8] c"\CD\80Q\D7", [4 x i8] c"\84\B4\A8\D7", [4 x i8] c"\C5\B2\D9\0C", [4 x i8] c"G\BE;\BA", [4 x i8] c"\06\B8Ja", [4 x i8] c"\02\A1\8E\0C", [4 x i8] c"C\A7\FF\D7", [4 x i8] c"\C1\AB\1Da", [4 x i8] c"\80\ADl\BA", [4 x i8] c"\CC\16a\D0", [4 x i8] c"\8D\10\10\0B", [4 x i8] c"\0F\1C\F2\BD", [4 x i8] c"N\1A\83f", [4 x i8] c"J\03G\0B", [4 x i8] c"\0B\056\D0", [4 x i8] c"\89\09\D4f", [4 x i8] c"\C8\0F\A5\BD", [4 x i8] c"\81;\5C\BD", [4 x i8] c"\C0=-f", [4 x i8] c"B1\CF\D0", [4 x i8] c"\037\BE\0B", [4 x i8] c"\07.zf", [4 x i8] c"F(\0B\BD", [4 x i8] c"\C4$\E9\0B", [4 x i8] c"\85\22\98\D0", [4 x i8] c"VL\1B\0A", [4 x i8] c"\17Jj\D1", [4 x i8] c"\95F\88g", [4 x i8] c"\D4@\F9\BC", [4 x i8] c"\D0Y=\D1", [4 x i8] c"\91_L\0A", [4 x i8] c"\13S\AE\BC", [4 x i8] c"RU\DFg", [4 x i8] c"\1Ba&g", [4 x i8] c"ZgW\BC", [4 x i8] c"\D8k\B5\0A", [4 x i8] c"\99m\C4\D1", [4 x i8] c"\9Dt\00\BC", [4 x i8] c"\DCrqg", [4 x i8] c"^~\93\D1", [4 x i8] c"\1Fx\E2\0A", [4 x i8] c"\B9\A5\E4\BF", [4 x i8] c"\F8\A3\95d", [4 x i8] c"z\AFw\D2", [4 x i8] c";\A9\06\09", [4 x i8] c"?\B0\C2d", [4 x i8] c"~\B6\B3\BF", [4 x i8] c"\FC\BAQ\09", [4 x i8] c"\BD\BC \D2", [4 x i8] c"\F4\88\D9\D2", [4 x i8] c"\B5\8E\A8\09", [4 x i8] c"7\82J\BF", [4 x i8] c"v\84;d", [4 x i8] c"r\9D\FF\09", [4 x i8] c"3\9B\8E\D2", [4 x i8] c"\B1\97ld", [4 x i8] c"\F0\91\1D\BF", [4 x i8] c"#\FF\9Ee", [4 x i8] c"b\F9\EF\BE", [4 x i8] c"\E0\F5\0D\08", [4 x i8] c"\A1\F3|\D3", [4 x i8] c"\A5\EA\B8\BE", [4 x i8] c"\E4\EC\C9e", [4 x i8] c"f\E0+\D3", [4 x i8] c"'\E6Z\08", [4 x i8] c"n\D2\A3\08", [4 x i8] c"/\D4\D2\D3", [4 x i8] c"\AD\D80e", [4 x i8] c"\EC\DEA\BE", [4 x i8] c"\E8\C7\85\D3", [4 x i8] c"\A9\C1\F4\08", [4 x i8] c"+\CD\16\BE", [4 x i8] c"j\CBge", [4 x i8] c"\B3\BB\0Dj", [4 x i8] c"\F2\BD|\B1", [4 x i8] c"p\B1\9E\07", [4 x i8] c"1\B7\EF\DC", [4 x i8] c"5\AE+\B1", [4 x i8] c"t\A8Zj", [4 x i8] c"\F6\A4\B8\DC", [4 x i8] c"\B7\A2\C9\07", [4 x i8] c"\FE\960\07", [4 x i8] c"\BF\90A\DC", [4 x i8] c"=\9C\A3j", [4 x i8] c"|\9A\D2\B1", [4 x i8] c"x\83\16\DC", [4 x i8] c"9\85g\07", [4 x i8] c"\BB\89\85\B1", [4 x i8] c"\FA\8F\F4j", [4 x i8] c")\E1w\B0", [4 x i8] c"h\E7\06k", [4 x i8] c"\EA\EB\E4\DD", [4 x i8] c"\AB\ED\95\06", [4 x i8] c"\AF\F4Qk", [4 x i8] c"\EE\F2 \B0", [4 x i8] c"l\FE\C2\06", [4 x i8] c"-\F8\B3\DD", [4 x i8] c"d\CCJ\DD", [4 x i8] c"%\CA;\06", [4 x i8] c"\A7\C6\D9\B0", [4 x i8] c"\E6\C0\A8k", [4 x i8] c"\E2\D9l\06", [4 x i8] c"\A3\DF\1D\DD", [4 x i8] c"!\D3\FFk", [4 x i8] c"`\D5\8E\B0", [4 x i8] c"\C6\08\88\05", [4 x i8] c"\87\0E\F9\DE", [4 x i8] c"\05\02\1Bh", [4 x i8] c"D\04j\B3", [4 x i8] c"@\1D\AE\DE", [4 x i8] c"\01\1B\DF\05", [4 x i8] c"\83\17=\B3", [4 x i8] c"\C2\11Lh", [4 x i8] c"\8B%\B5h", [4 x i8] c"\CA#\C4\B3", [4 x i8] c"H/&\05", [4 x i8] c"\09)W\DE", [4 x i8] c"\0D0\93\B3", [4 x i8] c"L6\E2h", [4 x i8] c"\CE:\00\DE", [4 x i8] c"\8F<q\05", [4 x i8] c"\5CR\F2\DF", [4 x i8] c"\1DT\83\04", [4 x i8] c"\9FXa\B2", [4 x i8] c"\DE^\10i", [4 x i8] c"\DAG\D4\04", [4 x i8] c"\9BA\A5\DF", [4 x i8] c"\19MGi", [4 x i8] c"XK6\B2", [4 x i8] c"\11\7F\CF\B2", [4 x i8] c"Py\BEi", [4 x i8] c"\D2u\5C\DF", [4 x i8] c"\93s-\04", [4 x i8] c"\97j\E9i", [4 x i8] c"\D6l\98\B2", [4 x i8] c"T`z\04", [4 x i8] c"\15f\0B\DF", [4 x i8] c"Y\DD\06\B5", [4 x i8] c"\18\DBwn", [4 x i8] c"\9A\D7\95\D8", [4 x i8] c"\DB\D1\E4\03", [4 x i8] c"\DF\C8 n", [4 x i8] c"\9E\CEQ\B5", [4 x i8] c"\1C\C2\B3\03", [4 x i8] c"]\C4\C2\D8", [4 x i8] c"\14\F0;\D8", [4 x i8] c"U\F6J\03", [4 x i8] c"\D7\FA\A8\B5", [4 x i8] c"\96\FC\D9n", [4 x i8] c"\92\E5\1D\03", [4 x i8] c"\D3\E3l\D8", [4 x i8] c"Q\EF\8En", [4 x i8] c"\10\E9\FF\B5", [4 x i8] c"\C3\87|o", [4 x i8] c"\82\81\0D\B4", [4 x i8] c"\00\8D\EF\02", [4 x i8] c"A\8B\9E\D9", [4 x i8] c"E\92Z\B4", [4 x i8] c"\04\94+o", [4 x i8] c"\86\98\C9\D9", [4 x i8] c"\C7\9E\B8\02", [4 x i8] c"\8E\AAA\02", [4 x i8] c"\CF\AC0\D9", [4 x i8] c"M\A0\D2o", [4 x i8] c"\0C\A6\A3\B4", [4 x i8] c"\08\BFg\D9", [4 x i8] c"I\B9\16\02", [4 x i8] c"\CB\B5\F4\B4", [4 x i8] c"\8A\B3\85o", [4 x i8] c",n\83\DA", [4 x i8] c"mh\F2\01", [4 x i8] c"\EFd\10\B7", [4 x i8] c"\AEbal", [4 x i8] c"\AA{\A5\01", [4 x i8] c"\EB}\D4\DA", [4 x i8] c"iq6l", [4 x i8] c"(wG\B7", [4 x i8] c"aC\BE\B7", [4 x i8] c" E\CFl", [4 x i8] c"\A2I-\DA", [4 x i8] c"\E3O\5C\01", [4 x i8] c"\E7V\98l", [4 x i8] c"\A6P\E9\B7", [4 x i8] c"$\5C\0B\01", [4 x i8] c"eZz\DA", [4 x i8] c"\B64\F9\00", [4 x i8] c"\F72\88\DB", [4 x i8] c"u>jm", [4 x i8] c"48\1B\B6", [4 x i8] c"0!\DF\DB", [4 x i8] c"q'\AE\00", [4 x i8] c"\F3+L\B6", [4 x i8] c"\B2-=m", [4 x i8] c"\FB\19\C4m", [4 x i8] c"\BA\1F\B5\B6", [4 x i8] c"8\13W\00", [4 x i8] c"y\15&\DB", [4 x i8] c"}\0C\E2\B6", [4 x i8] c"<\0A\93m", [4 x i8] c"\BE\06q\DB", [4 x i8] c"\FF\00\00\00"], align 16
@TkipSbox = dso_local constant [2 x [256 x i16]] [[256 x i16] [i16 -14683, i16 -1916, i16 -4455, i16 -2419, i16 -243, i16 -10563, i16 -8527, i16 -28332, i16 24656, i16 515, i16 -12631, i16 22141, i16 -6375, i16 -19102, i16 19942, i16 -4966, i16 -28859, i16 8093, i16 -30400, i16 -1401, i16 -4331, i16 -19733, i16 -28983, i16 -1269, i16 16876, i16 -19609, i16 24573, i16 17898, i16 9151, i16 21495, i16 -7018, i16 -25765, i16 30146, i16 -7908, i16 15790, i16 19562, i16 27738, i16 32321, i16 -2814, i16 -31921, i16 26716, i16 20980, i16 -11980, i16 -1784, i16 -7533, i16 -21645, i16 25171, i16 10815, i16 2060, i16 -27310, i16 18021, i16 -25250, i16 12328, i16 14241, i16 2575, i16 12213, i16 3593, i16 9270, i16 7067, i16 -8387, i16 -13018, i16 20073, i16 32717, i16 -5473, i16 4635, i16 7582, i16 22644, i16 13358, i16 13869, i16 -9038, i16 -19218, i16 23547, i16 -23306, i16 30285, i16 -18591, i16 32206, i16 21115, i16 -8898, i16 24177, i16 5015, i16 -22795, i16 -18072, i16 0, i16 -16084, i16 16480, i16 -7393, i16 31176, i16 -18707, i16 -11074, i16 -29370, i16 26585, i16 29259, i16 -27426, i16 -26412, i16 -20248, i16 -31414, i16 -17557, i16 -15062, i16 20453, i16 -4842, i16 -31035, i16 -25897, i16 26197, i16 4500, i16 -30001, i16 -5872, i16 1030, i16 -383, i16 -24336, i16 30788, i16 9658, i16 19427, i16 -23821, i16 24062, i16 -32576, i16 1418, i16 16301, i16 8636, i16 28744, i16 -3836, i16 25567, i16 30657, i16 -20619, i16 16995, i16 8240, i16 -6886, i16 -754, i16 -16531, i16 -32436, i16 6164, i16 9781, i16 -15569, i16 -16671, i16 13730, i16 -30516, i16 11833, i16 -27817, i16 22002, i16 -894, i16 31303, i16 -14164, i16 -17689, i16 12843, i16 -6507, i16 -16224, i16 6552, i16 -24879, i16 -23681, i16 17510, i16 21630, i16 15275, i16 2947, i16 -29494, i16 -14551, i16 27603, i16 10300, i16 -22663, i16 -17182, i16 5661, i16 -21130, i16 -9413, i16 25686, i16 29774, i16 5150, i16 -27941, i16 3082, i16 18540, i16 -18204, i16 -24739, i16 -17042, i16 17391, i16 -15194, i16 14760, i16 12708, i16 -11465, i16 -3445, i16 -10958, i16 -29885, i16 28249, i16 -9545, i16 396, i16 -20124, i16 -25390, i16 18912, i16 -10060, i16 -21254, i16 -3321, i16 -12507, i16 -13649, i16 -2930, i16 18409, i16 4120, i16 28629, i16 -3960, i16 19055, i16 23666, i16 14372, i16 22513, i16 29639, i16 -26799, i16 -13533, i16 -24196, i16 -5988, i16 15905, i16 -26915, i16 25052, i16 3462, i16 3973, i16 -8048, i16 31810, i16 29124, i16 -13142, i16 -28456, i16 1541, i16 -2303, i16 7186, i16 -15709, i16 27231, i16 -20743, i16 27088, i16 6033, i16 -26280, i16 14887, i16 10169, i16 -9928, i16 -5357, i16 11187, i16 8755, i16 -11589, i16 -22160, i16 1929, i16 13223, i16 11702, i16 15394, i16 5522, i16 -14048, i16 -30903, i16 -21761, i16 20600, i16 -23174, i16 911, i16 23032, i16 2432, i16 6679, i16 26074, i16 -10447, i16 -31546, i16 -12104, i16 -32061, i16 10672, i16 23159, i16 7697, i16 31691, i16 -22276, i16 28118, i16 11322], [256 x i16] [i16 -23098, i16 -31496, i16 -26130, i16 -29194, i16 3583, i16 -16938, i16 -20002, i16 21649, i16 20576, i16 770, i16 -22066, i16 32086, i16 6631, i16 25269, i16 -6579, i16 -25876, i16 17807, i16 -25313, i16 16521, i16 -30726, i16 5615, i16 -5198, i16 -13938, i16 3067, i16 -5055, i16 26547, i16 -673, i16 -5563, i16 -16605, i16 -2221, i16 -26908, i16 23451, i16 -15755, i16 7393, i16 -20931, i16 27212, i16 23148, i16 16766, i16 757, i16 20355, i16 23656, i16 -2991, i16 13521, i16 2297, i16 -27678, i16 29611, i16 21346, i16 16170, i16 3080, i16 21141, i16 25926, i16 24221, i16 10288, i16 -24265, i16 3850, i16 -19153, i16 2318, i16 13860, i16 -25829, i16 15839, i16 9933, i16 26958, i16 -12929, i16 -24598, i16 6930, i16 -25059, i16 29784, i16 11828, i16 11574, i16 -19748, i16 -4428, i16 -1189, i16 -2396, i16 19830, i16 25015, i16 -12675, i16 31570, i16 16093, i16 29022, i16 -26861, i16 -2650, i16 26809, i16 0, i16 11457, i16 24640, i16 8163, i16 -14215, i16 -4682, i16 -16684, i16 18061, i16 -9881, i16 19314, i16 -8556, i16 -11112, i16 -5968, i16 19077, i16 27579, i16 10949, i16 -6833, i16 5869, i16 -14970, i16 -10342, i16 21862, i16 -27631, i16 -12406, i16 4329, i16 1540, i16 -32258, i16 -3936, i16 17528, i16 -17883, i16 -7349, i16 -3166, i16 -419, i16 -16256, i16 -30203, i16 -21185, i16 -17375, i16 18544, i16 1265, i16 -8349, i16 -16009, i16 30127, i16 25410, i16 12320, i16 6885, i16 3837, i16 28095, i16 19585, i16 5144, i16 13606, i16 12227, i16 -7746, i16 -24011, i16 -13176, i16 14638, i16 22419, i16 -3499, i16 -32004, i16 18298, i16 -21304, i16 -6214, i16 11058, i16 -27162, i16 -24384, i16 -26599, i16 -11874, i16 32675, i16 26180, i16 32340, i16 -21701, i16 -31989, i16 -13684, i16 10695, i16 -11413, i16 15400, i16 31143, i16 -7492, i16 7446, i16 30381, i16 15323, i16 22116, i16 20084, i16 7700, i16 -9326, i16 2572, i16 27720, i16 -6984, i16 23967, i16 28349, i16 -4285, i16 -22844, i16 -22471, i16 -23503, i16 14291, i16 -29710, i16 13013, i16 17291, i16 22894, i16 -18470, i16 -29695, i16 25777, i16 -11620, i16 -8119, i16 -19240, i16 -1364, i16 2035, i16 9679, i16 -20534, i16 -28940, i16 -5817, i16 6160, i16 -10897, i16 -30480, i16 28490, i16 29276, i16 9272, i16 -3753, i16 -14477, i16 20887, i16 9163, i16 31905, i16 -25368, i16 8510, i16 -8810, i16 -9119, i16 -31219, i16 -31473, i16 -28448, i16 17020, i16 -15247, i16 -21812, i16 -10096, i16 1286, i16 503, i16 4636, i16 -23614, i16 24426, i16 -1618, i16 -12183, i16 -28393, i16 22681, i16 10042, i16 -18137, i16 14553, i16 5099, i16 -19669, i16 13090, i16 -17454, i16 28841, i16 -30457, i16 -22733, i16 -18899, i16 8764, i16 -28139, i16 8393, i16 18823, i16 -86, i16 30800, i16 31397, i16 -28925, i16 -1959, i16 -32759, i16 5914, i16 -9627, i16 12759, i16 -14716, i16 -18224, i16 -15486, i16 -20439, i16 30554, i16 4382, i16 -13445, i16 -856, i16 -10643, i16 14892]], align 16
@.str.159 = private unnamed_addr constant [23 x i8] c"Pairwise key expansion\00", align 1
@.str.1.160 = private unnamed_addr constant [3 x i8] c"33\00", align 1
@.str.2.161 = private unnamed_addr constant [7 x i8] c"\FF\FF\FF\FF\FF\FF\00", align 1
@.str.3.162 = private unnamed_addr constant [7 x i8] c"\01\80\C2\00\00\00\00", align 1
@.str.4.163 = private unnamed_addr constant [7 x i8] c"\01\00\0C\CC\CC\CC\00", align 1
@.str.5.166 = private unnamed_addr constant [9 x i8] c"\AA\AA\03\00\00\00\08\06\00", align 1
@.str.6.167 = private unnamed_addr constant [7 x i8] c"\00\01\08\00\06\04\00", align 1
@.str.7.168 = private unnamed_addr constant [3 x i8] c"\00\01\00", align 1
@.str.8.169 = private unnamed_addr constant [3 x i8] c"\00\02\00", align 1
@.str.9.170 = private unnamed_addr constant [9 x i8] c"BB\03\00\00\00\00\00\00", align 1
@.str.10.171 = private unnamed_addr constant [8 x i8] c"\AA\AA\03\00\00\0C \00", align 1
@.str.11.172 = private unnamed_addr constant [9 x i8] c"\AA\AA\03\00\00\00\08\00\00", align 1
@.str.12.173 = private unnamed_addr constant [3 x i8] c"E\00\00", align 1
@.str.13.174 = private unnamed_addr constant [3 x i8] zeroinitializer, align 1
@.str.14.175 = private unnamed_addr constant [3 x i8] c"@\00\00", align 1
@.str.15.176 = private unnamed_addr constant [7 x i8] c"weight\00", align 1
@.str.16.177 = private unnamed_addr constant [9 x i8] c"crypto.c\00", align 1
@__PRETTY_FUNCTION__.known_clear = private unnamed_addr constant [60 x i8] c"int known_clear(void *, int *, int *, unsigned char *, int)\00", align 1
@.str.17.178 = private unnamed_addr constant [9 x i8] zeroinitializer, align 1
@.str.18.179 = private unnamed_addr constant [8 x i8] c"Blub 2:\00", align 1
@.str.19.180 = private unnamed_addr constant [6 x i8] c"%02X \00", align 1
@.str.20.181 = private unnamed_addr constant [2 x i8] c"\0A\00", align 1
@.str.21.182 = private unnamed_addr constant [8 x i8] c"Blub 1:\00", align 1
@.str.22.183 = private unnamed_addr constant [8 x i8] c"Blub 3:\00", align 1
@.str.23.184 = private unnamed_addr constant [2 x i8] c"Z\00", align 1
@ZERO.185 = internal global [32 x i8] zeroinitializer, align 16
@.str.186 = private unnamed_addr constant [14 x i8] c"/proc/meminfo\00", align 1
@.str.1.187 = private unnamed_addr constant [2 x i8] c"r\00", align 1
@.str.2.188 = private unnamed_addr constant [12 x i8] c"fopen fails\00", align 1
@.str.3.189 = private unnamed_addr constant [6 x i8] c"%s %d\00", align 1
@.str.4.190 = private unnamed_addr constant [9 x i8] c"MemTotal\00", align 1
@.str.5.193 = private unnamed_addr constant [9 x i8] c"%s %d.%d\00", align 1
@.str.6.194 = private unnamed_addr constant [4 x i8] c".%d\00", align 1
@.str.7.195 = private unnamed_addr constant [6 x i8] c" rc%d\00", align 1
@.str.8.196 = private unnamed_addr constant [8 x i8] c" beta%d\00", align 1
@.str.9.197 = private unnamed_addr constant [5 x i8] c" r%d\00", align 1
@.str.10.200 = private unnamed_addr constant [14 x i8] c"/proc/cpuinfo\00", align 1
@.str.11.201 = private unnamed_addr constant [10 x i8] c"processor\00", align 1
@.str.12.202 = private unnamed_addr constant [30 x i8] c"%02X:%02X:%02X:%02X:%02X:%02X\00", align 1
@hexCharToInt.table_created = internal global i32 0, align 4
@hexCharToInt.table = internal global [256 x i32] zeroinitializer, align 16
@.str.13.207 = private unnamed_addr constant [3 x i8] c"%x\00", align 1
@tried = common dso_local global i32 0, align 4
@max_tries = common dso_local global i32 0, align 4
@depth = common dso_local global [29 x i32] zeroinitializer, align 16
@keytable = common dso_local global [29 x [256 x %struct.PTW_tableentry]] zeroinitializer, align 16, !track !11
@.str.222 = private unnamed_addr constant [27 x i8] c"could not allocate memory\0A\00", align 1
@eval = internal constant [13 x double] [double 0x3F75E381C9B66998, double 0x3F75C8326DCE6C47, double 0x3F75C39070455B06, double 0x3F75A8FF7DF66AE8, double 0x3F758B7C75B3FAC1, double 0x3F75685AB224FECA, double 0x3F75437FCDD71938, double 0x3F7515C4F01E415C, double 0x3F74E856F2B97ECC, double 0x3F74B4640EBF1C9C, double 0x3F748026EDE8B20E, double 0x3F7447705D26E843, double 0x3F7410493F7B69E4], align 16
@.str.1.223 = private unnamed_addr constant [36 x i8] c"hit with strongbyte for keybyte %d\0A\00", align 1
@rc4initial = internal constant [256 x i8] c"\00\01\02\03\04\05\06\07\08\09\0A\0B\0C\0D\0E\0F\10\11\12\13\14\15\16\17\18\19\1A\1B\1C\1D\1E\1F !\22#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\5C]^_`abcdefghijklmnopqrstuvwxyz{|}~\7F\80\81\82\83\84\85\86\87\88\89\8A\8B\8C\8D\8E\8F\90\91\92\93\94\95\96\97\98\99\9A\9B\9C\9D\9E\9F\A0\A1\A2\A3\A4\A5\A6\A7\A8\A9\AA\AB\AC\AD\AE\AF\B0\B1\B2\B3\B4\B5\B6\B7\B8\B9\BA\BB\BC\BD\BE\BF\C0\C1\C2\C3\C4\C5\C6\C7\C8\C9\CA\CB\CC\CD\CE\CF\D0\D1\D2\D3\D4\D5\D6\D7\D8\D9\DA\DB\DC\DD\DE\DF\E0\E1\E2\E3\E4\E5\E6\E7\E8\E9\EA\EB\EC\ED\EE\EF\F0\F1\F2\F3\F4\F5\F6\F7\F8\F9\FA\FB\FC\FD\FE\FF", align 16
@0 = private constant [11 x i8] c"aircrack-ng"
@1 = private constant [2 x i8] c"-w"
@2 = private constant [12 x i8] c"password.lst"
@3 = private constant [7 x i8] c"wpa.cap"
@__argv_new__ = global i8** null, !track !12

; Function Attrs: noinline nounwind uwtable
define dso_local void @show_result(i8*, i8*) #0 {
  %3 = getelementptr [7 x i8], [7 x i8]* @.str, i32 0, i32 0
  %4 = call i32 (i8*, ...) @printf(i8* %3, i8* %0)
  br label %5

; <label>:5:                                      ; preds = %2, %5
  %indvars.iv = phi i64 [ 0, %2 ], [ %indvars.iv.next, %5 ]
  %6 = getelementptr inbounds i8, i8* %1, i64 %indvars.iv
  %7 = load i8, i8* %6, align 1
  %8 = zext i8 %7 to i32
  %9 = getelementptr [5 x i8], [5 x i8]* @.str.1, i32 0, i32 0
  %10 = call i32 (i8*, ...) @printf(i8* %9, i32 %8)
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond = icmp ne i64 %indvars.iv.next, 32
  br i1 %exitcond, label %5, label %11

; <label>:11:                                     ; preds = %5
  %12 = getelementptr [2 x i8], [2 x i8]* @.str.2, i32 0, i32 0
  %13 = call i32 (i8*, ...) @printf(i8* %12)
  ret void
}

declare dso_local i32 @printf(i8*, ...) #1

; Function Attrs: noinline nounwind uwtable
define dso_local void @calc_4pmk(i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*) #0 {
  %10 = alloca [36 x i8], align 16, !track !15
  %11 = alloca [128 x i8], align 16, !track !16
  %12 = alloca [128 x i8], align 16, !track !17
  %13 = alloca [128 x i8], align 16, !track !18
  %14 = alloca [128 x i8], align 16, !track !19
  %15 = alloca [512 x i8], align 16, !track !20
  %16 = alloca [256 x i8], align 16, !track !21
  %17 = alloca [80 x i8], align 16, !track !22
  %18 = alloca [256 x i8], align 16, !track !23
  %19 = alloca [80 x i8], align 16, !track !24
  %20 = alloca [256 x i8], align 16, !track !25
  %21 = alloca [80 x i8], align 16, !track !26
  %22 = alloca [1280 x i8], align 16, !track !27
  %23 = getelementptr inbounds [36 x i8], [36 x i8]* %10, i32 0, i32 0
  %24 = call i8* @strncpy(i8* %23, i8* %4, i64 35) #9, !track !28
  %25 = getelementptr inbounds [128 x i8], [128 x i8]* %11, i32 0, i32 0
  %26 = call i8* @strncpy(i8* %25, i8* %0, i64 127) #9, !track !29
  %27 = getelementptr inbounds [128 x i8], [128 x i8]* %12, i32 0, i32 0
  %28 = call i8* @strncpy(i8* %27, i8* %1, i64 127) #9, !track !30
  %29 = getelementptr inbounds [128 x i8], [128 x i8]* %13, i32 0, i32 0
  %30 = call i8* @strncpy(i8* %29, i8* %2, i64 127) #9, !track !31
  %31 = getelementptr inbounds [128 x i8], [128 x i8]* %14, i32 0, i32 0
  %32 = call i8* @strncpy(i8* %31, i8* %3, i64 127) #9, !track !32
  %33 = getelementptr inbounds [36 x i8], [36 x i8]* %10, i32 0, i32 0
  %34 = call i64 @strlen(i8* %33) #10
  %35 = getelementptr inbounds [256 x i8], [256 x i8]* %16, i32 0, i32 0
  call void @llvm.memset.p0i8.i64(i8* align 16 %35, i8 0, i64 256, i1 false)
  %36 = getelementptr inbounds [256 x i8], [256 x i8]* %18, i32 0, i32 0
  call void @llvm.memset.p0i8.i64(i8* align 16 %36, i8 0, i64 256, i1 false)
  %37 = getelementptr inbounds [256 x i8], [256 x i8]* %16, i32 0, i32 0
  %38 = getelementptr inbounds [128 x i8], [128 x i8]* %11, i32 0, i32 0
  %39 = getelementptr inbounds [128 x i8], [128 x i8]* %11, i32 0, i32 0
  %40 = call i64 @strlen(i8* %39) #10
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 16 %37, i8* align 16 %38, i64 %40, i1 false), !track !33
  %41 = getelementptr inbounds [256 x i8], [256 x i8]* %18, i32 0, i32 0
  %42 = getelementptr inbounds [128 x i8], [128 x i8]* %11, i32 0, i32 0
  %43 = getelementptr inbounds [128 x i8], [128 x i8]* %11, i32 0, i32 0
  %44 = call i64 @strlen(i8* %43) #10
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 16 %41, i8* align 16 %42, i64 %44, i1 false), !track !34
  %45 = getelementptr inbounds [256 x i8], [256 x i8]* %16, i32 0, i32 0
  %46 = getelementptr inbounds i8, i8* %45, i64 64
  %47 = getelementptr inbounds [128 x i8], [128 x i8]* %12, i32 0, i32 0
  %48 = getelementptr inbounds [128 x i8], [128 x i8]* %12, i32 0, i32 0
  %49 = call i64 @strlen(i8* %48) #10
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %46, i8* align 16 %47, i64 %49, i1 false), !track !35
  %50 = getelementptr inbounds [256 x i8], [256 x i8]* %18, i32 0, i32 0
  %51 = getelementptr inbounds i8, i8* %50, i64 64
  %52 = getelementptr inbounds [128 x i8], [128 x i8]* %12, i32 0, i32 0
  %53 = getelementptr inbounds [128 x i8], [128 x i8]* %12, i32 0, i32 0
  %54 = call i64 @strlen(i8* %53) #10
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %51, i8* align 16 %52, i64 %54, i1 false), !track !36
  %55 = getelementptr inbounds [256 x i8], [256 x i8]* %16, i32 0, i32 0
  %56 = getelementptr inbounds i8, i8* %55, i64 128
  %57 = getelementptr inbounds [128 x i8], [128 x i8]* %13, i32 0, i32 0
  %58 = getelementptr inbounds [128 x i8], [128 x i8]* %13, i32 0, i32 0
  %59 = call i64 @strlen(i8* %58) #10
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %56, i8* align 16 %57, i64 %59, i1 false), !track !37
  %60 = getelementptr inbounds [256 x i8], [256 x i8]* %18, i32 0, i32 0
  %61 = getelementptr inbounds i8, i8* %60, i64 128
  %62 = getelementptr inbounds [128 x i8], [128 x i8]* %13, i32 0, i32 0
  %63 = getelementptr inbounds [128 x i8], [128 x i8]* %13, i32 0, i32 0
  %64 = call i64 @strlen(i8* %63) #10
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %61, i8* align 16 %62, i64 %64, i1 false), !track !38
  %65 = getelementptr inbounds [256 x i8], [256 x i8]* %16, i32 0, i32 0
  %66 = getelementptr inbounds i8, i8* %65, i64 192
  %67 = getelementptr inbounds [128 x i8], [128 x i8]* %14, i32 0, i32 0
  %68 = getelementptr inbounds [128 x i8], [128 x i8]* %14, i32 0, i32 0
  %69 = call i64 @strlen(i8* %68) #10
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %66, i8* align 16 %67, i64 %69, i1 false), !track !39
  %70 = getelementptr inbounds [256 x i8], [256 x i8]* %18, i32 0, i32 0
  %71 = getelementptr inbounds i8, i8* %70, i64 192
  %72 = getelementptr inbounds [128 x i8], [128 x i8]* %14, i32 0, i32 0
  %73 = getelementptr inbounds [128 x i8], [128 x i8]* %14, i32 0, i32 0
  %74 = call i64 @strlen(i8* %73) #10
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %71, i8* align 16 %72, i64 %74, i1 false), !track !40
  %75 = getelementptr inbounds [256 x i8], [256 x i8]* %16, i32 0, i32 0
  %76 = bitcast i8* %75 to i32*
  %77 = getelementptr inbounds [256 x i8], [256 x i8]* %16, i32 0, i32 0
  %78 = getelementptr inbounds i8, i8* %77, i64 64
  %79 = bitcast i8* %78 to i32*
  %80 = getelementptr inbounds [256 x i8], [256 x i8]* %16, i32 0, i32 0
  %81 = getelementptr inbounds i8, i8* %80, i64 128
  %82 = bitcast i8* %81 to i32*
  %83 = getelementptr inbounds [256 x i8], [256 x i8]* %16, i32 0, i32 0
  %84 = getelementptr inbounds i8, i8* %83, i64 192
  %85 = bitcast i8* %84 to i32*
  %86 = getelementptr inbounds [256 x i8], [256 x i8]* %20, i32 0, i32 0
  %87 = bitcast i8* %86 to i32*
  br label %88

; <label>:88:                                     ; preds = %9, %88
  %.026 = phi i32* [ %85, %9 ], [ %101, %88 ]
  %.0125 = phi i32* [ %82, %9 ], [ %97, %88 ]
  %.0324 = phi i32* [ %87, %9 ], [ %104, %88 ]
  %.0523 = phi i32* [ %79, %9 ], [ %93, %88 ]
  %.0722 = phi i32* [ %76, %9 ], [ %89, %88 ]
  %.0921 = phi i32 [ 0, %9 ], [ %105, %88 ]
  call void @unroll_loop(i32 4)
  %89 = getelementptr inbounds i32, i32* %.0722, i32 1
  %90 = load i32, i32* %.0722, align 4
  %91 = xor i32 %90, 909522486
  %92 = getelementptr inbounds i32, i32* %.0324, i32 1
  store i32 %91, i32* %.0324, align 4
  %93 = getelementptr inbounds i32, i32* %.0523, i32 1
  %94 = load i32, i32* %.0523, align 4
  %95 = xor i32 %94, 909522486
  %96 = getelementptr inbounds i32, i32* %92, i32 1
  store i32 %95, i32* %92, align 4
  %97 = getelementptr inbounds i32, i32* %.0125, i32 1
  %98 = load i32, i32* %.0125, align 4
  %99 = xor i32 %98, 909522486
  %100 = getelementptr inbounds i32, i32* %96, i32 1
  store i32 %99, i32* %96, align 4
  %101 = getelementptr inbounds i32, i32* %.026, i32 1
  %102 = load i32, i32* %.026, align 4
  %103 = xor i32 %102, 909522486
  %104 = getelementptr inbounds i32, i32* %100, i32 1
  store i32 %103, i32* %100, align 4
  %105 = add nuw nsw i32 %.0921, 1
  %exitcond27 = icmp ne i32 %105, 16
  br i1 %exitcond27, label %88, label %106

; <label>:106:                                    ; preds = %88
  %107 = getelementptr inbounds [512 x i8], [512 x i8]* %15, i32 0, i32 0
  %108 = getelementptr inbounds [512 x i8], [512 x i8]* %15, i32 0, i32 0
  %109 = getelementptr inbounds [512 x i8], [512 x i8]* %15, i32 0, i32 0
  %110 = getelementptr inbounds i8, i8* %108, i64 128
  %111 = getelementptr inbounds [80 x i8], [80 x i8]* %17, i32 0, i32 0
  %112 = call i32 @shasse2_init(i8* %111)
  %113 = getelementptr inbounds [80 x i8], [80 x i8]* %17, i32 0, i32 0
  %114 = getelementptr inbounds [256 x i8], [256 x i8]* %20, i32 0, i32 0
  %115 = getelementptr inbounds [1280 x i8], [1280 x i8]* %22, i32 0, i32 0
  %116 = call i32 @shasse2_data(i8* %113, i8* %114, i8* %115)
  %117 = getelementptr inbounds [256 x i8], [256 x i8]* %18, i32 0, i32 0
  %118 = bitcast i8* %117 to i32*
  %119 = getelementptr inbounds [256 x i8], [256 x i8]* %18, i32 0, i32 0
  %120 = getelementptr inbounds i8, i8* %119, i64 64
  %121 = bitcast i8* %120 to i32*
  %122 = getelementptr inbounds [256 x i8], [256 x i8]* %18, i32 0, i32 0
  %123 = getelementptr inbounds i8, i8* %122, i64 128
  %124 = bitcast i8* %123 to i32*
  %125 = getelementptr inbounds [256 x i8], [256 x i8]* %18, i32 0, i32 0
  %126 = getelementptr inbounds i8, i8* %125, i64 192
  %127 = bitcast i8* %126 to i32*
  %128 = getelementptr inbounds [256 x i8], [256 x i8]* %20, i32 0, i32 0
  %129 = bitcast i8* %128 to i32*
  br label %130

; <label>:130:                                    ; preds = %106, %130
  %.119 = phi i32* [ %127, %106 ], [ %143, %130 ]
  %.1218 = phi i32* [ %124, %106 ], [ %139, %130 ]
  %.1417 = phi i32* [ %129, %106 ], [ %146, %130 ]
  %.1616 = phi i32* [ %121, %106 ], [ %135, %130 ]
  %.1815 = phi i32* [ %118, %106 ], [ %131, %130 ]
  %.11014 = phi i32 [ 0, %106 ], [ %147, %130 ]
  call void @unroll_loop(i32 5)
  %131 = getelementptr inbounds i32, i32* %.1815, i32 1
  %132 = load i32, i32* %.1815, align 4
  %133 = xor i32 %132, 1549556828
  %134 = getelementptr inbounds i32, i32* %.1417, i32 1
  store i32 %133, i32* %.1417, align 4
  %135 = getelementptr inbounds i32, i32* %.1616, i32 1
  %136 = load i32, i32* %.1616, align 4
  %137 = xor i32 %136, 1549556828
  %138 = getelementptr inbounds i32, i32* %134, i32 1
  store i32 %137, i32* %134, align 4
  %139 = getelementptr inbounds i32, i32* %.1218, i32 1
  %140 = load i32, i32* %.1218, align 4
  %141 = xor i32 %140, 1549556828
  %142 = getelementptr inbounds i32, i32* %138, i32 1
  store i32 %141, i32* %138, align 4
  %143 = getelementptr inbounds i32, i32* %.119, i32 1
  %144 = load i32, i32* %.119, align 4
  %145 = xor i32 %144, 1549556828
  %146 = getelementptr inbounds i32, i32* %142, i32 1
  store i32 %145, i32* %142, align 4
  %147 = add nuw nsw i32 %.11014, 1
  %exitcond20 = icmp ne i32 %147, 16
  br i1 %exitcond20, label %130, label %148

; <label>:148:                                    ; preds = %130
  %149 = add i64 %34, 4
  %150 = getelementptr inbounds i8, i8* %109, i64 384
  %151 = getelementptr inbounds [512 x i8], [512 x i8]* %15, i32 0, i32 0
  %152 = getelementptr inbounds i8, i8* %107, i64 256
  %153 = trunc i64 %149 to i32
  %154 = getelementptr inbounds [80 x i8], [80 x i8]* %19, i32 0, i32 0
  %155 = call i32 @shasse2_init(i8* %154)
  %156 = getelementptr inbounds [80 x i8], [80 x i8]* %19, i32 0, i32 0
  %157 = getelementptr inbounds [256 x i8], [256 x i8]* %20, i32 0, i32 0
  %158 = getelementptr inbounds [1280 x i8], [1280 x i8]* %22, i32 0, i32 0
  %159 = call i32 @shasse2_data(i8* %156, i8* %157, i8* %158)
  %160 = getelementptr inbounds [256 x i8], [256 x i8]* %20, i32 0, i32 0
  call void @llvm.memset.p0i8.i64(i8* align 16 %160, i8 0, i64 256, i1 false)
  %161 = getelementptr inbounds [256 x i8], [256 x i8]* %20, i64 0, i64 92
  store i8 -128, i8* %161, align 4
  %162 = getelementptr inbounds [256 x i8], [256 x i8]* %20, i64 0, i64 88
  store i8 -128, i8* %162, align 8
  %163 = getelementptr inbounds [256 x i8], [256 x i8]* %20, i64 0, i64 84
  store i8 -128, i8* %163, align 4
  %164 = getelementptr inbounds [256 x i8], [256 x i8]* %20, i64 0, i64 80
  store i8 -128, i8* %164, align 16
  %165 = getelementptr inbounds [256 x i8], [256 x i8]* %20, i64 0, i64 254
  store i8 2, i8* %165, align 2
  %166 = getelementptr inbounds [256 x i8], [256 x i8]* %20, i64 0, i64 250
  store i8 2, i8* %166, align 2
  %167 = getelementptr inbounds [256 x i8], [256 x i8]* %20, i64 0, i64 246
  store i8 2, i8* %167, align 2
  %168 = getelementptr inbounds [256 x i8], [256 x i8]* %20, i64 0, i64 242
  store i8 2, i8* %168, align 2
  %169 = getelementptr inbounds [256 x i8], [256 x i8]* %20, i64 0, i64 255
  store i8 -96, i8* %169, align 1
  %170 = getelementptr inbounds [256 x i8], [256 x i8]* %20, i64 0, i64 251
  store i8 -96, i8* %170, align 1
  %171 = getelementptr inbounds [256 x i8], [256 x i8]* %20, i64 0, i64 247
  store i8 -96, i8* %171, align 1
  %172 = getelementptr inbounds [256 x i8], [256 x i8]* %20, i64 0, i64 243
  store i8 -96, i8* %172, align 1
  %173 = sub nsw i32 %153, 1
  %174 = sext i32 %173 to i64
  %175 = getelementptr inbounds [36 x i8], [36 x i8]* %10, i64 0, i64 %174
  store i8 1, i8* %175, align 1
  %176 = call %struct.env_md_st* @EVP_sha1()
  %177 = getelementptr inbounds [128 x i8], [128 x i8]* %11, i32 0, i32 0
  %178 = getelementptr inbounds [128 x i8], [128 x i8]* %11, i32 0, i32 0
  %179 = call i64 @strlen(i8* %178) #10
  %180 = trunc i64 %179 to i32
  %181 = getelementptr inbounds [36 x i8], [36 x i8]* %10, i32 0, i32 0
  %182 = sext i32 %153 to i64
  %183 = call i8* @HMAC(%struct.env_md_st* %176, i8* %177, i32 %180, i8* %181, i64 %182, i8* %151, i32* null)
  %184 = call %struct.env_md_st* @EVP_sha1()
  %185 = getelementptr inbounds [128 x i8], [128 x i8]* %12, i32 0, i32 0
  %186 = getelementptr inbounds [128 x i8], [128 x i8]* %12, i32 0, i32 0
  %187 = call i64 @strlen(i8* %186) #10
  %188 = trunc i64 %187 to i32
  %189 = getelementptr inbounds [36 x i8], [36 x i8]* %10, i32 0, i32 0
  %190 = sext i32 %153 to i64
  %191 = call i8* @HMAC(%struct.env_md_st* %184, i8* %185, i32 %188, i8* %189, i64 %190, i8* %110, i32* null)
  %192 = call %struct.env_md_st* @EVP_sha1()
  %193 = getelementptr inbounds [128 x i8], [128 x i8]* %13, i32 0, i32 0
  %194 = getelementptr inbounds [128 x i8], [128 x i8]* %13, i32 0, i32 0
  %195 = call i64 @strlen(i8* %194) #10
  %196 = trunc i64 %195 to i32
  %197 = getelementptr inbounds [36 x i8], [36 x i8]* %10, i32 0, i32 0
  %198 = sext i32 %153 to i64
  %199 = call i8* @HMAC(%struct.env_md_st* %192, i8* %193, i32 %196, i8* %197, i64 %198, i8* %152, i32* null)
  %200 = call %struct.env_md_st* @EVP_sha1()
  %201 = getelementptr inbounds [128 x i8], [128 x i8]* %14, i32 0, i32 0
  %202 = getelementptr inbounds [128 x i8], [128 x i8]* %14, i32 0, i32 0
  %203 = call i64 @strlen(i8* %202) #10
  %204 = trunc i64 %203 to i32
  %205 = getelementptr inbounds [36 x i8], [36 x i8]* %10, i32 0, i32 0
  %206 = sext i32 %153 to i64
  %207 = call i8* @HMAC(%struct.env_md_st* %200, i8* %201, i32 %204, i8* %205, i64 %206, i8* %150, i32* null)
  %208 = bitcast i8* %151 to i32*
  %209 = bitcast i8* %110 to i32*
  %210 = bitcast i8* %152 to i32*
  %211 = bitcast i8* %150 to i32*
  %212 = getelementptr inbounds [256 x i8], [256 x i8]* %20, i32 0, i32 0
  %213 = bitcast i8* %212 to i32*
  %214 = getelementptr inbounds i32, i32* %208, i32 1
  %215 = load i32, i32* %208, align 4
  %216 = getelementptr inbounds i32, i32* %213, i32 1
  store i32 %215, i32* %213, align 4
  %217 = getelementptr inbounds i32, i32* %209, i32 1
  %218 = load i32, i32* %209, align 4
  %219 = getelementptr inbounds i32, i32* %216, i32 1
  store i32 %218, i32* %216, align 4
  %220 = getelementptr inbounds i32, i32* %210, i32 1
  %221 = load i32, i32* %210, align 4
  %222 = getelementptr inbounds i32, i32* %219, i32 1
  store i32 %221, i32* %219, align 4
  %223 = getelementptr inbounds i32, i32* %211, i32 1
  %224 = load i32, i32* %211, align 4
  %225 = getelementptr inbounds i32, i32* %222, i32 1
  store i32 %224, i32* %222, align 4
  %226 = getelementptr inbounds i32, i32* %214, i32 1
  %227 = load i32, i32* %214, align 4
  %228 = getelementptr inbounds i32, i32* %225, i32 1
  store i32 %227, i32* %225, align 4
  %229 = getelementptr inbounds i32, i32* %217, i32 1
  %230 = load i32, i32* %217, align 4
  %231 = getelementptr inbounds i32, i32* %228, i32 1
  store i32 %230, i32* %228, align 4
  %232 = getelementptr inbounds i32, i32* %220, i32 1
  %233 = load i32, i32* %220, align 4
  %234 = getelementptr inbounds i32, i32* %231, i32 1
  store i32 %233, i32* %231, align 4
  %235 = getelementptr inbounds i32, i32* %223, i32 1
  %236 = load i32, i32* %223, align 4
  %237 = getelementptr inbounds i32, i32* %234, i32 1
  store i32 %236, i32* %234, align 4
  %238 = getelementptr inbounds i32, i32* %226, i32 1
  %239 = load i32, i32* %226, align 4
  %240 = getelementptr inbounds i32, i32* %237, i32 1
  store i32 %239, i32* %237, align 4
  %241 = getelementptr inbounds i32, i32* %229, i32 1
  %242 = load i32, i32* %229, align 4
  %243 = getelementptr inbounds i32, i32* %240, i32 1
  store i32 %242, i32* %240, align 4
  %244 = getelementptr inbounds i32, i32* %232, i32 1
  %245 = load i32, i32* %232, align 4
  %246 = getelementptr inbounds i32, i32* %243, i32 1
  store i32 %245, i32* %243, align 4
  %247 = getelementptr inbounds i32, i32* %235, i32 1
  %248 = load i32, i32* %235, align 4
  %249 = getelementptr inbounds i32, i32* %246, i32 1
  store i32 %248, i32* %246, align 4
  %250 = getelementptr inbounds i32, i32* %238, i32 1
  %251 = load i32, i32* %238, align 4
  %252 = getelementptr inbounds i32, i32* %249, i32 1
  store i32 %251, i32* %249, align 4
  %253 = getelementptr inbounds i32, i32* %241, i32 1
  %254 = load i32, i32* %241, align 4
  %255 = getelementptr inbounds i32, i32* %252, i32 1
  store i32 %254, i32* %252, align 4
  %256 = getelementptr inbounds i32, i32* %244, i32 1
  %257 = load i32, i32* %244, align 4
  %258 = getelementptr inbounds i32, i32* %255, i32 1
  store i32 %257, i32* %255, align 4
  %259 = getelementptr inbounds i32, i32* %247, i32 1
  %260 = load i32, i32* %247, align 4
  %261 = getelementptr inbounds i32, i32* %258, i32 1
  store i32 %260, i32* %258, align 4
  %262 = load i32, i32* %250, align 4
  %263 = getelementptr inbounds i32, i32* %261, i32 1
  store i32 %262, i32* %261, align 4
  %264 = load i32, i32* %253, align 4
  %265 = getelementptr inbounds i32, i32* %263, i32 1
  store i32 %264, i32* %263, align 4
  %266 = load i32, i32* %256, align 4
  %267 = getelementptr inbounds i32, i32* %265, i32 1
  store i32 %266, i32* %265, align 4
  %268 = load i32, i32* %259, align 4
  store i32 %268, i32* %267, align 4
  br label %269

; <label>:269:                                    ; preds = %148, %269
  %.212 = phi i32 [ 1, %148 ], [ %394, %269 ]
  call void @unroll_loop(i32 6)
  %270 = getelementptr inbounds [80 x i8], [80 x i8]* %21, i32 0, i32 0
  %271 = getelementptr inbounds [80 x i8], [80 x i8]* %17, i32 0, i32 0
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 16 %270, i8* align 16 %271, i64 80, i1 false), !track !41
  %272 = getelementptr inbounds [80 x i8], [80 x i8]* %21, i32 0, i32 0
  %273 = getelementptr inbounds [256 x i8], [256 x i8]* %20, i32 0, i32 0
  %274 = getelementptr inbounds [1280 x i8], [1280 x i8]* %22, i32 0, i32 0
  %275 = call i32 @shasse2_data(i8* %272, i8* %273, i8* %274)
  %276 = getelementptr inbounds [80 x i8], [80 x i8]* %21, i32 0, i32 0
  %277 = getelementptr inbounds [256 x i8], [256 x i8]* %20, i32 0, i32 0
  %278 = call i32 @shasse2_ends(i8* %276, i8* %277)
  %279 = getelementptr inbounds [80 x i8], [80 x i8]* %21, i32 0, i32 0
  %280 = getelementptr inbounds [80 x i8], [80 x i8]* %19, i32 0, i32 0
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 16 %279, i8* align 16 %280, i64 80, i1 false), !track !42
  %281 = getelementptr inbounds [80 x i8], [80 x i8]* %21, i32 0, i32 0
  %282 = getelementptr inbounds [256 x i8], [256 x i8]* %20, i32 0, i32 0
  %283 = getelementptr inbounds [1280 x i8], [1280 x i8]* %22, i32 0, i32 0
  %284 = call i32 @shasse2_data(i8* %281, i8* %282, i8* %283)
  %285 = getelementptr inbounds [80 x i8], [80 x i8]* %21, i32 0, i32 0
  %286 = getelementptr inbounds [256 x i8], [256 x i8]* %20, i32 0, i32 0
  %287 = call i32 @shasse2_ends(i8* %285, i8* %286)
  %288 = bitcast i8* %151 to i32*
  %289 = bitcast i8* %110 to i32*
  %290 = bitcast i8* %152 to i32*
  %291 = bitcast i8* %150 to i32*
  %292 = getelementptr inbounds [256 x i8], [256 x i8]* %20, i32 0, i32 0
  %293 = bitcast i8* %292 to i32*
  %294 = getelementptr inbounds i32, i32* %293, i32 1
  %295 = load i32, i32* %293, align 4
  %296 = getelementptr inbounds i32, i32* %288, i32 1
  %297 = load i32, i32* %288, align 4
  %298 = xor i32 %297, %295
  store i32 %298, i32* %288, align 4
  %299 = getelementptr inbounds i32, i32* %294, i32 1
  %300 = load i32, i32* %294, align 4
  %301 = getelementptr inbounds i32, i32* %289, i32 1
  %302 = load i32, i32* %289, align 4
  %303 = xor i32 %302, %300
  store i32 %303, i32* %289, align 4
  %304 = getelementptr inbounds i32, i32* %299, i32 1
  %305 = load i32, i32* %299, align 4
  %306 = getelementptr inbounds i32, i32* %290, i32 1
  %307 = load i32, i32* %290, align 4
  %308 = xor i32 %307, %305
  store i32 %308, i32* %290, align 4
  %309 = getelementptr inbounds i32, i32* %304, i32 1
  %310 = load i32, i32* %304, align 4
  %311 = getelementptr inbounds i32, i32* %291, i32 1
  %312 = load i32, i32* %291, align 4
  %313 = xor i32 %312, %310
  store i32 %313, i32* %291, align 4
  %314 = getelementptr inbounds i32, i32* %309, i32 1
  %315 = load i32, i32* %309, align 4
  %316 = getelementptr inbounds i32, i32* %296, i32 1
  %317 = load i32, i32* %296, align 4
  %318 = xor i32 %317, %315
  store i32 %318, i32* %296, align 4
  %319 = getelementptr inbounds i32, i32* %314, i32 1
  %320 = load i32, i32* %314, align 4
  %321 = getelementptr inbounds i32, i32* %301, i32 1
  %322 = load i32, i32* %301, align 4
  %323 = xor i32 %322, %320
  store i32 %323, i32* %301, align 4
  %324 = getelementptr inbounds i32, i32* %319, i32 1
  %325 = load i32, i32* %319, align 4
  %326 = getelementptr inbounds i32, i32* %306, i32 1
  %327 = load i32, i32* %306, align 4
  %328 = xor i32 %327, %325
  store i32 %328, i32* %306, align 4
  %329 = getelementptr inbounds i32, i32* %324, i32 1
  %330 = load i32, i32* %324, align 4
  %331 = getelementptr inbounds i32, i32* %311, i32 1
  %332 = load i32, i32* %311, align 4
  %333 = xor i32 %332, %330
  store i32 %333, i32* %311, align 4
  %334 = getelementptr inbounds i32, i32* %329, i32 1
  %335 = load i32, i32* %329, align 4
  %336 = getelementptr inbounds i32, i32* %316, i32 1
  %337 = load i32, i32* %316, align 4
  %338 = xor i32 %337, %335
  store i32 %338, i32* %316, align 4
  %339 = getelementptr inbounds i32, i32* %334, i32 1
  %340 = load i32, i32* %334, align 4
  %341 = getelementptr inbounds i32, i32* %321, i32 1
  %342 = load i32, i32* %321, align 4
  %343 = xor i32 %342, %340
  store i32 %343, i32* %321, align 4
  %344 = getelementptr inbounds i32, i32* %339, i32 1
  %345 = load i32, i32* %339, align 4
  %346 = getelementptr inbounds i32, i32* %326, i32 1
  %347 = load i32, i32* %326, align 4
  %348 = xor i32 %347, %345
  store i32 %348, i32* %326, align 4
  %349 = getelementptr inbounds i32, i32* %344, i32 1
  %350 = load i32, i32* %344, align 4
  %351 = getelementptr inbounds i32, i32* %331, i32 1
  %352 = load i32, i32* %331, align 4
  %353 = xor i32 %352, %350
  store i32 %353, i32* %331, align 4
  %354 = getelementptr inbounds i32, i32* %349, i32 1
  %355 = load i32, i32* %349, align 4
  %356 = getelementptr inbounds i32, i32* %336, i32 1
  %357 = load i32, i32* %336, align 4
  %358 = xor i32 %357, %355
  store i32 %358, i32* %336, align 4
  %359 = getelementptr inbounds i32, i32* %354, i32 1
  %360 = load i32, i32* %354, align 4
  %361 = getelementptr inbounds i32, i32* %341, i32 1
  %362 = load i32, i32* %341, align 4
  %363 = xor i32 %362, %360
  store i32 %363, i32* %341, align 4
  %364 = getelementptr inbounds i32, i32* %359, i32 1
  %365 = load i32, i32* %359, align 4
  %366 = getelementptr inbounds i32, i32* %346, i32 1
  %367 = load i32, i32* %346, align 4
  %368 = xor i32 %367, %365
  store i32 %368, i32* %346, align 4
  %369 = getelementptr inbounds i32, i32* %364, i32 1
  %370 = load i32, i32* %364, align 4
  %371 = getelementptr inbounds i32, i32* %351, i32 1
  %372 = load i32, i32* %351, align 4
  %373 = xor i32 %372, %370
  store i32 %373, i32* %351, align 4
  %374 = getelementptr inbounds i32, i32* %369, i32 1
  %375 = load i32, i32* %369, align 4
  %376 = getelementptr inbounds i32, i32* %356, i32 1
  %377 = load i32, i32* %356, align 4
  %378 = xor i32 %377, %375
  store i32 %378, i32* %356, align 4
  %379 = getelementptr inbounds i32, i32* %374, i32 1
  %380 = load i32, i32* %374, align 4
  %381 = getelementptr inbounds i32, i32* %361, i32 1
  %382 = load i32, i32* %361, align 4
  %383 = xor i32 %382, %380
  store i32 %383, i32* %361, align 4
  %384 = getelementptr inbounds i32, i32* %379, i32 1
  %385 = load i32, i32* %379, align 4
  %386 = getelementptr inbounds i32, i32* %366, i32 1
  %387 = load i32, i32* %366, align 4
  %388 = xor i32 %387, %385
  store i32 %388, i32* %366, align 4
  %389 = getelementptr inbounds i32, i32* %384, i32 1
  %390 = load i32, i32* %384, align 4
  %391 = getelementptr inbounds i32, i32* %371, i32 1
  %392 = load i32, i32* %371, align 4
  %393 = xor i32 %392, %390
  store i32 %393, i32* %371, align 4
  %394 = add nuw nsw i32 %.212, 1
  %exitcond13 = icmp ne i32 %394, 4096
  br i1 %exitcond13, label %269, label %395

; <label>:395:                                    ; preds = %269
  %396 = getelementptr inbounds i32, i32* %253, i32 1
  %397 = sub nsw i32 %153, 1
  %398 = sext i32 %397 to i64
  %399 = getelementptr inbounds [36 x i8], [36 x i8]* %10, i64 0, i64 %398
  store i8 2, i8* %399, align 1
  %400 = call %struct.env_md_st* @EVP_sha1()
  %401 = getelementptr inbounds [128 x i8], [128 x i8]* %11, i32 0, i32 0
  %402 = getelementptr inbounds [128 x i8], [128 x i8]* %11, i32 0, i32 0
  %403 = call i64 @strlen(i8* %402) #10
  %404 = trunc i64 %403 to i32
  %405 = getelementptr inbounds [36 x i8], [36 x i8]* %10, i32 0, i32 0
  %406 = sext i32 %153 to i64
  %407 = getelementptr inbounds i8, i8* %151, i64 20
  %408 = call i8* @HMAC(%struct.env_md_st* %400, i8* %401, i32 %404, i8* %405, i64 %406, i8* %407, i32* null)
  %409 = call %struct.env_md_st* @EVP_sha1()
  %410 = getelementptr inbounds [128 x i8], [128 x i8]* %12, i32 0, i32 0
  %411 = getelementptr inbounds [128 x i8], [128 x i8]* %12, i32 0, i32 0
  %412 = call i64 @strlen(i8* %411) #10
  %413 = trunc i64 %412 to i32
  %414 = getelementptr inbounds [36 x i8], [36 x i8]* %10, i32 0, i32 0
  %415 = sext i32 %153 to i64
  %416 = getelementptr inbounds i8, i8* %110, i64 20
  %417 = call i8* @HMAC(%struct.env_md_st* %409, i8* %410, i32 %413, i8* %414, i64 %415, i8* %416, i32* null)
  %418 = call %struct.env_md_st* @EVP_sha1()
  %419 = getelementptr inbounds [128 x i8], [128 x i8]* %13, i32 0, i32 0
  %420 = getelementptr inbounds [128 x i8], [128 x i8]* %13, i32 0, i32 0
  %421 = call i64 @strlen(i8* %420) #10
  %422 = trunc i64 %421 to i32
  %423 = getelementptr inbounds [36 x i8], [36 x i8]* %10, i32 0, i32 0
  %424 = sext i32 %153 to i64
  %425 = getelementptr inbounds i8, i8* %152, i64 20
  %426 = call i8* @HMAC(%struct.env_md_st* %418, i8* %419, i32 %422, i8* %423, i64 %424, i8* %425, i32* null)
  %427 = call %struct.env_md_st* @EVP_sha1()
  %428 = getelementptr inbounds [128 x i8], [128 x i8]* %14, i32 0, i32 0
  %429 = getelementptr inbounds [128 x i8], [128 x i8]* %14, i32 0, i32 0
  %430 = call i64 @strlen(i8* %429) #10
  %431 = trunc i64 %430 to i32
  %432 = getelementptr inbounds [36 x i8], [36 x i8]* %10, i32 0, i32 0
  %433 = sext i32 %153 to i64
  %434 = getelementptr inbounds i8, i8* %150, i64 20
  %435 = call i8* @HMAC(%struct.env_md_st* %427, i8* %428, i32 %431, i8* %432, i64 %433, i8* %434, i32* null)
  %436 = getelementptr inbounds i8, i8* %151, i64 20
  %437 = bitcast i8* %436 to i32*
  %438 = getelementptr inbounds i8, i8* %110, i64 20
  %439 = bitcast i8* %438 to i32*
  %440 = getelementptr inbounds i8, i8* %152, i64 20
  %441 = bitcast i8* %440 to i32*
  %442 = getelementptr inbounds i8, i8* %150, i64 20
  %443 = bitcast i8* %442 to i32*
  %444 = getelementptr inbounds [256 x i8], [256 x i8]* %20, i32 0, i32 0
  %445 = bitcast i8* %444 to i32*
  %446 = getelementptr inbounds i32, i32* %437, i32 1
  %447 = load i32, i32* %437, align 4
  %448 = getelementptr inbounds i32, i32* %445, i32 1
  store i32 %447, i32* %445, align 4
  %449 = getelementptr inbounds i32, i32* %439, i32 1
  %450 = load i32, i32* %439, align 4
  %451 = getelementptr inbounds i32, i32* %448, i32 1
  store i32 %450, i32* %448, align 4
  %452 = getelementptr inbounds i32, i32* %441, i32 1
  %453 = load i32, i32* %441, align 4
  %454 = getelementptr inbounds i32, i32* %451, i32 1
  store i32 %453, i32* %451, align 4
  %455 = getelementptr inbounds i32, i32* %443, i32 1
  %456 = load i32, i32* %443, align 4
  %457 = getelementptr inbounds i32, i32* %454, i32 1
  store i32 %456, i32* %454, align 4
  %458 = getelementptr inbounds i32, i32* %446, i32 1
  %459 = load i32, i32* %446, align 4
  %460 = getelementptr inbounds i32, i32* %457, i32 1
  store i32 %459, i32* %457, align 4
  %461 = getelementptr inbounds i32, i32* %449, i32 1
  %462 = load i32, i32* %449, align 4
  %463 = getelementptr inbounds i32, i32* %460, i32 1
  store i32 %462, i32* %460, align 4
  %464 = getelementptr inbounds i32, i32* %452, i32 1
  %465 = load i32, i32* %452, align 4
  %466 = getelementptr inbounds i32, i32* %463, i32 1
  store i32 %465, i32* %463, align 4
  %467 = getelementptr inbounds i32, i32* %455, i32 1
  %468 = load i32, i32* %455, align 4
  %469 = getelementptr inbounds i32, i32* %466, i32 1
  store i32 %468, i32* %466, align 4
  %470 = getelementptr inbounds i32, i32* %458, i32 1
  %471 = load i32, i32* %458, align 4
  %472 = getelementptr inbounds i32, i32* %469, i32 1
  store i32 %471, i32* %469, align 4
  %473 = getelementptr inbounds i32, i32* %461, i32 1
  %474 = load i32, i32* %461, align 4
  %475 = getelementptr inbounds i32, i32* %472, i32 1
  store i32 %474, i32* %472, align 4
  %476 = getelementptr inbounds i32, i32* %464, i32 1
  %477 = load i32, i32* %464, align 4
  %478 = getelementptr inbounds i32, i32* %475, i32 1
  store i32 %477, i32* %475, align 4
  %479 = getelementptr inbounds i32, i32* %467, i32 1
  %480 = load i32, i32* %467, align 4
  %481 = getelementptr inbounds i32, i32* %478, i32 1
  store i32 %480, i32* %478, align 4
  %482 = getelementptr inbounds i32, i32* %470, i32 1
  %483 = load i32, i32* %470, align 4
  %484 = getelementptr inbounds i32, i32* %481, i32 1
  store i32 %483, i32* %481, align 4
  %485 = getelementptr inbounds i32, i32* %473, i32 1
  %486 = load i32, i32* %473, align 4
  %487 = getelementptr inbounds i32, i32* %484, i32 1
  store i32 %486, i32* %484, align 4
  %488 = getelementptr inbounds i32, i32* %476, i32 1
  %489 = load i32, i32* %476, align 4
  %490 = getelementptr inbounds i32, i32* %487, i32 1
  store i32 %489, i32* %487, align 4
  %491 = getelementptr inbounds i32, i32* %479, i32 1
  %492 = load i32, i32* %479, align 4
  %493 = getelementptr inbounds i32, i32* %490, i32 1
  store i32 %492, i32* %490, align 4
  %494 = load i32, i32* %482, align 4
  %495 = getelementptr inbounds i32, i32* %493, i32 1
  store i32 %494, i32* %493, align 4
  %496 = load i32, i32* %485, align 4
  %497 = getelementptr inbounds i32, i32* %495, i32 1
  store i32 %496, i32* %495, align 4
  %498 = load i32, i32* %488, align 4
  %499 = getelementptr inbounds i32, i32* %497, i32 1
  store i32 %498, i32* %497, align 4
  %500 = load i32, i32* %491, align 4
  store i32 %500, i32* %499, align 4
  br label %501

; <label>:501:                                    ; preds = %395, %501
  %.311 = phi i32 [ 1, %395 ], [ %590, %501 ]
  call void @unroll_loop(i32 7)
  %502 = getelementptr inbounds [80 x i8], [80 x i8]* %21, i32 0, i32 0
  %503 = getelementptr inbounds [80 x i8], [80 x i8]* %17, i32 0, i32 0
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 16 %502, i8* align 16 %503, i64 80, i1 false), !track !43
  %504 = getelementptr inbounds [80 x i8], [80 x i8]* %21, i32 0, i32 0
  %505 = getelementptr inbounds [256 x i8], [256 x i8]* %20, i32 0, i32 0
  %506 = getelementptr inbounds [1280 x i8], [1280 x i8]* %22, i32 0, i32 0
  %507 = call i32 @shasse2_data(i8* %504, i8* %505, i8* %506)
  %508 = getelementptr inbounds [80 x i8], [80 x i8]* %21, i32 0, i32 0
  %509 = getelementptr inbounds [256 x i8], [256 x i8]* %20, i32 0, i32 0
  %510 = call i32 @shasse2_ends(i8* %508, i8* %509)
  %511 = getelementptr inbounds [80 x i8], [80 x i8]* %21, i32 0, i32 0
  %512 = getelementptr inbounds [80 x i8], [80 x i8]* %19, i32 0, i32 0
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 16 %511, i8* align 16 %512, i64 80, i1 false), !track !44
  %513 = getelementptr inbounds [80 x i8], [80 x i8]* %21, i32 0, i32 0
  %514 = getelementptr inbounds [256 x i8], [256 x i8]* %20, i32 0, i32 0
  %515 = getelementptr inbounds [1280 x i8], [1280 x i8]* %22, i32 0, i32 0
  %516 = call i32 @shasse2_data(i8* %513, i8* %514, i8* %515)
  %517 = getelementptr inbounds [80 x i8], [80 x i8]* %21, i32 0, i32 0
  %518 = getelementptr inbounds [256 x i8], [256 x i8]* %20, i32 0, i32 0
  %519 = call i32 @shasse2_ends(i8* %517, i8* %518)
  %520 = getelementptr inbounds i8, i8* %151, i64 20
  %521 = bitcast i8* %520 to i32*
  %522 = getelementptr inbounds i8, i8* %110, i64 20
  %523 = bitcast i8* %522 to i32*
  %524 = getelementptr inbounds i8, i8* %152, i64 20
  %525 = bitcast i8* %524 to i32*
  %526 = getelementptr inbounds i8, i8* %150, i64 20
  %527 = bitcast i8* %526 to i32*
  %528 = getelementptr inbounds [256 x i8], [256 x i8]* %20, i32 0, i32 0
  %529 = bitcast i8* %528 to i32*
  %530 = getelementptr inbounds i32, i32* %529, i32 1
  %531 = load i32, i32* %529, align 4
  %532 = getelementptr inbounds i32, i32* %521, i32 1
  %533 = load i32, i32* %521, align 4
  %534 = xor i32 %533, %531
  store i32 %534, i32* %521, align 4
  %535 = getelementptr inbounds i32, i32* %530, i32 1
  %536 = load i32, i32* %530, align 4
  %537 = getelementptr inbounds i32, i32* %523, i32 1
  %538 = load i32, i32* %523, align 4
  %539 = xor i32 %538, %536
  store i32 %539, i32* %523, align 4
  %540 = getelementptr inbounds i32, i32* %535, i32 1
  %541 = load i32, i32* %535, align 4
  %542 = getelementptr inbounds i32, i32* %525, i32 1
  %543 = load i32, i32* %525, align 4
  %544 = xor i32 %543, %541
  store i32 %544, i32* %525, align 4
  %545 = getelementptr inbounds i32, i32* %540, i32 1
  %546 = load i32, i32* %540, align 4
  %547 = getelementptr inbounds i32, i32* %527, i32 1
  %548 = load i32, i32* %527, align 4
  %549 = xor i32 %548, %546
  store i32 %549, i32* %527, align 4
  %550 = getelementptr inbounds i32, i32* %545, i32 1
  %551 = load i32, i32* %545, align 4
  %552 = getelementptr inbounds i32, i32* %532, i32 1
  %553 = load i32, i32* %532, align 4
  %554 = xor i32 %553, %551
  store i32 %554, i32* %532, align 4
  %555 = getelementptr inbounds i32, i32* %550, i32 1
  %556 = load i32, i32* %550, align 4
  %557 = getelementptr inbounds i32, i32* %537, i32 1
  %558 = load i32, i32* %537, align 4
  %559 = xor i32 %558, %556
  store i32 %559, i32* %537, align 4
  %560 = getelementptr inbounds i32, i32* %555, i32 1
  %561 = load i32, i32* %555, align 4
  %562 = getelementptr inbounds i32, i32* %542, i32 1
  %563 = load i32, i32* %542, align 4
  %564 = xor i32 %563, %561
  store i32 %564, i32* %542, align 4
  %565 = getelementptr inbounds i32, i32* %560, i32 1
  %566 = load i32, i32* %560, align 4
  %567 = getelementptr inbounds i32, i32* %547, i32 1
  %568 = load i32, i32* %547, align 4
  %569 = xor i32 %568, %566
  store i32 %569, i32* %547, align 4
  %570 = getelementptr inbounds i32, i32* %565, i32 1
  %571 = load i32, i32* %565, align 4
  %572 = getelementptr inbounds i32, i32* %552, i32 1
  %573 = load i32, i32* %552, align 4
  %574 = xor i32 %573, %571
  store i32 %574, i32* %552, align 4
  %575 = getelementptr inbounds i32, i32* %570, i32 1
  %576 = load i32, i32* %570, align 4
  %577 = getelementptr inbounds i32, i32* %557, i32 1
  %578 = load i32, i32* %557, align 4
  %579 = xor i32 %578, %576
  store i32 %579, i32* %557, align 4
  %580 = getelementptr inbounds i32, i32* %575, i32 1
  %581 = load i32, i32* %575, align 4
  %582 = getelementptr inbounds i32, i32* %562, i32 1
  %583 = load i32, i32* %562, align 4
  %584 = xor i32 %583, %581
  store i32 %584, i32* %562, align 4
  %585 = getelementptr inbounds i32, i32* %580, i32 1
  %586 = load i32, i32* %580, align 4
  %587 = getelementptr inbounds i32, i32* %567, i32 1
  %588 = load i32, i32* %567, align 4
  %589 = xor i32 %588, %586
  store i32 %589, i32* %567, align 4
  %590 = add nuw nsw i32 %.311, 1
  %exitcond = icmp ne i32 %590, 4096
  br i1 %exitcond, label %501, label %591

; <label>:591:                                    ; preds = %501
  %592 = getelementptr inbounds i32, i32* %259, i32 1
  %593 = getelementptr inbounds i32, i32* %250, i32 1
  %594 = getelementptr inbounds i32, i32* %256, i32 1
  %595 = getelementptr inbounds i32, i32* %267, i32 1
  %596 = getelementptr inbounds i32, i32* %482, i32 1
  %597 = getelementptr inbounds i32, i32* %485, i32 1
  %598 = getelementptr inbounds i32, i32* %488, i32 1
  %599 = getelementptr inbounds i32, i32* %491, i32 1
  %600 = getelementptr inbounds i32, i32* %499, i32 1
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %7, i8* align 1 %152, i64 32, i1 false), !track !45
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %8, i8* align 1 %150, i64 32, i1 false), !track !46
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %5, i8* align 1 %151, i64 32, i1 false), !track !47
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %6, i8* align 1 %110, i64 32, i1 false), !track !48
  ret void
}

; Function Attrs: nounwind
declare dso_local i8* @strncpy(i8*, i8*, i64) #2

; Function Attrs: nounwind readonly
declare dso_local i64 @strlen(i8*) #3

; Function Attrs: argmemonly nounwind
declare void @llvm.memset.p0i8.i64(i8* nocapture writeonly, i8, i64, i1) #4

; Function Attrs: argmemonly nounwind
declare void @llvm.memcpy.p0i8.p0i8.i64(i8* nocapture writeonly, i8* nocapture readonly, i64, i1) #4

declare dso_local i32 @shasse2_init(i8*) #1

declare dso_local i32 @shasse2_data(i8*, i8*, i8*) #1

declare dso_local %struct.env_md_st* @EVP_sha1() #1

declare dso_local i8* @HMAC(%struct.env_md_st*, i8*, i32, i8*, i64, i8*, i32*) #1

declare dso_local i32 @shasse2_ends(i8*, i8*) #1

; Function Attrs: noinline nounwind uwtable
define dso_local void @clean_exit(i32) #0 {
  %2 = alloca [128 x i8], align 16
  %3 = getelementptr inbounds [128 x i8], [128 x i8]* %2, i32 0, i32 0
  call void @llvm.memset.p0i8.i64(i8* align 16 %3, i8 0, i64 128, i1 false)
  %4 = icmp ne i32 %0, 0
  br i1 %4, label %5, label %14

; <label>:5:                                      ; preds = %1
  %6 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 6
  %7 = load i32, i32* %6, align 8
  %8 = icmp ne i32 %7, 0
  br i1 %8, label %14, label %9

; <label>:9:                                      ; preds = %5
  %10 = getelementptr [26 x i8], [26 x i8]* @.str.3, i32 0, i32 0
  %11 = call i32 (i8*, ...) @printf(i8* %10)
  %12 = load %struct._IO_FILE*, %struct._IO_FILE** @stdout, align 8
  %13 = call i32 @fflush(%struct._IO_FILE* %12)
  br label %14

; <label>:14:                                     ; preds = %9, %5, %1
  store i32 1, i32* @close_aircrack, align 4
  %15 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 5
  %16 = load i32, i32* %15, align 4
  %17 = icmp slt i32 0, %16
  br i1 %17, label %.lr.ph14.preheader, label %._crit_edge15

.lr.ph14.preheader:                               ; preds = %14
  br label %.lr.ph14

.lr.ph14:                                         ; preds = %.lr.ph14.preheader, %.lr.ph14
  %indvars.iv16 = phi i64 [ %indvars.iv.next17, %.lr.ph14 ], [ 0, %.lr.ph14.preheader ]
  call void @unroll_loop(i32 8)
  %18 = getelementptr inbounds [256 x [2 x i32]], [256 x [2 x i32]]* @mc_pipe, i64 0, i64 %indvars.iv16
  %19 = getelementptr inbounds [2 x i32], [2 x i32]* %18, i64 0, i64 1
  %20 = load i32, i32* %19, align 4
  %21 = getelementptr [6 x i8], [6 x i8]* @.str.4, i32 0, i32 0
  %22 = call i32 @safe_write(i32 %20, i8* %21, i64 5)
  %23 = getelementptr inbounds [256 x [2 x i32]], [256 x [2 x i32]]* @bf_pipe, i64 0, i64 %indvars.iv16
  %24 = getelementptr inbounds [2 x i32], [2 x i32]* %23, i64 0, i64 1
  %25 = load i32, i32* %24, align 4
  %26 = getelementptr inbounds [128 x i8], [128 x i8]* %2, i32 0, i32 0
  %27 = call i32 @safe_write(i32 %25, i8* %26, i64 64)
  %indvars.iv.next17 = add nuw nsw i64 %indvars.iv16, 1
  %28 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 5
  %29 = load i32, i32* %28, align 4
  %30 = sext i32 %29 to i64
  %31 = icmp slt i64 %indvars.iv.next17, %30
  br i1 %31, label %.lr.ph14, label %._crit_edge15.loopexit

._crit_edge15.loopexit:                           ; preds = %.lr.ph14
  br label %._crit_edge15

._crit_edge15:                                    ; preds = %._crit_edge15.loopexit, %14
  %32 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 0
  %33 = load i32, i32* %32, align 8
  %34 = icmp ne i32 %33, 2
  %35 = load i32, i32* @id, align 4
  %36 = icmp slt i32 0, %35
  %or.cond = and i1 %34, %36
  br i1 %or.cond, label %.lr.ph10.preheader, label %._crit_edge11

.lr.ph10.preheader:                               ; preds = %._crit_edge15
  br label %.lr.ph10

.lr.ph10:                                         ; preds = %.lr.ph10.preheader, %.lr.ph10
  %indvars.iv = phi i64 [ %indvars.iv.next, %.lr.ph10 ], [ 0, %.lr.ph10.preheader ]
  call void @unroll_loop(i32 9)
  %37 = getelementptr inbounds [128 x i64], [128 x i64]* @tid, i64 0, i64 %indvars.iv
  %38 = load i64, i64* %37, align 8
  %39 = call i32 @pthread_join(i64 %38, i8** null)
  %40 = icmp ne i32 %39, 0
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %41 = load i32, i32* @id, align 4
  %42 = sext i32 %41 to i64
  %43 = icmp slt i64 %indvars.iv.next, %42
  br i1 %43, label %.lr.ph10, label %._crit_edge11.loopexit

._crit_edge11.loopexit:                           ; preds = %.lr.ph10
  br label %._crit_edge11

._crit_edge11:                                    ; preds = %._crit_edge11.loopexit, %._crit_edge15
  %44 = getelementptr %struct.WEP_data, %struct.WEP_data* @wep, i32 0, i32 1
  %45 = load i8*, i8** %44, align 8
  %46 = icmp ne i8* %45, null
  br i1 %46, label %47, label %51

; <label>:47:                                     ; preds = %._crit_edge11
  %48 = getelementptr %struct.WEP_data, %struct.WEP_data* @wep, i32 0, i32 1
  %49 = load i8*, i8** %48, align 8
  call void @free(i8* %49) #9
  %50 = getelementptr %struct.WEP_data, %struct.WEP_data* @wep, i32 0, i32 1
  store i8* null, i8** %50, align 8
  br label %51

; <label>:51:                                     ; preds = %47, %._crit_edge11
  %52 = load %struct.AP_info*, %struct.AP_info** @ap_1st, align 8
  %53 = icmp ne %struct.AP_info* %52, null
  br i1 %53, label %.lr.ph6.preheader, label %._crit_edge7

.lr.ph6.preheader:                                ; preds = %51
  br label %.lr.ph6

.lr.ph6:                                          ; preds = %.lr.ph6.preheader, %111
  %.014 = phi %struct.AP_info* [ %113, %111 ], [ %52, %.lr.ph6.preheader ]
  call void @unroll_loop(i32 10)
  %54 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.014, i32 0, i32 4
  %55 = load i8*, i8** %54, align 8
  %56 = icmp ne i8* %55, null
  br i1 %56, label %57, label %61

; <label>:57:                                     ; preds = %.lr.ph6
  %58 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.014, i32 0, i32 4
  %59 = load i8*, i8** %58, align 8
  call void @free(i8* %59) #9
  %60 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.014, i32 0, i32 4
  store i8* null, i8** %60, align 8
  br label %61

; <label>:61:                                     ; preds = %57, %.lr.ph6
  %62 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.014, i32 0, i32 5
  %63 = load i8**, i8*** %62, align 8
  call void @uniqueiv_wipe(i8** %63)
  %64 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.014, i32 0, i32 15
  %65 = load %struct.PTW_attackstate*, %struct.PTW_attackstate** %64, align 8
  %66 = icmp ne %struct.PTW_attackstate* %65, null
  br i1 %66, label %67, label %87

; <label>:67:                                     ; preds = %61
  %68 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.014, i32 0, i32 15
  %69 = load %struct.PTW_attackstate*, %struct.PTW_attackstate** %68, align 8
  %70 = getelementptr inbounds %struct.PTW_attackstate, %struct.PTW_attackstate* %69, i32 0, i32 5
  %71 = load %struct.PTW_session*, %struct.PTW_session** %70, align 8
  %72 = icmp ne %struct.PTW_session* %71, null
  br i1 %72, label %73, label %82

; <label>:73:                                     ; preds = %67
  %74 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.014, i32 0, i32 15
  %75 = load %struct.PTW_attackstate*, %struct.PTW_attackstate** %74, align 8
  %76 = getelementptr inbounds %struct.PTW_attackstate, %struct.PTW_attackstate* %75, i32 0, i32 5
  %77 = load %struct.PTW_session*, %struct.PTW_session** %76, align 8
  %78 = bitcast %struct.PTW_session* %77 to i8*
  call void @free(i8* %78) #9
  %79 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.014, i32 0, i32 15
  %80 = load %struct.PTW_attackstate*, %struct.PTW_attackstate** %79, align 8
  %81 = getelementptr inbounds %struct.PTW_attackstate, %struct.PTW_attackstate* %80, i32 0, i32 5
  store %struct.PTW_session* null, %struct.PTW_session** %81, align 8
  br label %82

; <label>:82:                                     ; preds = %73, %67
  %83 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.014, i32 0, i32 15
  %84 = load %struct.PTW_attackstate*, %struct.PTW_attackstate** %83, align 8
  %85 = bitcast %struct.PTW_attackstate* %84 to i8*
  call void @free(i8* %85) #9
  %86 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.014, i32 0, i32 15
  store %struct.PTW_attackstate* null, %struct.PTW_attackstate** %86, align 8
  br label %87

; <label>:87:                                     ; preds = %82, %61
  %88 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.014, i32 0, i32 16
  %89 = load %struct.PTW_attackstate*, %struct.PTW_attackstate** %88, align 8
  %90 = icmp ne %struct.PTW_attackstate* %89, null
  br i1 %90, label %91, label %111

; <label>:91:                                     ; preds = %87
  %92 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.014, i32 0, i32 16
  %93 = load %struct.PTW_attackstate*, %struct.PTW_attackstate** %92, align 8
  %94 = getelementptr inbounds %struct.PTW_attackstate, %struct.PTW_attackstate* %93, i32 0, i32 5
  %95 = load %struct.PTW_session*, %struct.PTW_session** %94, align 8
  %96 = icmp ne %struct.PTW_session* %95, null
  br i1 %96, label %97, label %106

; <label>:97:                                     ; preds = %91
  %98 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.014, i32 0, i32 16
  %99 = load %struct.PTW_attackstate*, %struct.PTW_attackstate** %98, align 8
  %100 = getelementptr inbounds %struct.PTW_attackstate, %struct.PTW_attackstate* %99, i32 0, i32 5
  %101 = load %struct.PTW_session*, %struct.PTW_session** %100, align 8
  %102 = bitcast %struct.PTW_session* %101 to i8*
  call void @free(i8* %102) #9
  %103 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.014, i32 0, i32 16
  %104 = load %struct.PTW_attackstate*, %struct.PTW_attackstate** %103, align 8
  %105 = getelementptr inbounds %struct.PTW_attackstate, %struct.PTW_attackstate* %104, i32 0, i32 5
  store %struct.PTW_session* null, %struct.PTW_session** %105, align 8
  br label %106

; <label>:106:                                    ; preds = %97, %91
  %107 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.014, i32 0, i32 16
  %108 = load %struct.PTW_attackstate*, %struct.PTW_attackstate** %107, align 8
  %109 = bitcast %struct.PTW_attackstate* %108 to i8*
  call void @free(i8* %109) #9
  %110 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.014, i32 0, i32 16
  store %struct.PTW_attackstate* null, %struct.PTW_attackstate** %110, align 8
  br label %111

; <label>:111:                                    ; preds = %106, %87
  %112 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.014, i32 0, i32 0
  %113 = load %struct.AP_info*, %struct.AP_info** %112, align 8
  %114 = icmp ne %struct.AP_info* %113, null
  br i1 %114, label %.lr.ph6, label %._crit_edge7.loopexit

._crit_edge7.loopexit:                            ; preds = %111
  br label %._crit_edge7

._crit_edge7:                                     ; preds = %._crit_edge7.loopexit, %51
  %115 = load %struct.AP_info*, %struct.AP_info** @ap_1st, align 8
  %116 = icmp ne %struct.AP_info* %115, null
  br i1 %116, label %.lr.ph.preheader, label %._crit_edge

.lr.ph.preheader:                                 ; preds = %._crit_edge7
  br label %.lr.ph

.lr.ph:                                           ; preds = %.lr.ph.preheader, %122
  %.123 = phi %struct.AP_info* [ %118, %122 ], [ %115, %.lr.ph.preheader ]
  call void @unroll_loop(i32 11)
  %117 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.123, i32 0, i32 0
  %118 = load %struct.AP_info*, %struct.AP_info** %117, align 8
  %119 = icmp ne %struct.AP_info* %.123, null
  br i1 %119, label %120, label %122

; <label>:120:                                    ; preds = %.lr.ph
  %121 = bitcast %struct.AP_info* %.123 to i8*
  call void @free(i8* %121) #9
  br label %122

; <label>:122:                                    ; preds = %120, %.lr.ph
  %123 = icmp ne %struct.AP_info* %118, null
  br i1 %123, label %.lr.ph, label %._crit_edge.loopexit

._crit_edge.loopexit:                             ; preds = %122
  br label %._crit_edge

._crit_edge:                                      ; preds = %._crit_edge.loopexit, %._crit_edge7
  %124 = call i32 @fork() #9
  %125 = icmp eq i32 %124, -1
  %126 = icmp ne i32 %124, 0
  br i1 %126, label %127, label %128

; <label>:127:                                    ; preds = %._crit_edge
  call void @exit(i32 0) #11
  unreachable

; <label>:128:                                    ; preds = %._crit_edge
  call void @_exit(i32 %0) #12
  unreachable
}

declare dso_local i32 @fflush(%struct._IO_FILE*) #1

; Function Attrs: noinline nounwind uwtable
define dso_local i32 @safe_write(i32, i8*, i64) #0 {
  %4 = icmp ult i64 0, %2
  br i1 %4, label %.lr.ph.preheader, label %.outer._crit_edge

.lr.ph.preheader:                                 ; preds = %3
  br label %.lr.ph

.lr.ph:                                           ; preds = %.lr.ph.preheader, %.outer
  %5 = phi i1 [ %20, %.outer ], [ %4, %.lr.ph.preheader ]
  %.01.ph13 = phi i8* [ %19, %.outer ], [ %1, %.lr.ph.preheader ]
  %.02.ph12 = phi i64 [ %17, %.outer ], [ 0, %.lr.ph.preheader ]
  call void @unroll_loop(i32 23)
  br label %7

; <label>:6:                                      ; preds = %12
  br i1 %5, label %7, label %.outer._crit_edge.loopexit

; <label>:7:                                      ; preds = %.lr.ph, %6
  call void @unroll_loop(i32 24)
  %8 = sub i64 %2, %.02.ph12
  %9 = call i64 @write(i32 %0, i8* %.01.ph13, i64 %8)
  %10 = trunc i64 %9 to i32
  %11 = icmp slt i32 %10, 0
  br i1 %11, label %12, label %.outer

; <label>:12:                                     ; preds = %7
  %13 = call i32* @__errno_location() #13
  %14 = load i32, i32* %13, align 4
  %15 = icmp eq i32 %14, 4
  br i1 %15, label %6, label %.loopexit

.outer:                                           ; preds = %7
  %.lcssa9 = phi i32 [ %10, %7 ]
  %16 = sext i32 %.lcssa9 to i64
  %17 = add i64 %.02.ph12, %16
  %18 = sext i32 %.lcssa9 to i64
  %19 = getelementptr inbounds i8, i8* %.01.ph13, i64 %18
  %20 = icmp ult i64 %17, %2
  br i1 %20, label %.lr.ph, label %.outer._crit_edge.loopexit1

.outer._crit_edge.loopexit:                       ; preds = %6
  %.02.lcssa.ph = phi i64 [ %.02.ph12, %6 ]
  br label %.outer._crit_edge

.outer._crit_edge.loopexit1:                      ; preds = %.outer
  %.02.lcssa.ph2 = phi i64 [ %17, %.outer ]
  br label %.outer._crit_edge

.outer._crit_edge:                                ; preds = %.outer._crit_edge.loopexit1, %.outer._crit_edge.loopexit, %3
  %.02.lcssa = phi i64 [ 0, %3 ], [ %.02.lcssa.ph, %.outer._crit_edge.loopexit ], [ %.02.lcssa.ph2, %.outer._crit_edge.loopexit1 ]
  %21 = trunc i64 %.02.lcssa to i32
  br label %22

.loopexit:                                        ; preds = %12
  %.0.ph = phi i32 [ %10, %12 ]
  br label %22

; <label>:22:                                     ; preds = %.loopexit, %.outer._crit_edge
  %.0 = phi i32 [ %21, %.outer._crit_edge ], [ %.0.ph, %.loopexit ]
  ret i32 %.0
}

declare dso_local i32 @pthread_join(i64, i8**) #1

; Function Attrs: nounwind
declare dso_local void @free(i8*) #2

; Function Attrs: nounwind
declare dso_local i32 @fork() #2

; Function Attrs: noreturn nounwind
declare dso_local void @exit(i32) #5

; Function Attrs: noreturn
declare dso_local void @_exit(i32) #6

declare dso_local i64 @write(i32, i8*, i64) #1

; Function Attrs: nounwind readnone
declare dso_local i32* @__errno_location() #7

; Function Attrs: noinline nounwind uwtable
define dso_local void @sighandler(i32) #0 {
  %2 = call void (i32)* @signal(i32 %0, void (i32)* @sighandler) #9
  switch i32 %0, label %9 [
    i32 3, label %3
    i32 15, label %4
    i32 2, label %5
    i32 28, label %6
  ]

; <label>:3:                                      ; preds = %1
  call void @clean_exit(i32 0)
  br label %9

; <label>:4:                                      ; preds = %1
  call void @clean_exit(i32 1)
  br label %9

; <label>:5:                                      ; preds = %1
  call void @clean_exit(i32 1)
  br label %9

; <label>:6:                                      ; preds = %1
  %7 = getelementptr [6 x i8], [6 x i8]* @.str.5, i32 0, i32 0
  %8 = call i32 (i8*, ...) @printf(i8* %7)
  br label %9

; <label>:9:                                      ; preds = %5, %4, %3, %1, %6
  ret void
}

; Function Attrs: nounwind
declare dso_local void (i32)* @signal(i32, void (i32)*) #2

; Function Attrs: noinline nounwind uwtable
define dso_local void @eof_wait(i32*) #0 {
  %2 = load i32, i32* %0, align 4
  %3 = icmp eq i32 %2, 0
  br i1 %3, label %4, label %10

; <label>:4:                                      ; preds = %1
  store i32 1, i32* %0, align 4
  %5 = call i32 @pthread_mutex_lock(%union.pthread_mutex_t* @mx_eof) #9
  %6 = load i32, i32* @nb_eof, align 4
  %7 = add nsw i32 %6, 1
  store i32 %7, i32* @nb_eof, align 4
  %8 = call i32 @pthread_cond_broadcast(%union.pthread_cond_t* @cv_eof) #9
  %9 = call i32 @pthread_mutex_unlock(%union.pthread_mutex_t* @mx_eof) #9
  br label %10

; <label>:10:                                     ; preds = %4, %1
  %11 = call i32 @usleep(i32 100000)
  ret void
}

; Function Attrs: nounwind
declare dso_local i32 @pthread_mutex_lock(%union.pthread_mutex_t*) #2

; Function Attrs: nounwind
declare dso_local i32 @pthread_cond_broadcast(%union.pthread_cond_t*) #2

; Function Attrs: nounwind
declare dso_local i32 @pthread_mutex_unlock(%union.pthread_mutex_t*) #2

declare dso_local i32 @usleep(i32) #1

; Function Attrs: noinline nounwind uwtable
define dso_local i32 @wpa_send_passphrase(i8*, %struct.WPA_data*, i32) #0 {
  %4 = getelementptr inbounds %struct.WPA_data, %struct.WPA_data* %1, i32 0, i32 8
  %5 = call i32 @pthread_mutex_lock(%union.pthread_mutex_t* %4) #9
  %6 = getelementptr inbounds %struct.WPA_data, %struct.WPA_data* %1, i32 0, i32 5
  %7 = load i32, i32* %6, align 4
  %8 = add nsw i32 %7, 1
  %9 = getelementptr inbounds %struct.WPA_data, %struct.WPA_data* %1, i32 0, i32 2
  %10 = load i32, i32* %9, align 4
  %11 = srem i32 %8, %10
  %12 = getelementptr inbounds %struct.WPA_data, %struct.WPA_data* %1, i32 0, i32 4
  %13 = load i32, i32* %12, align 8
  %14 = icmp eq i32 %11, %13
  br i1 %14, label %15, label %24

; <label>:15:                                     ; preds = %3
  %16 = icmp ne i32 %2, 0
  br i1 %16, label %17, label %21

; <label>:17:                                     ; preds = %15
  %18 = getelementptr inbounds %struct.WPA_data, %struct.WPA_data* %1, i32 0, i32 7
  %19 = getelementptr inbounds %struct.WPA_data, %struct.WPA_data* %1, i32 0, i32 8
  %20 = call i32 @pthread_cond_wait(%union.pthread_cond_t* %18, %union.pthread_mutex_t* %19)
  br label %24

; <label>:21:                                     ; preds = %15
  %22 = getelementptr inbounds %struct.WPA_data, %struct.WPA_data* %1, i32 0, i32 8
  %23 = call i32 @pthread_mutex_unlock(%union.pthread_mutex_t* %22) #9
  br label %41

; <label>:24:                                     ; preds = %17, %3
  %25 = getelementptr inbounds %struct.WPA_data, %struct.WPA_data* %1, i32 0, i32 3
  %26 = load i8*, i8** %25, align 8
  %27 = getelementptr inbounds %struct.WPA_data, %struct.WPA_data* %1, i32 0, i32 5
  %28 = load i32, i32* %27, align 4
  %29 = mul nsw i32 %28, 128
  %30 = sext i32 %29 to i64
  %31 = getelementptr inbounds i8, i8* %26, i64 %30
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %31, i8* align 1 %0, i64 128, i1 false), !track !49
  %32 = getelementptr inbounds %struct.WPA_data, %struct.WPA_data* %1, i32 0, i32 5
  %33 = load i32, i32* %32, align 4
  %34 = add nsw i32 %33, 1
  %35 = getelementptr inbounds %struct.WPA_data, %struct.WPA_data* %1, i32 0, i32 2
  %36 = load i32, i32* %35, align 4
  %37 = srem i32 %34, %36
  %38 = getelementptr inbounds %struct.WPA_data, %struct.WPA_data* %1, i32 0, i32 5
  store i32 %37, i32* %38, align 4
  %39 = getelementptr inbounds %struct.WPA_data, %struct.WPA_data* %1, i32 0, i32 8
  %40 = call i32 @pthread_mutex_unlock(%union.pthread_mutex_t* %39) #9
  br label %41

; <label>:41:                                     ; preds = %24, %21
  %.0 = phi i32 [ 1, %24 ], [ 0, %21 ]
  ret i32 %.0
}

declare dso_local i32 @pthread_cond_wait(%union.pthread_cond_t*, %union.pthread_mutex_t*) #1

; Function Attrs: noinline nounwind uwtable
define dso_local i32 @wpa_receive_passphrase(i8*, %struct.WPA_data*) #0 {
  %3 = getelementptr inbounds %struct.WPA_data, %struct.WPA_data* %1, i32 0, i32 8
  %4 = call i32 @pthread_mutex_lock(%union.pthread_mutex_t* %3) #9
  %5 = getelementptr inbounds %struct.WPA_data, %struct.WPA_data* %1, i32 0, i32 4
  %6 = load i32, i32* %5, align 8
  %7 = getelementptr inbounds %struct.WPA_data, %struct.WPA_data* %1, i32 0, i32 5
  %8 = load i32, i32* %7, align 4
  %9 = icmp eq i32 %6, %8
  br i1 %9, label %10, label %13

; <label>:10:                                     ; preds = %2
  %11 = getelementptr inbounds %struct.WPA_data, %struct.WPA_data* %1, i32 0, i32 8
  %12 = call i32 @pthread_mutex_unlock(%union.pthread_mutex_t* %11) #9
  br label %32

; <label>:13:                                     ; preds = %2
  %14 = getelementptr inbounds %struct.WPA_data, %struct.WPA_data* %1, i32 0, i32 3
  %15 = load i8*, i8** %14, align 8
  %16 = getelementptr inbounds %struct.WPA_data, %struct.WPA_data* %1, i32 0, i32 4
  %17 = load i32, i32* %16, align 8
  %18 = mul nsw i32 %17, 128
  %19 = sext i32 %18 to i64
  %20 = getelementptr inbounds i8, i8* %15, i64 %19
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %0, i8* align 1 %20, i64 128, i1 false), !track !50
  %21 = getelementptr inbounds %struct.WPA_data, %struct.WPA_data* %1, i32 0, i32 4
  %22 = load i32, i32* %21, align 8
  %23 = add nsw i32 %22, 1
  %24 = getelementptr inbounds %struct.WPA_data, %struct.WPA_data* %1, i32 0, i32 2
  %25 = load i32, i32* %24, align 4
  %26 = srem i32 %23, %25
  %27 = getelementptr inbounds %struct.WPA_data, %struct.WPA_data* %1, i32 0, i32 4
  store i32 %26, i32* %27, align 8
  %28 = getelementptr inbounds %struct.WPA_data, %struct.WPA_data* %1, i32 0, i32 7
  %29 = call i32 @pthread_cond_signal(%union.pthread_cond_t* %28) #9
  %30 = getelementptr inbounds %struct.WPA_data, %struct.WPA_data* %1, i32 0, i32 8
  %31 = call i32 @pthread_mutex_unlock(%union.pthread_mutex_t* %30) #9
  br label %32

; <label>:32:                                     ; preds = %13, %10
  %.0 = phi i32 [ 0, %10 ], [ 1, %13 ]
  ret i32 %.0
}

; Function Attrs: nounwind
declare dso_local i32 @pthread_cond_signal(%union.pthread_cond_t*) #2

; Function Attrs: noinline nounwind uwtable
define dso_local i32 @checkbssids(i8*) #0 {
  %2 = alloca i8*, align 8, !track !51
  %3 = icmp eq i8* %0, null
  br i1 %3, label %.loopexit, label %4

; <label>:4:                                      ; preds = %1
  %5 = call noalias i8* @strdup(i8* %0) #9, !track !52
  store i8* %5, i8** %2, align 8
  br label %6

; <label>:6:                                      ; preds = %289, %4
  %.02 = phi i32 [ 1, %4 ], [ %.13, %289 ]
  %.01 = phi i32 [ 0, %4 ], [ %11, %289 ]
  call void @unroll_loop(i32 25)
  %7 = getelementptr [2 x i8], [2 x i8]* @.str.6, i32 0, i32 0
  %8 = call i8* @strsep(i8** %2, i8* %7) #9
  %9 = icmp eq i8* %8, null
  br i1 %9, label %.loopexit.loopexit1, label %10

; <label>:10:                                     ; preds = %6
  %11 = add nuw nsw i32 %.01, 1
  %12 = call i64 @strlen(i8* %8) #10
  %13 = icmp ne i64 %12, 17
  br i1 %13, label %.loopexit.loopexit1, label %14

; <label>:14:                                     ; preds = %10
  %15 = getelementptr inbounds i8, i8* %8, i64 0
  %16 = load i8, i8* %15, align 1
  %17 = sext i8 %16 to i32
  %18 = icmp eq i32 %17, 88
  br i1 %18, label %29, label %19

; <label>:19:                                     ; preds = %14
  %20 = getelementptr inbounds i8, i8* %8, i64 0
  %21 = load i8, i8* %20, align 1
  %22 = sext i8 %21 to i32
  %23 = icmp eq i32 %22, 120
  br i1 %23, label %29, label %24

; <label>:24:                                     ; preds = %19
  %25 = getelementptr inbounds i8, i8* %8, i64 0
  %26 = load i8, i8* %25, align 1
  %27 = call i32 @hexCharToInt(i8 zeroext %26)
  %28 = icmp sgt i32 %27, -1
  br i1 %28, label %29, label %.loopexit.loopexit1

; <label>:29:                                     ; preds = %24, %19, %14
  %30 = getelementptr inbounds i8, i8* %8, i64 1
  %31 = load i8, i8* %30, align 1
  %32 = sext i8 %31 to i32
  %33 = icmp eq i32 %32, 88
  br i1 %33, label %44, label %34

; <label>:34:                                     ; preds = %29
  %35 = getelementptr inbounds i8, i8* %8, i64 1
  %36 = load i8, i8* %35, align 1
  %37 = sext i8 %36 to i32
  %38 = icmp eq i32 %37, 120
  br i1 %38, label %44, label %39

; <label>:39:                                     ; preds = %34
  %40 = getelementptr inbounds i8, i8* %8, i64 1
  %41 = load i8, i8* %40, align 1
  %42 = call i32 @hexCharToInt(i8 zeroext %41)
  %43 = icmp sgt i32 %42, -1
  br i1 %43, label %44, label %.loopexit.loopexit1

; <label>:44:                                     ; preds = %39, %34, %29
  %45 = getelementptr inbounds i8, i8* %8, i64 2
  %46 = load i8, i8* %45, align 1
  %47 = sext i8 %46 to i32
  %48 = icmp eq i32 %47, 95
  br i1 %48, label %59, label %49

; <label>:49:                                     ; preds = %44
  %50 = getelementptr inbounds i8, i8* %8, i64 2
  %51 = load i8, i8* %50, align 1
  %52 = sext i8 %51 to i32
  %53 = icmp eq i32 %52, 45
  br i1 %53, label %59, label %54

; <label>:54:                                     ; preds = %49
  %55 = getelementptr inbounds i8, i8* %8, i64 2
  %56 = load i8, i8* %55, align 1
  %57 = sext i8 %56 to i32
  %58 = icmp eq i32 %57, 58
  br i1 %58, label %59, label %.loopexit.loopexit1

; <label>:59:                                     ; preds = %54, %49, %44
  %60 = getelementptr inbounds i8, i8* %8, i64 3
  %61 = load i8, i8* %60, align 1
  %62 = sext i8 %61 to i32
  %63 = icmp eq i32 %62, 88
  br i1 %63, label %74, label %64

; <label>:64:                                     ; preds = %59
  %65 = getelementptr inbounds i8, i8* %8, i64 3
  %66 = load i8, i8* %65, align 1
  %67 = sext i8 %66 to i32
  %68 = icmp eq i32 %67, 120
  br i1 %68, label %74, label %69

; <label>:69:                                     ; preds = %64
  %70 = getelementptr inbounds i8, i8* %8, i64 3
  %71 = load i8, i8* %70, align 1
  %72 = call i32 @hexCharToInt(i8 zeroext %71)
  %73 = icmp sgt i32 %72, -1
  br i1 %73, label %74, label %.loopexit.loopexit1

; <label>:74:                                     ; preds = %69, %64, %59
  %75 = getelementptr inbounds i8, i8* %8, i64 4
  %76 = load i8, i8* %75, align 1
  %77 = sext i8 %76 to i32
  %78 = icmp eq i32 %77, 88
  br i1 %78, label %89, label %79

; <label>:79:                                     ; preds = %74
  %80 = getelementptr inbounds i8, i8* %8, i64 4
  %81 = load i8, i8* %80, align 1
  %82 = sext i8 %81 to i32
  %83 = icmp eq i32 %82, 120
  br i1 %83, label %89, label %84

; <label>:84:                                     ; preds = %79
  %85 = getelementptr inbounds i8, i8* %8, i64 4
  %86 = load i8, i8* %85, align 1
  %87 = call i32 @hexCharToInt(i8 zeroext %86)
  %88 = icmp sgt i32 %87, -1
  br i1 %88, label %89, label %.loopexit.loopexit1

; <label>:89:                                     ; preds = %84, %79, %74
  %90 = getelementptr inbounds i8, i8* %8, i64 5
  %91 = load i8, i8* %90, align 1
  %92 = sext i8 %91 to i32
  %93 = icmp eq i32 %92, 95
  br i1 %93, label %104, label %94

; <label>:94:                                     ; preds = %89
  %95 = getelementptr inbounds i8, i8* %8, i64 5
  %96 = load i8, i8* %95, align 1
  %97 = sext i8 %96 to i32
  %98 = icmp eq i32 %97, 45
  br i1 %98, label %104, label %99

; <label>:99:                                     ; preds = %94
  %100 = getelementptr inbounds i8, i8* %8, i64 5
  %101 = load i8, i8* %100, align 1
  %102 = sext i8 %101 to i32
  %103 = icmp eq i32 %102, 58
  br i1 %103, label %104, label %.loopexit.loopexit1

; <label>:104:                                    ; preds = %99, %94, %89
  %105 = getelementptr inbounds i8, i8* %8, i64 6
  %106 = load i8, i8* %105, align 1
  %107 = sext i8 %106 to i32
  %108 = icmp eq i32 %107, 88
  br i1 %108, label %119, label %109

; <label>:109:                                    ; preds = %104
  %110 = getelementptr inbounds i8, i8* %8, i64 6
  %111 = load i8, i8* %110, align 1
  %112 = sext i8 %111 to i32
  %113 = icmp eq i32 %112, 120
  br i1 %113, label %119, label %114

; <label>:114:                                    ; preds = %109
  %115 = getelementptr inbounds i8, i8* %8, i64 6
  %116 = load i8, i8* %115, align 1
  %117 = call i32 @hexCharToInt(i8 zeroext %116)
  %118 = icmp sgt i32 %117, -1
  br i1 %118, label %119, label %.loopexit.loopexit1

; <label>:119:                                    ; preds = %114, %109, %104
  %120 = getelementptr inbounds i8, i8* %8, i64 7
  %121 = load i8, i8* %120, align 1
  %122 = sext i8 %121 to i32
  %123 = icmp eq i32 %122, 88
  br i1 %123, label %134, label %124

; <label>:124:                                    ; preds = %119
  %125 = getelementptr inbounds i8, i8* %8, i64 7
  %126 = load i8, i8* %125, align 1
  %127 = sext i8 %126 to i32
  %128 = icmp eq i32 %127, 120
  br i1 %128, label %134, label %129

; <label>:129:                                    ; preds = %124
  %130 = getelementptr inbounds i8, i8* %8, i64 7
  %131 = load i8, i8* %130, align 1
  %132 = call i32 @hexCharToInt(i8 zeroext %131)
  %133 = icmp sgt i32 %132, -1
  br i1 %133, label %134, label %.loopexit.loopexit1

; <label>:134:                                    ; preds = %129, %124, %119
  %135 = getelementptr inbounds i8, i8* %8, i64 8
  %136 = load i8, i8* %135, align 1
  %137 = sext i8 %136 to i32
  %138 = icmp eq i32 %137, 95
  br i1 %138, label %149, label %139

; <label>:139:                                    ; preds = %134
  %140 = getelementptr inbounds i8, i8* %8, i64 8
  %141 = load i8, i8* %140, align 1
  %142 = sext i8 %141 to i32
  %143 = icmp eq i32 %142, 45
  br i1 %143, label %149, label %144

; <label>:144:                                    ; preds = %139
  %145 = getelementptr inbounds i8, i8* %8, i64 8
  %146 = load i8, i8* %145, align 1
  %147 = sext i8 %146 to i32
  %148 = icmp eq i32 %147, 58
  br i1 %148, label %149, label %.loopexit.loopexit1

; <label>:149:                                    ; preds = %144, %139, %134
  %150 = getelementptr inbounds i8, i8* %8, i64 9
  %151 = load i8, i8* %150, align 1
  %152 = sext i8 %151 to i32
  %153 = icmp eq i32 %152, 88
  br i1 %153, label %164, label %154

; <label>:154:                                    ; preds = %149
  %155 = getelementptr inbounds i8, i8* %8, i64 9
  %156 = load i8, i8* %155, align 1
  %157 = sext i8 %156 to i32
  %158 = icmp eq i32 %157, 120
  br i1 %158, label %164, label %159

; <label>:159:                                    ; preds = %154
  %160 = getelementptr inbounds i8, i8* %8, i64 9
  %161 = load i8, i8* %160, align 1
  %162 = call i32 @hexCharToInt(i8 zeroext %161)
  %163 = icmp sgt i32 %162, -1
  br i1 %163, label %164, label %.loopexit.loopexit1

; <label>:164:                                    ; preds = %159, %154, %149
  %165 = getelementptr inbounds i8, i8* %8, i64 10
  %166 = load i8, i8* %165, align 1
  %167 = sext i8 %166 to i32
  %168 = icmp eq i32 %167, 88
  br i1 %168, label %179, label %169

; <label>:169:                                    ; preds = %164
  %170 = getelementptr inbounds i8, i8* %8, i64 10
  %171 = load i8, i8* %170, align 1
  %172 = sext i8 %171 to i32
  %173 = icmp eq i32 %172, 120
  br i1 %173, label %179, label %174

; <label>:174:                                    ; preds = %169
  %175 = getelementptr inbounds i8, i8* %8, i64 10
  %176 = load i8, i8* %175, align 1
  %177 = call i32 @hexCharToInt(i8 zeroext %176)
  %178 = icmp sgt i32 %177, -1
  br i1 %178, label %179, label %.loopexit.loopexit1

; <label>:179:                                    ; preds = %174, %169, %164
  %180 = getelementptr inbounds i8, i8* %8, i64 11
  %181 = load i8, i8* %180, align 1
  %182 = sext i8 %181 to i32
  %183 = icmp eq i32 %182, 95
  br i1 %183, label %194, label %184

; <label>:184:                                    ; preds = %179
  %185 = getelementptr inbounds i8, i8* %8, i64 11
  %186 = load i8, i8* %185, align 1
  %187 = sext i8 %186 to i32
  %188 = icmp eq i32 %187, 45
  br i1 %188, label %194, label %189

; <label>:189:                                    ; preds = %184
  %190 = getelementptr inbounds i8, i8* %8, i64 11
  %191 = load i8, i8* %190, align 1
  %192 = sext i8 %191 to i32
  %193 = icmp eq i32 %192, 58
  br i1 %193, label %194, label %.loopexit.loopexit1

; <label>:194:                                    ; preds = %189, %184, %179
  %195 = getelementptr inbounds i8, i8* %8, i64 12
  %196 = load i8, i8* %195, align 1
  %197 = sext i8 %196 to i32
  %198 = icmp eq i32 %197, 88
  br i1 %198, label %209, label %199

; <label>:199:                                    ; preds = %194
  %200 = getelementptr inbounds i8, i8* %8, i64 12
  %201 = load i8, i8* %200, align 1
  %202 = sext i8 %201 to i32
  %203 = icmp eq i32 %202, 120
  br i1 %203, label %209, label %204

; <label>:204:                                    ; preds = %199
  %205 = getelementptr inbounds i8, i8* %8, i64 12
  %206 = load i8, i8* %205, align 1
  %207 = call i32 @hexCharToInt(i8 zeroext %206)
  %208 = icmp sgt i32 %207, -1
  br i1 %208, label %209, label %.loopexit.loopexit1

; <label>:209:                                    ; preds = %204, %199, %194
  %210 = getelementptr inbounds i8, i8* %8, i64 13
  %211 = load i8, i8* %210, align 1
  %212 = sext i8 %211 to i32
  %213 = icmp eq i32 %212, 88
  br i1 %213, label %224, label %214

; <label>:214:                                    ; preds = %209
  %215 = getelementptr inbounds i8, i8* %8, i64 13
  %216 = load i8, i8* %215, align 1
  %217 = sext i8 %216 to i32
  %218 = icmp eq i32 %217, 120
  br i1 %218, label %224, label %219

; <label>:219:                                    ; preds = %214
  %220 = getelementptr inbounds i8, i8* %8, i64 13
  %221 = load i8, i8* %220, align 1
  %222 = call i32 @hexCharToInt(i8 zeroext %221)
  %223 = icmp sgt i32 %222, -1
  br i1 %223, label %224, label %.loopexit.loopexit1

; <label>:224:                                    ; preds = %219, %214, %209
  %225 = getelementptr inbounds i8, i8* %8, i64 14
  %226 = load i8, i8* %225, align 1
  %227 = sext i8 %226 to i32
  %228 = icmp eq i32 %227, 95
  br i1 %228, label %239, label %229

; <label>:229:                                    ; preds = %224
  %230 = getelementptr inbounds i8, i8* %8, i64 14
  %231 = load i8, i8* %230, align 1
  %232 = sext i8 %231 to i32
  %233 = icmp eq i32 %232, 45
  br i1 %233, label %239, label %234

; <label>:234:                                    ; preds = %229
  %235 = getelementptr inbounds i8, i8* %8, i64 14
  %236 = load i8, i8* %235, align 1
  %237 = sext i8 %236 to i32
  %238 = icmp eq i32 %237, 58
  br i1 %238, label %239, label %.loopexit.loopexit1

; <label>:239:                                    ; preds = %234, %229, %224
  %240 = getelementptr inbounds i8, i8* %8, i64 15
  %241 = load i8, i8* %240, align 1
  %242 = sext i8 %241 to i32
  %243 = icmp eq i32 %242, 88
  br i1 %243, label %254, label %244

; <label>:244:                                    ; preds = %239
  %245 = getelementptr inbounds i8, i8* %8, i64 15
  %246 = load i8, i8* %245, align 1
  %247 = sext i8 %246 to i32
  %248 = icmp eq i32 %247, 120
  br i1 %248, label %254, label %249

; <label>:249:                                    ; preds = %244
  %250 = getelementptr inbounds i8, i8* %8, i64 15
  %251 = load i8, i8* %250, align 1
  %252 = call i32 @hexCharToInt(i8 zeroext %251)
  %253 = icmp sgt i32 %252, -1
  br i1 %253, label %254, label %.loopexit.loopexit1

; <label>:254:                                    ; preds = %249, %244, %239
  %255 = getelementptr inbounds i8, i8* %8, i64 16
  %256 = load i8, i8* %255, align 1
  %257 = sext i8 %256 to i32
  %258 = icmp eq i32 %257, 88
  br i1 %258, label %269, label %259

; <label>:259:                                    ; preds = %254
  %260 = getelementptr inbounds i8, i8* %8, i64 16
  %261 = load i8, i8* %260, align 1
  %262 = sext i8 %261 to i32
  %263 = icmp eq i32 %262, 120
  br i1 %263, label %269, label %264

; <label>:264:                                    ; preds = %259
  %265 = getelementptr inbounds i8, i8* %8, i64 16
  %266 = load i8, i8* %265, align 1
  %267 = call i32 @hexCharToInt(i8 zeroext %266)
  %268 = icmp sgt i32 %267, -1
  br i1 %268, label %269, label %.loopexit.loopexit1

; <label>:269:                                    ; preds = %264, %259, %254
  %270 = icmp ne i32 %.02, 0
  br i1 %270, label %.preheader, label %289

.preheader:                                       ; preds = %269
  br label %271

; <label>:271:                                    ; preds = %.preheader, %281
  %indvars.iv = phi i64 [ %indvars.iv.next, %281 ], [ 0, %.preheader ]
  call void @unroll_loop(i32 26)
  %272 = getelementptr inbounds i8, i8* %8, i64 %indvars.iv
  %273 = load i8, i8* %272, align 1
  %274 = sext i8 %273 to i32
  %275 = icmp eq i32 %274, 88
  br i1 %275, label %.loopexit.loopexit, label %276

; <label>:276:                                    ; preds = %271
  %277 = getelementptr inbounds i8, i8* %8, i64 %indvars.iv
  %278 = load i8, i8* %277, align 1
  %279 = sext i8 %278 to i32
  %280 = icmp eq i32 %279, 120
  br i1 %280, label %.loopexit.loopexit, label %281

; <label>:281:                                    ; preds = %276
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %282 = icmp ult i64 %indvars.iv.next, 17
  br i1 %282, label %271, label %283

; <label>:283:                                    ; preds = %281
  %284 = call noalias i8* @malloc(i64 1) #9, !track !53
  %285 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 35
  store i8* %284, i8** %285, align 8
  %286 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 35
  %287 = load i8*, i8** %286, align 8
  %288 = call i32 @getmac(i8* %8, i32 1, i8* %287)
  br label %289

; <label>:289:                                    ; preds = %269, %283
  %.13 = phi i32 [ 0, %283 ], [ %.02, %269 ]
  %290 = load i8*, i8** %2, align 8
  %291 = icmp ne i8* %290, null
  br i1 %291, label %6, label %.loopexit.loopexit1

.loopexit.loopexit:                               ; preds = %276, %271
  %.0.ph = phi i32 [ -1, %271 ], [ -1, %276 ]
  br label %.loopexit

.loopexit.loopexit1:                              ; preds = %10, %24, %39, %54, %69, %84, %99, %114, %129, %144, %159, %174, %189, %204, %219, %234, %249, %264, %289, %6
  %.0.ph2 = phi i32 [ %11, %289 ], [ %.01, %6 ], [ -1, %264 ], [ -1, %249 ], [ -1, %234 ], [ -1, %219 ], [ -1, %204 ], [ -1, %189 ], [ -1, %174 ], [ -1, %159 ], [ -1, %144 ], [ -1, %129 ], [ -1, %114 ], [ -1, %99 ], [ -1, %84 ], [ -1, %69 ], [ -1, %54 ], [ -1, %39 ], [ -1, %24 ], [ -1, %10 ]
  br label %.loopexit

.loopexit:                                        ; preds = %.loopexit.loopexit1, %.loopexit.loopexit, %1
  %.0 = phi i32 [ -1, %1 ], [ %.0.ph, %.loopexit.loopexit ], [ %.0.ph2, %.loopexit.loopexit1 ]
  ret i32 %.0
}

; Function Attrs: nounwind
declare dso_local noalias i8* @strdup(i8*) #2

; Function Attrs: nounwind
declare dso_local i8* @strsep(i8**, i8*) #2

; Function Attrs: nounwind
declare dso_local noalias i8* @malloc(i64) #2

; Function Attrs: noinline nounwind uwtable
define dso_local i32 @mergebssids(i8*, i8*) #0 {
  %3 = alloca i8*, align 8, !track !54
  store i8* null, i8** %3, align 8
  %4 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 35
  %5 = load i8*, i8** %4, align 8
  %6 = call i32 @memcmp(i8* %5, i8* %1, i64 6) #10
  %7 = icmp eq i32 %6, 0
  br i1 %7, label %136, label %8

; <label>:8:                                      ; preds = %2
  %9 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 36
  %10 = load %struct.mergeBSSID*, %struct.mergeBSSID** %9, align 8
  %11 = icmp ne %struct.mergeBSSID* %10, null
  br i1 %11, label %.lr.ph.preheader, label %._crit_edge

.lr.ph.preheader:                                 ; preds = %8
  br label %.lr.ph

.lr.ph:                                           ; preds = %.lr.ph.preheader, %26
  %.0410 = phi %struct.mergeBSSID* [ %28, %26 ], [ %10, %.lr.ph.preheader ]
  call void @unroll_loop(i32 27)
  %12 = getelementptr inbounds %struct.mergeBSSID, %struct.mergeBSSID* %.0410, i32 0, i32 0
  %13 = getelementptr inbounds [6 x i8], [6 x i8]* %12, i32 0, i32 0
  %14 = call i32 @memcmp(i8* %13, i8* %1, i64 6) #10
  %15 = icmp eq i32 %14, 0
  br i1 %15, label %16, label %26

; <label>:16:                                     ; preds = %.lr.ph
  %.04.lcssa7 = phi %struct.mergeBSSID* [ %.0410, %.lr.ph ]
  %17 = getelementptr inbounds %struct.mergeBSSID, %struct.mergeBSSID* %.04.lcssa7, i32 0, i32 2
  %18 = load i32, i32* %17, align 8
  %19 = icmp ne i32 %18, 0
  br i1 %19, label %20, label %23

; <label>:20:                                     ; preds = %16
  %21 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 35
  %22 = load i8*, i8** %21, align 8
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %1, i8* align 1 %22, i64 6, i1 false), !track !55
  br label %23

; <label>:23:                                     ; preds = %20, %16
  %24 = getelementptr inbounds %struct.mergeBSSID, %struct.mergeBSSID* %.04.lcssa7, i32 0, i32 2
  %25 = load i32, i32* %24, align 8
  br label %136

; <label>:26:                                     ; preds = %.lr.ph
  %27 = getelementptr inbounds %struct.mergeBSSID, %struct.mergeBSSID* %.0410, i32 0, i32 3
  %28 = load %struct.mergeBSSID*, %struct.mergeBSSID** %27, align 8
  %29 = icmp ne %struct.mergeBSSID* %28, null
  br i1 %29, label %.lr.ph, label %._crit_edge.loopexit

._crit_edge.loopexit:                             ; preds = %26
  %.03.lcssa.ph = phi %struct.mergeBSSID* [ %.0410, %26 ]
  br label %._crit_edge

._crit_edge:                                      ; preds = %._crit_edge.loopexit, %8
  %.03.lcssa = phi %struct.mergeBSSID* [ null, %8 ], [ %.03.lcssa.ph, %._crit_edge.loopexit ]
  %30 = call noalias i8* @malloc(i64 18) #9
  %31 = icmp ne i8* %30, null
  br i1 %31, label %34, label %32

; <label>:32:                                     ; preds = %._crit_edge
  %33 = getelementptr [14 x i8], [14 x i8]* @.str.7, i32 0, i32 0
  call void @perror(i8* %33)
  br label %136

; <label>:34:                                     ; preds = %._crit_edge
  %35 = getelementptr inbounds i8, i8* %1, i64 0
  %36 = load i8, i8* %35, align 1
  %37 = zext i8 %36 to i32
  %38 = getelementptr inbounds i8, i8* %1, i64 1
  %39 = load i8, i8* %38, align 1
  %40 = zext i8 %39 to i32
  %41 = getelementptr inbounds i8, i8* %1, i64 2
  %42 = load i8, i8* %41, align 1
  %43 = zext i8 %42 to i32
  %44 = getelementptr inbounds i8, i8* %1, i64 3
  %45 = load i8, i8* %44, align 1
  %46 = zext i8 %45 to i32
  %47 = getelementptr inbounds i8, i8* %1, i64 4
  %48 = load i8, i8* %47, align 1
  %49 = zext i8 %48 to i32
  %50 = getelementptr inbounds i8, i8* %1, i64 5
  %51 = load i8, i8* %50, align 1
  %52 = zext i8 %51 to i32
  %53 = getelementptr [30 x i8], [30 x i8]* @.str.8, i32 0, i32 0
  %54 = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %30, i64 18, i8* %53, i32 %37, i32 %40, i32 %43, i32 %46, i32 %49, i32 %52) #9
  %55 = getelementptr inbounds i8, i8* %30, i64 17
  store i8 0, i8* %55, align 1
  %56 = call noalias i8* @strdup(i8* %0) #9, !track !56
  store i8* %56, i8** %3, align 8
  %57 = getelementptr [2 x i8], [2 x i8]* @.str.6, i32 0, i32 0
  %58 = call i8* @strsep(i8** %3, i8* %57) #9
  br label %59

; <label>:59:                                     ; preds = %100, %34
  call void @unroll_loop(i32 28)
  %60 = getelementptr [2 x i8], [2 x i8]* @.str.6, i32 0, i32 0
  %61 = call i8* @strsep(i8** %3, i8* %60) #9
  %62 = icmp eq i8* %61, null
  br i1 %62, label %.loopexit8, label %.preheader

.preheader:                                       ; preds = %59
  br label %63

; <label>:63:                                     ; preds = %.preheader, %97
  %indvars.iv = phi i64 [ %indvars.iv.next, %97 ], [ 0, %.preheader ]
  call void @unroll_loop(i32 29)
  %64 = getelementptr inbounds i8, i8* %61, i64 %indvars.iv
  %65 = load i8, i8* %64, align 1
  %66 = sext i8 %65 to i32
  %67 = icmp eq i32 %66, 88
  br i1 %67, label %97, label %68

; <label>:68:                                     ; preds = %63
  %69 = getelementptr inbounds i8, i8* %61, i64 %indvars.iv
  %70 = load i8, i8* %69, align 1
  %71 = sext i8 %70 to i32
  %72 = icmp eq i32 %71, 120
  br i1 %72, label %97, label %73

; <label>:73:                                     ; preds = %68
  %74 = getelementptr inbounds i8, i8* %61, i64 %indvars.iv
  %75 = load i8, i8* %74, align 1
  %76 = sext i8 %75 to i32
  %77 = icmp eq i32 %76, 95
  br i1 %77, label %97, label %78

; <label>:78:                                     ; preds = %73
  %79 = getelementptr inbounds i8, i8* %61, i64 %indvars.iv
  %80 = load i8, i8* %79, align 1
  %81 = sext i8 %80 to i32
  %82 = icmp eq i32 %81, 45
  br i1 %82, label %97, label %83

; <label>:83:                                     ; preds = %78
  %84 = getelementptr inbounds i8, i8* %61, i64 %indvars.iv
  %85 = load i8, i8* %84, align 1
  %86 = sext i8 %85 to i32
  %87 = icmp eq i32 %86, 58
  br i1 %87, label %97, label %88

; <label>:88:                                     ; preds = %83
  %89 = getelementptr inbounds i8, i8* %61, i64 %indvars.iv
  %90 = load i8, i8* %89, align 1
  %91 = sext i8 %90 to i32
  %92 = call i32 @toupper(i32 %91) #10
  %93 = getelementptr inbounds i8, i8* %30, i64 %indvars.iv
  %94 = load i8, i8* %93, align 1
  %95 = sext i8 %94 to i32
  %96 = icmp ne i32 %92, %95
  br i1 %96, label %.loopexit, label %97

; <label>:97:                                     ; preds = %88, %63, %68, %73, %78, %83
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %98 = icmp ult i64 %indvars.iv.next, 17
  br i1 %98, label %63, label %.loopexit

.loopexit:                                        ; preds = %97, %88
  %.05 = phi i32 [ 1, %88 ], [ 0, %97 ]
  %99 = icmp eq i32 %.05, 0
  br i1 %99, label %.loopexit8, label %100

; <label>:100:                                    ; preds = %.loopexit
  %101 = load i8*, i8** %3, align 8
  %102 = icmp ne i8* %101, null
  br i1 %102, label %59, label %.loopexit8

.loopexit8:                                       ; preds = %100, %.loopexit, %59
  %.01 = phi i32 [ 0, %59 ], [ 1, %.loopexit ], [ 0, %100 ]
  %103 = icmp ne i8* %30, null
  br i1 %103, label %104, label %105

; <label>:104:                                    ; preds = %.loopexit8
  call void @free(i8* %30) #9
  br label %105

; <label>:105:                                    ; preds = %104, %.loopexit8
  %106 = icmp ne i8* %56, null
  br i1 %106, label %107, label %108

; <label>:107:                                    ; preds = %105
  call void @free(i8* %56) #9
  br label %108

; <label>:108:                                    ; preds = %107, %105
  %109 = call noalias i8* @malloc(i64 24) #9, !track !57
  %110 = bitcast i8* %109 to %struct.mergeBSSID*
  %111 = icmp ne %struct.mergeBSSID* %110, null
  br i1 %111, label %114, label %112

; <label>:112:                                    ; preds = %108
  %113 = getelementptr [14 x i8], [14 x i8]* @.str.7, i32 0, i32 0
  call void @perror(i8* %113)
  br label %136

; <label>:114:                                    ; preds = %108
  %115 = getelementptr inbounds %struct.mergeBSSID, %struct.mergeBSSID* %110, i32 0, i32 2
  store i32 %.01, i32* %115, align 8
  %116 = getelementptr inbounds %struct.mergeBSSID, %struct.mergeBSSID* %110, i32 0, i32 3
  store %struct.mergeBSSID* null, %struct.mergeBSSID** %116, align 8
  %117 = getelementptr inbounds %struct.mergeBSSID, %struct.mergeBSSID* %110, i32 0, i32 0
  %118 = getelementptr inbounds [6 x i8], [6 x i8]* %117, i32 0, i32 0
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %118, i8* align 1 %1, i64 6, i1 false), !track !58
  %119 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 36
  %120 = load %struct.mergeBSSID*, %struct.mergeBSSID** %119, align 8
  %121 = icmp eq %struct.mergeBSSID* %120, null
  br i1 %121, label %122, label %124

; <label>:122:                                    ; preds = %114
  %123 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 36
  store %struct.mergeBSSID* %110, %struct.mergeBSSID** %123, align 8
  br label %126

; <label>:124:                                    ; preds = %114
  %125 = getelementptr inbounds %struct.mergeBSSID, %struct.mergeBSSID* %.03.lcssa, i32 0, i32 3
  store %struct.mergeBSSID* %110, %struct.mergeBSSID** %125, align 8
  br label %126

; <label>:126:                                    ; preds = %124, %122
  %127 = getelementptr inbounds %struct.mergeBSSID, %struct.mergeBSSID* %110, i32 0, i32 2
  %128 = load i32, i32* %127, align 8
  %129 = icmp ne i32 %128, 0
  br i1 %129, label %130, label %133

; <label>:130:                                    ; preds = %126
  %131 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 35
  %132 = load i8*, i8** %131, align 8
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %1, i8* align 1 %132, i64 6, i1 false), !track !59
  br label %133

; <label>:133:                                    ; preds = %130, %126
  %134 = getelementptr inbounds %struct.mergeBSSID, %struct.mergeBSSID* %110, i32 0, i32 2
  %135 = load i32, i32* %134, align 8
  br label %136

; <label>:136:                                    ; preds = %2, %133, %112, %32, %23
  %.0 = phi i32 [ %25, %23 ], [ %135, %133 ], [ -1, %112 ], [ -1, %32 ], [ 1, %2 ]
  ret i32 %.0
}

; Function Attrs: nounwind readonly
declare dso_local i32 @memcmp(i8*, i8*, i64) #3

declare dso_local void @perror(i8*) #1

; Function Attrs: nounwind
declare dso_local i32 @snprintf(i8*, i64, i8*, ...) #2

; Function Attrs: nounwind readonly
declare dso_local i32 @toupper(i32) #3

; Function Attrs: noinline nounwind uwtable
define dso_local i32 @atomic_read(%struct.read_buf*, i32, i32, i8*) #0 {
  %5 = load i32, i32* @close_aircrack, align 4
  %6 = icmp ne i32 %5, 0
  br i1 %6, label %107, label %7

; <label>:7:                                      ; preds = %4
  %8 = getelementptr inbounds %struct.read_buf, %struct.read_buf* %0, i32 0, i32 2
  %9 = load i8*, i8** %8, align 8
  %10 = icmp eq i8* %9, null
  br i1 %10, label %11, label %26

; <label>:11:                                     ; preds = %7
  %12 = call noalias i8* @malloc(i64 65536) #9, !track !60
  %13 = getelementptr inbounds %struct.read_buf, %struct.read_buf* %0, i32 0, i32 2
  store i8* %12, i8** %13, align 8
  %14 = call noalias i8* @malloc(i64 65536) #9, !track !61
  %15 = getelementptr inbounds %struct.read_buf, %struct.read_buf* %0, i32 0, i32 3
  store i8* %14, i8** %15, align 8
  %16 = getelementptr inbounds %struct.read_buf, %struct.read_buf* %0, i32 0, i32 2
  %17 = load i8*, i8** %16, align 8
  %18 = icmp eq i8* %17, null
  br i1 %18, label %107, label %19

; <label>:19:                                     ; preds = %11
  %20 = getelementptr inbounds %struct.read_buf, %struct.read_buf* %0, i32 0, i32 3
  %21 = load i8*, i8** %20, align 8
  %22 = icmp eq i8* %21, null
  br i1 %22, label %107, label %23

; <label>:23:                                     ; preds = %19
  %24 = getelementptr inbounds %struct.read_buf, %struct.read_buf* %0, i32 0, i32 0
  store i32 0, i32* %24, align 8
  %25 = getelementptr inbounds %struct.read_buf, %struct.read_buf* %0, i32 0, i32 1
  store i32 0, i32* %25, align 4
  br label %26

; <label>:26:                                     ; preds = %23, %7
  %27 = getelementptr inbounds %struct.read_buf, %struct.read_buf* %0, i32 0, i32 0
  %28 = load i32, i32* %27, align 8
  %29 = sub nsw i32 65536, %28
  %30 = icmp sgt i32 %2, %29
  br i1 %30, label %31, label %56

; <label>:31:                                     ; preds = %26
  %32 = getelementptr inbounds %struct.read_buf, %struct.read_buf* %0, i32 0, i32 0
  %33 = load i32, i32* %32, align 8
  %34 = getelementptr inbounds %struct.read_buf, %struct.read_buf* %0, i32 0, i32 1
  %35 = load i32, i32* %34, align 4
  %36 = sub nsw i32 %35, %33
  store i32 %36, i32* %34, align 4
  %37 = getelementptr inbounds %struct.read_buf, %struct.read_buf* %0, i32 0, i32 3
  %38 = load i8*, i8** %37, align 8
  %39 = getelementptr inbounds %struct.read_buf, %struct.read_buf* %0, i32 0, i32 2
  %40 = load i8*, i8** %39, align 8
  %41 = getelementptr inbounds %struct.read_buf, %struct.read_buf* %0, i32 0, i32 0
  %42 = load i32, i32* %41, align 8
  %43 = sext i32 %42 to i64
  %44 = getelementptr i8, i8* %40, i64 %43
  %45 = getelementptr inbounds %struct.read_buf, %struct.read_buf* %0, i32 0, i32 1
  %46 = load i32, i32* %45, align 4
  %47 = sext i32 %46 to i64
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %38, i8* align 1 %44, i64 %47, i1 false), !track !62
  %48 = getelementptr inbounds %struct.read_buf, %struct.read_buf* %0, i32 0, i32 2
  %49 = load i8*, i8** %48, align 8
  %50 = getelementptr inbounds %struct.read_buf, %struct.read_buf* %0, i32 0, i32 3
  %51 = load i8*, i8** %50, align 8
  %52 = getelementptr inbounds %struct.read_buf, %struct.read_buf* %0, i32 0, i32 1
  %53 = load i32, i32* %52, align 4
  %54 = sext i32 %53 to i64
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %49, i8* align 1 %51, i64 %54, i1 false), !track !63
  %55 = getelementptr inbounds %struct.read_buf, %struct.read_buf* %0, i32 0, i32 0
  store i32 0, i32* %55, align 8
  br label %56

; <label>:56:                                     ; preds = %31, %26
  %57 = getelementptr inbounds %struct.read_buf, %struct.read_buf* %0, i32 0, i32 1
  %58 = load i32, i32* %57, align 4
  %59 = getelementptr inbounds %struct.read_buf, %struct.read_buf* %0, i32 0, i32 0
  %60 = load i32, i32* %59, align 8
  %61 = sub nsw i32 %58, %60
  %62 = icmp sge i32 %61, %2
  %63 = getelementptr inbounds %struct.read_buf, %struct.read_buf* %0, i32 0, i32 2
  %64 = load i8*, i8** %63, align 8
  br i1 %62, label %65, label %74

; <label>:65:                                     ; preds = %56
  %66 = getelementptr inbounds %struct.read_buf, %struct.read_buf* %0, i32 0, i32 0
  %67 = load i32, i32* %66, align 8
  %68 = sext i32 %67 to i64
  %69 = getelementptr i8, i8* %64, i64 %68
  %70 = sext i32 %2 to i64
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %3, i8* align 1 %69, i64 %70, i1 false), !track !64
  %71 = getelementptr inbounds %struct.read_buf, %struct.read_buf* %0, i32 0, i32 0
  %72 = load i32, i32* %71, align 8
  %73 = add nsw i32 %72, %2
  store i32 %73, i32* %71, align 8
  br label %107

; <label>:74:                                     ; preds = %56
  %75 = getelementptr inbounds %struct.read_buf, %struct.read_buf* %0, i32 0, i32 1
  %76 = load i32, i32* %75, align 4
  %77 = sext i32 %76 to i64
  %78 = getelementptr i8, i8* %64, i64 %77
  %79 = getelementptr inbounds %struct.read_buf, %struct.read_buf* %0, i32 0, i32 1
  %80 = load i32, i32* %79, align 4
  %81 = sub nsw i32 65536, %80
  %82 = sext i32 %81 to i64
  %83 = call i64 @read(i32 %1, i8* %78, i64 %82)
  %84 = trunc i64 %83 to i32
  %85 = icmp sle i32 %84, 0
  br i1 %85, label %107, label %86

; <label>:86:                                     ; preds = %74
  %87 = getelementptr inbounds %struct.read_buf, %struct.read_buf* %0, i32 0, i32 1
  %88 = load i32, i32* %87, align 4
  %89 = add nsw i32 %88, %84
  store i32 %89, i32* %87, align 4
  %90 = getelementptr inbounds %struct.read_buf, %struct.read_buf* %0, i32 0, i32 1
  %91 = load i32, i32* %90, align 4
  %92 = getelementptr inbounds %struct.read_buf, %struct.read_buf* %0, i32 0, i32 0
  %93 = load i32, i32* %92, align 8
  %94 = sub nsw i32 %91, %93
  %95 = icmp sge i32 %94, %2
  br i1 %95, label %96, label %107

; <label>:96:                                     ; preds = %86
  %97 = getelementptr inbounds %struct.read_buf, %struct.read_buf* %0, i32 0, i32 2
  %98 = load i8*, i8** %97, align 8
  %99 = getelementptr inbounds %struct.read_buf, %struct.read_buf* %0, i32 0, i32 0
  %100 = load i32, i32* %99, align 8
  %101 = sext i32 %100 to i64
  %102 = getelementptr i8, i8* %98, i64 %101
  %103 = sext i32 %2 to i64
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %3, i8* align 1 %102, i64 %103, i1 false), !track !65
  %104 = getelementptr inbounds %struct.read_buf, %struct.read_buf* %0, i32 0, i32 0
  %105 = load i32, i32* %104, align 8
  %106 = add nsw i32 %105, %2
  store i32 %106, i32* %104, align 8
  br label %107

; <label>:107:                                    ; preds = %86, %74, %11, %19, %4, %96, %65
  %.0 = phi i32 [ 1, %65 ], [ 1, %96 ], [ 100000, %4 ], [ 0, %19 ], [ 0, %11 ], [ 0, %74 ], [ 0, %86 ]
  ret i32 %.0
}

declare dso_local i64 @read(i32, i8*, i64) #1

; Function Attrs: noinline nounwind uwtable
define dso_local void @read_thread(i8*) #0 {
  %2 = alloca i32, align 4
  %3 = alloca %struct.read_buf, align 8, !track !66
  %4 = alloca [6 x i8], align 1, !track !67
  %5 = alloca [6 x i8], align 1, !track !68
  %6 = alloca [6 x i8], align 1, !track !69
  %7 = alloca [16 x i32], align 16, !track !70
  %8 = alloca %struct.ivs2_pkthdr, align 2, !track !71
  %9 = alloca %struct.ivs2_filehdr, align 2, !track !72
  %10 = alloca %struct.pcap_pkthdr, align 4, !track !73
  %11 = alloca %struct.pcap_file_header, align 4, !track !74
  %12 = alloca [2048 x i8], align 16, !track !75
  %13 = alloca i32, align 4
  %14 = alloca [16 x i32], align 16
  store i32 0, i32* %2, align 4
  %15 = call void (i32)* @signal(i32 2, void (i32)* @sighandler) #9
  %16 = bitcast %struct.read_buf* %3 to i8*
  call void @llvm.memset.p0i8.i64(i8* align 8 %16, i8 0, i64 24, i1 false)
  %17 = bitcast %struct.pcap_file_header* %11 to i8*
  call void @llvm.memset.p0i8.i64(i8* align 4 %17, i8 0, i64 24, i1 false)
  %18 = call noalias i8* @malloc(i64 65536) #9, !track !76
  %19 = icmp eq i8* %18, null
  br i1 %19, label %20, label %22

; <label>:20:                                     ; preds = %1
  %21 = getelementptr [14 x i8], [14 x i8]* @.str.7, i32 0, i32 0
  call void @perror(i8* %21)
  br label %._crit_edge87

; <label>:22:                                     ; preds = %1
  %23 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 6
  %24 = load i32, i32* %23, align 8
  %25 = icmp ne i32 %24, 0
  br i1 %25, label %29, label %26

; <label>:26:                                     ; preds = %22
  %27 = getelementptr [12 x i8], [12 x i8]* @.str.9, i32 0, i32 0
  %28 = call i32 (i8*, ...) @printf(i8* %27, i8* %0)
  br label %29

; <label>:29:                                     ; preds = %26, %22
  %30 = getelementptr [2 x i8], [2 x i8]* @.str.10, i32 0, i32 0
  %31 = call i32 @strcmp(i8* %0, i8* %30) #10
  %32 = icmp eq i32 %31, 0
  br i1 %32, label %38, label %33

; <label>:33:                                     ; preds = %29
  %34 = call i32 (i8*, i32, ...) @open64(i8* %0, i32 0)
  %35 = icmp slt i32 %34, 0
  br i1 %35, label %36, label %38

; <label>:36:                                     ; preds = %33
  %37 = getelementptr [12 x i8], [12 x i8]* @.str.11, i32 0, i32 0
  call void @perror(i8* %37)
  br label %._crit_edge87

; <label>:38:                                     ; preds = %33, %29
  %.01 = phi i32 [ 0, %29 ], [ %34, %33 ]
  %39 = bitcast %struct.pcap_file_header* %11 to i8*
  %40 = call i32 @atomic_read(%struct.read_buf* %3, i32 %.01, i32 4, i8* %39)
  %41 = icmp ne i32 %40, 0
  br i1 %41, label %44, label %42

; <label>:42:                                     ; preds = %38
  %43 = getelementptr [25 x i8], [25 x i8]* @.str.12, i32 0, i32 0
  call void @perror(i8* %43)
  br label %._crit_edge87

; <label>:44:                                     ; preds = %38
  %45 = bitcast %struct.pcap_file_header* %11 to i8*
  %46 = getelementptr [5 x i8], [5 x i8]* @.str.13, i32 0, i32 0
  %47 = call i32 @memcmp(i8* %45, i8* %46, i64 4) #10
  %48 = icmp ne i32 %47, 0
  br i1 %48, label %49, label %118

; <label>:49:                                     ; preds = %44
  %50 = bitcast %struct.pcap_file_header* %11 to i8*
  %51 = getelementptr [5 x i8], [5 x i8]* @.str.14, i32 0, i32 0
  %52 = call i32 @memcmp(i8* %50, i8* %51, i64 4) #10
  %53 = icmp ne i32 %52, 0
  br i1 %53, label %54, label %118

; <label>:54:                                     ; preds = %49
  %55 = getelementptr inbounds %struct.pcap_file_header, %struct.pcap_file_header* %11, i32 0, i32 0
  %56 = load i32, i32* %55, align 4
  %57 = icmp ne i32 %56, -1582119980
  br i1 %57, label %58, label %66

; <label>:58:                                     ; preds = %54
  %59 = getelementptr inbounds %struct.pcap_file_header, %struct.pcap_file_header* %11, i32 0, i32 0
  %60 = load i32, i32* %59, align 4
  %61 = icmp ne i32 %60, -725372255
  br i1 %61, label %62, label %66

; <label>:62:                                     ; preds = %58
  %63 = load %struct._IO_FILE*, %struct._IO_FILE** @stderr, align 8
  %64 = getelementptr [51 x i8], [51 x i8]* @.str.15, i32 0, i32 0
  %65 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %63, i8* %64)
  br label %._crit_edge87

; <label>:66:                                     ; preds = %58, %54
  %67 = bitcast %struct.pcap_file_header* %11 to i8*
  %68 = getelementptr inbounds i8, i8* %67, i64 4
  %69 = call i32 @atomic_read(%struct.read_buf* %3, i32 %.01, i32 20, i8* %68)
  %70 = icmp ne i32 %69, 0
  br i1 %70, label %73, label %71

; <label>:71:                                     ; preds = %66
  %72 = getelementptr [25 x i8], [25 x i8]* @.str.12, i32 0, i32 0
  call void @perror(i8* %72)
  br label %._crit_edge87

; <label>:73:                                     ; preds = %66
  %74 = getelementptr inbounds %struct.pcap_file_header, %struct.pcap_file_header* %11, i32 0, i32 0
  %75 = load i32, i32* %74, align 4
  %76 = icmp eq i32 %75, -725372255
  br i1 %76, label %77, label %98

; <label>:77:                                     ; preds = %73
  %78 = getelementptr inbounds %struct.pcap_file_header, %struct.pcap_file_header* %11, i32 0, i32 6
  %79 = load i32, i32* %78, align 4
  %80 = lshr i32 %79, 24
  %81 = and i32 %80, 255
  %82 = getelementptr inbounds %struct.pcap_file_header, %struct.pcap_file_header* %11, i32 0, i32 6
  %83 = load i32, i32* %82, align 4
  %84 = lshr i32 %83, 8
  %85 = and i32 %84, 65280
  %86 = or i32 %81, %85
  %87 = getelementptr inbounds %struct.pcap_file_header, %struct.pcap_file_header* %11, i32 0, i32 6
  %88 = load i32, i32* %87, align 4
  %89 = shl i32 %88, 8
  %90 = and i32 %89, 16711680
  %91 = or i32 %86, %90
  %92 = getelementptr inbounds %struct.pcap_file_header, %struct.pcap_file_header* %11, i32 0, i32 6
  %93 = load i32, i32* %92, align 4
  %94 = shl i32 %93, 24
  %95 = and i32 %94, -16777216
  %96 = or i32 %91, %95
  %97 = getelementptr inbounds %struct.pcap_file_header, %struct.pcap_file_header* %11, i32 0, i32 6
  store i32 %96, i32* %97, align 4
  br label %98

; <label>:98:                                     ; preds = %77, %73
  %99 = getelementptr inbounds %struct.pcap_file_header, %struct.pcap_file_header* %11, i32 0, i32 6
  %100 = load i32, i32* %99, align 4
  %101 = icmp ne i32 %100, 105
  br i1 %101, label %102, label %153

; <label>:102:                                    ; preds = %98
  %103 = getelementptr inbounds %struct.pcap_file_header, %struct.pcap_file_header* %11, i32 0, i32 6
  %104 = load i32, i32* %103, align 4
  %105 = icmp ne i32 %104, 119
  br i1 %105, label %106, label %153

; <label>:106:                                    ; preds = %102
  %107 = getelementptr inbounds %struct.pcap_file_header, %struct.pcap_file_header* %11, i32 0, i32 6
  %108 = load i32, i32* %107, align 4
  %109 = icmp ne i32 %108, 127
  br i1 %109, label %110, label %153

; <label>:110:                                    ; preds = %106
  %111 = getelementptr inbounds %struct.pcap_file_header, %struct.pcap_file_header* %11, i32 0, i32 6
  %112 = load i32, i32* %111, align 4
  %113 = icmp ne i32 %112, 192
  br i1 %113, label %114, label %153

; <label>:114:                                    ; preds = %110
  %115 = load %struct._IO_FILE*, %struct._IO_FILE** @stderr, align 8
  %116 = getelementptr [55 x i8], [55 x i8]* @.str.16, i32 0, i32 0
  %117 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %115, i8* %116)
  br label %._crit_edge87

; <label>:118:                                    ; preds = %49, %44
  %119 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 38
  %120 = load i32, i32* %119, align 8
  %121 = icmp ne i32 %120, 0
  br i1 %121, label %122, label %124

; <label>:122:                                    ; preds = %118
  %123 = getelementptr [37 x i8], [37 x i8]* @.str.17, i32 0, i32 0
  call void (i32, i8*, ...) @errx(i32 1, i8* %123) #12
  unreachable

; <label>:124:                                    ; preds = %118
  %125 = bitcast %struct.pcap_file_header* %11 to i8*
  %126 = getelementptr [5 x i8], [5 x i8]* @.str.14, i32 0, i32 0
  %127 = call i32 @memcmp(i8* %125, i8* %126, i64 4) #10
  %128 = icmp eq i32 %127, 0
  br i1 %128, label %129, label %147

; <label>:129:                                    ; preds = %124
  %130 = bitcast %struct.ivs2_filehdr* %9 to i8*
  %131 = call i32 @atomic_read(%struct.read_buf* %3, i32 %.01, i32 2, i8* %130)
  %132 = icmp ne i32 %131, 0
  br i1 %132, label %135, label %133

; <label>:133:                                    ; preds = %129
  %134 = getelementptr [25 x i8], [25 x i8]* @.str.12, i32 0, i32 0
  call void @perror(i8* %134)
  br label %._crit_edge87

; <label>:135:                                    ; preds = %129
  %136 = getelementptr inbounds %struct.ivs2_filehdr, %struct.ivs2_filehdr* %9, i32 0, i32 0
  %137 = load i16, i16* %136, align 2
  %138 = zext i16 %137 to i32
  %139 = icmp sgt i32 %138, 1
  br i1 %139, label %140, label %153

; <label>:140:                                    ; preds = %135
  %141 = getelementptr inbounds %struct.ivs2_filehdr, %struct.ivs2_filehdr* %9, i32 0, i32 0
  %142 = load i16, i16* %141, align 2
  %143 = zext i16 %142 to i32
  %144 = getelementptr [58 x i8], [58 x i8]* @.str.18, i32 0, i32 0
  %145 = getelementptr [4 x i8], [4 x i8]* @.str.19, i32 0, i32 0
  %146 = call i32 (i8*, ...) @printf(i8* %144, i8* %145, i32 %143, i32 1)
  br label %._crit_edge87

; <label>:147:                                    ; preds = %124
  %148 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 20
  %149 = load i32, i32* %148, align 4
  %150 = icmp ne i32 %149, 0
  br i1 %150, label %151, label %153

; <label>:151:                                    ; preds = %147
  %152 = getelementptr [84 x i8], [84 x i8]* @.str.20, i32 0, i32 0
  call void (i32, i8*, ...) @errx(i32 1, i8* %152) #12
  unreachable

; <label>:153:                                    ; preds = %135, %147, %98, %102, %106, %110
  %.15 = phi i32 [ 1, %110 ], [ 1, %106 ], [ 1, %102 ], [ 1, %98 ], [ 3, %135 ], [ 2, %147 ]
  %154 = call i32 (i32, i32, ...) @fcntl(i32 %.01, i32 4, i32 2048)
  %155 = icmp slt i32 %154, 0
  br i1 %155, label %156, label %158

; <label>:156:                                    ; preds = %153
  %157 = getelementptr [25 x i8], [25 x i8]* @.str.21, i32 0, i32 0
  call void @perror(i8* %157)
  br label %._crit_edge87

; <label>:158:                                    ; preds = %153
  %159 = load i32, i32* @close_aircrack, align 4
  %160 = icmp ne i32 %159, 0
  br i1 %160, label %._crit_edge87, label %.lr.ph86.preheader

.lr.ph86.preheader:                               ; preds = %158
  br label %.lr.ph86

.lr.ph86:                                         ; preds = %.lr.ph86.preheader, %.backedge
  %.0684 = phi i8* [ %.06.be, %.backedge ], [ %18, %.lr.ph86.preheader ]
  %.01280 = phi %struct.AP_info* [ %.012.be, %.backedge ], [ null, %.lr.ph86.preheader ]
  call void @unroll_loop(i32 30)
  switch i32 %.15, label %244 [
    i32 2, label %161
    i32 3, label %198
  ]

; <label>:161:                                    ; preds = %.lr.ph86
  %162 = call i32 @atomic_read(%struct.read_buf* %3, i32 %.01, i32 1, i8* %18)
  %163 = icmp ne i32 %162, 0
  %164 = xor i1 %163, true
  br i1 %164, label %.lr.ph45.preheader, label %._crit_edge46

.lr.ph45.preheader:                               ; preds = %161
  br label %.lr.ph45

.lr.ph45:                                         ; preds = %.lr.ph45.preheader, %.lr.ph45
  call void @unroll_loop(i32 31)
  call void @eof_wait(i32* %2)
  %165 = call i32 @atomic_read(%struct.read_buf* %3, i32 %.01, i32 1, i8* %18)
  %166 = icmp ne i32 %165, 0
  %167 = xor i1 %166, true
  br i1 %167, label %.lr.ph45, label %._crit_edge46.loopexit

._crit_edge46.loopexit:                           ; preds = %.lr.ph45
  br label %._crit_edge46

._crit_edge46:                                    ; preds = %._crit_edge46.loopexit, %161
  %168 = load i32, i32* @close_aircrack, align 4
  %169 = icmp ne i32 %168, 0
  br i1 %169, label %._crit_edge87.loopexit, label %170

; <label>:170:                                    ; preds = %._crit_edge46
  %171 = getelementptr inbounds i8, i8* %18, i64 0
  %172 = load i8, i8* %171, align 1
  %173 = zext i8 %172 to i32
  %174 = icmp ne i32 %173, 255
  br i1 %174, label %175, label %189

; <label>:175:                                    ; preds = %170
  %176 = getelementptr inbounds i8, i8* %18, i64 0
  %177 = load i8, i8* %176, align 1
  %178 = getelementptr inbounds [6 x i8], [6 x i8]* %4, i64 0, i64 0
  store i8 %177, i8* %178, align 1
  %179 = getelementptr inbounds [6 x i8], [6 x i8]* %4, i32 0, i32 0
  %180 = getelementptr inbounds i8, i8* %179, i64 1
  %181 = call i32 @atomic_read(%struct.read_buf* %3, i32 %.01, i32 5, i8* %180)
  %182 = icmp ne i32 %181, 0
  %183 = xor i1 %182, true
  br i1 %183, label %.lr.ph48.preheader, label %._crit_edge49

.lr.ph48.preheader:                               ; preds = %175
  br label %.lr.ph48

.lr.ph48:                                         ; preds = %.lr.ph48.preheader, %.lr.ph48
  call void @unroll_loop(i32 32)
  call void @eof_wait(i32* %2)
  %184 = call i32 @atomic_read(%struct.read_buf* %3, i32 %.01, i32 5, i8* %180)
  %185 = icmp ne i32 %184, 0
  %186 = xor i1 %185, true
  br i1 %186, label %.lr.ph48, label %._crit_edge49.loopexit

._crit_edge49.loopexit:                           ; preds = %.lr.ph48
  br label %._crit_edge49

._crit_edge49:                                    ; preds = %._crit_edge49.loopexit, %175
  %187 = load i32, i32* @close_aircrack, align 4
  %188 = icmp ne i32 %187, 0
  br i1 %188, label %._crit_edge87.loopexit, label %189

; <label>:189:                                    ; preds = %._crit_edge49, %170
  %190 = call i32 @atomic_read(%struct.read_buf* %3, i32 %.01, i32 5, i8* %18)
  %191 = icmp ne i32 %190, 0
  %192 = xor i1 %191, true
  br i1 %192, label %.lr.ph51.preheader, label %._crit_edge52

.lr.ph51.preheader:                               ; preds = %189
  br label %.lr.ph51

.lr.ph51:                                         ; preds = %.lr.ph51.preheader, %.lr.ph51
  call void @unroll_loop(i32 33)
  call void @eof_wait(i32* %2)
  %193 = call i32 @atomic_read(%struct.read_buf* %3, i32 %.01, i32 5, i8* %18)
  %194 = icmp ne i32 %193, 0
  %195 = xor i1 %194, true
  br i1 %195, label %.lr.ph51, label %._crit_edge52.loopexit

._crit_edge52.loopexit:                           ; preds = %.lr.ph51
  br label %._crit_edge52

._crit_edge52:                                    ; preds = %._crit_edge52.loopexit, %189
  %196 = load i32, i32* @close_aircrack, align 4
  %197 = icmp ne i32 %196, 0
  br i1 %197, label %._crit_edge87.loopexit, label %399

; <label>:198:                                    ; preds = %.lr.ph86
  %199 = bitcast %struct.ivs2_pkthdr* %8 to i8*
  %200 = call i32 @atomic_read(%struct.read_buf* %3, i32 %.01, i32 4, i8* %199)
  %201 = icmp ne i32 %200, 0
  %202 = xor i1 %201, true
  br i1 %202, label %.lr.ph36.preheader, label %._crit_edge37

.lr.ph36.preheader:                               ; preds = %198
  br label %.lr.ph36

.lr.ph36:                                         ; preds = %.lr.ph36.preheader, %.lr.ph36
  call void @unroll_loop(i32 34)
  call void @eof_wait(i32* %2)
  %203 = call i32 @atomic_read(%struct.read_buf* %3, i32 %.01, i32 4, i8* %199)
  %204 = icmp ne i32 %203, 0
  %205 = xor i1 %204, true
  br i1 %205, label %.lr.ph36, label %._crit_edge37.loopexit

._crit_edge37.loopexit:                           ; preds = %.lr.ph36
  br label %._crit_edge37

._crit_edge37:                                    ; preds = %._crit_edge37.loopexit, %198
  %206 = load i32, i32* @close_aircrack, align 4
  %207 = icmp ne i32 %206, 0
  br i1 %207, label %._crit_edge87.loopexit, label %208

; <label>:208:                                    ; preds = %._crit_edge37
  %209 = getelementptr inbounds %struct.ivs2_pkthdr, %struct.ivs2_pkthdr* %8, i32 0, i32 0
  %210 = load i16, i16* %209, align 2
  %211 = zext i16 %210 to i32
  %212 = and i32 %211, 1
  %213 = icmp ne i32 %212, 0
  br i1 %213, label %214, label %230

; <label>:214:                                    ; preds = %208
  %215 = getelementptr inbounds [6 x i8], [6 x i8]* %4, i32 0, i32 0
  %216 = call i32 @atomic_read(%struct.read_buf* %3, i32 %.01, i32 6, i8* %215)
  %217 = icmp ne i32 %216, 0
  %218 = xor i1 %217, true
  br i1 %218, label %.lr.ph39.preheader, label %._crit_edge40

.lr.ph39.preheader:                               ; preds = %214
  br label %.lr.ph39

.lr.ph39:                                         ; preds = %.lr.ph39.preheader, %.lr.ph39
  call void @unroll_loop(i32 35)
  call void @eof_wait(i32* %2)
  %219 = call i32 @atomic_read(%struct.read_buf* %3, i32 %.01, i32 6, i8* %215)
  %220 = icmp ne i32 %219, 0
  %221 = xor i1 %220, true
  br i1 %221, label %.lr.ph39, label %._crit_edge40.loopexit

._crit_edge40.loopexit:                           ; preds = %.lr.ph39
  br label %._crit_edge40

._crit_edge40:                                    ; preds = %._crit_edge40.loopexit, %214
  %222 = load i32, i32* @close_aircrack, align 4
  %223 = icmp ne i32 %222, 0
  br i1 %223, label %._crit_edge87.loopexit, label %224

; <label>:224:                                    ; preds = %._crit_edge40
  %225 = getelementptr inbounds %struct.ivs2_pkthdr, %struct.ivs2_pkthdr* %8, i32 0, i32 1
  %226 = load i16, i16* %225, align 2
  %227 = zext i16 %226 to i32
  %228 = sub nsw i32 %227, 6
  %229 = trunc i32 %228 to i16
  store i16 %229, i16* %225, align 2
  br label %230

; <label>:230:                                    ; preds = %224, %208
  %231 = getelementptr inbounds %struct.ivs2_pkthdr, %struct.ivs2_pkthdr* %8, i32 0, i32 1
  %232 = load i16, i16* %231, align 2
  %233 = zext i16 %232 to i32
  %234 = call i32 @atomic_read(%struct.read_buf* %3, i32 %.01, i32 %233, i8* %18)
  %235 = icmp ne i32 %234, 0
  %236 = xor i1 %235, true
  br i1 %236, label %.lr.ph42.preheader, label %._crit_edge43

.lr.ph42.preheader:                               ; preds = %230
  br label %.lr.ph42

.lr.ph42:                                         ; preds = %.lr.ph42.preheader, %.lr.ph42
  call void @unroll_loop(i32 36)
  call void @eof_wait(i32* %2)
  %237 = load i16, i16* %231, align 2
  %238 = zext i16 %237 to i32
  %239 = call i32 @atomic_read(%struct.read_buf* %3, i32 %.01, i32 %238, i8* %18)
  %240 = icmp ne i32 %239, 0
  %241 = xor i1 %240, true
  br i1 %241, label %.lr.ph42, label %._crit_edge43.loopexit

._crit_edge43.loopexit:                           ; preds = %.lr.ph42
  br label %._crit_edge43

._crit_edge43:                                    ; preds = %._crit_edge43.loopexit, %230
  %242 = load i32, i32* @close_aircrack, align 4
  %243 = icmp ne i32 %242, 0
  br i1 %243, label %._crit_edge87.loopexit, label %399

; <label>:244:                                    ; preds = %.lr.ph86
  %245 = bitcast %struct.pcap_pkthdr* %10 to i8*
  %246 = call i32 @atomic_read(%struct.read_buf* %3, i32 %.01, i32 16, i8* %245)
  %247 = icmp ne i32 %246, 0
  %248 = xor i1 %247, true
  br i1 %248, label %.lr.ph.preheader, label %._crit_edge

.lr.ph.preheader:                                 ; preds = %244
  br label %.lr.ph

.lr.ph:                                           ; preds = %.lr.ph.preheader, %.lr.ph
  call void @unroll_loop(i32 37)
  call void @eof_wait(i32* %2)
  %249 = call i32 @atomic_read(%struct.read_buf* %3, i32 %.01, i32 16, i8* %245)
  %250 = icmp ne i32 %249, 0
  %251 = xor i1 %250, true
  br i1 %251, label %.lr.ph, label %._crit_edge.loopexit

._crit_edge.loopexit:                             ; preds = %.lr.ph
  br label %._crit_edge

._crit_edge:                                      ; preds = %._crit_edge.loopexit, %244
  %252 = load i32, i32* @close_aircrack, align 4
  %253 = icmp ne i32 %252, 0
  br i1 %253, label %._crit_edge87.loopexit, label %254

; <label>:254:                                    ; preds = %._crit_edge
  %255 = getelementptr inbounds %struct.pcap_file_header, %struct.pcap_file_header* %11, i32 0, i32 0
  %256 = load i32, i32* %255, align 4
  %257 = icmp eq i32 %256, -725372255
  br i1 %257, label %258, label %279

; <label>:258:                                    ; preds = %254
  %259 = getelementptr inbounds %struct.pcap_pkthdr, %struct.pcap_pkthdr* %10, i32 0, i32 2
  %260 = load i32, i32* %259, align 4
  %261 = lshr i32 %260, 24
  %262 = and i32 %261, 255
  %263 = getelementptr inbounds %struct.pcap_pkthdr, %struct.pcap_pkthdr* %10, i32 0, i32 2
  %264 = load i32, i32* %263, align 4
  %265 = lshr i32 %264, 8
  %266 = and i32 %265, 65280
  %267 = or i32 %262, %266
  %268 = getelementptr inbounds %struct.pcap_pkthdr, %struct.pcap_pkthdr* %10, i32 0, i32 2
  %269 = load i32, i32* %268, align 4
  %270 = shl i32 %269, 8
  %271 = and i32 %270, 16711680
  %272 = or i32 %267, %271
  %273 = getelementptr inbounds %struct.pcap_pkthdr, %struct.pcap_pkthdr* %10, i32 0, i32 2
  %274 = load i32, i32* %273, align 4
  %275 = shl i32 %274, 24
  %276 = and i32 %275, -16777216
  %277 = or i32 %272, %276
  %278 = getelementptr inbounds %struct.pcap_pkthdr, %struct.pcap_pkthdr* %10, i32 0, i32 2
  store i32 %277, i32* %278, align 4
  br label %279

; <label>:279:                                    ; preds = %258, %254
  %280 = getelementptr inbounds %struct.pcap_pkthdr, %struct.pcap_pkthdr* %10, i32 0, i32 2
  %281 = load i32, i32* %280, align 4
  %282 = icmp ule i32 %281, 0
  br i1 %282, label %287, label %283

; <label>:283:                                    ; preds = %279
  %284 = getelementptr inbounds %struct.pcap_pkthdr, %struct.pcap_pkthdr* %10, i32 0, i32 2
  %285 = load i32, i32* %284, align 4
  %286 = icmp ugt i32 %285, 65535
  br i1 %286, label %287, label %293

; <label>:287:                                    ; preds = %283, %279
  %288 = load %struct._IO_FILE*, %struct._IO_FILE** @stderr, align 8
  %289 = getelementptr inbounds %struct.pcap_pkthdr, %struct.pcap_pkthdr* %10, i32 0, i32 2
  %290 = load i32, i32* %289, align 4
  %291 = getelementptr [53 x i8], [53 x i8]* @.str.22, i32 0, i32 0
  %292 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %288, i8* %291, i32 %290)
  call void @eof_wait(i32* %2)
  call void @_exit(i32 1) #12
  unreachable

; <label>:293:                                    ; preds = %283
  %294 = getelementptr inbounds %struct.pcap_pkthdr, %struct.pcap_pkthdr* %10, i32 0, i32 2
  %295 = load i32, i32* %294, align 4
  %296 = call i32 @atomic_read(%struct.read_buf* %3, i32 %.01, i32 %295, i8* %18)
  %297 = icmp ne i32 %296, 0
  %298 = xor i1 %297, true
  br i1 %298, label %.lr.ph33.preheader, label %._crit_edge34

.lr.ph33.preheader:                               ; preds = %293
  br label %.lr.ph33

.lr.ph33:                                         ; preds = %.lr.ph33.preheader, %.lr.ph33
  call void @unroll_loop(i32 38)
  call void @eof_wait(i32* %2)
  %299 = load i32, i32* %294, align 4
  %300 = call i32 @atomic_read(%struct.read_buf* %3, i32 %.01, i32 %299, i8* %18)
  %301 = icmp ne i32 %300, 0
  %302 = xor i1 %301, true
  br i1 %302, label %.lr.ph33, label %._crit_edge34.loopexit

._crit_edge34.loopexit:                           ; preds = %.lr.ph33
  br label %._crit_edge34

._crit_edge34:                                    ; preds = %._crit_edge34.loopexit, %293
  %303 = load i32, i32* @close_aircrack, align 4
  %304 = icmp ne i32 %303, 0
  br i1 %304, label %._crit_edge87.loopexit, label %305

; <label>:305:                                    ; preds = %._crit_edge34
  %306 = getelementptr inbounds %struct.pcap_file_header, %struct.pcap_file_header* %11, i32 0, i32 6
  %307 = load i32, i32* %306, align 4
  %308 = icmp eq i32 %307, 119
  br i1 %308, label %309, label %345

; <label>:309:                                    ; preds = %305
  %310 = getelementptr inbounds i8, i8* %18, i64 7
  %311 = load i8, i8* %310, align 1
  %312 = zext i8 %311 to i32
  %313 = icmp eq i32 %312, 64
  br i1 %313, label %333, label %314

; <label>:314:                                    ; preds = %309
  %315 = getelementptr inbounds i8, i8* %18, i64 4
  %316 = bitcast i8* %315 to i32*
  %317 = load i32, i32* %316, align 4
  %318 = getelementptr inbounds %struct.pcap_file_header, %struct.pcap_file_header* %11, i32 0, i32 0
  %319 = load i32, i32* %318, align 4
  %320 = icmp eq i32 %319, -725372255
  br i1 %320, label %321, label %333

; <label>:321:                                    ; preds = %314
  %322 = ashr i32 %317, 24
  %323 = and i32 %322, 255
  %324 = ashr i32 %317, 8
  %325 = and i32 %324, 65280
  %326 = or i32 %323, %325
  %327 = shl i32 %317, 8
  %328 = and i32 %327, 16711680
  %329 = or i32 %326, %328
  %330 = shl i32 %317, 24
  %331 = and i32 %330, -16777216
  %332 = or i32 %329, %331
  br label %333

; <label>:333:                                    ; preds = %314, %321, %309
  %.1 = phi i32 [ 64, %309 ], [ %332, %321 ], [ %317, %314 ]
  %334 = icmp slt i32 %.1, 8
  br i1 %334, label %.backedge, label %335

; <label>:335:                                    ; preds = %333
  %336 = getelementptr inbounds %struct.pcap_pkthdr, %struct.pcap_pkthdr* %10, i32 0, i32 2
  %337 = load i32, i32* %336, align 4
  %338 = icmp sge i32 %.1, %337
  br i1 %338, label %.backedge, label %339

; <label>:339:                                    ; preds = %335
  %340 = sext i32 %.1 to i64
  %341 = getelementptr inbounds i8, i8* %18, i64 %340
  %342 = getelementptr inbounds %struct.pcap_pkthdr, %struct.pcap_pkthdr* %10, i32 0, i32 2
  %343 = load i32, i32* %342, align 4
  %344 = sub i32 %343, %.1
  store i32 %344, i32* %342, align 4
  br label %345

; <label>:345:                                    ; preds = %339, %305
  %.17 = phi i8* [ %341, %339 ], [ %18, %305 ]
  %346 = getelementptr inbounds %struct.pcap_file_header, %struct.pcap_file_header* %11, i32 0, i32 6
  %347 = load i32, i32* %346, align 4
  %348 = icmp eq i32 %347, 127
  br i1 %348, label %349, label %365

; <label>:349:                                    ; preds = %345
  %350 = getelementptr inbounds i8, i8* %.17, i64 2
  %351 = bitcast i8* %350 to i16*
  %352 = load i16, i16* %351, align 2
  %353 = zext i16 %352 to i32
  %354 = icmp sle i32 %353, 0
  br i1 %354, label %.backedge, label %355

; <label>:355:                                    ; preds = %349
  %356 = getelementptr inbounds %struct.pcap_pkthdr, %struct.pcap_pkthdr* %10, i32 0, i32 2
  %357 = load i32, i32* %356, align 4
  %358 = icmp sge i32 %353, %357
  br i1 %358, label %.backedge, label %359

; <label>:359:                                    ; preds = %355
  %360 = sext i32 %353 to i64
  %361 = getelementptr inbounds i8, i8* %.17, i64 %360
  %362 = getelementptr inbounds %struct.pcap_pkthdr, %struct.pcap_pkthdr* %10, i32 0, i32 2
  %363 = load i32, i32* %362, align 4
  %364 = sub i32 %363, %353
  store i32 %364, i32* %362, align 4
  br label %365

; <label>:365:                                    ; preds = %359, %345
  %.28 = phi i8* [ %361, %359 ], [ %.17, %345 ]
  %366 = getelementptr inbounds %struct.pcap_file_header, %struct.pcap_file_header* %11, i32 0, i32 6
  %367 = load i32, i32* %366, align 4
  %368 = icmp eq i32 %367, 192
  br i1 %368, label %369, label %399

; <label>:369:                                    ; preds = %365
  %370 = getelementptr inbounds i8, i8* %.28, i64 2
  %371 = bitcast i8* %370 to i16*
  %372 = load i16, i16* %371, align 2
  %373 = zext i16 %372 to i32
  %374 = icmp sle i32 %373, 0
  br i1 %374, label %.backedge, label %375

; <label>:375:                                    ; preds = %369
  %376 = getelementptr inbounds %struct.pcap_pkthdr, %struct.pcap_pkthdr* %10, i32 0, i32 2
  %377 = load i32, i32* %376, align 4
  %378 = icmp sge i32 %373, %377
  br i1 %378, label %.backedge, label %379

; <label>:379:                                    ; preds = %375
  %380 = icmp eq i32 %373, 24
  br i1 %380, label %381, label %387

; <label>:381:                                    ; preds = %379
  %382 = getelementptr inbounds i8, i8* %.28, i64 8
  %383 = bitcast i8* %382 to i16*
  %384 = load i16, i16* %383, align 2
  %385 = zext i16 %384 to i32
  %386 = icmp eq i32 %385, 2
  %spec.select = select i1 %386, i32 32, i32 %373
  br label %387

; <label>:387:                                    ; preds = %381, %379
  %.2 = phi i32 [ %373, %379 ], [ %spec.select, %381 ]
  %388 = icmp sle i32 %.2, 0
  br i1 %388, label %.backedge, label %389

; <label>:389:                                    ; preds = %387
  %390 = getelementptr inbounds %struct.pcap_pkthdr, %struct.pcap_pkthdr* %10, i32 0, i32 2
  %391 = load i32, i32* %390, align 4
  %392 = icmp sge i32 %.2, %391
  br i1 %392, label %.backedge, label %393

; <label>:393:                                    ; preds = %389
  %394 = sext i32 %.2 to i64
  %395 = getelementptr inbounds i8, i8* %.28, i64 %394
  %396 = getelementptr inbounds %struct.pcap_pkthdr, %struct.pcap_pkthdr* %10, i32 0, i32 2
  %397 = load i32, i32* %396, align 4
  %398 = sub i32 %397, %.2
  store i32 %398, i32* %396, align 4
  br label %399

; <label>:399:                                    ; preds = %._crit_edge43, %393, %365, %._crit_edge52
  %.5 = phi i8* [ %.0684, %._crit_edge52 ], [ %.0684, %._crit_edge43 ], [ %395, %393 ], [ %.28, %365 ]
  %400 = call i32 @pthread_mutex_lock(%union.pthread_mutex_t* @mx_apl) #9
  %401 = load i64, i64* @nb_pkt, align 8
  %402 = add nsw i64 %401, 1
  store i64 %402, i64* @nb_pkt, align 8
  %403 = icmp eq i32 %.15, 1
  br i1 %403, label %404, label %459

; <label>:404:                                    ; preds = %399
  %405 = getelementptr inbounds %struct.pcap_pkthdr, %struct.pcap_pkthdr* %10, i32 0, i32 2
  %406 = load i32, i32* %405, align 4
  %407 = icmp ult i32 %406, 24
  br i1 %407, label %1619, label %408

; <label>:408:                                    ; preds = %404
  %409 = getelementptr inbounds i8, i8* %.5, i64 0
  %410 = load i8, i8* %409, align 1
  %411 = zext i8 %410 to i32
  %412 = and i32 %411, 12
  %413 = icmp eq i32 %412, 4
  br i1 %413, label %1619, label %414

; <label>:414:                                    ; preds = %408
  %415 = getelementptr inbounds i8, i8* %.5, i64 1
  %416 = load i8, i8* %415, align 1
  %417 = zext i8 %416 to i32
  %418 = and i32 %417, 3
  switch i32 %418, label %431 [
    i32 0, label %419
    i32 1, label %422
    i32 2, label %425
    i32 3, label %428
  ]

; <label>:419:                                    ; preds = %414
  %420 = getelementptr inbounds [6 x i8], [6 x i8]* %4, i32 0, i32 0
  %421 = getelementptr inbounds i8, i8* %.5, i64 16
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %420, i8* align 1 %421, i64 6, i1 false), !track !77
  br label %432

; <label>:422:                                    ; preds = %414
  %423 = getelementptr inbounds [6 x i8], [6 x i8]* %4, i32 0, i32 0
  %424 = getelementptr inbounds i8, i8* %.5, i64 4
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %423, i8* align 1 %424, i64 6, i1 false), !track !78
  br label %432

; <label>:425:                                    ; preds = %414
  %426 = getelementptr inbounds [6 x i8], [6 x i8]* %4, i32 0, i32 0
  %427 = getelementptr inbounds i8, i8* %.5, i64 10
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %426, i8* align 1 %427, i64 6, i1 false), !track !79
  br label %432

; <label>:428:                                    ; preds = %414
  %429 = getelementptr inbounds [6 x i8], [6 x i8]* %4, i32 0, i32 0
  %430 = getelementptr inbounds i8, i8* %.5, i64 10
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %429, i8* align 1 %430, i64 6, i1 false), !track !80
  br label %432

; <label>:431:                                    ; preds = %414
  unreachable

; <label>:432:                                    ; preds = %428, %425, %422, %419
  %433 = getelementptr inbounds i8, i8* %.5, i64 1
  %434 = load i8, i8* %433, align 1
  %435 = zext i8 %434 to i32
  %436 = and i32 %435, 3
  switch i32 %436, label %449 [
    i32 0, label %437
    i32 1, label %440
    i32 2, label %443
    i32 3, label %446
  ]

; <label>:437:                                    ; preds = %432
  %438 = getelementptr inbounds [6 x i8], [6 x i8]* %5, i32 0, i32 0
  %439 = getelementptr inbounds i8, i8* %.5, i64 4
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %438, i8* align 1 %439, i64 6, i1 false), !track !81
  br label %450

; <label>:440:                                    ; preds = %432
  %441 = getelementptr inbounds [6 x i8], [6 x i8]* %5, i32 0, i32 0
  %442 = getelementptr inbounds i8, i8* %.5, i64 16
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %441, i8* align 1 %442, i64 6, i1 false), !track !82
  br label %450

; <label>:443:                                    ; preds = %432
  %444 = getelementptr inbounds [6 x i8], [6 x i8]* %5, i32 0, i32 0
  %445 = getelementptr inbounds i8, i8* %.5, i64 4
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %444, i8* align 1 %445, i64 6, i1 false), !track !83
  br label %450

; <label>:446:                                    ; preds = %432
  %447 = getelementptr inbounds [6 x i8], [6 x i8]* %5, i32 0, i32 0
  %448 = getelementptr inbounds i8, i8* %.5, i64 16
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %447, i8* align 1 %448, i64 6, i1 false), !track !84
  br label %450

; <label>:449:                                    ; preds = %432
  unreachable

; <label>:450:                                    ; preds = %446, %443, %440, %437
  %451 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 38
  %452 = load i32, i32* %451, align 8
  %453 = icmp ne i32 %452, 0
  br i1 %453, label %454, label %459

; <label>:454:                                    ; preds = %450
  %455 = getelementptr inbounds [6 x i8], [6 x i8]* %5, i64 0, i64 0
  %456 = load i8, i8* %455, align 1
  %457 = zext i8 %456 to i32
  %458 = icmp eq i32 %457, 1
  br i1 %458, label %1619, label %459

; <label>:459:                                    ; preds = %450, %454, %399
  %460 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 34
  %461 = load i8*, i8** %460, align 8
  %462 = icmp ne i8* %461, null
  br i1 %462, label %463, label %468

; <label>:463:                                    ; preds = %459
  %464 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 34
  %465 = load i8*, i8** %464, align 8
  %466 = getelementptr inbounds [6 x i8], [6 x i8]* %4, i32 0, i32 0
  %467 = call i32 @mergebssids(i8* %465, i8* %466)
  br label %468

; <label>:468:                                    ; preds = %463, %459
  %469 = getelementptr inbounds [6 x i8], [6 x i8]* %4, i32 0, i32 0
  %470 = getelementptr [7 x i8], [7 x i8]* @.str.23, i32 0, i32 0
  %471 = call i32 @memcmp(i8* %469, i8* %470, i64 6) #10
  %472 = icmp eq i32 %471, 0
  br i1 %472, label %1619, label %473

; <label>:473:                                    ; preds = %468
  %474 = getelementptr inbounds [6 x i8], [6 x i8]* %4, i32 0, i32 0
  %475 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 4, i32 0
  %476 = call i32 @memcmp(i8* %474, i8* %475, i64 6) #10
  %477 = icmp ne i32 %476, 0
  br i1 %477, label %1619, label %478

; <label>:478:                                    ; preds = %473
  %479 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 9, i32 0
  %480 = getelementptr [32 x i8], [32 x i8]* @ZERO, i32 0, i32 0
  %481 = call i32 @memcmp(i8* %479, i8* %480, i64 6) #10
  %482 = icmp ne i32 %481, 0
  br i1 %482, label %483, label %503

; <label>:483:                                    ; preds = %478
  %484 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 9, i32 0
  %485 = getelementptr [7 x i8], [7 x i8]* @.str.23, i32 0, i32 0
  %486 = call i32 @memcmp(i8* %484, i8* %485, i64 6) #10
  %487 = icmp ne i32 %486, 0
  br i1 %487, label %488, label %503

; <label>:488:                                    ; preds = %483
  %489 = getelementptr inbounds i8, i8* %.5, i64 4
  %490 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 9, i32 0
  %491 = call i32 @memcmp(i8* %490, i8* %489, i64 6) #10
  %492 = icmp ne i32 %491, 0
  br i1 %492, label %493, label %503

; <label>:493:                                    ; preds = %488
  %494 = getelementptr inbounds i8, i8* %.5, i64 10
  %495 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 9, i32 0
  %496 = call i32 @memcmp(i8* %495, i8* %494, i64 6) #10
  %497 = icmp ne i32 %496, 0
  br i1 %497, label %498, label %503

; <label>:498:                                    ; preds = %493
  %499 = getelementptr inbounds i8, i8* %.5, i64 16
  %500 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 9, i32 0
  %501 = call i32 @memcmp(i8* %500, i8* %499, i64 6) #10
  %502 = icmp ne i32 %501, 0
  br i1 %502, label %1619, label %503

; <label>:503:                                    ; preds = %488, %493, %498, %483, %478
  %504 = load %struct.AP_info*, %struct.AP_info** @ap_1st, align 8
  %505 = icmp ne %struct.AP_info* %504, null
  br i1 %505, label %.lr.ph56, label %._crit_edge3

.lr.ph56:                                         ; preds = %503
  %506 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %504, i32 0, i32 1
  %507 = getelementptr inbounds [6 x i8], [6 x i8]* %506, i32 0, i32 0
  %508 = getelementptr inbounds [6 x i8], [6 x i8]* %4, i32 0, i32 0
  %509 = call i32 @memcmp(i8* %507, i8* %508, i64 6) #10
  %510 = icmp ne i32 %509, 0
  br i1 %510, label %.lr.ph2.preheader, label %._crit_edge3

.lr.ph2.preheader:                                ; preds = %.lr.ph56
  br label %.lr.ph2

; <label>:511:                                    ; preds = %.lr.ph2
  %.11353 = phi %struct.AP_info* [ %517, %.lr.ph2 ]
  %512 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.11353, i32 0, i32 1
  %513 = getelementptr inbounds [6 x i8], [6 x i8]* %512, i32 0, i32 0
  %514 = call i32 @memcmp(i8* %513, i8* %508, i64 6) #10
  %515 = icmp ne i32 %514, 0
  br i1 %515, label %.lr.ph2, label %._crit_edge3.loopexit

.lr.ph2:                                          ; preds = %.lr.ph2.preheader, %511
  %.113531 = phi %struct.AP_info* [ %.11353, %511 ], [ %504, %.lr.ph2.preheader ]
  call void @unroll_loop(i32 39)
  %516 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.113531, i32 0, i32 0
  %517 = load %struct.AP_info*, %struct.AP_info** %516, align 8
  %518 = icmp ne %struct.AP_info* %517, null
  br i1 %518, label %511, label %._crit_edge3.loopexit

._crit_edge3.loopexit:                            ; preds = %511, %.lr.ph2
  %.113.lcssa.ph = phi %struct.AP_info* [ %517, %.lr.ph2 ], [ %.11353, %511 ]
  %.011.lcssa.ph = phi %struct.AP_info* [ %.113531, %.lr.ph2 ], [ %.113531, %511 ]
  br label %._crit_edge3

._crit_edge3:                                     ; preds = %._crit_edge3.loopexit, %503, %.lr.ph56
  %.113.lcssa = phi %struct.AP_info* [ %504, %.lr.ph56 ], [ %504, %503 ], [ %.113.lcssa.ph, %._crit_edge3.loopexit ]
  %.011.lcssa = phi %struct.AP_info* [ null, %.lr.ph56 ], [ null, %503 ], [ %.011.lcssa.ph, %._crit_edge3.loopexit ]
  %519 = icmp eq %struct.AP_info* %.113.lcssa, null
  br i1 %519, label %520, label %559

; <label>:520:                                    ; preds = %._crit_edge3
  %521 = call noalias i8* @malloc(i64 504) #9, !track !85
  %522 = bitcast i8* %521 to %struct.AP_info*
  %523 = icmp ne %struct.AP_info* %522, null
  br i1 %523, label %526, label %524

; <label>:524:                                    ; preds = %520
  %525 = getelementptr [14 x i8], [14 x i8]* @.str.7, i32 0, i32 0
  call void @perror(i8* %525)
  br label %._crit_edge87

; <label>:526:                                    ; preds = %520
  %527 = bitcast %struct.AP_info* %522 to i8*
  call void @llvm.memset.p0i8.i64(i8* align 8 %527, i8 0, i64 504, i1 false)
  %528 = load %struct.AP_info*, %struct.AP_info** @ap_1st, align 8
  %529 = icmp eq %struct.AP_info* %528, null
  br i1 %529, label %530, label %531

; <label>:530:                                    ; preds = %526
  store %struct.AP_info* %522, %struct.AP_info** @ap_1st, align 8
  br label %533

; <label>:531:                                    ; preds = %526
  %532 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.011.lcssa, i32 0, i32 0
  store %struct.AP_info* %522, %struct.AP_info** %532, align 8
  br label %533

; <label>:533:                                    ; preds = %531, %530
  %534 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %522, i32 0, i32 1
  %535 = getelementptr inbounds [6 x i8], [6 x i8]* %534, i32 0, i32 0
  %536 = getelementptr inbounds [6 x i8], [6 x i8]* %4, i32 0, i32 0
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %535, i8* align 1 %536, i64 6, i1 false), !track !86
  %537 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %522, i32 0, i32 10
  store i32 -1, i32* %537, align 8
  %538 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 20
  %539 = load i32, i32* %538, align 4
  %540 = icmp eq i32 %539, 1
  br i1 %540, label %541, label %559

; <label>:541:                                    ; preds = %533
  %542 = call %struct.PTW_attackstate* (...) bitcast (%struct.PTW_attackstate* ()* @PTW_newattackstate to %struct.PTW_attackstate* (...)*)()
  %543 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %522, i32 0, i32 15
  store %struct.PTW_attackstate* %542, %struct.PTW_attackstate** %543, align 8
  %544 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %522, i32 0, i32 15
  %545 = load %struct.PTW_attackstate*, %struct.PTW_attackstate** %544, align 8
  %546 = icmp ne %struct.PTW_attackstate* %545, null
  br i1 %546, label %550, label %547

; <label>:547:                                    ; preds = %541
  %.lcssa27 = phi %struct.AP_info* [ %522, %541 ]
  %548 = getelementptr [21 x i8], [21 x i8]* @.str.24, i32 0, i32 0
  call void @perror(i8* %548)
  %549 = bitcast %struct.AP_info* %.lcssa27 to i8*
  call void @free(i8* %549) #9
  br label %._crit_edge87

; <label>:550:                                    ; preds = %541
  %551 = call %struct.PTW_attackstate* (...) bitcast (%struct.PTW_attackstate* ()* @PTW_newattackstate to %struct.PTW_attackstate* (...)*)()
  %552 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %522, i32 0, i32 16
  store %struct.PTW_attackstate* %551, %struct.PTW_attackstate** %552, align 8
  %553 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %522, i32 0, i32 16
  %554 = load %struct.PTW_attackstate*, %struct.PTW_attackstate** %553, align 8
  %555 = icmp ne %struct.PTW_attackstate* %554, null
  br i1 %555, label %559, label %556

; <label>:556:                                    ; preds = %550
  %.lcssa28 = phi %struct.AP_info* [ %522, %550 ]
  %557 = getelementptr [21 x i8], [21 x i8]* @.str.24, i32 0, i32 0
  call void @perror(i8* %557)
  %558 = bitcast %struct.AP_info* %.lcssa28 to i8*
  call void @free(i8* %558) #9
  br label %._crit_edge87

; <label>:559:                                    ; preds = %533, %550, %._crit_edge3
  %.214 = phi %struct.AP_info* [ %.113.lcssa, %._crit_edge3 ], [ %522, %550 ], [ %522, %533 ]
  switch i32 %.15, label %849 [
    i32 2, label %560
    i32 3, label %610
  ]

; <label>:560:                                    ; preds = %559
  %561 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.214, i32 0, i32 10
  store i32 2, i32* %561, align 8
  br label %562

; <label>:562:                                    ; preds = %1214, %1219, %560
  %563 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.214, i32 0, i32 7
  %564 = load i64, i64* %563, align 8
  %565 = icmp eq i64 %564, 0
  br i1 %565, label %566, label %569

; <label>:566:                                    ; preds = %562
  %567 = call i8** @uniqueiv_init()
  %568 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.214, i32 0, i32 5
  store i8** %567, i8*** %568, align 8
  br label %569

; <label>:569:                                    ; preds = %566, %562
  %570 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.214, i32 0, i32 5
  %571 = load i8**, i8*** %570, align 8
  %572 = call i32 @uniqueiv_check(i8** %571, i8* %18)
  %573 = icmp eq i32 %572, 0
  br i1 %573, label %574, label %1619

; <label>:574:                                    ; preds = %569
  %575 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.214, i32 0, i32 7
  %576 = load i64, i64* %575, align 8
  %577 = mul nsw i64 %576, 5
  %578 = trunc i64 %577 to i32
  %579 = add nsw i32 %578, 5
  %580 = sext i32 %579 to i64
  %581 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.214, i32 0, i32 6
  %582 = load i64, i64* %581, align 8
  %583 = icmp sgt i64 %580, %582
  br i1 %583, label %584, label %599

; <label>:584:                                    ; preds = %574
  %585 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.214, i32 0, i32 6
  %586 = load i64, i64* %585, align 8
  %587 = add nsw i64 %586, 131072
  store i64 %587, i64* %585, align 8
  %588 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.214, i32 0, i32 4
  %589 = load i8*, i8** %588, align 8
  %590 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.214, i32 0, i32 6
  %591 = load i64, i64* %590, align 8
  %592 = call i8* @realloc(i8* %589, i64 %591) #9, !track !87
  %593 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.214, i32 0, i32 4
  store i8* %592, i8** %593, align 8
  %594 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.214, i32 0, i32 4
  %595 = load i8*, i8** %594, align 8
  %596 = icmp eq i8* %595, null
  br i1 %596, label %597, label %599

; <label>:597:                                    ; preds = %584
  %598 = getelementptr [15 x i8], [15 x i8]* @.str.25, i32 0, i32 0
  call void @perror(i8* %598)
  br label %._crit_edge87

; <label>:599:                                    ; preds = %584, %574
  %600 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.214, i32 0, i32 4
  %601 = load i8*, i8** %600, align 8
  %602 = sext i32 %578 to i64
  %603 = getelementptr inbounds i8, i8* %601, i64 %602
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %603, i8* align 1 %18, i64 5, i1 false), !track !88
  %604 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.214, i32 0, i32 5
  %605 = load i8**, i8*** %604, align 8
  %606 = call i32 @uniqueiv_mark(i8** %605, i8* %18)
  %607 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.214, i32 0, i32 7
  %608 = load i64, i64* %607, align 8
  %609 = add nsw i64 %608, 1
  store i64 %609, i64* %607, align 8
  br label %1619

; <label>:610:                                    ; preds = %559
  %611 = getelementptr inbounds %struct.ivs2_pkthdr, %struct.ivs2_pkthdr* %8, i32 0, i32 0
  %612 = load i16, i16* %611, align 2
  %613 = zext i16 %612 to i32
  %614 = and i32 %613, 2
  %615 = icmp ne i32 %614, 0
  br i1 %615, label %616, label %622

; <label>:616:                                    ; preds = %610
  %617 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.214, i32 0, i32 2
  %618 = getelementptr inbounds [33 x i8], [33 x i8]* %617, i32 0, i32 0
  %619 = getelementptr inbounds %struct.ivs2_pkthdr, %struct.ivs2_pkthdr* %8, i32 0, i32 1
  %620 = load i16, i16* %619, align 2
  %621 = zext i16 %620 to i64
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 2 %618, i8* align 1 %18, i64 %621, i1 false), !track !89
  br label %1619

; <label>:622:                                    ; preds = %610
  %623 = getelementptr inbounds %struct.ivs2_pkthdr, %struct.ivs2_pkthdr* %8, i32 0, i32 0
  %624 = load i16, i16* %623, align 2
  %625 = zext i16 %624 to i32
  %626 = and i32 %625, 8
  %627 = icmp ne i32 %626, 0
  br i1 %627, label %628, label %727

; <label>:628:                                    ; preds = %622
  %629 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.214, i32 0, i32 10
  store i32 2, i32* %629, align 8
  %630 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 20
  %631 = load i32, i32* %630, align 4
  %632 = icmp ne i32 %631, 0
  br i1 %632, label %633, label %663

; <label>:633:                                    ; preds = %628
  %634 = getelementptr inbounds %struct.ivs2_pkthdr, %struct.ivs2_pkthdr* %8, i32 0, i32 1
  %635 = load i16, i16* %634, align 2
  %636 = zext i16 %635 to i32
  %637 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 10
  %638 = load i32, i32* %637, align 4
  %639 = add nsw i32 %638, 3
  %640 = icmp slt i32 %636, %639
  br i1 %640, label %1619, label %641

; <label>:641:                                    ; preds = %633
  %642 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.214, i32 0, i32 15
  %643 = load %struct.PTW_attackstate*, %struct.PTW_attackstate** %642, align 8
  %644 = getelementptr inbounds i8, i8* %18, i64 4
  %645 = getelementptr [1 x i32], [1 x i32]* @PTW_DEFAULTWEIGHT, i32 0, i32 0
  %646 = call i32 @PTW_addsession(%struct.PTW_attackstate* %643, i8* %18, i8* %644, i32* %645, i32 1)
  %647 = icmp ne i32 %646, 0
  br i1 %647, label %648, label %652

; <label>:648:                                    ; preds = %641
  %649 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.214, i32 0, i32 8
  %650 = load i64, i64* %649, align 8
  %651 = add nsw i64 %650, 1
  store i64 %651, i64* %649, align 8
  br label %652

; <label>:652:                                    ; preds = %648, %641
  %653 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.214, i32 0, i32 16
  %654 = load %struct.PTW_attackstate*, %struct.PTW_attackstate** %653, align 8
  %655 = getelementptr inbounds i8, i8* %18, i64 4
  %656 = getelementptr [1 x i32], [1 x i32]* @PTW_DEFAULTWEIGHT, i32 0, i32 0
  %657 = call i32 @PTW_addsession(%struct.PTW_attackstate* %654, i8* %18, i8* %655, i32* %656, i32 1)
  %658 = icmp ne i32 %657, 0
  br i1 %658, label %659, label %1619

; <label>:659:                                    ; preds = %652
  %660 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.214, i32 0, i32 9
  %661 = load i64, i64* %660, align 8
  %662 = add nsw i64 %661, 1
  store i64 %662, i64* %660, align 8
  br label %1619

; <label>:663:                                    ; preds = %628
  %664 = getelementptr inbounds i8, i8* %18, i64 4
  %665 = load i8, i8* %664, align 1
  %666 = getelementptr inbounds i8, i8* %18, i64 3
  store i8 %665, i8* %666, align 1
  %667 = getelementptr inbounds i8, i8* %18, i64 5
  %668 = load i8, i8* %667, align 1
  %669 = getelementptr inbounds i8, i8* %18, i64 4
  store i8 %668, i8* %669, align 1
  %670 = getelementptr inbounds i8, i8* %18, i64 3
  %671 = load i8, i8* %670, align 1
  %672 = zext i8 %671 to i32
  %673 = xor i32 %672, 170
  %674 = trunc i32 %673 to i8
  store i8 %674, i8* %670, align 1
  %675 = getelementptr inbounds i8, i8* %18, i64 4
  %676 = load i8, i8* %675, align 1
  %677 = zext i8 %676 to i32
  %678 = xor i32 %677, 170
  %679 = trunc i32 %678 to i8
  store i8 %679, i8* %675, align 1
  %680 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.214, i32 0, i32 7
  %681 = load i64, i64* %680, align 8
  %682 = icmp eq i64 %681, 0
  br i1 %682, label %683, label %686

; <label>:683:                                    ; preds = %663
  %684 = call i8** @uniqueiv_init()
  %685 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.214, i32 0, i32 5
  store i8** %684, i8*** %685, align 8
  br label %686

; <label>:686:                                    ; preds = %683, %663
  %687 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.214, i32 0, i32 5
  %688 = load i8**, i8*** %687, align 8
  %689 = call i32 @uniqueiv_check(i8** %688, i8* %18)
  %690 = icmp eq i32 %689, 0
  br i1 %690, label %691, label %1619

; <label>:691:                                    ; preds = %686
  %692 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.214, i32 0, i32 7
  %693 = load i64, i64* %692, align 8
  %694 = mul nsw i64 %693, 5
  %695 = trunc i64 %694 to i32
  %696 = add nsw i32 %695, 5
  %697 = sext i32 %696 to i64
  %698 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.214, i32 0, i32 6
  %699 = load i64, i64* %698, align 8
  %700 = icmp sgt i64 %697, %699
  br i1 %700, label %701, label %716

; <label>:701:                                    ; preds = %691
  %702 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.214, i32 0, i32 6
  %703 = load i64, i64* %702, align 8
  %704 = add nsw i64 %703, 131072
  store i64 %704, i64* %702, align 8
  %705 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.214, i32 0, i32 4
  %706 = load i8*, i8** %705, align 8
  %707 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.214, i32 0, i32 6
  %708 = load i64, i64* %707, align 8
  %709 = call i8* @realloc(i8* %706, i64 %708) #9, !track !90
  %710 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.214, i32 0, i32 4
  store i8* %709, i8** %710, align 8
  %711 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.214, i32 0, i32 4
  %712 = load i8*, i8** %711, align 8
  %713 = icmp eq i8* %712, null
  br i1 %713, label %714, label %716

; <label>:714:                                    ; preds = %701
  %715 = getelementptr [15 x i8], [15 x i8]* @.str.25, i32 0, i32 0
  call void @perror(i8* %715)
  br label %._crit_edge87

; <label>:716:                                    ; preds = %701, %691
  %717 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.214, i32 0, i32 4
  %718 = load i8*, i8** %717, align 8
  %719 = sext i32 %695 to i64
  %720 = getelementptr inbounds i8, i8* %718, i64 %719
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %720, i8* align 1 %18, i64 5, i1 false), !track !91
  %721 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.214, i32 0, i32 5
  %722 = load i8**, i8*** %721, align 8
  %723 = call i32 @uniqueiv_mark(i8** %722, i8* %18)
  %724 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.214, i32 0, i32 7
  %725 = load i64, i64* %724, align 8
  %726 = add nsw i64 %725, 1
  store i64 %726, i64* %724, align 8
  br label %1619

; <label>:727:                                    ; preds = %622
  %728 = getelementptr inbounds %struct.ivs2_pkthdr, %struct.ivs2_pkthdr* %8, i32 0, i32 0
  %729 = load i16, i16* %728, align 2
  %730 = zext i16 %729 to i32
  %731 = and i32 %730, 16
  %732 = icmp ne i32 %731, 0
  br i1 %732, label %733, label %839

; <label>:733:                                    ; preds = %727
  %734 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.214, i32 0, i32 10
  store i32 2, i32* %734, align 8
  %735 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 20
  %736 = load i32, i32* %735, align 4
  %737 = icmp ne i32 %736, 0
  br i1 %737, label %738, label %775

; <label>:738:                                    ; preds = %733
  %739 = getelementptr inbounds %struct.ivs2_pkthdr, %struct.ivs2_pkthdr* %8, i32 0, i32 1
  %740 = load i16, i16* %739, align 2
  %741 = zext i16 %740 to i32
  %742 = getelementptr inbounds i8, i8* %18, i64 5
  %743 = load i8, i8* %742, align 1
  %744 = zext i8 %743 to i32
  %745 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 10
  %746 = load i32, i32* %745, align 4
  %747 = icmp slt i32 %744, %746
  br i1 %747, label %1619, label %748

; <label>:748:                                    ; preds = %738
  %749 = getelementptr inbounds i8, i8* %18, i64 4
  %750 = load i8, i8* %749, align 1
  %751 = zext i8 %750 to i32
  %752 = mul nsw i32 %751, 32
  %753 = add nsw i32 6, %752
  %754 = add nsw i32 %753, 64
  %755 = icmp slt i32 %741, %754
  br i1 %755, label %1619, label %756

; <label>:756:                                    ; preds = %748
  %757 = getelementptr inbounds [16 x i32], [16 x i32]* %7, i32 0, i32 0
  %758 = bitcast i32* %757 to i8*
  %759 = sext i32 %741 to i64
  %760 = getelementptr inbounds i8, i8* %18, i64 %759
  %761 = getelementptr inbounds i8, i8* %760, i64 -60
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 16 %758, i8* align 1 %761, i64 64, i1 false), !track !92
  %762 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.214, i32 0, i32 16
  %763 = load %struct.PTW_attackstate*, %struct.PTW_attackstate** %762, align 8
  %764 = getelementptr inbounds i8, i8* %18, i64 6
  %765 = getelementptr inbounds [16 x i32], [16 x i32]* %7, i32 0, i32 0
  %766 = getelementptr inbounds i8, i8* %18, i64 4
  %767 = load i8, i8* %766, align 1
  %768 = zext i8 %767 to i32
  %769 = call i32 @PTW_addsession(%struct.PTW_attackstate* %763, i8* %18, i8* %764, i32* %765, i32 %768)
  %770 = icmp ne i32 %769, 0
  br i1 %770, label %771, label %1619

; <label>:771:                                    ; preds = %756
  %772 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.214, i32 0, i32 9
  %773 = load i64, i64* %772, align 8
  %774 = add nsw i64 %773, 1
  store i64 %774, i64* %772, align 8
  br label %1619

; <label>:775:                                    ; preds = %733
  %776 = getelementptr inbounds i8, i8* %18, i64 6
  %777 = load i8, i8* %776, align 1
  %778 = getelementptr inbounds i8, i8* %18, i64 3
  store i8 %777, i8* %778, align 1
  %779 = getelementptr inbounds i8, i8* %18, i64 7
  %780 = load i8, i8* %779, align 1
  %781 = getelementptr inbounds i8, i8* %18, i64 4
  store i8 %780, i8* %781, align 1
  %782 = getelementptr inbounds i8, i8* %18, i64 3
  %783 = load i8, i8* %782, align 1
  %784 = zext i8 %783 to i32
  %785 = xor i32 %784, 170
  %786 = trunc i32 %785 to i8
  store i8 %786, i8* %782, align 1
  %787 = getelementptr inbounds i8, i8* %18, i64 4
  %788 = load i8, i8* %787, align 1
  %789 = zext i8 %788 to i32
  %790 = xor i32 %789, 170
  %791 = trunc i32 %790 to i8
  store i8 %791, i8* %787, align 1
  %792 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.214, i32 0, i32 7
  %793 = load i64, i64* %792, align 8
  %794 = icmp eq i64 %793, 0
  br i1 %794, label %795, label %798

; <label>:795:                                    ; preds = %775
  %796 = call i8** @uniqueiv_init()
  %797 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.214, i32 0, i32 5
  store i8** %796, i8*** %797, align 8
  br label %798

; <label>:798:                                    ; preds = %795, %775
  %799 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.214, i32 0, i32 5
  %800 = load i8**, i8*** %799, align 8
  %801 = call i32 @uniqueiv_check(i8** %800, i8* %18)
  %802 = icmp eq i32 %801, 0
  br i1 %802, label %803, label %1619

; <label>:803:                                    ; preds = %798
  %804 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.214, i32 0, i32 7
  %805 = load i64, i64* %804, align 8
  %806 = mul nsw i64 %805, 5
  %807 = trunc i64 %806 to i32
  %808 = add nsw i32 %807, 5
  %809 = sext i32 %808 to i64
  %810 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.214, i32 0, i32 6
  %811 = load i64, i64* %810, align 8
  %812 = icmp sgt i64 %809, %811
  br i1 %812, label %813, label %828

; <label>:813:                                    ; preds = %803
  %814 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.214, i32 0, i32 6
  %815 = load i64, i64* %814, align 8
  %816 = add nsw i64 %815, 131072
  store i64 %816, i64* %814, align 8
  %817 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.214, i32 0, i32 4
  %818 = load i8*, i8** %817, align 8
  %819 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.214, i32 0, i32 6
  %820 = load i64, i64* %819, align 8
  %821 = call i8* @realloc(i8* %818, i64 %820) #9, !track !93
  %822 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.214, i32 0, i32 4
  store i8* %821, i8** %822, align 8
  %823 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.214, i32 0, i32 4
  %824 = load i8*, i8** %823, align 8
  %825 = icmp eq i8* %824, null
  br i1 %825, label %826, label %828

; <label>:826:                                    ; preds = %813
  %827 = getelementptr [15 x i8], [15 x i8]* @.str.25, i32 0, i32 0
  call void @perror(i8* %827)
  br label %._crit_edge87

; <label>:828:                                    ; preds = %813, %803
  %829 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.214, i32 0, i32 4
  %830 = load i8*, i8** %829, align 8
  %831 = sext i32 %807 to i64
  %832 = getelementptr inbounds i8, i8* %830, i64 %831
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %832, i8* align 1 %18, i64 5, i1 false), !track !94
  %833 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.214, i32 0, i32 5
  %834 = load i8**, i8*** %833, align 8
  %835 = call i32 @uniqueiv_mark(i8** %834, i8* %18)
  %836 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.214, i32 0, i32 7
  %837 = load i64, i64* %836, align 8
  %838 = add nsw i64 %837, 1
  store i64 %838, i64* %836, align 8
  br label %1619

; <label>:839:                                    ; preds = %727
  %840 = getelementptr inbounds %struct.ivs2_pkthdr, %struct.ivs2_pkthdr* %8, i32 0, i32 0
  %841 = load i16, i16* %840, align 2
  %842 = zext i16 %841 to i32
  %843 = and i32 %842, 4
  %844 = icmp ne i32 %843, 0
  br i1 %844, label %845, label %1619

; <label>:845:                                    ; preds = %839
  %846 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.214, i32 0, i32 10
  store i32 3, i32* %846, align 8
  %847 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.214, i32 0, i32 14
  %848 = bitcast %struct.WPA_hdsk* %847 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %848, i8* align 1 %18, i64 356, i1 false), !track !95
  br label %1619

; <label>:849:                                    ; preds = %559
  %850 = getelementptr inbounds i8, i8* %.5, i64 1
  %851 = load i8, i8* %850, align 1
  %852 = zext i8 %851 to i32
  %853 = and i32 %852, 3
  switch i32 %853, label %906 [
    i32 0, label %854
    i32 1, label %857
    i32 2, label %860
  ]

; <label>:854:                                    ; preds = %849
  %855 = getelementptr inbounds [6 x i8], [6 x i8]* %6, i32 0, i32 0
  %856 = getelementptr inbounds i8, i8* %.5, i64 10
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %855, i8* align 1 %856, i64 6, i1 false), !track !96
  br label %869

; <label>:857:                                    ; preds = %849
  %858 = getelementptr inbounds [6 x i8], [6 x i8]* %6, i32 0, i32 0
  %859 = getelementptr inbounds i8, i8* %.5, i64 10
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %858, i8* align 1 %859, i64 6, i1 false), !track !97
  br label %869

; <label>:860:                                    ; preds = %849
  %861 = getelementptr inbounds i8, i8* %.5, i64 4
  %862 = load i8, i8* %861, align 1
  %863 = zext i8 %862 to i32
  %864 = srem i32 %863, 2
  %865 = icmp ne i32 %864, 0
  br i1 %865, label %906, label %866

; <label>:866:                                    ; preds = %860
  %867 = getelementptr inbounds [6 x i8], [6 x i8]* %6, i32 0, i32 0
  %868 = getelementptr inbounds i8, i8* %.5, i64 4
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %867, i8* align 1 %868, i64 6, i1 false), !track !98
  br label %869

; <label>:869:                                    ; preds = %866, %857, %854
  %870 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.214, i32 0, i32 13
  %871 = load %struct.ST_info*, %struct.ST_info** %870, align 8
  %872 = icmp ne %struct.ST_info* %871, null
  br i1 %872, label %.lr.ph61, label %._crit_edge8

.lr.ph61:                                         ; preds = %869
  %873 = getelementptr inbounds %struct.ST_info, %struct.ST_info* %871, i32 0, i32 3
  %874 = getelementptr inbounds [6 x i8], [6 x i8]* %873, i32 0, i32 0
  %875 = getelementptr inbounds [6 x i8], [6 x i8]* %6, i32 0, i32 0
  %876 = call i32 @memcmp(i8* %874, i8* %875, i64 6) #10
  %877 = icmp ne i32 %876, 0
  br i1 %877, label %.lr.ph7.preheader, label %._crit_edge8

.lr.ph7.preheader:                                ; preds = %.lr.ph61
  br label %.lr.ph7

; <label>:878:                                    ; preds = %.lr.ph7
  %.01758 = phi %struct.ST_info* [ %884, %.lr.ph7 ]
  %879 = getelementptr inbounds %struct.ST_info, %struct.ST_info* %.01758, i32 0, i32 3
  %880 = getelementptr inbounds [6 x i8], [6 x i8]* %879, i32 0, i32 0
  %881 = call i32 @memcmp(i8* %880, i8* %875, i64 6) #10
  %882 = icmp ne i32 %881, 0
  br i1 %882, label %.lr.ph7, label %._crit_edge8.loopexit

.lr.ph7:                                          ; preds = %.lr.ph7.preheader, %878
  %.017586 = phi %struct.ST_info* [ %.01758, %878 ], [ %871, %.lr.ph7.preheader ]
  call void @unroll_loop(i32 40)
  %883 = getelementptr inbounds %struct.ST_info, %struct.ST_info* %.017586, i32 0, i32 1
  %884 = load %struct.ST_info*, %struct.ST_info** %883, align 8
  %885 = icmp ne %struct.ST_info* %884, null
  br i1 %885, label %878, label %._crit_edge8.loopexit

._crit_edge8.loopexit:                            ; preds = %878, %.lr.ph7
  %.017.lcssa.ph = phi %struct.ST_info* [ %884, %.lr.ph7 ], [ %.01758, %878 ]
  %.016.lcssa.ph = phi %struct.ST_info* [ %.017586, %.lr.ph7 ], [ %.017586, %878 ]
  br label %._crit_edge8

._crit_edge8:                                     ; preds = %._crit_edge8.loopexit, %869, %.lr.ph61
  %.017.lcssa = phi %struct.ST_info* [ %871, %.lr.ph61 ], [ %871, %869 ], [ %.017.lcssa.ph, %._crit_edge8.loopexit ]
  %.016.lcssa = phi %struct.ST_info* [ null, %.lr.ph61 ], [ null, %869 ], [ %.016.lcssa.ph, %._crit_edge8.loopexit ]
  %886 = icmp eq %struct.ST_info* %.017.lcssa, null
  br i1 %886, label %887, label %906

; <label>:887:                                    ; preds = %._crit_edge8
  %888 = call noalias i8* @malloc(i64 384) #9, !track !99
  %889 = bitcast i8* %888 to %struct.ST_info*
  %890 = icmp ne %struct.ST_info* %889, null
  br i1 %890, label %893, label %891

; <label>:891:                                    ; preds = %887
  %892 = getelementptr [14 x i8], [14 x i8]* @.str.7, i32 0, i32 0
  call void @perror(i8* %892)
  br label %._crit_edge87

; <label>:893:                                    ; preds = %887
  %894 = bitcast %struct.ST_info* %889 to i8*
  call void @llvm.memset.p0i8.i64(i8* align 8 %894, i8 0, i64 384, i1 false)
  %895 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.214, i32 0, i32 13
  %896 = load %struct.ST_info*, %struct.ST_info** %895, align 8
  %897 = icmp eq %struct.ST_info* %896, null
  br i1 %897, label %898, label %900

; <label>:898:                                    ; preds = %893
  %899 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.214, i32 0, i32 13
  store %struct.ST_info* %889, %struct.ST_info** %899, align 8
  br label %902

; <label>:900:                                    ; preds = %893
  %901 = getelementptr inbounds %struct.ST_info, %struct.ST_info* %.016.lcssa, i32 0, i32 1
  store %struct.ST_info* %889, %struct.ST_info** %901, align 8
  br label %902

; <label>:902:                                    ; preds = %900, %898
  %903 = getelementptr inbounds %struct.ST_info, %struct.ST_info* %889, i32 0, i32 3
  %904 = getelementptr inbounds [6 x i8], [6 x i8]* %903, i32 0, i32 0
  %905 = getelementptr inbounds [6 x i8], [6 x i8]* %6, i32 0, i32 0
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %904, i8* align 1 %905, i64 6, i1 false), !track !100
  br label %906

; <label>:906:                                    ; preds = %._crit_edge8, %902, %849, %860
  %.219 = phi %struct.ST_info* [ null, %860 ], [ null, %849 ], [ %889, %902 ], [ %.017.lcssa, %._crit_edge8 ]
  %907 = getelementptr inbounds i8, i8* %.5, i64 0
  %908 = load i8, i8* %907, align 1
  %909 = zext i8 %908 to i32
  %910 = icmp eq i32 %909, 128
  br i1 %910, label %916, label %911

; <label>:911:                                    ; preds = %906
  %912 = getelementptr inbounds i8, i8* %.5, i64 0
  %913 = load i8, i8* %912, align 1
  %914 = zext i8 %913 to i32
  %915 = icmp eq i32 %914, 80
  br i1 %915, label %916, label %.loopexit29

; <label>:916:                                    ; preds = %911, %906
  %917 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.214, i32 0, i32 10
  %918 = load i32, i32* %917, align 8
  %919 = icmp slt i32 %918, 0
  br i1 %919, label %920, label %927

; <label>:920:                                    ; preds = %916
  %921 = getelementptr inbounds i8, i8* %.5, i64 34
  %922 = load i8, i8* %921, align 1
  %923 = zext i8 %922 to i32
  %924 = and i32 %923, 16
  %925 = ashr i32 %924, 4
  %926 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.214, i32 0, i32 10
  store i32 %925, i32* %926, align 8
  br label %927

; <label>:927:                                    ; preds = %920, %916
  %928 = getelementptr inbounds i8, i8* %.5, i64 36
  %929 = getelementptr inbounds %struct.pcap_pkthdr, %struct.pcap_pkthdr* %10, i32 0, i32 2
  %930 = load i32, i32* %929, align 4
  %931 = zext i32 %930 to i64
  %932 = getelementptr inbounds i8, i8* %.5, i64 %931
  %933 = icmp ult i8* %928, %932
  br i1 %933, label %.lr.ph66.preheader, label %.loopexit29

.lr.ph66.preheader:                               ; preds = %927
  br label %.lr.ph66

.lr.ph66:                                         ; preds = %.lr.ph66.preheader, %976
  %.0964 = phi i8* [ %982, %976 ], [ %928, %.lr.ph66.preheader ]
  call void @unroll_loop(i32 41)
  %934 = getelementptr inbounds i8, i8* %.0964, i64 2
  %935 = getelementptr inbounds i8, i8* %.0964, i64 1
  %936 = load i8, i8* %935, align 1
  %937 = zext i8 %936 to i32
  %938 = sext i32 %937 to i64
  %939 = getelementptr inbounds i8, i8* %934, i64 %938
  %940 = getelementptr inbounds %struct.pcap_pkthdr, %struct.pcap_pkthdr* %10, i32 0, i32 2
  %941 = load i32, i32* %940, align 4
  %942 = zext i32 %941 to i64
  %943 = getelementptr inbounds i8, i8* %.5, i64 %942
  %944 = icmp ugt i8* %939, %943
  br i1 %944, label %.loopexit29.loopexit, label %945

; <label>:945:                                    ; preds = %.lr.ph66
  %946 = load i8, i8* %.0964, align 1
  %947 = zext i8 %946 to i32
  %948 = icmp eq i32 %947, 0
  br i1 %948, label %949, label %976

; <label>:949:                                    ; preds = %945
  %950 = getelementptr inbounds i8, i8* %.0964, i64 1
  %951 = load i8, i8* %950, align 1
  %952 = zext i8 %951 to i32
  %953 = icmp sgt i32 %952, 0
  br i1 %953, label %954, label %976

; <label>:954:                                    ; preds = %949
  %955 = getelementptr inbounds i8, i8* %.0964, i64 2
  %956 = load i8, i8* %955, align 1
  %957 = zext i8 %956 to i32
  %958 = icmp ne i32 %957, 0
  br i1 %958, label %959, label %976

; <label>:959:                                    ; preds = %954
  %960 = getelementptr inbounds i8, i8* %.0964, i64 1
  %961 = load i8, i8* %960, align 1
  %962 = zext i8 %961 to i32
  %963 = icmp sgt i32 %962, 32
  br i1 %963, label %968, label %964

; <label>:964:                                    ; preds = %959
  %965 = getelementptr inbounds i8, i8* %.0964, i64 1
  %966 = load i8, i8* %965, align 1
  %967 = zext i8 %966 to i32
  br label %968

; <label>:968:                                    ; preds = %959, %964
  %969 = phi i32 [ %967, %964 ], [ 32, %959 ]
  %970 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.214, i32 0, i32 2
  %971 = getelementptr inbounds [33 x i8], [33 x i8]* %970, i32 0, i32 0
  call void @llvm.memset.p0i8.i64(i8* align 2 %971, i8 0, i64 33, i1 false)
  %972 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.214, i32 0, i32 2
  %973 = getelementptr inbounds [33 x i8], [33 x i8]* %972, i32 0, i32 0
  %974 = getelementptr inbounds i8, i8* %.0964, i64 2
  %975 = sext i32 %969 to i64
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 2 %973, i8* align 1 %974, i64 %975, i1 false), !track !101
  br label %976

; <label>:976:                                    ; preds = %968, %954, %949, %945
  %977 = getelementptr inbounds i8, i8* %.0964, i64 1
  %978 = load i8, i8* %977, align 1
  %979 = zext i8 %978 to i32
  %980 = add nsw i32 2, %979
  %981 = sext i32 %980 to i64
  %982 = getelementptr inbounds i8, i8* %.0964, i64 %981
  %983 = load i32, i32* %929, align 4
  %984 = zext i32 %983 to i64
  %985 = getelementptr inbounds i8, i8* %.5, i64 %984
  %986 = icmp ult i8* %982, %985
  br i1 %986, label %.lr.ph66, label %.loopexit29.loopexit

.loopexit29.loopexit:                             ; preds = %976, %.lr.ph66
  br label %.loopexit29

.loopexit29:                                      ; preds = %.loopexit29.loopexit, %927, %911
  %987 = getelementptr inbounds i8, i8* %.5, i64 0
  %988 = load i8, i8* %987, align 1
  %989 = zext i8 %988 to i32
  %990 = icmp eq i32 %989, 0
  br i1 %990, label %991, label %.loopexit

; <label>:991:                                    ; preds = %.loopexit29
  %992 = getelementptr inbounds i8, i8* %.5, i64 28
  %993 = getelementptr inbounds %struct.pcap_pkthdr, %struct.pcap_pkthdr* %10, i32 0, i32 2
  %994 = load i32, i32* %993, align 4
  %995 = zext i32 %994 to i64
  %996 = getelementptr inbounds i8, i8* %.5, i64 %995
  %997 = icmp ult i8* %992, %996
  br i1 %997, label %.lr.ph69.preheader, label %.loopexit

.lr.ph69.preheader:                               ; preds = %991
  br label %.lr.ph69

.lr.ph69:                                         ; preds = %.lr.ph69.preheader, %1040
  %.11067 = phi i8* [ %1046, %1040 ], [ %992, %.lr.ph69.preheader ]
  call void @unroll_loop(i32 42)
  %998 = getelementptr inbounds i8, i8* %.11067, i64 2
  %999 = getelementptr inbounds i8, i8* %.11067, i64 1
  %1000 = load i8, i8* %999, align 1
  %1001 = zext i8 %1000 to i32
  %1002 = sext i32 %1001 to i64
  %1003 = getelementptr inbounds i8, i8* %998, i64 %1002
  %1004 = getelementptr inbounds %struct.pcap_pkthdr, %struct.pcap_pkthdr* %10, i32 0, i32 2
  %1005 = load i32, i32* %1004, align 4
  %1006 = zext i32 %1005 to i64
  %1007 = getelementptr inbounds i8, i8* %.5, i64 %1006
  %1008 = icmp ugt i8* %1003, %1007
  br i1 %1008, label %.loopexit.loopexit, label %1009

; <label>:1009:                                   ; preds = %.lr.ph69
  %1010 = load i8, i8* %.11067, align 1
  %1011 = zext i8 %1010 to i32
  %1012 = icmp eq i32 %1011, 0
  br i1 %1012, label %1013, label %1040

; <label>:1013:                                   ; preds = %1009
  %1014 = getelementptr inbounds i8, i8* %.11067, i64 1
  %1015 = load i8, i8* %1014, align 1
  %1016 = zext i8 %1015 to i32
  %1017 = icmp sgt i32 %1016, 0
  br i1 %1017, label %1018, label %1040

; <label>:1018:                                   ; preds = %1013
  %1019 = getelementptr inbounds i8, i8* %.11067, i64 2
  %1020 = load i8, i8* %1019, align 1
  %1021 = zext i8 %1020 to i32
  %1022 = icmp ne i32 %1021, 0
  br i1 %1022, label %1023, label %1040

; <label>:1023:                                   ; preds = %1018
  %1024 = getelementptr inbounds i8, i8* %.11067, i64 1
  %1025 = load i8, i8* %1024, align 1
  %1026 = zext i8 %1025 to i32
  %1027 = icmp sgt i32 %1026, 32
  br i1 %1027, label %1032, label %1028

; <label>:1028:                                   ; preds = %1023
  %1029 = getelementptr inbounds i8, i8* %.11067, i64 1
  %1030 = load i8, i8* %1029, align 1
  %1031 = zext i8 %1030 to i32
  br label %1032

; <label>:1032:                                   ; preds = %1023, %1028
  %1033 = phi i32 [ %1031, %1028 ], [ 32, %1023 ]
  %1034 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.214, i32 0, i32 2
  %1035 = getelementptr inbounds [33 x i8], [33 x i8]* %1034, i32 0, i32 0
  call void @llvm.memset.p0i8.i64(i8* align 2 %1035, i8 0, i64 33, i1 false)
  %1036 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.214, i32 0, i32 2
  %1037 = getelementptr inbounds [33 x i8], [33 x i8]* %1036, i32 0, i32 0
  %1038 = getelementptr inbounds i8, i8* %.11067, i64 2
  %1039 = sext i32 %1033 to i64
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 2 %1037, i8* align 1 %1038, i64 %1039, i1 false), !track !102
  br label %1040

; <label>:1040:                                   ; preds = %1032, %1018, %1013, %1009
  %1041 = getelementptr inbounds i8, i8* %.11067, i64 1
  %1042 = load i8, i8* %1041, align 1
  %1043 = zext i8 %1042 to i32
  %1044 = add nsw i32 2, %1043
  %1045 = sext i32 %1044 to i64
  %1046 = getelementptr inbounds i8, i8* %.11067, i64 %1045
  %1047 = load i32, i32* %993, align 4
  %1048 = zext i32 %1047 to i64
  %1049 = getelementptr inbounds i8, i8* %.5, i64 %1048
  %1050 = icmp ult i8* %1046, %1049
  br i1 %1050, label %.lr.ph69, label %.loopexit.loopexit

.loopexit.loopexit:                               ; preds = %1040, %.lr.ph69
  br label %.loopexit

.loopexit:                                        ; preds = %.loopexit.loopexit, %991, %.loopexit29
  %1051 = getelementptr inbounds i8, i8* %.5, i64 0
  %1052 = load i8, i8* %1051, align 1
  %1053 = zext i8 %1052 to i32
  %1054 = icmp eq i32 %1053, 16
  %1055 = icmp ne %struct.ST_info* %.219, null
  %or.cond = and i1 %1054, %1055
  br i1 %or.cond, label %1056, label %1059

; <label>:1056:                                   ; preds = %.loopexit
  %1057 = getelementptr inbounds %struct.ST_info, %struct.ST_info* %.219, i32 0, i32 2
  %1058 = getelementptr inbounds %struct.WPA_hdsk, %struct.WPA_hdsk* %1057, i32 0, i32 7
  store i32 0, i32* %1058, align 8
  br label %1059

; <label>:1059:                                   ; preds = %1056, %.loopexit
  %1060 = getelementptr inbounds i8, i8* %.5, i64 0
  %1061 = load i8, i8* %1060, align 1
  %1062 = zext i8 %1061 to i32
  %1063 = and i32 %1062, 12
  %1064 = icmp ne i32 %1063, 8
  br i1 %1064, label %1619, label %1065

; <label>:1065:                                   ; preds = %1059
  %1066 = getelementptr inbounds i8, i8* %.5, i64 1
  %1067 = load i8, i8* %1066, align 1
  %1068 = zext i8 %1067 to i32
  %1069 = and i32 %1068, 3
  %1070 = icmp ne i32 %1069, 3
  %1071 = zext i1 %1070 to i64
  %1072 = select i1 %1070, i32 24, i32 30
  %1073 = getelementptr inbounds i8, i8* %.5, i64 0
  %1074 = load i8, i8* %1073, align 1
  %1075 = zext i8 %1074 to i32
  %1076 = and i32 %1075, 128
  %1077 = icmp eq i32 %1076, 128
  %1078 = add nsw i32 %1072, 2
  %spec.select1 = select i1 %1077, i32 %1078, i32 %1072
  %1079 = add nsw i32 %spec.select1, 16
  %1080 = getelementptr inbounds %struct.pcap_pkthdr, %struct.pcap_pkthdr* %10, i32 0, i32 2
  %1081 = load i32, i32* %1080, align 4
  %1082 = icmp sgt i32 %1079, %1081
  br i1 %1082, label %1619, label %1083

; <label>:1083:                                   ; preds = %1065
  %1084 = sext i32 %spec.select1 to i64
  %1085 = getelementptr inbounds i8, i8* %.5, i64 %1084
  %1086 = load i8, i8* %1085, align 1
  %1087 = zext i8 %1086 to i32
  %1088 = add nsw i32 %spec.select1, 1
  %1089 = sext i32 %1088 to i64
  %1090 = getelementptr inbounds i8, i8* %.5, i64 %1089
  %1091 = load i8, i8* %1090, align 1
  %1092 = zext i8 %1091 to i32
  %1093 = icmp ne i32 %1087, %1092
  br i1 %1093, label %1101, label %1094

; <label>:1094:                                   ; preds = %1083
  %1095 = add nsw i32 %spec.select1, 2
  %1096 = sext i32 %1095 to i64
  %1097 = getelementptr inbounds i8, i8* %.5, i64 %1096
  %1098 = load i8, i8* %1097, align 1
  %1099 = zext i8 %1098 to i32
  %1100 = icmp ne i32 %1099, 3
  br i1 %1100, label %1101, label %1234

; <label>:1101:                                   ; preds = %1094, %1083
  %1102 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.214, i32 0, i32 10
  store i32 2, i32* %1102, align 8
  %1103 = add nsw i32 %spec.select1, 3
  %1104 = sext i32 %1103 to i64
  %1105 = getelementptr inbounds i8, i8* %.5, i64 %1104
  %1106 = load i8, i8* %1105, align 1
  %1107 = zext i8 %1106 to i32
  %1108 = and i32 %1107, 32
  %1109 = icmp ne i32 %1108, 0
  br i1 %1109, label %1110, label %1112

; <label>:1110:                                   ; preds = %1101
  %1111 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.214, i32 0, i32 10
  store i32 3, i32* %1111, align 8
  br label %1112

; <label>:1112:                                   ; preds = %1110, %1101
  %1113 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 11
  %1114 = load i32, i32* %1113, align 8
  %1115 = icmp ne i32 %1114, 0
  br i1 %1115, label %1116, label %1127

; <label>:1116:                                   ; preds = %1112
  %1117 = add nsw i32 %spec.select1, 3
  %1118 = sext i32 %1117 to i64
  %1119 = getelementptr inbounds i8, i8* %.5, i64 %1118
  %1120 = load i8, i8* %1119, align 1
  %1121 = zext i8 %1120 to i32
  %1122 = ashr i32 %1121, 6
  %1123 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 11
  %1124 = load i32, i32* %1123, align 8
  %1125 = sub nsw i32 %1124, 1
  %1126 = icmp ne i32 %1122, %1125
  br i1 %1126, label %1619, label %1127

; <label>:1127:                                   ; preds = %1116, %1112
  %1128 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 20
  %1129 = load i32, i32* %1128, align 4
  %1130 = icmp ne i32 %1129, 0
  %1131 = sext i32 %spec.select1 to i64
  %1132 = getelementptr inbounds i8, i8* %.5, i64 %1131
  br i1 %1130, label %1133, label %1205

; <label>:1133:                                   ; preds = %1127
  %1134 = getelementptr inbounds %struct.pcap_pkthdr, %struct.pcap_pkthdr* %10, i32 0, i32 2
  %1135 = load i32, i32* %1134, align 4
  %1136 = zext i32 %1135 to i64
  %1137 = ptrtoint i8* %1132 to i64
  %1138 = ptrtoint i8* %.5 to i64
  %1139 = sub i64 %1137, %1138
  %1140 = sub nsw i64 %1136, %1139
  %1141 = sub nsw i64 %1140, 4
  %1142 = sub nsw i64 %1141, 4
  %1143 = trunc i64 %1142 to i32
  %1144 = getelementptr inbounds i8, i8* %.5, i64 1
  %1145 = load i8, i8* %1144, align 1
  %1146 = zext i8 %1145 to i32
  %1147 = and i32 %1146, 3
  %1148 = icmp eq i32 %1147, 3
  %1149 = getelementptr inbounds i8, i8* %1132, i64 6
  %1150 = sub nsw i32 %1143, 6
  %.022 = select i1 %1148, i8* %1149, i8* %1132
  %.021 = select i1 %1148, i32 %1150, i32 %1143
  %1151 = getelementptr inbounds [16 x i32], [16 x i32]* %14, i32 0, i32 0
  %1152 = bitcast i32* %1151 to i8*
  call void @llvm.memset.p0i8.i64(i8* align 16 %1152, i8 0, i64 64, i1 false)
  %1153 = getelementptr inbounds [2048 x i8], [2048 x i8]* %12, i32 0, i32 0
  call void @llvm.memset.p0i8.i64(i8* align 16 %1153, i8 0, i64 2048, i1 false)
  %1154 = getelementptr inbounds [2048 x i8], [2048 x i8]* %12, i32 0, i32 0
  %1155 = getelementptr inbounds [16 x i32], [16 x i32]* %14, i32 0, i32 0
  %1156 = call i32 @known_clear(i8* %1154, i32* %13, i32* %1155, i8* %.5, i32 %.021)
  %1157 = load i32, i32* %13, align 4
  %1158 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 10
  %1159 = load i32, i32* %1158, align 4
  %1160 = add nsw i32 %1159, 3
  %1161 = icmp slt i32 %1157, %1160
  br i1 %1161, label %1619, label %1162

; <label>:1162:                                   ; preds = %1133
  %1163 = icmp slt i32 0, %1156
  br i1 %1163, label %.lr.ph76, label %._crit_edge77

.lr.ph76:                                         ; preds = %1162
  %1164 = zext i32 %1156 to i64
  br label %1165

; <label>:1165:                                   ; preds = %.lr.ph76, %._crit_edge73
  %indvars.iv78 = phi i64 [ 0, %.lr.ph76 ], [ %indvars.iv.next79, %._crit_edge73 ]
  call void @unroll_loop(i32 43)
  %1166 = load i32, i32* %13, align 4
  %1167 = icmp slt i32 0, %1166
  br i1 %1167, label %.lr.ph72.preheader, label %._crit_edge73

.lr.ph72.preheader:                               ; preds = %1165
  br label %.lr.ph72

.lr.ph72:                                         ; preds = %.lr.ph72.preheader, %.lr.ph72
  %indvars.iv = phi i64 [ %indvars.iv.next, %.lr.ph72 ], [ 0, %.lr.ph72.preheader ]
  call void @unroll_loop(i32 44)
  %1168 = add nuw nsw i64 4, %indvars.iv
  %1169 = getelementptr inbounds i8, i8* %.022, i64 %1168
  %1170 = load i8, i8* %1169, align 1
  %1171 = zext i8 %1170 to i32
  %1172 = mul nuw nsw i64 32, %indvars.iv78
  %1173 = add nuw nsw i64 %indvars.iv, %1172
  %1174 = getelementptr inbounds [2048 x i8], [2048 x i8]* %12, i64 0, i64 %1173
  %1175 = load i8, i8* %1174, align 1
  %1176 = zext i8 %1175 to i32
  %1177 = xor i32 %1176, %1171
  %1178 = trunc i32 %1177 to i8
  store i8 %1178, i8* %1174, align 1
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %1179 = load i32, i32* %13, align 4
  %1180 = sext i32 %1179 to i64
  %1181 = icmp slt i64 %indvars.iv.next, %1180
  br i1 %1181, label %.lr.ph72, label %._crit_edge73.loopexit

._crit_edge73.loopexit:                           ; preds = %.lr.ph72
  br label %._crit_edge73

._crit_edge73:                                    ; preds = %._crit_edge73.loopexit, %1165
  %indvars.iv.next79 = add nuw nsw i64 %indvars.iv78, 1
  %exitcond11 = icmp ne i64 %indvars.iv.next79, %1164
  br i1 %exitcond11, label %1165, label %._crit_edge77.loopexit

._crit_edge77.loopexit:                           ; preds = %._crit_edge73
  br label %._crit_edge77

._crit_edge77:                                    ; preds = %._crit_edge77.loopexit, %1162
  %1182 = icmp eq i32 %1156, 1
  br i1 %1182, label %1183, label %1194

; <label>:1183:                                   ; preds = %._crit_edge77
  %1184 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.214, i32 0, i32 15
  %1185 = load %struct.PTW_attackstate*, %struct.PTW_attackstate** %1184, align 8
  %1186 = getelementptr inbounds [2048 x i8], [2048 x i8]* %12, i32 0, i32 0
  %1187 = getelementptr inbounds [16 x i32], [16 x i32]* %14, i32 0, i32 0
  %1188 = call i32 @PTW_addsession(%struct.PTW_attackstate* %1185, i8* %.022, i8* %1186, i32* %1187, i32 %1156)
  %1189 = icmp ne i32 %1188, 0
  br i1 %1189, label %1190, label %1194

; <label>:1190:                                   ; preds = %1183
  %1191 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.214, i32 0, i32 8
  %1192 = load i64, i64* %1191, align 8
  %1193 = add nsw i64 %1192, 1
  store i64 %1193, i64* %1191, align 8
  br label %1194

; <label>:1194:                                   ; preds = %1183, %1190, %._crit_edge77
  %1195 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.214, i32 0, i32 16
  %1196 = load %struct.PTW_attackstate*, %struct.PTW_attackstate** %1195, align 8
  %1197 = getelementptr inbounds [2048 x i8], [2048 x i8]* %12, i32 0, i32 0
  %1198 = getelementptr inbounds [16 x i32], [16 x i32]* %14, i32 0, i32 0
  %1199 = call i32 @PTW_addsession(%struct.PTW_attackstate* %1196, i8* %.022, i8* %1197, i32* %1198, i32 %1156)
  %1200 = icmp ne i32 %1199, 0
  br i1 %1200, label %1201, label %1619

; <label>:1201:                                   ; preds = %1194
  %1202 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.214, i32 0, i32 9
  %1203 = load i64, i64* %1202, align 8
  %1204 = add nsw i64 %1203, 1
  store i64 %1204, i64* %1202, align 8
  br label %1619

; <label>:1205:                                   ; preds = %1127
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %18, i8* align 1 %1132, i64 3, i1 false), !track !103
  %1206 = getelementptr inbounds i8, i8* %18, i64 3
  %1207 = sext i32 %spec.select1 to i64
  %1208 = getelementptr inbounds i8, i8* %.5, i64 %1207
  %1209 = getelementptr inbounds i8, i8* %1208, i64 4
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %1206, i8* align 1 %1209, i64 2, i1 false), !track !104
  %1210 = getelementptr inbounds i8, i8* %.5, i64 4
  %1211 = getelementptr [7 x i8], [7 x i8]* @.str.26, i32 0, i32 0
  %1212 = call i32 @memcmp(i8* %1210, i8* %1211, i64 6) #10
  %1213 = icmp eq i32 %1212, 0
  br i1 %1213, label %1219, label %1214

; <label>:1214:                                   ; preds = %1205
  %1215 = getelementptr inbounds i8, i8* %.5, i64 16
  %1216 = getelementptr [7 x i8], [7 x i8]* @.str.26, i32 0, i32 0
  %1217 = call i32 @memcmp(i8* %1215, i8* %1216, i64 6) #10
  %1218 = icmp eq i32 %1217, 0
  br i1 %1218, label %1219, label %562

; <label>:1219:                                   ; preds = %1214, %1205
  %1220 = getelementptr inbounds i8, i8* %18, i64 3
  %1221 = load i8, i8* %1220, align 1
  %1222 = zext i8 %1221 to i32
  %1223 = xor i32 %1222, 66
  %1224 = xor i32 %1223, 170
  %1225 = trunc i32 %1224 to i8
  %1226 = getelementptr inbounds i8, i8* %18, i64 3
  store i8 %1225, i8* %1226, align 1
  %1227 = getelementptr inbounds i8, i8* %18, i64 4
  %1228 = load i8, i8* %1227, align 1
  %1229 = zext i8 %1228 to i32
  %1230 = xor i32 %1229, 66
  %1231 = xor i32 %1230, 170
  %1232 = trunc i32 %1231 to i8
  %1233 = getelementptr inbounds i8, i8* %18, i64 4
  store i8 %1232, i8* %1233, align 1
  br label %562

; <label>:1234:                                   ; preds = %1094
  %1235 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.214, i32 0, i32 10
  %1236 = load i32, i32* %1235, align 8
  %1237 = icmp slt i32 %1236, 0
  br i1 %1237, label %1238, label %1240

; <label>:1238:                                   ; preds = %1234
  %1239 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.214, i32 0, i32 10
  store i32 0, i32* %1239, align 8
  br label %1240

; <label>:1240:                                   ; preds = %1238, %1234
  %1241 = add nsw i32 %spec.select1, 6
  %1242 = add nsw i32 %1241, 20
  %1243 = getelementptr inbounds %struct.pcap_pkthdr, %struct.pcap_pkthdr* %10, i32 0, i32 2
  %1244 = load i32, i32* %1243, align 4
  %1245 = icmp slt i32 %1242, %1244
  br i1 %1245, label %1246, label %1290

; <label>:1246:                                   ; preds = %1240
  %1247 = sext i32 %1241 to i64
  %1248 = getelementptr inbounds i8, i8* %.5, i64 %1247
  %1249 = load i8, i8* %1248, align 1
  %1250 = zext i8 %1249 to i32
  %1251 = icmp eq i32 %1250, 8
  br i1 %1251, label %1252, label %1271

; <label>:1252:                                   ; preds = %1246
  %1253 = add nsw i32 %1241, 1
  %1254 = sext i32 %1253 to i64
  %1255 = getelementptr inbounds i8, i8* %.5, i64 %1254
  %1256 = load i8, i8* %1255, align 1
  %1257 = zext i8 %1256 to i32
  %1258 = icmp eq i32 %1257, 0
  br i1 %1258, label %1259, label %1271

; <label>:1259:                                   ; preds = %1252
  %1260 = getelementptr inbounds i8, i8* %.5, i64 1
  %1261 = load i8, i8* %1260, align 1
  %1262 = zext i8 %1261 to i32
  %1263 = and i32 %1262, 3
  %1264 = icmp eq i32 %1263, 1
  br i1 %1264, label %1265, label %1271

; <label>:1265:                                   ; preds = %1259
  %1266 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.214, i32 0, i32 3
  %1267 = getelementptr inbounds [4 x i8], [4 x i8]* %1266, i32 0, i32 0
  %1268 = add nsw i32 %1241, 14
  %1269 = sext i32 %1268 to i64
  %1270 = getelementptr inbounds i8, i8* %.5, i64 %1269
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %1267, i8* align 1 %1270, i64 4, i1 false), !track !105
  br label %1271

; <label>:1271:                                   ; preds = %1265, %1259, %1252, %1246
  %1272 = sext i32 %1241 to i64
  %1273 = getelementptr inbounds i8, i8* %.5, i64 %1272
  %1274 = load i8, i8* %1273, align 1
  %1275 = zext i8 %1274 to i32
  %1276 = icmp eq i32 %1275, 8
  br i1 %1276, label %1277, label %1290

; <label>:1277:                                   ; preds = %1271
  %1278 = add nsw i32 %1241, 1
  %1279 = sext i32 %1278 to i64
  %1280 = getelementptr inbounds i8, i8* %.5, i64 %1279
  %1281 = load i8, i8* %1280, align 1
  %1282 = zext i8 %1281 to i32
  %1283 = icmp eq i32 %1282, 6
  br i1 %1283, label %1284, label %1290

; <label>:1284:                                   ; preds = %1277
  %1285 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.214, i32 0, i32 3
  %1286 = getelementptr inbounds [4 x i8], [4 x i8]* %1285, i32 0, i32 0
  %1287 = add nsw i32 %1241, 16
  %1288 = sext i32 %1287 to i64
  %1289 = getelementptr inbounds i8, i8* %.5, i64 %1288
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %1286, i8* align 1 %1289, i64 4, i1 false), !track !106
  br label %1290

; <label>:1290:                                   ; preds = %1271, %1277, %1284, %1240
  %1291 = sext i32 %1241 to i64
  %1292 = getelementptr inbounds i8, i8* %.5, i64 %1291
  %1293 = load i8, i8* %1292, align 1
  %1294 = zext i8 %1293 to i32
  %1295 = icmp ne i32 %1294, 136
  br i1 %1295, label %1619, label %1296

; <label>:1296:                                   ; preds = %1290
  %1297 = add nsw i32 %1241, 1
  %1298 = sext i32 %1297 to i64
  %1299 = getelementptr inbounds i8, i8* %.5, i64 %1298
  %1300 = load i8, i8* %1299, align 1
  %1301 = zext i8 %1300 to i32
  %1302 = icmp ne i32 %1301, 142
  br i1 %1302, label %1619, label %1303

; <label>:1303:                                   ; preds = %1296
  %1304 = add nsw i32 %1241, 2
  %1305 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.214, i32 0, i32 11
  store i32 1, i32* %1305, align 4
  %1306 = add nsw i32 %1304, 1
  %1307 = sext i32 %1306 to i64
  %1308 = getelementptr inbounds i8, i8* %.5, i64 %1307
  %1309 = load i8, i8* %1308, align 1
  %1310 = zext i8 %1309 to i32
  %1311 = icmp ne i32 %1310, 3
  br i1 %1311, label %1619, label %1312

; <label>:1312:                                   ; preds = %1303
  %1313 = add nsw i32 %1304, 4
  %1314 = sext i32 %1313 to i64
  %1315 = getelementptr inbounds i8, i8* %.5, i64 %1314
  %1316 = load i8, i8* %1315, align 1
  %1317 = zext i8 %1316 to i32
  %1318 = icmp ne i32 %1317, 254
  br i1 %1318, label %1319, label %1326

; <label>:1319:                                   ; preds = %1312
  %1320 = add nsw i32 %1304, 4
  %1321 = sext i32 %1320 to i64
  %1322 = getelementptr inbounds i8, i8* %.5, i64 %1321
  %1323 = load i8, i8* %1322, align 1
  %1324 = zext i8 %1323 to i32
  %1325 = icmp ne i32 %1324, 2
  br i1 %1325, label %1619, label %1326

; <label>:1326:                                   ; preds = %1319, %1312
  %1327 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.214, i32 0, i32 11
  store i32 0, i32* %1327, align 4
  %1328 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.214, i32 0, i32 10
  store i32 3, i32* %1328, align 8
  %1329 = icmp eq %struct.ST_info* %.219, null
  br i1 %1329, label %1330, label %1332

; <label>:1330:                                   ; preds = %1326
  %1331 = call i32 @pthread_mutex_unlock(%union.pthread_mutex_t* @mx_apl) #9
  br label %.backedge

; <label>:1332:                                   ; preds = %1326
  %1333 = add nsw i32 %1304, 6
  %1334 = sext i32 %1333 to i64
  %1335 = getelementptr inbounds i8, i8* %.5, i64 %1334
  %1336 = load i8, i8* %1335, align 1
  %1337 = zext i8 %1336 to i32
  %1338 = and i32 %1337, 8
  %1339 = icmp ne i32 %1338, 0
  br i1 %1339, label %1340, label %1373

; <label>:1340:                                   ; preds = %1332
  %1341 = add nsw i32 %1304, 6
  %1342 = sext i32 %1341 to i64
  %1343 = getelementptr inbounds i8, i8* %.5, i64 %1342
  %1344 = load i8, i8* %1343, align 1
  %1345 = zext i8 %1344 to i32
  %1346 = and i32 %1345, 64
  %1347 = icmp eq i32 %1346, 0
  br i1 %1347, label %1348, label %1373

; <label>:1348:                                   ; preds = %1340
  %1349 = add nsw i32 %1304, 6
  %1350 = sext i32 %1349 to i64
  %1351 = getelementptr inbounds i8, i8* %.5, i64 %1350
  %1352 = load i8, i8* %1351, align 1
  %1353 = zext i8 %1352 to i32
  %1354 = and i32 %1353, 128
  %1355 = icmp ne i32 %1354, 0
  br i1 %1355, label %1356, label %1373

; <label>:1356:                                   ; preds = %1348
  %1357 = add nsw i32 %1304, 5
  %1358 = sext i32 %1357 to i64
  %1359 = getelementptr inbounds i8, i8* %.5, i64 %1358
  %1360 = load i8, i8* %1359, align 1
  %1361 = zext i8 %1360 to i32
  %1362 = and i32 %1361, 1
  %1363 = icmp eq i32 %1362, 0
  br i1 %1363, label %1364, label %1373

; <label>:1364:                                   ; preds = %1356
  %1365 = getelementptr inbounds %struct.ST_info, %struct.ST_info* %.219, i32 0, i32 2
  %1366 = getelementptr inbounds %struct.WPA_hdsk, %struct.WPA_hdsk* %1365, i32 0, i32 2
  %1367 = getelementptr inbounds [32 x i8], [32 x i8]* %1366, i32 0, i32 0
  %1368 = add nsw i32 %1304, 17
  %1369 = sext i32 %1368 to i64
  %1370 = getelementptr inbounds i8, i8* %.5, i64 %1369
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 2 %1367, i8* align 1 %1370, i64 32, i1 false), !track !107
  %1371 = getelementptr inbounds %struct.ST_info, %struct.ST_info* %.219, i32 0, i32 2
  %1372 = getelementptr inbounds %struct.WPA_hdsk, %struct.WPA_hdsk* %1371, i32 0, i32 7
  store i32 1, i32* %1372, align 8
  br label %1373

; <label>:1373:                                   ; preds = %1364, %1356, %1348, %1340, %1332
  %1374 = add nsw i32 %1304, 6
  %1375 = sext i32 %1374 to i64
  %1376 = getelementptr inbounds i8, i8* %.5, i64 %1375
  %1377 = load i8, i8* %1376, align 1
  %1378 = zext i8 %1377 to i32
  %1379 = and i32 %1378, 8
  %1380 = icmp ne i32 %1379, 0
  br i1 %1380, label %1381, label %1489

; <label>:1381:                                   ; preds = %1373
  %1382 = add nsw i32 %1304, 6
  %1383 = sext i32 %1382 to i64
  %1384 = getelementptr inbounds i8, i8* %.5, i64 %1383
  %1385 = load i8, i8* %1384, align 1
  %1386 = zext i8 %1385 to i32
  %1387 = and i32 %1386, 64
  %1388 = icmp eq i32 %1387, 0
  br i1 %1388, label %1389, label %1489

; <label>:1389:                                   ; preds = %1381
  %1390 = add nsw i32 %1304, 6
  %1391 = sext i32 %1390 to i64
  %1392 = getelementptr inbounds i8, i8* %.5, i64 %1391
  %1393 = load i8, i8* %1392, align 1
  %1394 = zext i8 %1393 to i32
  %1395 = and i32 %1394, 128
  %1396 = icmp eq i32 %1395, 0
  br i1 %1396, label %1397, label %1489

; <label>:1397:                                   ; preds = %1389
  %1398 = add nsw i32 %1304, 5
  %1399 = sext i32 %1398 to i64
  %1400 = getelementptr inbounds i8, i8* %.5, i64 %1399
  %1401 = load i8, i8* %1400, align 1
  %1402 = zext i8 %1401 to i32
  %1403 = and i32 %1402, 1
  %1404 = icmp ne i32 %1403, 0
  br i1 %1404, label %1405, label %1489

; <label>:1405:                                   ; preds = %1397
  %1406 = add nsw i32 %1304, 17
  %1407 = sext i32 %1406 to i64
  %1408 = getelementptr inbounds i8, i8* %.5, i64 %1407
  %1409 = getelementptr [32 x i8], [32 x i8]* @ZERO, i32 0, i32 0
  %1410 = call i32 @memcmp(i8* %1408, i8* %1409, i64 32) #10
  %1411 = icmp ne i32 %1410, 0
  br i1 %1411, label %1412, label %1423

; <label>:1412:                                   ; preds = %1405
  %1413 = getelementptr inbounds %struct.ST_info, %struct.ST_info* %.219, i32 0, i32 2
  %1414 = getelementptr inbounds %struct.WPA_hdsk, %struct.WPA_hdsk* %1413, i32 0, i32 1
  %1415 = getelementptr inbounds [32 x i8], [32 x i8]* %1414, i32 0, i32 0
  %1416 = add nsw i32 %1304, 17
  %1417 = sext i32 %1416 to i64
  %1418 = getelementptr inbounds i8, i8* %.5, i64 %1417
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 2 %1415, i8* align 1 %1418, i64 32, i1 false), !track !108
  %1419 = getelementptr inbounds %struct.ST_info, %struct.ST_info* %.219, i32 0, i32 2
  %1420 = getelementptr inbounds %struct.WPA_hdsk, %struct.WPA_hdsk* %1419, i32 0, i32 7
  %1421 = load i32, i32* %1420, align 8
  %1422 = or i32 %1421, 2
  store i32 %1422, i32* %1420, align 8
  br label %1423

; <label>:1423:                                   ; preds = %1412, %1405
  %1424 = getelementptr inbounds %struct.ST_info, %struct.ST_info* %.219, i32 0, i32 2
  %1425 = getelementptr inbounds %struct.WPA_hdsk, %struct.WPA_hdsk* %1424, i32 0, i32 7
  %1426 = load i32, i32* %1425, align 8
  %1427 = and i32 %1426, 4
  %1428 = icmp ne i32 %1427, 4
  br i1 %1428, label %1429, label %1489

; <label>:1429:                                   ; preds = %1423
  %1430 = add nsw i32 %1304, 2
  %1431 = sext i32 %1430 to i64
  %1432 = getelementptr inbounds i8, i8* %.5, i64 %1431
  %1433 = load i8, i8* %1432, align 1
  %1434 = zext i8 %1433 to i32
  %1435 = shl i32 %1434, 8
  %1436 = add nsw i32 %1304, 3
  %1437 = sext i32 %1436 to i64
  %1438 = getelementptr inbounds i8, i8* %.5, i64 %1437
  %1439 = load i8, i8* %1438, align 1
  %1440 = zext i8 %1439 to i32
  %1441 = add nsw i32 %1435, %1440
  %1442 = add nsw i32 %1441, 4
  %1443 = getelementptr inbounds %struct.ST_info, %struct.ST_info* %.219, i32 0, i32 2
  %1444 = getelementptr inbounds %struct.WPA_hdsk, %struct.WPA_hdsk* %1443, i32 0, i32 5
  store i32 %1442, i32* %1444, align 8
  %1445 = getelementptr inbounds %struct.pcap_pkthdr, %struct.pcap_pkthdr* %10, i32 0, i32 3
  %1446 = load i32, i32* %1445, align 4
  %1447 = sub nsw i32 %1446, %1304
  %1448 = getelementptr inbounds %struct.ST_info, %struct.ST_info* %.219, i32 0, i32 2
  %1449 = getelementptr inbounds %struct.WPA_hdsk, %struct.WPA_hdsk* %1448, i32 0, i32 5
  %1450 = load i32, i32* %1449, align 8
  %1451 = icmp slt i32 %1447, %1450
  br i1 %1451, label %.backedge, label %1452

; <label>:1452:                                   ; preds = %1429
  %1453 = getelementptr inbounds %struct.ST_info, %struct.ST_info* %.219, i32 0, i32 2
  %1454 = getelementptr inbounds %struct.WPA_hdsk, %struct.WPA_hdsk* %1453, i32 0, i32 5
  %1455 = load i32, i32* %1454, align 8
  %1456 = icmp eq i32 %1455, 0
  br i1 %1456, label %.backedge, label %1457

; <label>:1457:                                   ; preds = %1452
  %1458 = getelementptr inbounds %struct.ST_info, %struct.ST_info* %.219, i32 0, i32 2
  %1459 = getelementptr inbounds %struct.WPA_hdsk, %struct.WPA_hdsk* %1458, i32 0, i32 3
  %1460 = getelementptr inbounds [16 x i8], [16 x i8]* %1459, i32 0, i32 0
  %1461 = add nsw i32 %1304, 81
  %1462 = sext i32 %1461 to i64
  %1463 = getelementptr inbounds i8, i8* %.5, i64 %1462
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 2 %1460, i8* align 1 %1463, i64 16, i1 false), !track !109
  %1464 = getelementptr inbounds %struct.ST_info, %struct.ST_info* %.219, i32 0, i32 2
  %1465 = getelementptr inbounds %struct.WPA_hdsk, %struct.WPA_hdsk* %1464, i32 0, i32 4
  %1466 = getelementptr inbounds [256 x i8], [256 x i8]* %1465, i32 0, i32 0
  %1467 = sext i32 %1304 to i64
  %1468 = getelementptr inbounds i8, i8* %.5, i64 %1467
  %1469 = getelementptr inbounds %struct.ST_info, %struct.ST_info* %.219, i32 0, i32 2
  %1470 = getelementptr inbounds %struct.WPA_hdsk, %struct.WPA_hdsk* %1469, i32 0, i32 5
  %1471 = load i32, i32* %1470, align 8
  %1472 = sext i32 %1471 to i64
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 2 %1466, i8* align 1 %1468, i64 %1472, i1 false), !track !110
  %1473 = getelementptr inbounds %struct.ST_info, %struct.ST_info* %.219, i32 0, i32 2
  %1474 = getelementptr inbounds %struct.WPA_hdsk, %struct.WPA_hdsk* %1473, i32 0, i32 4
  %1475 = getelementptr inbounds [256 x i8], [256 x i8]* %1474, i32 0, i32 0
  %1476 = getelementptr inbounds i8, i8* %1475, i64 81
  call void @llvm.memset.p0i8.i64(i8* align 1 %1476, i8 0, i64 16, i1 false)
  %1477 = getelementptr inbounds %struct.ST_info, %struct.ST_info* %.219, i32 0, i32 2
  %1478 = getelementptr inbounds %struct.WPA_hdsk, %struct.WPA_hdsk* %1477, i32 0, i32 7
  %1479 = load i32, i32* %1478, align 8
  %1480 = or i32 %1479, 4
  store i32 %1480, i32* %1478, align 8
  %1481 = add nsw i32 %1304, 6
  %1482 = sext i32 %1481 to i64
  %1483 = getelementptr inbounds i8, i8* %.5, i64 %1482
  %1484 = load i8, i8* %1483, align 1
  %1485 = zext i8 %1484 to i32
  %1486 = and i32 %1485, 7
  %1487 = getelementptr inbounds %struct.ST_info, %struct.ST_info* %.219, i32 0, i32 2
  %1488 = getelementptr inbounds %struct.WPA_hdsk, %struct.WPA_hdsk* %1487, i32 0, i32 6
  store i32 %1486, i32* %1488, align 4
  br label %1489

; <label>:1489:                                   ; preds = %1423, %1457, %1397, %1389, %1381, %1373
  %1490 = add nsw i32 %1304, 6
  %1491 = sext i32 %1490 to i64
  %1492 = getelementptr inbounds i8, i8* %.5, i64 %1491
  %1493 = load i8, i8* %1492, align 1
  %1494 = zext i8 %1493 to i32
  %1495 = and i32 %1494, 8
  %1496 = icmp ne i32 %1495, 0
  br i1 %1496, label %1497, label %1605

; <label>:1497:                                   ; preds = %1489
  %1498 = add nsw i32 %1304, 6
  %1499 = sext i32 %1498 to i64
  %1500 = getelementptr inbounds i8, i8* %.5, i64 %1499
  %1501 = load i8, i8* %1500, align 1
  %1502 = zext i8 %1501 to i32
  %1503 = and i32 %1502, 64
  %1504 = icmp ne i32 %1503, 0
  br i1 %1504, label %1505, label %1605

; <label>:1505:                                   ; preds = %1497
  %1506 = add nsw i32 %1304, 6
  %1507 = sext i32 %1506 to i64
  %1508 = getelementptr inbounds i8, i8* %.5, i64 %1507
  %1509 = load i8, i8* %1508, align 1
  %1510 = zext i8 %1509 to i32
  %1511 = and i32 %1510, 128
  %1512 = icmp ne i32 %1511, 0
  br i1 %1512, label %1513, label %1605

; <label>:1513:                                   ; preds = %1505
  %1514 = add nsw i32 %1304, 5
  %1515 = sext i32 %1514 to i64
  %1516 = getelementptr inbounds i8, i8* %.5, i64 %1515
  %1517 = load i8, i8* %1516, align 1
  %1518 = zext i8 %1517 to i32
  %1519 = and i32 %1518, 1
  %1520 = icmp ne i32 %1519, 0
  br i1 %1520, label %1521, label %1605

; <label>:1521:                                   ; preds = %1513
  %1522 = add nsw i32 %1304, 17
  %1523 = sext i32 %1522 to i64
  %1524 = getelementptr inbounds i8, i8* %.5, i64 %1523
  %1525 = getelementptr [32 x i8], [32 x i8]* @ZERO, i32 0, i32 0
  %1526 = call i32 @memcmp(i8* %1524, i8* %1525, i64 32) #10
  %1527 = icmp ne i32 %1526, 0
  br i1 %1527, label %1528, label %1539

; <label>:1528:                                   ; preds = %1521
  %1529 = getelementptr inbounds %struct.ST_info, %struct.ST_info* %.219, i32 0, i32 2
  %1530 = getelementptr inbounds %struct.WPA_hdsk, %struct.WPA_hdsk* %1529, i32 0, i32 2
  %1531 = getelementptr inbounds [32 x i8], [32 x i8]* %1530, i32 0, i32 0
  %1532 = add nsw i32 %1304, 17
  %1533 = sext i32 %1532 to i64
  %1534 = getelementptr inbounds i8, i8* %.5, i64 %1533
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 2 %1531, i8* align 1 %1534, i64 32, i1 false), !track !111
  %1535 = getelementptr inbounds %struct.ST_info, %struct.ST_info* %.219, i32 0, i32 2
  %1536 = getelementptr inbounds %struct.WPA_hdsk, %struct.WPA_hdsk* %1535, i32 0, i32 7
  %1537 = load i32, i32* %1536, align 8
  %1538 = or i32 %1537, 1
  store i32 %1538, i32* %1536, align 8
  br label %1539

; <label>:1539:                                   ; preds = %1528, %1521
  %1540 = getelementptr inbounds %struct.ST_info, %struct.ST_info* %.219, i32 0, i32 2
  %1541 = getelementptr inbounds %struct.WPA_hdsk, %struct.WPA_hdsk* %1540, i32 0, i32 7
  %1542 = load i32, i32* %1541, align 8
  %1543 = and i32 %1542, 4
  %1544 = icmp ne i32 %1543, 4
  br i1 %1544, label %1545, label %1605

; <label>:1545:                                   ; preds = %1539
  %1546 = add nsw i32 %1304, 2
  %1547 = sext i32 %1546 to i64
  %1548 = getelementptr inbounds i8, i8* %.5, i64 %1547
  %1549 = load i8, i8* %1548, align 1
  %1550 = zext i8 %1549 to i32
  %1551 = shl i32 %1550, 8
  %1552 = add nsw i32 %1304, 3
  %1553 = sext i32 %1552 to i64
  %1554 = getelementptr inbounds i8, i8* %.5, i64 %1553
  %1555 = load i8, i8* %1554, align 1
  %1556 = zext i8 %1555 to i32
  %1557 = add nsw i32 %1551, %1556
  %1558 = add nsw i32 %1557, 4
  %1559 = getelementptr inbounds %struct.ST_info, %struct.ST_info* %.219, i32 0, i32 2
  %1560 = getelementptr inbounds %struct.WPA_hdsk, %struct.WPA_hdsk* %1559, i32 0, i32 5
  store i32 %1558, i32* %1560, align 8
  %1561 = getelementptr inbounds %struct.pcap_pkthdr, %struct.pcap_pkthdr* %10, i32 0, i32 3
  %1562 = load i32, i32* %1561, align 4
  %1563 = sub nsw i32 %1562, %1304
  %1564 = getelementptr inbounds %struct.ST_info, %struct.ST_info* %.219, i32 0, i32 2
  %1565 = getelementptr inbounds %struct.WPA_hdsk, %struct.WPA_hdsk* %1564, i32 0, i32 5
  %1566 = load i32, i32* %1565, align 8
  %1567 = icmp slt i32 %1563, %1566
  br i1 %1567, label %.backedge, label %1568

; <label>:1568:                                   ; preds = %1545
  %1569 = getelementptr inbounds %struct.ST_info, %struct.ST_info* %.219, i32 0, i32 2
  %1570 = getelementptr inbounds %struct.WPA_hdsk, %struct.WPA_hdsk* %1569, i32 0, i32 5
  %1571 = load i32, i32* %1570, align 8
  %1572 = icmp eq i32 %1571, 0
  br i1 %1572, label %.backedge, label %1573

; <label>:1573:                                   ; preds = %1568
  %1574 = getelementptr inbounds %struct.ST_info, %struct.ST_info* %.219, i32 0, i32 2
  %1575 = getelementptr inbounds %struct.WPA_hdsk, %struct.WPA_hdsk* %1574, i32 0, i32 3
  %1576 = getelementptr inbounds [16 x i8], [16 x i8]* %1575, i32 0, i32 0
  %1577 = add nsw i32 %1304, 81
  %1578 = sext i32 %1577 to i64
  %1579 = getelementptr inbounds i8, i8* %.5, i64 %1578
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 2 %1576, i8* align 1 %1579, i64 16, i1 false), !track !112
  %1580 = getelementptr inbounds %struct.ST_info, %struct.ST_info* %.219, i32 0, i32 2
  %1581 = getelementptr inbounds %struct.WPA_hdsk, %struct.WPA_hdsk* %1580, i32 0, i32 4
  %1582 = getelementptr inbounds [256 x i8], [256 x i8]* %1581, i32 0, i32 0
  %1583 = sext i32 %1304 to i64
  %1584 = getelementptr inbounds i8, i8* %.5, i64 %1583
  %1585 = getelementptr inbounds %struct.ST_info, %struct.ST_info* %.219, i32 0, i32 2
  %1586 = getelementptr inbounds %struct.WPA_hdsk, %struct.WPA_hdsk* %1585, i32 0, i32 5
  %1587 = load i32, i32* %1586, align 8
  %1588 = sext i32 %1587 to i64
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 2 %1582, i8* align 1 %1584, i64 %1588, i1 false), !track !113
  %1589 = getelementptr inbounds %struct.ST_info, %struct.ST_info* %.219, i32 0, i32 2
  %1590 = getelementptr inbounds %struct.WPA_hdsk, %struct.WPA_hdsk* %1589, i32 0, i32 4
  %1591 = getelementptr inbounds [256 x i8], [256 x i8]* %1590, i32 0, i32 0
  %1592 = getelementptr inbounds i8, i8* %1591, i64 81
  call void @llvm.memset.p0i8.i64(i8* align 1 %1592, i8 0, i64 16, i1 false)
  %1593 = getelementptr inbounds %struct.ST_info, %struct.ST_info* %.219, i32 0, i32 2
  %1594 = getelementptr inbounds %struct.WPA_hdsk, %struct.WPA_hdsk* %1593, i32 0, i32 7
  %1595 = load i32, i32* %1594, align 8
  %1596 = or i32 %1595, 4
  store i32 %1596, i32* %1594, align 8
  %1597 = add nsw i32 %1304, 6
  %1598 = sext i32 %1597 to i64
  %1599 = getelementptr inbounds i8, i8* %.5, i64 %1598
  %1600 = load i8, i8* %1599, align 1
  %1601 = zext i8 %1600 to i32
  %1602 = and i32 %1601, 7
  %1603 = getelementptr inbounds %struct.ST_info, %struct.ST_info* %.219, i32 0, i32 2
  %1604 = getelementptr inbounds %struct.WPA_hdsk, %struct.WPA_hdsk* %1603, i32 0, i32 6
  store i32 %1602, i32* %1604, align 4
  br label %1605

; <label>:1605:                                   ; preds = %1539, %1573, %1513, %1505, %1497, %1489
  %1606 = getelementptr inbounds %struct.ST_info, %struct.ST_info* %.219, i32 0, i32 2
  %1607 = getelementptr inbounds %struct.WPA_hdsk, %struct.WPA_hdsk* %1606, i32 0, i32 7
  %1608 = load i32, i32* %1607, align 8
  %1609 = icmp eq i32 %1608, 7
  br i1 %1609, label %1610, label %1619

; <label>:1610:                                   ; preds = %1605
  %1611 = getelementptr inbounds %struct.ST_info, %struct.ST_info* %.219, i32 0, i32 2
  %1612 = getelementptr inbounds %struct.WPA_hdsk, %struct.WPA_hdsk* %1611, i32 0, i32 0
  %1613 = getelementptr inbounds [6 x i8], [6 x i8]* %1612, i32 0, i32 0
  %1614 = getelementptr inbounds [6 x i8], [6 x i8]* %6, i32 0, i32 0
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %1613, i8* align 1 %1614, i64 6, i1 false), !track !114
  %1615 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.214, i32 0, i32 14
  %1616 = bitcast %struct.WPA_hdsk* %1615 to i8*
  %1617 = getelementptr inbounds %struct.ST_info, %struct.ST_info* %.219, i32 0, i32 2
  %1618 = bitcast %struct.WPA_hdsk* %1617 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %1616, i8* align 8 %1618, i64 356, i1 false), !track !115
  br label %1619

; <label>:1619:                                   ; preds = %1605, %1610, %1303, %1319, %1290, %1296, %1194, %1201, %1133, %1116, %1065, %1059, %616, %828, %798, %845, %839, %686, %716, %756, %771, %748, %738, %652, %659, %633, %569, %599, %498, %473, %468, %454, %408, %404
  %.315 = phi %struct.AP_info* [ %.01280, %404 ], [ %.01280, %408 ], [ %.01280, %454 ], [ %.01280, %468 ], [ %.01280, %473 ], [ %.01280, %498 ], [ %.214, %599 ], [ %.214, %569 ], [ %.214, %633 ], [ %.214, %659 ], [ %.214, %652 ], [ %.214, %738 ], [ %.214, %748 ], [ %.214, %771 ], [ %.214, %756 ], [ %.214, %716 ], [ %.214, %686 ], [ %.214, %839 ], [ %.214, %845 ], [ %.214, %798 ], [ %.214, %828 ], [ %.214, %616 ], [ %.214, %1059 ], [ %.214, %1065 ], [ %.214, %1116 ], [ %.214, %1133 ], [ %.214, %1201 ], [ %.214, %1194 ], [ %.214, %1296 ], [ %.214, %1290 ], [ %.214, %1319 ], [ %.214, %1303 ], [ %.214, %1610 ], [ %.214, %1605 ]
  %1620 = call i32 @pthread_mutex_unlock(%union.pthread_mutex_t* @mx_apl) #9
  %1621 = icmp ne %struct.AP_info* %.315, null
  br i1 %1621, label %1622, label %.backedge

; <label>:1622:                                   ; preds = %1619
  %1623 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.315, i32 0, i32 7
  %1624 = load i64, i64* %1623, align 8
  %1625 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 33
  %1626 = load i32, i32* %1625, align 8
  %1627 = sext i32 %1626 to i64
  %1628 = icmp sge i64 %1624, %1627
  br i1 %1628, label %1643, label %1629

; <label>:1629:                                   ; preds = %1622
  %1630 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.315, i32 0, i32 8
  %1631 = load i64, i64* %1630, align 8
  %1632 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 33
  %1633 = load i32, i32* %1632, align 8
  %1634 = sext i32 %1633 to i64
  %1635 = icmp sge i64 %1631, %1634
  br i1 %1635, label %1643, label %1636

; <label>:1636:                                   ; preds = %1629
  %1637 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.315, i32 0, i32 9
  %1638 = load i64, i64* %1637, align 8
  %1639 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 33
  %1640 = load i32, i32* %1639, align 8
  %1641 = sext i32 %1640 to i64
  %1642 = icmp sge i64 %1638, %1641
  br i1 %1642, label %1643, label %.backedge

; <label>:1643:                                   ; preds = %1636, %1629, %1622
  call void @eof_wait(i32* %2)
  br label %1669

.backedge:                                        ; preds = %1619, %1636, %1545, %1568, %1429, %1452, %387, %389, %369, %375, %349, %355, %333, %335, %1330
  %.012.be = phi %struct.AP_info* [ %.214, %1330 ], [ %.01280, %335 ], [ %.01280, %333 ], [ %.01280, %355 ], [ %.01280, %349 ], [ %.01280, %375 ], [ %.01280, %369 ], [ %.01280, %389 ], [ %.01280, %387 ], [ %.214, %1452 ], [ %.214, %1429 ], [ %.214, %1568 ], [ %.214, %1545 ], [ %.315, %1636 ], [ %.315, %1619 ]
  %.06.be = phi i8* [ %.5, %1330 ], [ %18, %335 ], [ %18, %333 ], [ %.17, %355 ], [ %.17, %349 ], [ %.28, %375 ], [ %.28, %369 ], [ %.28, %389 ], [ %.28, %387 ], [ %.5, %1452 ], [ %.5, %1429 ], [ %.5, %1568 ], [ %.5, %1545 ], [ %.5, %1636 ], [ %.5, %1619 ]
  %1644 = load i32, i32* @close_aircrack, align 4
  %1645 = icmp ne i32 %1644, 0
  br i1 %1645, label %._crit_edge87.loopexit, label %.lr.ph86

._crit_edge87.loopexit:                           ; preds = %._crit_edge34, %._crit_edge, %._crit_edge43, %._crit_edge40, %._crit_edge37, %._crit_edge52, %._crit_edge49, %._crit_edge46, %.backedge
  br label %._crit_edge87

._crit_edge87:                                    ; preds = %._crit_edge87.loopexit, %524, %547, %556, %597, %714, %826, %891, %158, %156, %140, %133, %114, %71, %62, %42, %36, %20
  %1646 = getelementptr inbounds %struct.read_buf, %struct.read_buf* %3, i32 0, i32 2
  %1647 = load i8*, i8** %1646, align 8
  %1648 = icmp ne i8* %1647, null
  br i1 %1648, label %1649, label %1653

; <label>:1649:                                   ; preds = %._crit_edge87
  %1650 = getelementptr inbounds %struct.read_buf, %struct.read_buf* %3, i32 0, i32 2
  %1651 = load i8*, i8** %1650, align 8
  call void @free(i8* %1651) #9
  %1652 = getelementptr inbounds %struct.read_buf, %struct.read_buf* %3, i32 0, i32 2
  store i8* null, i8** %1652, align 8
  br label %1653

; <label>:1653:                                   ; preds = %1649, %._crit_edge87
  %1654 = getelementptr inbounds %struct.read_buf, %struct.read_buf* %3, i32 0, i32 3
  %1655 = load i8*, i8** %1654, align 8
  %1656 = icmp ne i8* %1655, null
  br i1 %1656, label %1657, label %1661

; <label>:1657:                                   ; preds = %1653
  %1658 = getelementptr inbounds %struct.read_buf, %struct.read_buf* %3, i32 0, i32 3
  %1659 = load i8*, i8** %1658, align 8
  call void @free(i8* %1659) #9
  %1660 = getelementptr inbounds %struct.read_buf, %struct.read_buf* %3, i32 0, i32 3
  store i8* null, i8** %1660, align 8
  br label %1661

; <label>:1661:                                   ; preds = %1657, %1653
  %1662 = icmp ne i8* %18, null
  br i1 %1662, label %1663, label %1664

; <label>:1663:                                   ; preds = %1661
  call void @free(i8* %18) #9
  br label %1664

; <label>:1664:                                   ; preds = %1663, %1661
  %1665 = load i32, i32* @close_aircrack, align 4
  %1666 = icmp ne i32 %1665, 0
  br i1 %1666, label %1669, label %1667

; <label>:1667:                                   ; preds = %1664
  %1668 = call i32 @kill(i32 0, i32 15) #9
  call void @_exit(i32 1) #12
  unreachable

; <label>:1669:                                   ; preds = %1664, %1643
  ret void
}

; Function Attrs: nounwind readonly
declare dso_local i32 @strcmp(i8*, i8*) #3

declare dso_local i32 @open64(i8*, i32, ...) #1

declare dso_local i32 @fprintf(%struct._IO_FILE*, i8*, ...) #1

; Function Attrs: noreturn
declare dso_local void @errx(i32, i8*, ...) #6

declare dso_local i32 @fcntl(i32, i32, ...) #1

; Function Attrs: nounwind
declare dso_local i8* @realloc(i8*, i64) #2

; Function Attrs: nounwind
declare dso_local i32 @kill(i32, i32) #2

; Function Attrs: noinline nounwind uwtable
define dso_local void @check_thread(i8*) #0 {
  %2 = alloca %struct.read_buf, align 8, !track !116
  %3 = alloca [6 x i8], align 1, !track !117
  %4 = alloca [6 x i8], align 1, !track !118
  %5 = alloca [6 x i8], align 1, !track !119
  %6 = alloca [16 x i32], align 16
  %7 = alloca %struct.ivs2_pkthdr, align 2, !track !120
  %8 = alloca %struct.ivs2_filehdr, align 2, !track !121
  %9 = alloca %struct.pcap_pkthdr, align 4, !track !122
  %10 = alloca %struct.pcap_file_header, align 4, !track !123
  %11 = alloca [2048 x i8], align 16, !track !124
  %12 = alloca i32, align 4
  %13 = bitcast %struct.read_buf* %2 to i8*
  call void @llvm.memset.p0i8.i64(i8* align 8 %13, i8 0, i64 24, i1 false)
  %14 = call noalias i8* @malloc(i64 65536) #9, !track !125
  %15 = icmp eq i8* %14, null
  br i1 %15, label %16, label %18

; <label>:16:                                     ; preds = %1
  %17 = getelementptr [14 x i8], [14 x i8]* @.str.7, i32 0, i32 0
  call void @perror(i8* %17)
  br label %._crit_edge

; <label>:18:                                     ; preds = %1
  %19 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 6
  %20 = load i32, i32* %19, align 8
  %21 = icmp ne i32 %20, 0
  br i1 %21, label %25, label %22

; <label>:22:                                     ; preds = %18
  %23 = getelementptr [12 x i8], [12 x i8]* @.str.9, i32 0, i32 0
  %24 = call i32 (i8*, ...) @printf(i8* %23, i8* %0)
  br label %25

; <label>:25:                                     ; preds = %22, %18
  %26 = getelementptr [2 x i8], [2 x i8]* @.str.10, i32 0, i32 0
  %27 = call i32 @strcmp(i8* %0, i8* %26) #10
  %28 = icmp eq i32 %27, 0
  br i1 %28, label %34, label %29

; <label>:29:                                     ; preds = %25
  %30 = call i32 (i8*, i32, ...) @open64(i8* %0, i32 0)
  %31 = icmp slt i32 %30, 0
  br i1 %31, label %32, label %34

; <label>:32:                                     ; preds = %29
  %33 = getelementptr [12 x i8], [12 x i8]* @.str.11, i32 0, i32 0
  call void @perror(i8* %33)
  br label %._crit_edge

; <label>:34:                                     ; preds = %29, %25
  %.01 = phi i32 [ 0, %25 ], [ %30, %29 ]
  %35 = bitcast %struct.pcap_file_header* %10 to i8*
  %36 = call i32 @atomic_read(%struct.read_buf* %2, i32 %.01, i32 4, i8* %35)
  %37 = icmp ne i32 %36, 0
  br i1 %37, label %40, label %38

; <label>:38:                                     ; preds = %34
  %39 = getelementptr [25 x i8], [25 x i8]* @.str.12, i32 0, i32 0
  call void @perror(i8* %39)
  br label %._crit_edge

; <label>:40:                                     ; preds = %34
  %41 = bitcast %struct.pcap_file_header* %10 to i8*
  %42 = getelementptr [5 x i8], [5 x i8]* @.str.13, i32 0, i32 0
  %43 = call i32 @memcmp(i8* %41, i8* %42, i64 4) #10
  %44 = icmp ne i32 %43, 0
  br i1 %44, label %45, label %114

; <label>:45:                                     ; preds = %40
  %46 = bitcast %struct.pcap_file_header* %10 to i8*
  %47 = getelementptr [5 x i8], [5 x i8]* @.str.14, i32 0, i32 0
  %48 = call i32 @memcmp(i8* %46, i8* %47, i64 4) #10
  %49 = icmp ne i32 %48, 0
  br i1 %49, label %50, label %114

; <label>:50:                                     ; preds = %45
  %51 = getelementptr inbounds %struct.pcap_file_header, %struct.pcap_file_header* %10, i32 0, i32 0
  %52 = load i32, i32* %51, align 4
  %53 = icmp ne i32 %52, -1582119980
  br i1 %53, label %54, label %62

; <label>:54:                                     ; preds = %50
  %55 = getelementptr inbounds %struct.pcap_file_header, %struct.pcap_file_header* %10, i32 0, i32 0
  %56 = load i32, i32* %55, align 4
  %57 = icmp ne i32 %56, -725372255
  br i1 %57, label %58, label %62

; <label>:58:                                     ; preds = %54
  %59 = load %struct._IO_FILE*, %struct._IO_FILE** @stderr, align 8
  %60 = getelementptr [51 x i8], [51 x i8]* @.str.15, i32 0, i32 0
  %61 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %59, i8* %60)
  br label %._crit_edge

; <label>:62:                                     ; preds = %54, %50
  %63 = bitcast %struct.pcap_file_header* %10 to i8*
  %64 = getelementptr inbounds i8, i8* %63, i64 4
  %65 = call i32 @atomic_read(%struct.read_buf* %2, i32 %.01, i32 20, i8* %64)
  %66 = icmp ne i32 %65, 0
  br i1 %66, label %69, label %67

; <label>:67:                                     ; preds = %62
  %68 = getelementptr [25 x i8], [25 x i8]* @.str.12, i32 0, i32 0
  call void @perror(i8* %68)
  br label %._crit_edge

; <label>:69:                                     ; preds = %62
  %70 = getelementptr inbounds %struct.pcap_file_header, %struct.pcap_file_header* %10, i32 0, i32 0
  %71 = load i32, i32* %70, align 4
  %72 = icmp eq i32 %71, -725372255
  br i1 %72, label %73, label %94

; <label>:73:                                     ; preds = %69
  %74 = getelementptr inbounds %struct.pcap_file_header, %struct.pcap_file_header* %10, i32 0, i32 6
  %75 = load i32, i32* %74, align 4
  %76 = lshr i32 %75, 24
  %77 = and i32 %76, 255
  %78 = getelementptr inbounds %struct.pcap_file_header, %struct.pcap_file_header* %10, i32 0, i32 6
  %79 = load i32, i32* %78, align 4
  %80 = lshr i32 %79, 8
  %81 = and i32 %80, 65280
  %82 = or i32 %77, %81
  %83 = getelementptr inbounds %struct.pcap_file_header, %struct.pcap_file_header* %10, i32 0, i32 6
  %84 = load i32, i32* %83, align 4
  %85 = shl i32 %84, 8
  %86 = and i32 %85, 16711680
  %87 = or i32 %82, %86
  %88 = getelementptr inbounds %struct.pcap_file_header, %struct.pcap_file_header* %10, i32 0, i32 6
  %89 = load i32, i32* %88, align 4
  %90 = shl i32 %89, 24
  %91 = and i32 %90, -16777216
  %92 = or i32 %87, %91
  %93 = getelementptr inbounds %struct.pcap_file_header, %struct.pcap_file_header* %10, i32 0, i32 6
  store i32 %92, i32* %93, align 4
  br label %94

; <label>:94:                                     ; preds = %73, %69
  %95 = getelementptr inbounds %struct.pcap_file_header, %struct.pcap_file_header* %10, i32 0, i32 6
  %96 = load i32, i32* %95, align 4
  %97 = icmp ne i32 %96, 105
  br i1 %97, label %98, label %149

; <label>:98:                                     ; preds = %94
  %99 = getelementptr inbounds %struct.pcap_file_header, %struct.pcap_file_header* %10, i32 0, i32 6
  %100 = load i32, i32* %99, align 4
  %101 = icmp ne i32 %100, 119
  br i1 %101, label %102, label %149

; <label>:102:                                    ; preds = %98
  %103 = getelementptr inbounds %struct.pcap_file_header, %struct.pcap_file_header* %10, i32 0, i32 6
  %104 = load i32, i32* %103, align 4
  %105 = icmp ne i32 %104, 127
  br i1 %105, label %106, label %149

; <label>:106:                                    ; preds = %102
  %107 = getelementptr inbounds %struct.pcap_file_header, %struct.pcap_file_header* %10, i32 0, i32 6
  %108 = load i32, i32* %107, align 4
  %109 = icmp ne i32 %108, 192
  br i1 %109, label %110, label %149

; <label>:110:                                    ; preds = %106
  %111 = load %struct._IO_FILE*, %struct._IO_FILE** @stderr, align 8
  %112 = getelementptr [55 x i8], [55 x i8]* @.str.16, i32 0, i32 0
  %113 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %111, i8* %112)
  br label %._crit_edge

; <label>:114:                                    ; preds = %45, %40
  %115 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 38
  %116 = load i32, i32* %115, align 8
  %117 = icmp ne i32 %116, 0
  br i1 %117, label %118, label %120

; <label>:118:                                    ; preds = %114
  %119 = getelementptr [37 x i8], [37 x i8]* @.str.17, i32 0, i32 0
  call void (i32, i8*, ...) @errx(i32 1, i8* %119) #12
  unreachable

; <label>:120:                                    ; preds = %114
  %121 = bitcast %struct.pcap_file_header* %10 to i8*
  %122 = getelementptr [5 x i8], [5 x i8]* @.str.14, i32 0, i32 0
  %123 = call i32 @memcmp(i8* %121, i8* %122, i64 4) #10
  %124 = icmp eq i32 %123, 0
  br i1 %124, label %125, label %143

; <label>:125:                                    ; preds = %120
  %126 = bitcast %struct.ivs2_filehdr* %8 to i8*
  %127 = call i32 @atomic_read(%struct.read_buf* %2, i32 %.01, i32 2, i8* %126)
  %128 = icmp ne i32 %127, 0
  br i1 %128, label %131, label %129

; <label>:129:                                    ; preds = %125
  %130 = getelementptr [25 x i8], [25 x i8]* @.str.12, i32 0, i32 0
  call void @perror(i8* %130)
  br label %._crit_edge

; <label>:131:                                    ; preds = %125
  %132 = getelementptr inbounds %struct.ivs2_filehdr, %struct.ivs2_filehdr* %8, i32 0, i32 0
  %133 = load i16, i16* %132, align 2
  %134 = zext i16 %133 to i32
  %135 = icmp sgt i32 %134, 1
  br i1 %135, label %136, label %149

; <label>:136:                                    ; preds = %131
  %137 = getelementptr inbounds %struct.ivs2_filehdr, %struct.ivs2_filehdr* %8, i32 0, i32 0
  %138 = load i16, i16* %137, align 2
  %139 = zext i16 %138 to i32
  %140 = getelementptr [58 x i8], [58 x i8]* @.str.18, i32 0, i32 0
  %141 = getelementptr [4 x i8], [4 x i8]* @.str.19, i32 0, i32 0
  %142 = call i32 (i8*, ...) @printf(i8* %140, i8* %141, i32 %139, i32 1)
  br label %._crit_edge

; <label>:143:                                    ; preds = %120
  %144 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 20
  %145 = load i32, i32* %144, align 4
  %146 = icmp ne i32 %145, 0
  br i1 %146, label %147, label %149

; <label>:147:                                    ; preds = %143
  %148 = getelementptr [84 x i8], [84 x i8]* @.str.20, i32 0, i32 0
  call void (i32, i8*, ...) @errx(i32 1, i8* %148) #12
  unreachable

; <label>:149:                                    ; preds = %131, %143, %94, %98, %102, %106
  %.15 = phi i32 [ 1, %106 ], [ 1, %102 ], [ 1, %98 ], [ 1, %94 ], [ 3, %131 ], [ 2, %143 ]
  %150 = call i32 (i32, i32, ...) @fcntl(i32 %.01, i32 4, i32 2048)
  %151 = icmp slt i32 %150, 0
  br i1 %151, label %152, label %154

; <label>:152:                                    ; preds = %149
  %153 = getelementptr [25 x i8], [25 x i8]* @.str.21, i32 0, i32 0
  call void @perror(i8* %153)
  br label %._crit_edge

; <label>:154:                                    ; preds = %149
  %155 = load i32, i32* @close_aircrack, align 4
  %156 = icmp ne i32 %155, 0
  br i1 %156, label %._crit_edge, label %.lr.ph44.preheader

.lr.ph44.preheader:                               ; preds = %154
  br label %.lr.ph44

.lr.ph44:                                         ; preds = %.lr.ph44.preheader, %.backedge
  %.0643 = phi i8* [ %.06.be, %.backedge ], [ %14, %.lr.ph44.preheader ]
  %.01239 = phi %struct.AP_info* [ %.012.be, %.backedge ], [ null, %.lr.ph44.preheader ]
  call void @unroll_loop(i32 45)
  switch i32 %.15, label %208 [
    i32 2, label %157
    i32 3, label %179
  ]

; <label>:157:                                    ; preds = %.lr.ph44
  %158 = call i32 @atomic_read(%struct.read_buf* %2, i32 %.01, i32 1, i8* %14)
  %159 = icmp ne i32 %158, 0
  %160 = xor i1 %159, true
  br i1 %160, label %._crit_edge.loopexit, label %161

; <label>:161:                                    ; preds = %157
  %162 = getelementptr inbounds i8, i8* %14, i64 0
  %163 = load i8, i8* %162, align 1
  %164 = zext i8 %163 to i32
  %165 = icmp ne i32 %164, 255
  br i1 %165, label %166, label %175

; <label>:166:                                    ; preds = %161
  %167 = getelementptr inbounds i8, i8* %14, i64 0
  %168 = load i8, i8* %167, align 1
  %169 = getelementptr inbounds [6 x i8], [6 x i8]* %3, i64 0, i64 0
  store i8 %168, i8* %169, align 1
  %170 = getelementptr inbounds [6 x i8], [6 x i8]* %3, i32 0, i32 0
  %171 = getelementptr inbounds i8, i8* %170, i64 1
  %172 = call i32 @atomic_read(%struct.read_buf* %2, i32 %.01, i32 5, i8* %171)
  %173 = icmp ne i32 %172, 0
  %174 = xor i1 %173, true
  br i1 %174, label %._crit_edge.loopexit, label %175

; <label>:175:                                    ; preds = %161, %166
  %176 = call i32 @atomic_read(%struct.read_buf* %2, i32 %.01, i32 5, i8* %14)
  %177 = icmp ne i32 %176, 0
  %178 = xor i1 %177, true
  br i1 %178, label %._crit_edge.loopexit, label %352

; <label>:179:                                    ; preds = %.lr.ph44
  %180 = bitcast %struct.ivs2_pkthdr* %7 to i8*
  %181 = call i32 @atomic_read(%struct.read_buf* %2, i32 %.01, i32 4, i8* %180)
  %182 = icmp ne i32 %181, 0
  %183 = xor i1 %182, true
  br i1 %183, label %._crit_edge.loopexit, label %184

; <label>:184:                                    ; preds = %179
  %185 = getelementptr inbounds %struct.ivs2_pkthdr, %struct.ivs2_pkthdr* %7, i32 0, i32 0
  %186 = load i16, i16* %185, align 2
  %187 = zext i16 %186 to i32
  %188 = and i32 %187, 1
  %189 = icmp ne i32 %188, 0
  br i1 %189, label %190, label %201

; <label>:190:                                    ; preds = %184
  %191 = getelementptr inbounds [6 x i8], [6 x i8]* %3, i32 0, i32 0
  %192 = call i32 @atomic_read(%struct.read_buf* %2, i32 %.01, i32 6, i8* %191)
  %193 = icmp ne i32 %192, 0
  %194 = xor i1 %193, true
  br i1 %194, label %._crit_edge.loopexit, label %195

; <label>:195:                                    ; preds = %190
  %196 = getelementptr inbounds %struct.ivs2_pkthdr, %struct.ivs2_pkthdr* %7, i32 0, i32 1
  %197 = load i16, i16* %196, align 2
  %198 = zext i16 %197 to i32
  %199 = sub nsw i32 %198, 6
  %200 = trunc i32 %199 to i16
  store i16 %200, i16* %196, align 2
  br label %201

; <label>:201:                                    ; preds = %184, %195
  %202 = getelementptr inbounds %struct.ivs2_pkthdr, %struct.ivs2_pkthdr* %7, i32 0, i32 1
  %203 = load i16, i16* %202, align 2
  %204 = zext i16 %203 to i32
  %205 = call i32 @atomic_read(%struct.read_buf* %2, i32 %.01, i32 %204, i8* %14)
  %206 = icmp ne i32 %205, 0
  %207 = xor i1 %206, true
  br i1 %207, label %._crit_edge.loopexit, label %352

; <label>:208:                                    ; preds = %.lr.ph44
  %209 = bitcast %struct.pcap_pkthdr* %9 to i8*
  %210 = call i32 @atomic_read(%struct.read_buf* %2, i32 %.01, i32 16, i8* %209)
  %211 = icmp ne i32 %210, 0
  %212 = xor i1 %211, true
  br i1 %212, label %._crit_edge.loopexit, label %213

; <label>:213:                                    ; preds = %208
  %214 = getelementptr inbounds %struct.pcap_file_header, %struct.pcap_file_header* %10, i32 0, i32 0
  %215 = load i32, i32* %214, align 4
  %216 = icmp eq i32 %215, -725372255
  br i1 %216, label %217, label %238

; <label>:217:                                    ; preds = %213
  %218 = getelementptr inbounds %struct.pcap_pkthdr, %struct.pcap_pkthdr* %9, i32 0, i32 2
  %219 = load i32, i32* %218, align 4
  %220 = lshr i32 %219, 24
  %221 = and i32 %220, 255
  %222 = getelementptr inbounds %struct.pcap_pkthdr, %struct.pcap_pkthdr* %9, i32 0, i32 2
  %223 = load i32, i32* %222, align 4
  %224 = lshr i32 %223, 8
  %225 = and i32 %224, 65280
  %226 = or i32 %221, %225
  %227 = getelementptr inbounds %struct.pcap_pkthdr, %struct.pcap_pkthdr* %9, i32 0, i32 2
  %228 = load i32, i32* %227, align 4
  %229 = shl i32 %228, 8
  %230 = and i32 %229, 16711680
  %231 = or i32 %226, %230
  %232 = getelementptr inbounds %struct.pcap_pkthdr, %struct.pcap_pkthdr* %9, i32 0, i32 2
  %233 = load i32, i32* %232, align 4
  %234 = shl i32 %233, 24
  %235 = and i32 %234, -16777216
  %236 = or i32 %231, %235
  %237 = getelementptr inbounds %struct.pcap_pkthdr, %struct.pcap_pkthdr* %9, i32 0, i32 2
  store i32 %236, i32* %237, align 4
  br label %238

; <label>:238:                                    ; preds = %217, %213
  %239 = getelementptr inbounds %struct.pcap_pkthdr, %struct.pcap_pkthdr* %9, i32 0, i32 2
  %240 = load i32, i32* %239, align 4
  %241 = icmp ule i32 %240, 0
  br i1 %241, label %246, label %242

; <label>:242:                                    ; preds = %238
  %243 = getelementptr inbounds %struct.pcap_pkthdr, %struct.pcap_pkthdr* %9, i32 0, i32 2
  %244 = load i32, i32* %243, align 4
  %245 = icmp ugt i32 %244, 65535
  br i1 %245, label %246, label %252

; <label>:246:                                    ; preds = %242, %238
  %247 = load %struct._IO_FILE*, %struct._IO_FILE** @stderr, align 8
  %248 = getelementptr inbounds %struct.pcap_pkthdr, %struct.pcap_pkthdr* %9, i32 0, i32 2
  %249 = load i32, i32* %248, align 4
  %250 = getelementptr [53 x i8], [53 x i8]* @.str.22, i32 0, i32 0
  %251 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %247, i8* %250, i32 %249)
  br label %._crit_edge

; <label>:252:                                    ; preds = %242
  %253 = getelementptr inbounds %struct.pcap_pkthdr, %struct.pcap_pkthdr* %9, i32 0, i32 2
  %254 = load i32, i32* %253, align 4
  %255 = call i32 @atomic_read(%struct.read_buf* %2, i32 %.01, i32 %254, i8* %14)
  %256 = icmp ne i32 %255, 0
  %257 = xor i1 %256, true
  br i1 %257, label %._crit_edge.loopexit, label %258

; <label>:258:                                    ; preds = %252
  %259 = getelementptr inbounds %struct.pcap_file_header, %struct.pcap_file_header* %10, i32 0, i32 6
  %260 = load i32, i32* %259, align 4
  %261 = icmp eq i32 %260, 119
  br i1 %261, label %262, label %298

; <label>:262:                                    ; preds = %258
  %263 = getelementptr inbounds i8, i8* %14, i64 7
  %264 = load i8, i8* %263, align 1
  %265 = zext i8 %264 to i32
  %266 = icmp eq i32 %265, 64
  br i1 %266, label %286, label %267

; <label>:267:                                    ; preds = %262
  %268 = getelementptr inbounds i8, i8* %14, i64 4
  %269 = bitcast i8* %268 to i32*
  %270 = load i32, i32* %269, align 4
  %271 = getelementptr inbounds %struct.pcap_file_header, %struct.pcap_file_header* %10, i32 0, i32 0
  %272 = load i32, i32* %271, align 4
  %273 = icmp eq i32 %272, -725372255
  br i1 %273, label %274, label %286

; <label>:274:                                    ; preds = %267
  %275 = ashr i32 %270, 24
  %276 = and i32 %275, 255
  %277 = ashr i32 %270, 8
  %278 = and i32 %277, 65280
  %279 = or i32 %276, %278
  %280 = shl i32 %270, 8
  %281 = and i32 %280, 16711680
  %282 = or i32 %279, %281
  %283 = shl i32 %270, 24
  %284 = and i32 %283, -16777216
  %285 = or i32 %282, %284
  br label %286

; <label>:286:                                    ; preds = %267, %274, %262
  %.1 = phi i32 [ 64, %262 ], [ %285, %274 ], [ %270, %267 ]
  %287 = icmp slt i32 %.1, 8
  br i1 %287, label %.backedge, label %288

; <label>:288:                                    ; preds = %286
  %289 = getelementptr inbounds %struct.pcap_pkthdr, %struct.pcap_pkthdr* %9, i32 0, i32 2
  %290 = load i32, i32* %289, align 4
  %291 = icmp sge i32 %.1, %290
  br i1 %291, label %.backedge, label %292

; <label>:292:                                    ; preds = %288
  %293 = sext i32 %.1 to i64
  %294 = getelementptr inbounds i8, i8* %14, i64 %293
  %295 = getelementptr inbounds %struct.pcap_pkthdr, %struct.pcap_pkthdr* %9, i32 0, i32 2
  %296 = load i32, i32* %295, align 4
  %297 = sub i32 %296, %.1
  store i32 %297, i32* %295, align 4
  br label %298

; <label>:298:                                    ; preds = %292, %258
  %.17 = phi i8* [ %294, %292 ], [ %14, %258 ]
  %299 = getelementptr inbounds %struct.pcap_file_header, %struct.pcap_file_header* %10, i32 0, i32 6
  %300 = load i32, i32* %299, align 4
  %301 = icmp eq i32 %300, 127
  br i1 %301, label %302, label %318

; <label>:302:                                    ; preds = %298
  %303 = getelementptr inbounds i8, i8* %.17, i64 2
  %304 = bitcast i8* %303 to i16*
  %305 = load i16, i16* %304, align 2
  %306 = zext i16 %305 to i32
  %307 = icmp sle i32 %306, 0
  br i1 %307, label %.backedge, label %308

; <label>:308:                                    ; preds = %302
  %309 = getelementptr inbounds %struct.pcap_pkthdr, %struct.pcap_pkthdr* %9, i32 0, i32 2
  %310 = load i32, i32* %309, align 4
  %311 = icmp sge i32 %306, %310
  br i1 %311, label %.backedge, label %312

; <label>:312:                                    ; preds = %308
  %313 = sext i32 %306 to i64
  %314 = getelementptr inbounds i8, i8* %.17, i64 %313
  %315 = getelementptr inbounds %struct.pcap_pkthdr, %struct.pcap_pkthdr* %9, i32 0, i32 2
  %316 = load i32, i32* %315, align 4
  %317 = sub i32 %316, %306
  store i32 %317, i32* %315, align 4
  br label %318

; <label>:318:                                    ; preds = %312, %298
  %.28 = phi i8* [ %314, %312 ], [ %.17, %298 ]
  %319 = getelementptr inbounds %struct.pcap_file_header, %struct.pcap_file_header* %10, i32 0, i32 6
  %320 = load i32, i32* %319, align 4
  %321 = icmp eq i32 %320, 192
  br i1 %321, label %322, label %352

; <label>:322:                                    ; preds = %318
  %323 = getelementptr inbounds i8, i8* %.28, i64 2
  %324 = bitcast i8* %323 to i16*
  %325 = load i16, i16* %324, align 2
  %326 = zext i16 %325 to i32
  %327 = icmp sle i32 %326, 0
  br i1 %327, label %.backedge, label %328

; <label>:328:                                    ; preds = %322
  %329 = getelementptr inbounds %struct.pcap_pkthdr, %struct.pcap_pkthdr* %9, i32 0, i32 2
  %330 = load i32, i32* %329, align 4
  %331 = icmp sge i32 %326, %330
  br i1 %331, label %.backedge, label %332

; <label>:332:                                    ; preds = %328
  %333 = icmp eq i32 %326, 24
  br i1 %333, label %334, label %340

; <label>:334:                                    ; preds = %332
  %335 = getelementptr inbounds i8, i8* %.28, i64 8
  %336 = bitcast i8* %335 to i16*
  %337 = load i16, i16* %336, align 2
  %338 = zext i16 %337 to i32
  %339 = icmp eq i32 %338, 2
  %spec.select = select i1 %339, i32 32, i32 %326
  br label %340

; <label>:340:                                    ; preds = %334, %332
  %.2 = phi i32 [ %326, %332 ], [ %spec.select, %334 ]
  %341 = icmp sle i32 %.2, 0
  br i1 %341, label %.backedge, label %342

; <label>:342:                                    ; preds = %340
  %343 = getelementptr inbounds %struct.pcap_pkthdr, %struct.pcap_pkthdr* %9, i32 0, i32 2
  %344 = load i32, i32* %343, align 4
  %345 = icmp sge i32 %.2, %344
  br i1 %345, label %.backedge, label %346

; <label>:346:                                    ; preds = %342
  %347 = sext i32 %.2 to i64
  %348 = getelementptr inbounds i8, i8* %.28, i64 %347
  %349 = getelementptr inbounds %struct.pcap_pkthdr, %struct.pcap_pkthdr* %9, i32 0, i32 2
  %350 = load i32, i32* %349, align 4
  %351 = sub i32 %350, %.2
  store i32 %351, i32* %349, align 4
  br label %352

; <label>:352:                                    ; preds = %201, %346, %318, %175
  %.5 = phi i8* [ %.0643, %175 ], [ %.0643, %201 ], [ %348, %346 ], [ %.28, %318 ]
  %353 = call i32 @pthread_mutex_lock(%union.pthread_mutex_t* @mx_apl) #9
  %354 = load i64, i64* @nb_pkt, align 8
  %355 = add nsw i64 %354, 1
  store i64 %355, i64* @nb_pkt, align 8
  %356 = icmp eq i32 %.15, 1
  br i1 %356, label %357, label %412

; <label>:357:                                    ; preds = %352
  %358 = getelementptr inbounds %struct.pcap_pkthdr, %struct.pcap_pkthdr* %9, i32 0, i32 2
  %359 = load i32, i32* %358, align 4
  %360 = icmp ult i32 %359, 24
  br i1 %360, label %1350, label %361

; <label>:361:                                    ; preds = %357
  %362 = getelementptr inbounds i8, i8* %.5, i64 0
  %363 = load i8, i8* %362, align 1
  %364 = zext i8 %363 to i32
  %365 = and i32 %364, 12
  %366 = icmp eq i32 %365, 4
  br i1 %366, label %1350, label %367

; <label>:367:                                    ; preds = %361
  %368 = getelementptr inbounds i8, i8* %.5, i64 1
  %369 = load i8, i8* %368, align 1
  %370 = zext i8 %369 to i32
  %371 = and i32 %370, 3
  switch i32 %371, label %384 [
    i32 0, label %372
    i32 1, label %375
    i32 2, label %378
    i32 3, label %381
  ]

; <label>:372:                                    ; preds = %367
  %373 = getelementptr inbounds [6 x i8], [6 x i8]* %3, i32 0, i32 0
  %374 = getelementptr inbounds i8, i8* %.5, i64 16
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %373, i8* align 1 %374, i64 6, i1 false), !track !126
  br label %385

; <label>:375:                                    ; preds = %367
  %376 = getelementptr inbounds [6 x i8], [6 x i8]* %3, i32 0, i32 0
  %377 = getelementptr inbounds i8, i8* %.5, i64 4
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %376, i8* align 1 %377, i64 6, i1 false), !track !127
  br label %385

; <label>:378:                                    ; preds = %367
  %379 = getelementptr inbounds [6 x i8], [6 x i8]* %3, i32 0, i32 0
  %380 = getelementptr inbounds i8, i8* %.5, i64 10
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %379, i8* align 1 %380, i64 6, i1 false), !track !128
  br label %385

; <label>:381:                                    ; preds = %367
  %382 = getelementptr inbounds [6 x i8], [6 x i8]* %3, i32 0, i32 0
  %383 = getelementptr inbounds i8, i8* %.5, i64 10
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %382, i8* align 1 %383, i64 6, i1 false), !track !129
  br label %385

; <label>:384:                                    ; preds = %367
  unreachable

; <label>:385:                                    ; preds = %381, %378, %375, %372
  %386 = getelementptr inbounds i8, i8* %.5, i64 1
  %387 = load i8, i8* %386, align 1
  %388 = zext i8 %387 to i32
  %389 = and i32 %388, 3
  switch i32 %389, label %402 [
    i32 0, label %390
    i32 1, label %393
    i32 2, label %396
    i32 3, label %399
  ]

; <label>:390:                                    ; preds = %385
  %391 = getelementptr inbounds [6 x i8], [6 x i8]* %4, i32 0, i32 0
  %392 = getelementptr inbounds i8, i8* %.5, i64 4
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %391, i8* align 1 %392, i64 6, i1 false), !track !130
  br label %403

; <label>:393:                                    ; preds = %385
  %394 = getelementptr inbounds [6 x i8], [6 x i8]* %4, i32 0, i32 0
  %395 = getelementptr inbounds i8, i8* %.5, i64 16
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %394, i8* align 1 %395, i64 6, i1 false), !track !131
  br label %403

; <label>:396:                                    ; preds = %385
  %397 = getelementptr inbounds [6 x i8], [6 x i8]* %4, i32 0, i32 0
  %398 = getelementptr inbounds i8, i8* %.5, i64 4
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %397, i8* align 1 %398, i64 6, i1 false), !track !132
  br label %403

; <label>:399:                                    ; preds = %385
  %400 = getelementptr inbounds [6 x i8], [6 x i8]* %4, i32 0, i32 0
  %401 = getelementptr inbounds i8, i8* %.5, i64 16
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %400, i8* align 1 %401, i64 6, i1 false), !track !133
  br label %403

; <label>:402:                                    ; preds = %385
  unreachable

; <label>:403:                                    ; preds = %399, %396, %393, %390
  %404 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 38
  %405 = load i32, i32* %404, align 8
  %406 = icmp ne i32 %405, 0
  br i1 %406, label %407, label %412

; <label>:407:                                    ; preds = %403
  %408 = getelementptr inbounds [6 x i8], [6 x i8]* %4, i64 0, i64 0
  %409 = load i8, i8* %408, align 1
  %410 = zext i8 %409 to i32
  %411 = icmp eq i32 %410, 1
  br i1 %411, label %1350, label %412

; <label>:412:                                    ; preds = %403, %407, %352
  %413 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 34
  %414 = load i8*, i8** %413, align 8
  %415 = icmp ne i8* %414, null
  br i1 %415, label %416, label %421

; <label>:416:                                    ; preds = %412
  %417 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 34
  %418 = load i8*, i8** %417, align 8
  %419 = getelementptr inbounds [6 x i8], [6 x i8]* %3, i32 0, i32 0
  %420 = call i32 @mergebssids(i8* %418, i8* %419)
  br label %421

; <label>:421:                                    ; preds = %416, %412
  %422 = getelementptr inbounds [6 x i8], [6 x i8]* %3, i32 0, i32 0
  %423 = getelementptr [7 x i8], [7 x i8]* @.str.23, i32 0, i32 0
  %424 = call i32 @memcmp(i8* %422, i8* %423, i64 6) #10
  %425 = icmp eq i32 %424, 0
  br i1 %425, label %1350, label %426

; <label>:426:                                    ; preds = %421
  %427 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 9, i32 0
  %428 = getelementptr [32 x i8], [32 x i8]* @ZERO, i32 0, i32 0
  %429 = call i32 @memcmp(i8* %427, i8* %428, i64 6) #10
  %430 = icmp ne i32 %429, 0
  br i1 %430, label %431, label %451

; <label>:431:                                    ; preds = %426
  %432 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 9, i32 0
  %433 = getelementptr [7 x i8], [7 x i8]* @.str.23, i32 0, i32 0
  %434 = call i32 @memcmp(i8* %432, i8* %433, i64 6) #10
  %435 = icmp ne i32 %434, 0
  br i1 %435, label %436, label %451

; <label>:436:                                    ; preds = %431
  %437 = getelementptr inbounds i8, i8* %.5, i64 4
  %438 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 9, i32 0
  %439 = call i32 @memcmp(i8* %438, i8* %437, i64 6) #10
  %440 = icmp ne i32 %439, 0
  br i1 %440, label %441, label %451

; <label>:441:                                    ; preds = %436
  %442 = getelementptr inbounds i8, i8* %.5, i64 10
  %443 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 9, i32 0
  %444 = call i32 @memcmp(i8* %443, i8* %442, i64 6) #10
  %445 = icmp ne i32 %444, 0
  br i1 %445, label %446, label %451

; <label>:446:                                    ; preds = %441
  %447 = getelementptr inbounds i8, i8* %.5, i64 16
  %448 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 9, i32 0
  %449 = call i32 @memcmp(i8* %448, i8* %447, i64 6) #10
  %450 = icmp ne i32 %449, 0
  br i1 %450, label %1350, label %451

; <label>:451:                                    ; preds = %436, %441, %446, %431, %426
  %452 = load %struct.AP_info*, %struct.AP_info** @ap_1st, align 8
  %453 = icmp ne %struct.AP_info* %452, null
  br i1 %453, label %.lr.ph, label %._crit_edge3

.lr.ph:                                           ; preds = %451
  %454 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %452, i32 0, i32 1
  %455 = getelementptr inbounds [6 x i8], [6 x i8]* %454, i32 0, i32 0
  %456 = getelementptr inbounds [6 x i8], [6 x i8]* %3, i32 0, i32 0
  %457 = call i32 @memcmp(i8* %455, i8* %456, i64 6) #10
  %458 = icmp ne i32 %457, 0
  br i1 %458, label %.lr.ph2.preheader, label %._crit_edge3

.lr.ph2.preheader:                                ; preds = %.lr.ph
  br label %.lr.ph2

; <label>:459:                                    ; preds = %.lr.ph2
  %.11327 = phi %struct.AP_info* [ %465, %.lr.ph2 ]
  %460 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.11327, i32 0, i32 1
  %461 = getelementptr inbounds [6 x i8], [6 x i8]* %460, i32 0, i32 0
  %462 = call i32 @memcmp(i8* %461, i8* %456, i64 6) #10
  %463 = icmp ne i32 %462, 0
  br i1 %463, label %.lr.ph2, label %._crit_edge3.loopexit

.lr.ph2:                                          ; preds = %.lr.ph2.preheader, %459
  %.113271 = phi %struct.AP_info* [ %.11327, %459 ], [ %452, %.lr.ph2.preheader ]
  call void @unroll_loop(i32 46)
  %464 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.113271, i32 0, i32 0
  %465 = load %struct.AP_info*, %struct.AP_info** %464, align 8
  %466 = icmp ne %struct.AP_info* %465, null
  br i1 %466, label %459, label %._crit_edge3.loopexit

._crit_edge3.loopexit:                            ; preds = %459, %.lr.ph2
  %.113.lcssa.ph = phi %struct.AP_info* [ %465, %.lr.ph2 ], [ %.11327, %459 ]
  %.011.lcssa.ph = phi %struct.AP_info* [ %.113271, %.lr.ph2 ], [ %.113271, %459 ]
  br label %._crit_edge3

._crit_edge3:                                     ; preds = %._crit_edge3.loopexit, %451, %.lr.ph
  %.113.lcssa = phi %struct.AP_info* [ %452, %.lr.ph ], [ %452, %451 ], [ %.113.lcssa.ph, %._crit_edge3.loopexit ]
  %.011.lcssa = phi %struct.AP_info* [ null, %.lr.ph ], [ null, %451 ], [ %.011.lcssa.ph, %._crit_edge3.loopexit ]
  %467 = icmp eq %struct.AP_info* %.113.lcssa, null
  br i1 %467, label %468, label %486

; <label>:468:                                    ; preds = %._crit_edge3
  %469 = call noalias i8* @malloc(i64 504) #9, !track !134
  %470 = bitcast i8* %469 to %struct.AP_info*
  %471 = icmp ne %struct.AP_info* %470, null
  br i1 %471, label %474, label %472

; <label>:472:                                    ; preds = %468
  %473 = getelementptr [14 x i8], [14 x i8]* @.str.7, i32 0, i32 0
  call void @perror(i8* %473)
  br label %._crit_edge

; <label>:474:                                    ; preds = %468
  %475 = bitcast %struct.AP_info* %470 to i8*
  call void @llvm.memset.p0i8.i64(i8* align 8 %475, i8 0, i64 504, i1 false)
  %476 = load %struct.AP_info*, %struct.AP_info** @ap_1st, align 8
  %477 = icmp eq %struct.AP_info* %476, null
  br i1 %477, label %478, label %479

; <label>:478:                                    ; preds = %474
  store %struct.AP_info* %470, %struct.AP_info** @ap_1st, align 8
  br label %481

; <label>:479:                                    ; preds = %474
  %480 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.011.lcssa, i32 0, i32 0
  store %struct.AP_info* %470, %struct.AP_info** %480, align 8
  br label %481

; <label>:481:                                    ; preds = %479, %478
  %482 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %470, i32 0, i32 1
  %483 = getelementptr inbounds [6 x i8], [6 x i8]* %482, i32 0, i32 0
  %484 = getelementptr inbounds [6 x i8], [6 x i8]* %3, i32 0, i32 0
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %483, i8* align 1 %484, i64 6, i1 false), !track !135
  %485 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %470, i32 0, i32 10
  store i32 -1, i32* %485, align 8
  br label %486

; <label>:486:                                    ; preds = %481, %._crit_edge3
  %.214 = phi %struct.AP_info* [ %470, %481 ], [ %.113.lcssa, %._crit_edge3 ]
  switch i32 %.15, label %629 [
    i32 2, label %487
    i32 3, label %508
  ]

; <label>:487:                                    ; preds = %486
  %488 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.214, i32 0, i32 10
  store i32 2, i32* %488, align 8
  br label %489

; <label>:489:                                    ; preds = %972, %487
  %490 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.214, i32 0, i32 7
  %491 = load i64, i64* %490, align 8
  %492 = icmp eq i64 %491, 0
  br i1 %492, label %493, label %496

; <label>:493:                                    ; preds = %489
  %494 = call i8** @uniqueiv_init()
  %495 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.214, i32 0, i32 5
  store i8** %494, i8*** %495, align 8
  br label %496

; <label>:496:                                    ; preds = %493, %489
  %497 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.214, i32 0, i32 5
  %498 = load i8**, i8*** %497, align 8
  %499 = call i32 @uniqueiv_check(i8** %498, i8* %14)
  %500 = icmp eq i32 %499, 0
  br i1 %500, label %501, label %1350

; <label>:501:                                    ; preds = %496
  %502 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.214, i32 0, i32 5
  %503 = load i8**, i8*** %502, align 8
  %504 = call i32 @uniqueiv_mark(i8** %503, i8* %14)
  %505 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.214, i32 0, i32 7
  %506 = load i64, i64* %505, align 8
  %507 = add nsw i64 %506, 1
  store i64 %507, i64* %505, align 8
  br label %1350

; <label>:508:                                    ; preds = %486
  %509 = getelementptr inbounds %struct.ivs2_pkthdr, %struct.ivs2_pkthdr* %7, i32 0, i32 0
  %510 = load i16, i16* %509, align 2
  %511 = zext i16 %510 to i32
  %512 = and i32 %511, 2
  %513 = icmp ne i32 %512, 0
  br i1 %513, label %514, label %533

; <label>:514:                                    ; preds = %508
  %515 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.214, i32 0, i32 2
  %516 = getelementptr inbounds [33 x i8], [33 x i8]* %515, i32 0, i32 0
  %517 = getelementptr inbounds %struct.ivs2_pkthdr, %struct.ivs2_pkthdr* %7, i32 0, i32 1
  %518 = load i16, i16* %517, align 2
  %519 = zext i16 %518 to i64
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 2 %516, i8* align 1 %14, i64 %519, i1 false), !track !136
  %520 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 1
  %521 = load i32, i32* %520, align 4
  %522 = icmp ne i32 %521, 0
  br i1 %522, label %523, label %1350

; <label>:523:                                    ; preds = %514
  %524 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.214, i32 0, i32 2
  %525 = getelementptr inbounds [33 x i8], [33 x i8]* %524, i32 0, i32 0
  %526 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 3, i32 0
  %527 = call i32 @strcmp(i8* %526, i8* %525) #10
  %528 = icmp ne i32 %527, 0
  br i1 %528, label %1350, label %529

; <label>:529:                                    ; preds = %523
  %530 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.214, i32 0, i32 1
  %531 = getelementptr inbounds [6 x i8], [6 x i8]* %530, i32 0, i32 0
  %532 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 4, i32 0
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %532, i8* align 8 %531, i64 6, i1 false), !track !137
  br label %1350

; <label>:533:                                    ; preds = %508
  %534 = getelementptr inbounds %struct.ivs2_pkthdr, %struct.ivs2_pkthdr* %7, i32 0, i32 0
  %535 = load i16, i16* %534, align 2
  %536 = zext i16 %535 to i32
  %537 = and i32 %536, 8
  %538 = icmp ne i32 %537, 0
  br i1 %538, label %539, label %571

; <label>:539:                                    ; preds = %533
  %540 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.214, i32 0, i32 10
  store i32 2, i32* %540, align 8
  %541 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 20
  %542 = load i32, i32* %541, align 4
  %543 = icmp ne i32 %542, 0
  br i1 %543, label %544, label %552

; <label>:544:                                    ; preds = %539
  %545 = getelementptr inbounds %struct.ivs2_pkthdr, %struct.ivs2_pkthdr* %7, i32 0, i32 1
  %546 = load i16, i16* %545, align 2
  %547 = zext i16 %546 to i32
  %548 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 10
  %549 = load i32, i32* %548, align 4
  %550 = add nsw i32 %549, 3
  %551 = icmp slt i32 %547, %550
  br i1 %551, label %1350, label %552

; <label>:552:                                    ; preds = %544, %539
  %553 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.214, i32 0, i32 7
  %554 = load i64, i64* %553, align 8
  %555 = icmp eq i64 %554, 0
  br i1 %555, label %556, label %559

; <label>:556:                                    ; preds = %552
  %557 = call i8** @uniqueiv_init()
  %558 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.214, i32 0, i32 5
  store i8** %557, i8*** %558, align 8
  br label %559

; <label>:559:                                    ; preds = %556, %552
  %560 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.214, i32 0, i32 5
  %561 = load i8**, i8*** %560, align 8
  %562 = call i32 @uniqueiv_check(i8** %561, i8* %14)
  %563 = icmp eq i32 %562, 0
  br i1 %563, label %564, label %1350

; <label>:564:                                    ; preds = %559
  %565 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.214, i32 0, i32 5
  %566 = load i8**, i8*** %565, align 8
  %567 = call i32 @uniqueiv_mark(i8** %566, i8* %14)
  %568 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.214, i32 0, i32 7
  %569 = load i64, i64* %568, align 8
  %570 = add nsw i64 %569, 1
  store i64 %570, i64* %568, align 8
  br label %1350

; <label>:571:                                    ; preds = %533
  %572 = getelementptr inbounds %struct.ivs2_pkthdr, %struct.ivs2_pkthdr* %7, i32 0, i32 0
  %573 = load i16, i16* %572, align 2
  %574 = zext i16 %573 to i32
  %575 = and i32 %574, 16
  %576 = icmp ne i32 %575, 0
  br i1 %576, label %577, label %619

; <label>:577:                                    ; preds = %571
  %578 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.214, i32 0, i32 10
  store i32 2, i32* %578, align 8
  %579 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 20
  %580 = load i32, i32* %579, align 4
  %581 = icmp ne i32 %580, 0
  br i1 %581, label %582, label %600

; <label>:582:                                    ; preds = %577
  %583 = getelementptr inbounds %struct.ivs2_pkthdr, %struct.ivs2_pkthdr* %7, i32 0, i32 1
  %584 = load i16, i16* %583, align 2
  %585 = zext i16 %584 to i32
  %586 = getelementptr inbounds i8, i8* %14, i64 5
  %587 = load i8, i8* %586, align 1
  %588 = zext i8 %587 to i32
  %589 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 10
  %590 = load i32, i32* %589, align 4
  %591 = icmp slt i32 %588, %590
  br i1 %591, label %1350, label %592

; <label>:592:                                    ; preds = %582
  %593 = getelementptr inbounds i8, i8* %14, i64 4
  %594 = load i8, i8* %593, align 1
  %595 = zext i8 %594 to i32
  %596 = mul nsw i32 %595, 32
  %597 = add nsw i32 6, %596
  %598 = add nsw i32 %597, 64
  %599 = icmp slt i32 %585, %598
  br i1 %599, label %1350, label %600

; <label>:600:                                    ; preds = %592, %577
  %601 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.214, i32 0, i32 7
  %602 = load i64, i64* %601, align 8
  %603 = icmp eq i64 %602, 0
  br i1 %603, label %604, label %607

; <label>:604:                                    ; preds = %600
  %605 = call i8** @uniqueiv_init()
  %606 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.214, i32 0, i32 5
  store i8** %605, i8*** %606, align 8
  br label %607

; <label>:607:                                    ; preds = %604, %600
  %608 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.214, i32 0, i32 5
  %609 = load i8**, i8*** %608, align 8
  %610 = call i32 @uniqueiv_check(i8** %609, i8* %14)
  %611 = icmp eq i32 %610, 0
  br i1 %611, label %612, label %1350

; <label>:612:                                    ; preds = %607
  %613 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.214, i32 0, i32 5
  %614 = load i8**, i8*** %613, align 8
  %615 = call i32 @uniqueiv_mark(i8** %614, i8* %14)
  %616 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.214, i32 0, i32 7
  %617 = load i64, i64* %616, align 8
  %618 = add nsw i64 %617, 1
  store i64 %618, i64* %616, align 8
  br label %1350

; <label>:619:                                    ; preds = %571
  %620 = getelementptr inbounds %struct.ivs2_pkthdr, %struct.ivs2_pkthdr* %7, i32 0, i32 0
  %621 = load i16, i16* %620, align 2
  %622 = zext i16 %621 to i32
  %623 = and i32 %622, 4
  %624 = icmp ne i32 %623, 0
  br i1 %624, label %625, label %1350

; <label>:625:                                    ; preds = %619
  %626 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.214, i32 0, i32 10
  store i32 3, i32* %626, align 8
  %627 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.214, i32 0, i32 14
  %628 = bitcast %struct.WPA_hdsk* %627 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %628, i8* align 1 %14, i64 356, i1 false), !track !138
  br label %1350

; <label>:629:                                    ; preds = %486
  %630 = getelementptr inbounds i8, i8* %.5, i64 1
  %631 = load i8, i8* %630, align 1
  %632 = zext i8 %631 to i32
  %633 = and i32 %632, 3
  switch i32 %633, label %686 [
    i32 0, label %634
    i32 1, label %637
    i32 2, label %640
  ]

; <label>:634:                                    ; preds = %629
  %635 = getelementptr inbounds [6 x i8], [6 x i8]* %5, i32 0, i32 0
  %636 = getelementptr inbounds i8, i8* %.5, i64 10
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %635, i8* align 1 %636, i64 6, i1 false), !track !139
  br label %649

; <label>:637:                                    ; preds = %629
  %638 = getelementptr inbounds [6 x i8], [6 x i8]* %5, i32 0, i32 0
  %639 = getelementptr inbounds i8, i8* %.5, i64 10
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %638, i8* align 1 %639, i64 6, i1 false), !track !140
  br label %649

; <label>:640:                                    ; preds = %629
  %641 = getelementptr inbounds i8, i8* %.5, i64 4
  %642 = load i8, i8* %641, align 1
  %643 = zext i8 %642 to i32
  %644 = srem i32 %643, 2
  %645 = icmp ne i32 %644, 0
  br i1 %645, label %686, label %646

; <label>:646:                                    ; preds = %640
  %647 = getelementptr inbounds [6 x i8], [6 x i8]* %5, i32 0, i32 0
  %648 = getelementptr inbounds i8, i8* %.5, i64 4
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %647, i8* align 1 %648, i64 6, i1 false), !track !141
  br label %649

; <label>:649:                                    ; preds = %646, %637, %634
  %650 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.214, i32 0, i32 13
  %651 = load %struct.ST_info*, %struct.ST_info** %650, align 8
  %652 = icmp ne %struct.ST_info* %651, null
  br i1 %652, label %.lr.ph32, label %._crit_edge8

.lr.ph32:                                         ; preds = %649
  %653 = getelementptr inbounds %struct.ST_info, %struct.ST_info* %651, i32 0, i32 3
  %654 = getelementptr inbounds [6 x i8], [6 x i8]* %653, i32 0, i32 0
  %655 = getelementptr inbounds [6 x i8], [6 x i8]* %5, i32 0, i32 0
  %656 = call i32 @memcmp(i8* %654, i8* %655, i64 6) #10
  %657 = icmp ne i32 %656, 0
  br i1 %657, label %.lr.ph7.preheader, label %._crit_edge8

.lr.ph7.preheader:                                ; preds = %.lr.ph32
  br label %.lr.ph7

; <label>:658:                                    ; preds = %.lr.ph7
  %.01730 = phi %struct.ST_info* [ %664, %.lr.ph7 ]
  %659 = getelementptr inbounds %struct.ST_info, %struct.ST_info* %.01730, i32 0, i32 3
  %660 = getelementptr inbounds [6 x i8], [6 x i8]* %659, i32 0, i32 0
  %661 = call i32 @memcmp(i8* %660, i8* %655, i64 6) #10
  %662 = icmp ne i32 %661, 0
  br i1 %662, label %.lr.ph7, label %._crit_edge8.loopexit

.lr.ph7:                                          ; preds = %.lr.ph7.preheader, %658
  %.017306 = phi %struct.ST_info* [ %.01730, %658 ], [ %651, %.lr.ph7.preheader ]
  call void @unroll_loop(i32 47)
  %663 = getelementptr inbounds %struct.ST_info, %struct.ST_info* %.017306, i32 0, i32 1
  %664 = load %struct.ST_info*, %struct.ST_info** %663, align 8
  %665 = icmp ne %struct.ST_info* %664, null
  br i1 %665, label %658, label %._crit_edge8.loopexit

._crit_edge8.loopexit:                            ; preds = %658, %.lr.ph7
  %.017.lcssa.ph = phi %struct.ST_info* [ %664, %.lr.ph7 ], [ %.01730, %658 ]
  %.016.lcssa.ph = phi %struct.ST_info* [ %.017306, %.lr.ph7 ], [ %.017306, %658 ]
  br label %._crit_edge8

._crit_edge8:                                     ; preds = %._crit_edge8.loopexit, %649, %.lr.ph32
  %.017.lcssa = phi %struct.ST_info* [ %651, %.lr.ph32 ], [ %651, %649 ], [ %.017.lcssa.ph, %._crit_edge8.loopexit ]
  %.016.lcssa = phi %struct.ST_info* [ null, %.lr.ph32 ], [ null, %649 ], [ %.016.lcssa.ph, %._crit_edge8.loopexit ]
  %666 = icmp eq %struct.ST_info* %.017.lcssa, null
  br i1 %666, label %667, label %686

; <label>:667:                                    ; preds = %._crit_edge8
  %668 = call noalias i8* @malloc(i64 384) #9, !track !142
  %669 = bitcast i8* %668 to %struct.ST_info*
  %670 = icmp ne %struct.ST_info* %669, null
  br i1 %670, label %673, label %671

; <label>:671:                                    ; preds = %667
  %672 = getelementptr [14 x i8], [14 x i8]* @.str.7, i32 0, i32 0
  call void @perror(i8* %672)
  br label %._crit_edge

; <label>:673:                                    ; preds = %667
  %674 = bitcast %struct.ST_info* %669 to i8*
  call void @llvm.memset.p0i8.i64(i8* align 8 %674, i8 0, i64 384, i1 false)
  %675 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.214, i32 0, i32 13
  %676 = load %struct.ST_info*, %struct.ST_info** %675, align 8
  %677 = icmp eq %struct.ST_info* %676, null
  br i1 %677, label %678, label %680

; <label>:678:                                    ; preds = %673
  %679 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.214, i32 0, i32 13
  store %struct.ST_info* %669, %struct.ST_info** %679, align 8
  br label %682

; <label>:680:                                    ; preds = %673
  %681 = getelementptr inbounds %struct.ST_info, %struct.ST_info* %.016.lcssa, i32 0, i32 1
  store %struct.ST_info* %669, %struct.ST_info** %681, align 8
  br label %682

; <label>:682:                                    ; preds = %680, %678
  %683 = getelementptr inbounds %struct.ST_info, %struct.ST_info* %669, i32 0, i32 3
  %684 = getelementptr inbounds [6 x i8], [6 x i8]* %683, i32 0, i32 0
  %685 = getelementptr inbounds [6 x i8], [6 x i8]* %5, i32 0, i32 0
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %684, i8* align 1 %685, i64 6, i1 false), !track !143
  br label %686

; <label>:686:                                    ; preds = %._crit_edge8, %682, %629, %640
  %.219 = phi %struct.ST_info* [ null, %640 ], [ null, %629 ], [ %669, %682 ], [ %.017.lcssa, %._crit_edge8 ]
  %687 = getelementptr inbounds i8, i8* %.5, i64 0
  %688 = load i8, i8* %687, align 1
  %689 = zext i8 %688 to i32
  %690 = icmp eq i32 %689, 128
  br i1 %690, label %696, label %691

; <label>:691:                                    ; preds = %686
  %692 = getelementptr inbounds i8, i8* %.5, i64 0
  %693 = load i8, i8* %692, align 1
  %694 = zext i8 %693 to i32
  %695 = icmp eq i32 %694, 80
  br i1 %695, label %696, label %.loopexit24

; <label>:696:                                    ; preds = %691, %686
  %697 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.214, i32 0, i32 10
  %698 = load i32, i32* %697, align 8
  %699 = icmp slt i32 %698, 0
  br i1 %699, label %700, label %707

; <label>:700:                                    ; preds = %696
  %701 = getelementptr inbounds i8, i8* %.5, i64 34
  %702 = load i8, i8* %701, align 1
  %703 = zext i8 %702 to i32
  %704 = and i32 %703, 16
  %705 = ashr i32 %704, 4
  %706 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.214, i32 0, i32 10
  store i32 %705, i32* %706, align 8
  br label %707

; <label>:707:                                    ; preds = %700, %696
  %708 = getelementptr inbounds i8, i8* %.5, i64 36
  %709 = getelementptr inbounds %struct.pcap_pkthdr, %struct.pcap_pkthdr* %9, i32 0, i32 2
  %710 = load i32, i32* %709, align 4
  %711 = zext i32 %710 to i64
  %712 = getelementptr inbounds i8, i8* %.5, i64 %711
  %713 = icmp ult i8* %708, %712
  br i1 %713, label %.lr.ph36.preheader, label %.loopexit24

.lr.ph36.preheader:                               ; preds = %707
  br label %.lr.ph36

.lr.ph36:                                         ; preds = %.lr.ph36.preheader, %769
  %.0935 = phi i8* [ %775, %769 ], [ %708, %.lr.ph36.preheader ]
  call void @unroll_loop(i32 48)
  %714 = getelementptr inbounds i8, i8* %.0935, i64 2
  %715 = getelementptr inbounds i8, i8* %.0935, i64 1
  %716 = load i8, i8* %715, align 1
  %717 = zext i8 %716 to i32
  %718 = sext i32 %717 to i64
  %719 = getelementptr inbounds i8, i8* %714, i64 %718
  %720 = getelementptr inbounds %struct.pcap_pkthdr, %struct.pcap_pkthdr* %9, i32 0, i32 2
  %721 = load i32, i32* %720, align 4
  %722 = zext i32 %721 to i64
  %723 = getelementptr inbounds i8, i8* %.5, i64 %722
  %724 = icmp ugt i8* %719, %723
  br i1 %724, label %.loopexit24.loopexit, label %725

; <label>:725:                                    ; preds = %.lr.ph36
  %726 = load i8, i8* %.0935, align 1
  %727 = zext i8 %726 to i32
  %728 = icmp eq i32 %727, 0
  br i1 %728, label %729, label %769

; <label>:729:                                    ; preds = %725
  %730 = getelementptr inbounds i8, i8* %.0935, i64 1
  %731 = load i8, i8* %730, align 1
  %732 = zext i8 %731 to i32
  %733 = icmp sgt i32 %732, 0
  br i1 %733, label %734, label %769

; <label>:734:                                    ; preds = %729
  %735 = getelementptr inbounds i8, i8* %.0935, i64 2
  %736 = load i8, i8* %735, align 1
  %737 = zext i8 %736 to i32
  %738 = icmp ne i32 %737, 0
  br i1 %738, label %739, label %769

; <label>:739:                                    ; preds = %734
  %740 = getelementptr inbounds i8, i8* %.0935, i64 1
  %741 = load i8, i8* %740, align 1
  %742 = zext i8 %741 to i32
  %743 = icmp sgt i32 %742, 32
  br i1 %743, label %748, label %744

; <label>:744:                                    ; preds = %739
  %745 = getelementptr inbounds i8, i8* %.0935, i64 1
  %746 = load i8, i8* %745, align 1
  %747 = zext i8 %746 to i32
  br label %748

; <label>:748:                                    ; preds = %739, %744
  %749 = phi i32 [ %747, %744 ], [ 32, %739 ]
  %750 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.214, i32 0, i32 2
  %751 = getelementptr inbounds [33 x i8], [33 x i8]* %750, i32 0, i32 0
  call void @llvm.memset.p0i8.i64(i8* align 2 %751, i8 0, i64 33, i1 false)
  %752 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.214, i32 0, i32 2
  %753 = getelementptr inbounds [33 x i8], [33 x i8]* %752, i32 0, i32 0
  %754 = getelementptr inbounds i8, i8* %.0935, i64 2
  %755 = sext i32 %749 to i64
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 2 %753, i8* align 1 %754, i64 %755, i1 false), !track !144
  %756 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 1
  %757 = load i32, i32* %756, align 4
  %758 = icmp ne i32 %757, 0
  br i1 %758, label %759, label %769

; <label>:759:                                    ; preds = %748
  %760 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.214, i32 0, i32 2
  %761 = getelementptr inbounds [33 x i8], [33 x i8]* %760, i32 0, i32 0
  %762 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 3, i32 0
  %763 = call i32 @strcmp(i8* %762, i8* %761) #10
  %764 = icmp ne i32 %763, 0
  br i1 %764, label %769, label %765

; <label>:765:                                    ; preds = %759
  %766 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.214, i32 0, i32 1
  %767 = getelementptr inbounds [6 x i8], [6 x i8]* %766, i32 0, i32 0
  %768 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 4, i32 0
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %768, i8* align 8 %767, i64 6, i1 false), !track !145
  br label %769

; <label>:769:                                    ; preds = %748, %759, %765, %734, %729, %725
  %770 = getelementptr inbounds i8, i8* %.0935, i64 1
  %771 = load i8, i8* %770, align 1
  %772 = zext i8 %771 to i32
  %773 = add nsw i32 2, %772
  %774 = sext i32 %773 to i64
  %775 = getelementptr inbounds i8, i8* %.0935, i64 %774
  %776 = load i32, i32* %709, align 4
  %777 = zext i32 %776 to i64
  %778 = getelementptr inbounds i8, i8* %.5, i64 %777
  %779 = icmp ult i8* %775, %778
  br i1 %779, label %.lr.ph36, label %.loopexit24.loopexit

.loopexit24.loopexit:                             ; preds = %769, %.lr.ph36
  br label %.loopexit24

.loopexit24:                                      ; preds = %.loopexit24.loopexit, %707, %691
  %780 = getelementptr inbounds i8, i8* %.5, i64 0
  %781 = load i8, i8* %780, align 1
  %782 = zext i8 %781 to i32
  %783 = icmp eq i32 %782, 0
  br i1 %783, label %784, label %861

; <label>:784:                                    ; preds = %.loopexit24
  %785 = getelementptr inbounds i8, i8* %.5, i64 28
  %786 = getelementptr inbounds %struct.pcap_pkthdr, %struct.pcap_pkthdr* %9, i32 0, i32 2
  %787 = load i32, i32* %786, align 4
  %788 = zext i32 %787 to i64
  %789 = getelementptr inbounds i8, i8* %.5, i64 %788
  %790 = icmp ult i8* %785, %789
  br i1 %790, label %.lr.ph38.preheader, label %.loopexit

.lr.ph38.preheader:                               ; preds = %784
  br label %.lr.ph38

.lr.ph38:                                         ; preds = %.lr.ph38.preheader, %846
  %.11037 = phi i8* [ %852, %846 ], [ %785, %.lr.ph38.preheader ]
  call void @unroll_loop(i32 49)
  %791 = getelementptr inbounds i8, i8* %.11037, i64 2
  %792 = getelementptr inbounds i8, i8* %.11037, i64 1
  %793 = load i8, i8* %792, align 1
  %794 = zext i8 %793 to i32
  %795 = sext i32 %794 to i64
  %796 = getelementptr inbounds i8, i8* %791, i64 %795
  %797 = getelementptr inbounds %struct.pcap_pkthdr, %struct.pcap_pkthdr* %9, i32 0, i32 2
  %798 = load i32, i32* %797, align 4
  %799 = zext i32 %798 to i64
  %800 = getelementptr inbounds i8, i8* %.5, i64 %799
  %801 = icmp ugt i8* %796, %800
  br i1 %801, label %.loopexit.loopexit, label %802

; <label>:802:                                    ; preds = %.lr.ph38
  %803 = load i8, i8* %.11037, align 1
  %804 = zext i8 %803 to i32
  %805 = icmp eq i32 %804, 0
  br i1 %805, label %806, label %846

; <label>:806:                                    ; preds = %802
  %807 = getelementptr inbounds i8, i8* %.11037, i64 1
  %808 = load i8, i8* %807, align 1
  %809 = zext i8 %808 to i32
  %810 = icmp sgt i32 %809, 0
  br i1 %810, label %811, label %846

; <label>:811:                                    ; preds = %806
  %812 = getelementptr inbounds i8, i8* %.11037, i64 2
  %813 = load i8, i8* %812, align 1
  %814 = zext i8 %813 to i32
  %815 = icmp ne i32 %814, 0
  br i1 %815, label %816, label %846

; <label>:816:                                    ; preds = %811
  %817 = getelementptr inbounds i8, i8* %.11037, i64 1
  %818 = load i8, i8* %817, align 1
  %819 = zext i8 %818 to i32
  %820 = icmp sgt i32 %819, 32
  br i1 %820, label %825, label %821

; <label>:821:                                    ; preds = %816
  %822 = getelementptr inbounds i8, i8* %.11037, i64 1
  %823 = load i8, i8* %822, align 1
  %824 = zext i8 %823 to i32
  br label %825

; <label>:825:                                    ; preds = %816, %821
  %826 = phi i32 [ %824, %821 ], [ 32, %816 ]
  %827 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.214, i32 0, i32 2
  %828 = getelementptr inbounds [33 x i8], [33 x i8]* %827, i32 0, i32 0
  call void @llvm.memset.p0i8.i64(i8* align 2 %828, i8 0, i64 33, i1 false)
  %829 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.214, i32 0, i32 2
  %830 = getelementptr inbounds [33 x i8], [33 x i8]* %829, i32 0, i32 0
  %831 = getelementptr inbounds i8, i8* %.11037, i64 2
  %832 = sext i32 %826 to i64
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 2 %830, i8* align 1 %831, i64 %832, i1 false), !track !146
  %833 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 1
  %834 = load i32, i32* %833, align 4
  %835 = icmp ne i32 %834, 0
  br i1 %835, label %836, label %846

; <label>:836:                                    ; preds = %825
  %837 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.214, i32 0, i32 2
  %838 = getelementptr inbounds [33 x i8], [33 x i8]* %837, i32 0, i32 0
  %839 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 3, i32 0
  %840 = call i32 @strcmp(i8* %839, i8* %838) #10
  %841 = icmp ne i32 %840, 0
  br i1 %841, label %846, label %842

; <label>:842:                                    ; preds = %836
  %843 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.214, i32 0, i32 1
  %844 = getelementptr inbounds [6 x i8], [6 x i8]* %843, i32 0, i32 0
  %845 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 4, i32 0
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %845, i8* align 8 %844, i64 6, i1 false), !track !147
  br label %846

; <label>:846:                                    ; preds = %825, %836, %842, %811, %806, %802
  %847 = getelementptr inbounds i8, i8* %.11037, i64 1
  %848 = load i8, i8* %847, align 1
  %849 = zext i8 %848 to i32
  %850 = add nsw i32 2, %849
  %851 = sext i32 %850 to i64
  %852 = getelementptr inbounds i8, i8* %.11037, i64 %851
  %853 = load i32, i32* %786, align 4
  %854 = zext i32 %853 to i64
  %855 = getelementptr inbounds i8, i8* %.5, i64 %854
  %856 = icmp ult i8* %852, %855
  br i1 %856, label %.lr.ph38, label %.loopexit.loopexit

.loopexit.loopexit:                               ; preds = %.lr.ph38, %846
  br label %.loopexit

.loopexit:                                        ; preds = %.loopexit.loopexit, %784
  %857 = icmp ne %struct.ST_info* %.219, null
  br i1 %857, label %858, label %861

; <label>:858:                                    ; preds = %.loopexit
  %859 = getelementptr inbounds %struct.ST_info, %struct.ST_info* %.219, i32 0, i32 2
  %860 = getelementptr inbounds %struct.WPA_hdsk, %struct.WPA_hdsk* %859, i32 0, i32 7
  store i32 0, i32* %860, align 8
  br label %861

; <label>:861:                                    ; preds = %.loopexit, %858, %.loopexit24
  %862 = getelementptr inbounds i8, i8* %.5, i64 0
  %863 = load i8, i8* %862, align 1
  %864 = zext i8 %863 to i32
  %865 = icmp eq i32 %864, 16
  %866 = icmp ne %struct.ST_info* %.219, null
  %or.cond = and i1 %865, %866
  br i1 %or.cond, label %867, label %870

; <label>:867:                                    ; preds = %861
  %868 = getelementptr inbounds %struct.ST_info, %struct.ST_info* %.219, i32 0, i32 2
  %869 = getelementptr inbounds %struct.WPA_hdsk, %struct.WPA_hdsk* %868, i32 0, i32 7
  store i32 0, i32* %869, align 8
  br label %870

; <label>:870:                                    ; preds = %867, %861
  %871 = getelementptr inbounds i8, i8* %.5, i64 0
  %872 = load i8, i8* %871, align 1
  %873 = zext i8 %872 to i32
  %874 = and i32 %873, 12
  %875 = icmp ne i32 %874, 8
  br i1 %875, label %1350, label %876

; <label>:876:                                    ; preds = %870
  %877 = getelementptr inbounds i8, i8* %.5, i64 1
  %878 = load i8, i8* %877, align 1
  %879 = zext i8 %878 to i32
  %880 = and i32 %879, 3
  %881 = icmp ne i32 %880, 3
  %882 = zext i1 %881 to i64
  %883 = select i1 %881, i32 24, i32 30
  %884 = getelementptr inbounds i8, i8* %.5, i64 0
  %885 = load i8, i8* %884, align 1
  %886 = zext i8 %885 to i32
  %887 = and i32 %886, 128
  %888 = icmp eq i32 %887, 128
  %889 = add nsw i32 %883, 2
  %spec.select1 = select i1 %888, i32 %889, i32 %883
  %890 = add nsw i32 %spec.select1, 16
  %891 = getelementptr inbounds %struct.pcap_pkthdr, %struct.pcap_pkthdr* %9, i32 0, i32 2
  %892 = load i32, i32* %891, align 4
  %893 = icmp sgt i32 %890, %892
  br i1 %893, label %1350, label %894

; <label>:894:                                    ; preds = %876
  %895 = sext i32 %spec.select1 to i64
  %896 = getelementptr inbounds i8, i8* %.5, i64 %895
  %897 = load i8, i8* %896, align 1
  %898 = zext i8 %897 to i32
  %899 = add nsw i32 %spec.select1, 1
  %900 = sext i32 %899 to i64
  %901 = getelementptr inbounds i8, i8* %.5, i64 %900
  %902 = load i8, i8* %901, align 1
  %903 = zext i8 %902 to i32
  %904 = icmp ne i32 %898, %903
  br i1 %904, label %912, label %905

; <label>:905:                                    ; preds = %894
  %906 = add nsw i32 %spec.select1, 2
  %907 = sext i32 %906 to i64
  %908 = getelementptr inbounds i8, i8* %.5, i64 %907
  %909 = load i8, i8* %908, align 1
  %910 = zext i8 %909 to i32
  %911 = icmp ne i32 %910, 3
  br i1 %911, label %912, label %975

; <label>:912:                                    ; preds = %905, %894
  %913 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.214, i32 0, i32 10
  store i32 2, i32* %913, align 8
  %914 = add nsw i32 %spec.select1, 3
  %915 = sext i32 %914 to i64
  %916 = getelementptr inbounds i8, i8* %.5, i64 %915
  %917 = load i8, i8* %916, align 1
  %918 = zext i8 %917 to i32
  %919 = and i32 %918, 32
  %920 = icmp ne i32 %919, 0
  br i1 %920, label %921, label %923

; <label>:921:                                    ; preds = %912
  %922 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.214, i32 0, i32 10
  store i32 3, i32* %922, align 8
  br label %923

; <label>:923:                                    ; preds = %921, %912
  %924 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 11
  %925 = load i32, i32* %924, align 8
  %926 = icmp ne i32 %925, 0
  br i1 %926, label %927, label %938

; <label>:927:                                    ; preds = %923
  %928 = add nsw i32 %spec.select1, 3
  %929 = sext i32 %928 to i64
  %930 = getelementptr inbounds i8, i8* %.5, i64 %929
  %931 = load i8, i8* %930, align 1
  %932 = zext i8 %931 to i32
  %933 = ashr i32 %932, 6
  %934 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 11
  %935 = load i32, i32* %934, align 8
  %936 = sub nsw i32 %935, 1
  %937 = icmp ne i32 %933, %936
  br i1 %937, label %1350, label %938

; <label>:938:                                    ; preds = %927, %923
  %939 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 20
  %940 = load i32, i32* %939, align 4
  %941 = icmp ne i32 %940, 0
  br i1 %941, label %942, label %972

; <label>:942:                                    ; preds = %938
  %943 = sext i32 %spec.select1 to i64
  %944 = getelementptr inbounds i8, i8* %.5, i64 %943
  %945 = getelementptr inbounds %struct.pcap_pkthdr, %struct.pcap_pkthdr* %9, i32 0, i32 2
  %946 = load i32, i32* %945, align 4
  %947 = zext i32 %946 to i64
  %948 = ptrtoint i8* %944 to i64
  %949 = ptrtoint i8* %.5 to i64
  %950 = sub i64 %948, %949
  %951 = sub nsw i64 %947, %950
  %952 = sub nsw i64 %951, 4
  %953 = sub nsw i64 %952, 4
  %954 = trunc i64 %953 to i32
  %955 = getelementptr inbounds i8, i8* %.5, i64 1
  %956 = load i8, i8* %955, align 1
  %957 = zext i8 %956 to i32
  %958 = and i32 %957, 3
  %959 = icmp eq i32 %958, 3
  br i1 %959, label %960, label %963

; <label>:960:                                    ; preds = %942
  %961 = getelementptr inbounds i8, i8* %944, i64 6
  %962 = sub nsw i32 %954, 6
  br label %963

; <label>:963:                                    ; preds = %960, %942
  %.0 = phi i32 [ %962, %960 ], [ %954, %942 ]
  %964 = getelementptr inbounds [2048 x i8], [2048 x i8]* %11, i32 0, i32 0
  %965 = getelementptr inbounds [16 x i32], [16 x i32]* %6, i32 0, i32 0
  %966 = call i32 @known_clear(i8* %964, i32* %12, i32* %965, i8* %.5, i32 %.0)
  %967 = load i32, i32* %12, align 4
  %968 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 10
  %969 = load i32, i32* %968, align 4
  %970 = add nsw i32 %969, 3
  %971 = icmp slt i32 %967, %970
  br i1 %971, label %1350, label %972

; <label>:972:                                    ; preds = %963, %938
  %973 = sext i32 %spec.select1 to i64
  %974 = getelementptr inbounds i8, i8* %.5, i64 %973
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %14, i8* align 1 %974, i64 3, i1 false), !track !148
  br label %489

; <label>:975:                                    ; preds = %905
  %976 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.214, i32 0, i32 10
  %977 = load i32, i32* %976, align 8
  %978 = icmp slt i32 %977, 0
  br i1 %978, label %979, label %981

; <label>:979:                                    ; preds = %975
  %980 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.214, i32 0, i32 10
  store i32 0, i32* %980, align 8
  br label %981

; <label>:981:                                    ; preds = %979, %975
  %982 = add nsw i32 %spec.select1, 6
  %983 = add nsw i32 %982, 20
  %984 = getelementptr inbounds %struct.pcap_pkthdr, %struct.pcap_pkthdr* %9, i32 0, i32 2
  %985 = load i32, i32* %984, align 4
  %986 = icmp slt i32 %983, %985
  br i1 %986, label %987, label %1031

; <label>:987:                                    ; preds = %981
  %988 = sext i32 %982 to i64
  %989 = getelementptr inbounds i8, i8* %.5, i64 %988
  %990 = load i8, i8* %989, align 1
  %991 = zext i8 %990 to i32
  %992 = icmp eq i32 %991, 8
  br i1 %992, label %993, label %1012

; <label>:993:                                    ; preds = %987
  %994 = add nsw i32 %982, 1
  %995 = sext i32 %994 to i64
  %996 = getelementptr inbounds i8, i8* %.5, i64 %995
  %997 = load i8, i8* %996, align 1
  %998 = zext i8 %997 to i32
  %999 = icmp eq i32 %998, 0
  br i1 %999, label %1000, label %1012

; <label>:1000:                                   ; preds = %993
  %1001 = getelementptr inbounds i8, i8* %.5, i64 1
  %1002 = load i8, i8* %1001, align 1
  %1003 = zext i8 %1002 to i32
  %1004 = and i32 %1003, 3
  %1005 = icmp eq i32 %1004, 1
  br i1 %1005, label %1006, label %1012

; <label>:1006:                                   ; preds = %1000
  %1007 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.214, i32 0, i32 3
  %1008 = getelementptr inbounds [4 x i8], [4 x i8]* %1007, i32 0, i32 0
  %1009 = add nsw i32 %982, 14
  %1010 = sext i32 %1009 to i64
  %1011 = getelementptr inbounds i8, i8* %.5, i64 %1010
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %1008, i8* align 1 %1011, i64 4, i1 false), !track !149
  br label %1012

; <label>:1012:                                   ; preds = %1006, %1000, %993, %987
  %1013 = sext i32 %982 to i64
  %1014 = getelementptr inbounds i8, i8* %.5, i64 %1013
  %1015 = load i8, i8* %1014, align 1
  %1016 = zext i8 %1015 to i32
  %1017 = icmp eq i32 %1016, 8
  br i1 %1017, label %1018, label %1031

; <label>:1018:                                   ; preds = %1012
  %1019 = add nsw i32 %982, 1
  %1020 = sext i32 %1019 to i64
  %1021 = getelementptr inbounds i8, i8* %.5, i64 %1020
  %1022 = load i8, i8* %1021, align 1
  %1023 = zext i8 %1022 to i32
  %1024 = icmp eq i32 %1023, 6
  br i1 %1024, label %1025, label %1031

; <label>:1025:                                   ; preds = %1018
  %1026 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.214, i32 0, i32 3
  %1027 = getelementptr inbounds [4 x i8], [4 x i8]* %1026, i32 0, i32 0
  %1028 = add nsw i32 %982, 16
  %1029 = sext i32 %1028 to i64
  %1030 = getelementptr inbounds i8, i8* %.5, i64 %1029
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %1027, i8* align 1 %1030, i64 4, i1 false), !track !150
  br label %1031

; <label>:1031:                                   ; preds = %1012, %1018, %1025, %981
  %1032 = sext i32 %982 to i64
  %1033 = getelementptr inbounds i8, i8* %.5, i64 %1032
  %1034 = load i8, i8* %1033, align 1
  %1035 = zext i8 %1034 to i32
  %1036 = icmp ne i32 %1035, 136
  br i1 %1036, label %1350, label %1037

; <label>:1037:                                   ; preds = %1031
  %1038 = add nsw i32 %982, 1
  %1039 = sext i32 %1038 to i64
  %1040 = getelementptr inbounds i8, i8* %.5, i64 %1039
  %1041 = load i8, i8* %1040, align 1
  %1042 = zext i8 %1041 to i32
  %1043 = icmp ne i32 %1042, 142
  br i1 %1043, label %1350, label %1044

; <label>:1044:                                   ; preds = %1037
  %1045 = add nsw i32 %982, 2
  %1046 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.214, i32 0, i32 11
  store i32 1, i32* %1046, align 4
  %1047 = add nsw i32 %1045, 1
  %1048 = sext i32 %1047 to i64
  %1049 = getelementptr inbounds i8, i8* %.5, i64 %1048
  %1050 = load i8, i8* %1049, align 1
  %1051 = zext i8 %1050 to i32
  %1052 = icmp ne i32 %1051, 3
  br i1 %1052, label %1350, label %1053

; <label>:1053:                                   ; preds = %1044
  %1054 = add nsw i32 %1045, 4
  %1055 = sext i32 %1054 to i64
  %1056 = getelementptr inbounds i8, i8* %.5, i64 %1055
  %1057 = load i8, i8* %1056, align 1
  %1058 = zext i8 %1057 to i32
  %1059 = icmp ne i32 %1058, 254
  br i1 %1059, label %1060, label %1067

; <label>:1060:                                   ; preds = %1053
  %1061 = add nsw i32 %1045, 4
  %1062 = sext i32 %1061 to i64
  %1063 = getelementptr inbounds i8, i8* %.5, i64 %1062
  %1064 = load i8, i8* %1063, align 1
  %1065 = zext i8 %1064 to i32
  %1066 = icmp ne i32 %1065, 2
  br i1 %1066, label %1350, label %1067

; <label>:1067:                                   ; preds = %1060, %1053
  %1068 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.214, i32 0, i32 11
  store i32 0, i32* %1068, align 4
  %1069 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.214, i32 0, i32 10
  store i32 3, i32* %1069, align 8
  %1070 = icmp eq %struct.ST_info* %.219, null
  br i1 %1070, label %1071, label %1073

; <label>:1071:                                   ; preds = %1067
  %1072 = call i32 @pthread_mutex_unlock(%union.pthread_mutex_t* @mx_apl) #9
  br label %.backedge

; <label>:1073:                                   ; preds = %1067
  %1074 = add nsw i32 %1045, 6
  %1075 = sext i32 %1074 to i64
  %1076 = getelementptr inbounds i8, i8* %.5, i64 %1075
  %1077 = load i8, i8* %1076, align 1
  %1078 = zext i8 %1077 to i32
  %1079 = and i32 %1078, 8
  %1080 = icmp ne i32 %1079, 0
  br i1 %1080, label %1081, label %1114

; <label>:1081:                                   ; preds = %1073
  %1082 = add nsw i32 %1045, 6
  %1083 = sext i32 %1082 to i64
  %1084 = getelementptr inbounds i8, i8* %.5, i64 %1083
  %1085 = load i8, i8* %1084, align 1
  %1086 = zext i8 %1085 to i32
  %1087 = and i32 %1086, 64
  %1088 = icmp eq i32 %1087, 0
  br i1 %1088, label %1089, label %1114

; <label>:1089:                                   ; preds = %1081
  %1090 = add nsw i32 %1045, 6
  %1091 = sext i32 %1090 to i64
  %1092 = getelementptr inbounds i8, i8* %.5, i64 %1091
  %1093 = load i8, i8* %1092, align 1
  %1094 = zext i8 %1093 to i32
  %1095 = and i32 %1094, 128
  %1096 = icmp ne i32 %1095, 0
  br i1 %1096, label %1097, label %1114

; <label>:1097:                                   ; preds = %1089
  %1098 = add nsw i32 %1045, 5
  %1099 = sext i32 %1098 to i64
  %1100 = getelementptr inbounds i8, i8* %.5, i64 %1099
  %1101 = load i8, i8* %1100, align 1
  %1102 = zext i8 %1101 to i32
  %1103 = and i32 %1102, 1
  %1104 = icmp eq i32 %1103, 0
  br i1 %1104, label %1105, label %1114

; <label>:1105:                                   ; preds = %1097
  %1106 = getelementptr inbounds %struct.ST_info, %struct.ST_info* %.219, i32 0, i32 2
  %1107 = getelementptr inbounds %struct.WPA_hdsk, %struct.WPA_hdsk* %1106, i32 0, i32 2
  %1108 = getelementptr inbounds [32 x i8], [32 x i8]* %1107, i32 0, i32 0
  %1109 = add nsw i32 %1045, 17
  %1110 = sext i32 %1109 to i64
  %1111 = getelementptr inbounds i8, i8* %.5, i64 %1110
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 2 %1108, i8* align 1 %1111, i64 32, i1 false), !track !151
  %1112 = getelementptr inbounds %struct.ST_info, %struct.ST_info* %.219, i32 0, i32 2
  %1113 = getelementptr inbounds %struct.WPA_hdsk, %struct.WPA_hdsk* %1112, i32 0, i32 7
  store i32 1, i32* %1113, align 8
  br label %1114

; <label>:1114:                                   ; preds = %1105, %1097, %1089, %1081, %1073
  %1115 = add nsw i32 %1045, 6
  %1116 = sext i32 %1115 to i64
  %1117 = getelementptr inbounds i8, i8* %.5, i64 %1116
  %1118 = load i8, i8* %1117, align 1
  %1119 = zext i8 %1118 to i32
  %1120 = and i32 %1119, 8
  %1121 = icmp ne i32 %1120, 0
  br i1 %1121, label %1122, label %1225

; <label>:1122:                                   ; preds = %1114
  %1123 = add nsw i32 %1045, 6
  %1124 = sext i32 %1123 to i64
  %1125 = getelementptr inbounds i8, i8* %.5, i64 %1124
  %1126 = load i8, i8* %1125, align 1
  %1127 = zext i8 %1126 to i32
  %1128 = and i32 %1127, 64
  %1129 = icmp eq i32 %1128, 0
  br i1 %1129, label %1130, label %1225

; <label>:1130:                                   ; preds = %1122
  %1131 = add nsw i32 %1045, 6
  %1132 = sext i32 %1131 to i64
  %1133 = getelementptr inbounds i8, i8* %.5, i64 %1132
  %1134 = load i8, i8* %1133, align 1
  %1135 = zext i8 %1134 to i32
  %1136 = and i32 %1135, 128
  %1137 = icmp eq i32 %1136, 0
  br i1 %1137, label %1138, label %1225

; <label>:1138:                                   ; preds = %1130
  %1139 = add nsw i32 %1045, 5
  %1140 = sext i32 %1139 to i64
  %1141 = getelementptr inbounds i8, i8* %.5, i64 %1140
  %1142 = load i8, i8* %1141, align 1
  %1143 = zext i8 %1142 to i32
  %1144 = and i32 %1143, 1
  %1145 = icmp ne i32 %1144, 0
  br i1 %1145, label %1146, label %1225

; <label>:1146:                                   ; preds = %1138
  %1147 = add nsw i32 %1045, 17
  %1148 = sext i32 %1147 to i64
  %1149 = getelementptr inbounds i8, i8* %.5, i64 %1148
  %1150 = getelementptr [32 x i8], [32 x i8]* @ZERO, i32 0, i32 0
  %1151 = call i32 @memcmp(i8* %1149, i8* %1150, i64 32) #10
  %1152 = icmp ne i32 %1151, 0
  br i1 %1152, label %1153, label %1164

; <label>:1153:                                   ; preds = %1146
  %1154 = getelementptr inbounds %struct.ST_info, %struct.ST_info* %.219, i32 0, i32 2
  %1155 = getelementptr inbounds %struct.WPA_hdsk, %struct.WPA_hdsk* %1154, i32 0, i32 1
  %1156 = getelementptr inbounds [32 x i8], [32 x i8]* %1155, i32 0, i32 0
  %1157 = add nsw i32 %1045, 17
  %1158 = sext i32 %1157 to i64
  %1159 = getelementptr inbounds i8, i8* %.5, i64 %1158
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 2 %1156, i8* align 1 %1159, i64 32, i1 false), !track !152
  %1160 = getelementptr inbounds %struct.ST_info, %struct.ST_info* %.219, i32 0, i32 2
  %1161 = getelementptr inbounds %struct.WPA_hdsk, %struct.WPA_hdsk* %1160, i32 0, i32 7
  %1162 = load i32, i32* %1161, align 8
  %1163 = or i32 %1162, 2
  store i32 %1163, i32* %1161, align 8
  br label %1164

; <label>:1164:                                   ; preds = %1153, %1146
  %1165 = getelementptr inbounds %struct.ST_info, %struct.ST_info* %.219, i32 0, i32 2
  %1166 = getelementptr inbounds %struct.WPA_hdsk, %struct.WPA_hdsk* %1165, i32 0, i32 7
  %1167 = load i32, i32* %1166, align 8
  %1168 = and i32 %1167, 4
  %1169 = icmp ne i32 %1168, 4
  br i1 %1169, label %1170, label %1225

; <label>:1170:                                   ; preds = %1164
  %1171 = add nsw i32 %1045, 2
  %1172 = sext i32 %1171 to i64
  %1173 = getelementptr inbounds i8, i8* %.5, i64 %1172
  %1174 = load i8, i8* %1173, align 1
  %1175 = zext i8 %1174 to i32
  %1176 = shl i32 %1175, 8
  %1177 = add nsw i32 %1045, 3
  %1178 = sext i32 %1177 to i64
  %1179 = getelementptr inbounds i8, i8* %.5, i64 %1178
  %1180 = load i8, i8* %1179, align 1
  %1181 = zext i8 %1180 to i32
  %1182 = add nsw i32 %1176, %1181
  %1183 = add nsw i32 %1182, 4
  %1184 = getelementptr inbounds %struct.ST_info, %struct.ST_info* %.219, i32 0, i32 2
  %1185 = getelementptr inbounds %struct.WPA_hdsk, %struct.WPA_hdsk* %1184, i32 0, i32 5
  store i32 %1183, i32* %1185, align 8
  %1186 = getelementptr inbounds %struct.pcap_pkthdr, %struct.pcap_pkthdr* %9, i32 0, i32 3
  %1187 = load i32, i32* %1186, align 4
  %1188 = sub nsw i32 %1187, %1045
  %1189 = getelementptr inbounds %struct.ST_info, %struct.ST_info* %.219, i32 0, i32 2
  %1190 = getelementptr inbounds %struct.WPA_hdsk, %struct.WPA_hdsk* %1189, i32 0, i32 5
  %1191 = load i32, i32* %1190, align 8
  %1192 = icmp slt i32 %1188, %1191
  br i1 %1192, label %.backedge, label %1193

; <label>:1193:                                   ; preds = %1170
  %1194 = getelementptr inbounds %struct.ST_info, %struct.ST_info* %.219, i32 0, i32 2
  %1195 = getelementptr inbounds %struct.WPA_hdsk, %struct.WPA_hdsk* %1194, i32 0, i32 3
  %1196 = getelementptr inbounds [16 x i8], [16 x i8]* %1195, i32 0, i32 0
  %1197 = add nsw i32 %1045, 81
  %1198 = sext i32 %1197 to i64
  %1199 = getelementptr inbounds i8, i8* %.5, i64 %1198
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 2 %1196, i8* align 1 %1199, i64 16, i1 false), !track !153
  %1200 = getelementptr inbounds %struct.ST_info, %struct.ST_info* %.219, i32 0, i32 2
  %1201 = getelementptr inbounds %struct.WPA_hdsk, %struct.WPA_hdsk* %1200, i32 0, i32 4
  %1202 = getelementptr inbounds [256 x i8], [256 x i8]* %1201, i32 0, i32 0
  %1203 = sext i32 %1045 to i64
  %1204 = getelementptr inbounds i8, i8* %.5, i64 %1203
  %1205 = getelementptr inbounds %struct.ST_info, %struct.ST_info* %.219, i32 0, i32 2
  %1206 = getelementptr inbounds %struct.WPA_hdsk, %struct.WPA_hdsk* %1205, i32 0, i32 5
  %1207 = load i32, i32* %1206, align 8
  %1208 = sext i32 %1207 to i64
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 2 %1202, i8* align 1 %1204, i64 %1208, i1 false), !track !154
  %1209 = getelementptr inbounds %struct.ST_info, %struct.ST_info* %.219, i32 0, i32 2
  %1210 = getelementptr inbounds %struct.WPA_hdsk, %struct.WPA_hdsk* %1209, i32 0, i32 4
  %1211 = getelementptr inbounds [256 x i8], [256 x i8]* %1210, i32 0, i32 0
  %1212 = getelementptr inbounds i8, i8* %1211, i64 81
  call void @llvm.memset.p0i8.i64(i8* align 1 %1212, i8 0, i64 16, i1 false)
  %1213 = getelementptr inbounds %struct.ST_info, %struct.ST_info* %.219, i32 0, i32 2
  %1214 = getelementptr inbounds %struct.WPA_hdsk, %struct.WPA_hdsk* %1213, i32 0, i32 7
  %1215 = load i32, i32* %1214, align 8
  %1216 = or i32 %1215, 4
  store i32 %1216, i32* %1214, align 8
  %1217 = add nsw i32 %1045, 6
  %1218 = sext i32 %1217 to i64
  %1219 = getelementptr inbounds i8, i8* %.5, i64 %1218
  %1220 = load i8, i8* %1219, align 1
  %1221 = zext i8 %1220 to i32
  %1222 = and i32 %1221, 7
  %1223 = getelementptr inbounds %struct.ST_info, %struct.ST_info* %.219, i32 0, i32 2
  %1224 = getelementptr inbounds %struct.WPA_hdsk, %struct.WPA_hdsk* %1223, i32 0, i32 6
  store i32 %1222, i32* %1224, align 4
  br label %1225

; <label>:1225:                                   ; preds = %1164, %1193, %1138, %1130, %1122, %1114
  %1226 = add nsw i32 %1045, 6
  %1227 = sext i32 %1226 to i64
  %1228 = getelementptr inbounds i8, i8* %.5, i64 %1227
  %1229 = load i8, i8* %1228, align 1
  %1230 = zext i8 %1229 to i32
  %1231 = and i32 %1230, 8
  %1232 = icmp ne i32 %1231, 0
  br i1 %1232, label %1233, label %1336

; <label>:1233:                                   ; preds = %1225
  %1234 = add nsw i32 %1045, 6
  %1235 = sext i32 %1234 to i64
  %1236 = getelementptr inbounds i8, i8* %.5, i64 %1235
  %1237 = load i8, i8* %1236, align 1
  %1238 = zext i8 %1237 to i32
  %1239 = and i32 %1238, 64
  %1240 = icmp ne i32 %1239, 0
  br i1 %1240, label %1241, label %1336

; <label>:1241:                                   ; preds = %1233
  %1242 = add nsw i32 %1045, 6
  %1243 = sext i32 %1242 to i64
  %1244 = getelementptr inbounds i8, i8* %.5, i64 %1243
  %1245 = load i8, i8* %1244, align 1
  %1246 = zext i8 %1245 to i32
  %1247 = and i32 %1246, 128
  %1248 = icmp ne i32 %1247, 0
  br i1 %1248, label %1249, label %1336

; <label>:1249:                                   ; preds = %1241
  %1250 = add nsw i32 %1045, 5
  %1251 = sext i32 %1250 to i64
  %1252 = getelementptr inbounds i8, i8* %.5, i64 %1251
  %1253 = load i8, i8* %1252, align 1
  %1254 = zext i8 %1253 to i32
  %1255 = and i32 %1254, 1
  %1256 = icmp ne i32 %1255, 0
  br i1 %1256, label %1257, label %1336

; <label>:1257:                                   ; preds = %1249
  %1258 = add nsw i32 %1045, 17
  %1259 = sext i32 %1258 to i64
  %1260 = getelementptr inbounds i8, i8* %.5, i64 %1259
  %1261 = getelementptr [32 x i8], [32 x i8]* @ZERO, i32 0, i32 0
  %1262 = call i32 @memcmp(i8* %1260, i8* %1261, i64 32) #10
  %1263 = icmp ne i32 %1262, 0
  br i1 %1263, label %1264, label %1275

; <label>:1264:                                   ; preds = %1257
  %1265 = getelementptr inbounds %struct.ST_info, %struct.ST_info* %.219, i32 0, i32 2
  %1266 = getelementptr inbounds %struct.WPA_hdsk, %struct.WPA_hdsk* %1265, i32 0, i32 2
  %1267 = getelementptr inbounds [32 x i8], [32 x i8]* %1266, i32 0, i32 0
  %1268 = add nsw i32 %1045, 17
  %1269 = sext i32 %1268 to i64
  %1270 = getelementptr inbounds i8, i8* %.5, i64 %1269
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 2 %1267, i8* align 1 %1270, i64 32, i1 false), !track !155
  %1271 = getelementptr inbounds %struct.ST_info, %struct.ST_info* %.219, i32 0, i32 2
  %1272 = getelementptr inbounds %struct.WPA_hdsk, %struct.WPA_hdsk* %1271, i32 0, i32 7
  %1273 = load i32, i32* %1272, align 8
  %1274 = or i32 %1273, 1
  store i32 %1274, i32* %1272, align 8
  br label %1275

; <label>:1275:                                   ; preds = %1264, %1257
  %1276 = getelementptr inbounds %struct.ST_info, %struct.ST_info* %.219, i32 0, i32 2
  %1277 = getelementptr inbounds %struct.WPA_hdsk, %struct.WPA_hdsk* %1276, i32 0, i32 7
  %1278 = load i32, i32* %1277, align 8
  %1279 = and i32 %1278, 4
  %1280 = icmp ne i32 %1279, 4
  br i1 %1280, label %1281, label %1336

; <label>:1281:                                   ; preds = %1275
  %1282 = add nsw i32 %1045, 2
  %1283 = sext i32 %1282 to i64
  %1284 = getelementptr inbounds i8, i8* %.5, i64 %1283
  %1285 = load i8, i8* %1284, align 1
  %1286 = zext i8 %1285 to i32
  %1287 = shl i32 %1286, 8
  %1288 = add nsw i32 %1045, 3
  %1289 = sext i32 %1288 to i64
  %1290 = getelementptr inbounds i8, i8* %.5, i64 %1289
  %1291 = load i8, i8* %1290, align 1
  %1292 = zext i8 %1291 to i32
  %1293 = add nsw i32 %1287, %1292
  %1294 = add nsw i32 %1293, 4
  %1295 = getelementptr inbounds %struct.ST_info, %struct.ST_info* %.219, i32 0, i32 2
  %1296 = getelementptr inbounds %struct.WPA_hdsk, %struct.WPA_hdsk* %1295, i32 0, i32 5
  store i32 %1294, i32* %1296, align 8
  %1297 = getelementptr inbounds %struct.pcap_pkthdr, %struct.pcap_pkthdr* %9, i32 0, i32 3
  %1298 = load i32, i32* %1297, align 4
  %1299 = sub nsw i32 %1298, %1045
  %1300 = getelementptr inbounds %struct.ST_info, %struct.ST_info* %.219, i32 0, i32 2
  %1301 = getelementptr inbounds %struct.WPA_hdsk, %struct.WPA_hdsk* %1300, i32 0, i32 5
  %1302 = load i32, i32* %1301, align 8
  %1303 = icmp slt i32 %1299, %1302
  br i1 %1303, label %.backedge, label %1304

; <label>:1304:                                   ; preds = %1281
  %1305 = getelementptr inbounds %struct.ST_info, %struct.ST_info* %.219, i32 0, i32 2
  %1306 = getelementptr inbounds %struct.WPA_hdsk, %struct.WPA_hdsk* %1305, i32 0, i32 3
  %1307 = getelementptr inbounds [16 x i8], [16 x i8]* %1306, i32 0, i32 0
  %1308 = add nsw i32 %1045, 81
  %1309 = sext i32 %1308 to i64
  %1310 = getelementptr inbounds i8, i8* %.5, i64 %1309
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 2 %1307, i8* align 1 %1310, i64 16, i1 false), !track !156
  %1311 = getelementptr inbounds %struct.ST_info, %struct.ST_info* %.219, i32 0, i32 2
  %1312 = getelementptr inbounds %struct.WPA_hdsk, %struct.WPA_hdsk* %1311, i32 0, i32 4
  %1313 = getelementptr inbounds [256 x i8], [256 x i8]* %1312, i32 0, i32 0
  %1314 = sext i32 %1045 to i64
  %1315 = getelementptr inbounds i8, i8* %.5, i64 %1314
  %1316 = getelementptr inbounds %struct.ST_info, %struct.ST_info* %.219, i32 0, i32 2
  %1317 = getelementptr inbounds %struct.WPA_hdsk, %struct.WPA_hdsk* %1316, i32 0, i32 5
  %1318 = load i32, i32* %1317, align 8
  %1319 = sext i32 %1318 to i64
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 2 %1313, i8* align 1 %1315, i64 %1319, i1 false), !track !157
  %1320 = getelementptr inbounds %struct.ST_info, %struct.ST_info* %.219, i32 0, i32 2
  %1321 = getelementptr inbounds %struct.WPA_hdsk, %struct.WPA_hdsk* %1320, i32 0, i32 4
  %1322 = getelementptr inbounds [256 x i8], [256 x i8]* %1321, i32 0, i32 0
  %1323 = getelementptr inbounds i8, i8* %1322, i64 81
  call void @llvm.memset.p0i8.i64(i8* align 1 %1323, i8 0, i64 16, i1 false)
  %1324 = getelementptr inbounds %struct.ST_info, %struct.ST_info* %.219, i32 0, i32 2
  %1325 = getelementptr inbounds %struct.WPA_hdsk, %struct.WPA_hdsk* %1324, i32 0, i32 7
  %1326 = load i32, i32* %1325, align 8
  %1327 = or i32 %1326, 4
  store i32 %1327, i32* %1325, align 8
  %1328 = add nsw i32 %1045, 6
  %1329 = sext i32 %1328 to i64
  %1330 = getelementptr inbounds i8, i8* %.5, i64 %1329
  %1331 = load i8, i8* %1330, align 1
  %1332 = zext i8 %1331 to i32
  %1333 = and i32 %1332, 7
  %1334 = getelementptr inbounds %struct.ST_info, %struct.ST_info* %.219, i32 0, i32 2
  %1335 = getelementptr inbounds %struct.WPA_hdsk, %struct.WPA_hdsk* %1334, i32 0, i32 6
  store i32 %1333, i32* %1335, align 4
  br label %1336

; <label>:1336:                                   ; preds = %1275, %1304, %1249, %1241, %1233, %1225
  %1337 = getelementptr inbounds %struct.ST_info, %struct.ST_info* %.219, i32 0, i32 2
  %1338 = getelementptr inbounds %struct.WPA_hdsk, %struct.WPA_hdsk* %1337, i32 0, i32 7
  %1339 = load i32, i32* %1338, align 8
  %1340 = icmp eq i32 %1339, 7
  br i1 %1340, label %1341, label %1350

; <label>:1341:                                   ; preds = %1336
  %1342 = getelementptr inbounds %struct.ST_info, %struct.ST_info* %.219, i32 0, i32 2
  %1343 = getelementptr inbounds %struct.WPA_hdsk, %struct.WPA_hdsk* %1342, i32 0, i32 0
  %1344 = getelementptr inbounds [6 x i8], [6 x i8]* %1343, i32 0, i32 0
  %1345 = getelementptr inbounds [6 x i8], [6 x i8]* %5, i32 0, i32 0
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %1344, i8* align 1 %1345, i64 6, i1 false), !track !158
  %1346 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.214, i32 0, i32 14
  %1347 = bitcast %struct.WPA_hdsk* %1346 to i8*
  %1348 = getelementptr inbounds %struct.ST_info, %struct.ST_info* %.219, i32 0, i32 2
  %1349 = bitcast %struct.WPA_hdsk* %1348 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %1347, i8* align 8 %1349, i64 356, i1 false), !track !159
  br label %1350

; <label>:1350:                                   ; preds = %1336, %1341, %1044, %1060, %1031, %1037, %963, %927, %876, %870, %529, %523, %514, %612, %607, %625, %619, %559, %564, %592, %582, %544, %496, %501, %446, %421, %407, %361, %357
  %.315 = phi %struct.AP_info* [ %.01239, %357 ], [ %.01239, %361 ], [ %.01239, %407 ], [ %.01239, %421 ], [ %.01239, %446 ], [ %.214, %501 ], [ %.214, %496 ], [ %.214, %544 ], [ %.214, %582 ], [ %.214, %592 ], [ %.214, %564 ], [ %.214, %559 ], [ %.214, %619 ], [ %.214, %625 ], [ %.214, %607 ], [ %.214, %612 ], [ %.214, %514 ], [ %.214, %523 ], [ %.214, %529 ], [ %.214, %870 ], [ %.214, %876 ], [ %.214, %927 ], [ %.214, %963 ], [ %.214, %1037 ], [ %.214, %1031 ], [ %.214, %1060 ], [ %.214, %1044 ], [ %.214, %1341 ], [ %.214, %1336 ]
  %1351 = call i32 @pthread_mutex_unlock(%union.pthread_mutex_t* @mx_apl) #9
  %1352 = icmp ne %struct.AP_info* %.315, null
  br i1 %1352, label %1353, label %.backedge

; <label>:1353:                                   ; preds = %1350
  %1354 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.315, i32 0, i32 7
  %1355 = load i64, i64* %1354, align 8
  %1356 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 33
  %1357 = load i32, i32* %1356, align 8
  %1358 = sext i32 %1357 to i64
  %1359 = icmp sge i64 %1355, %1358
  br i1 %1359, label %._crit_edge.loopexit, label %.backedge

.backedge:                                        ; preds = %1350, %1353, %1281, %1170, %340, %342, %322, %328, %302, %308, %286, %288, %1071
  %.012.be = phi %struct.AP_info* [ %.214, %1071 ], [ %.01239, %288 ], [ %.01239, %286 ], [ %.01239, %308 ], [ %.01239, %302 ], [ %.01239, %328 ], [ %.01239, %322 ], [ %.01239, %342 ], [ %.01239, %340 ], [ %.214, %1170 ], [ %.214, %1281 ], [ %.315, %1353 ], [ %.315, %1350 ]
  %.06.be = phi i8* [ %.5, %1071 ], [ %14, %288 ], [ %14, %286 ], [ %.17, %308 ], [ %.17, %302 ], [ %.28, %328 ], [ %.28, %322 ], [ %.28, %342 ], [ %.28, %340 ], [ %.5, %1170 ], [ %.5, %1281 ], [ %.5, %1353 ], [ %.5, %1350 ]
  %1360 = load i32, i32* @close_aircrack, align 4
  %1361 = icmp ne i32 %1360, 0
  br i1 %1361, label %._crit_edge.loopexit, label %.lr.ph44

._crit_edge.loopexit:                             ; preds = %157, %166, %175, %179, %190, %201, %208, %252, %1353, %.backedge
  br label %._crit_edge

._crit_edge:                                      ; preds = %._crit_edge.loopexit, %472, %671, %154, %246, %152, %136, %129, %110, %67, %58, %38, %32, %16
  %1362 = getelementptr inbounds %struct.read_buf, %struct.read_buf* %2, i32 0, i32 2
  %1363 = load i8*, i8** %1362, align 8
  %1364 = icmp ne i8* %1363, null
  br i1 %1364, label %1365, label %1369

; <label>:1365:                                   ; preds = %._crit_edge
  %1366 = getelementptr inbounds %struct.read_buf, %struct.read_buf* %2, i32 0, i32 2
  %1367 = load i8*, i8** %1366, align 8
  call void @free(i8* %1367) #9
  %1368 = getelementptr inbounds %struct.read_buf, %struct.read_buf* %2, i32 0, i32 2
  store i8* null, i8** %1368, align 8
  br label %1369

; <label>:1369:                                   ; preds = %1365, %._crit_edge
  %1370 = getelementptr inbounds %struct.read_buf, %struct.read_buf* %2, i32 0, i32 3
  %1371 = load i8*, i8** %1370, align 8
  %1372 = icmp ne i8* %1371, null
  br i1 %1372, label %1373, label %1377

; <label>:1373:                                   ; preds = %1369
  %1374 = getelementptr inbounds %struct.read_buf, %struct.read_buf* %2, i32 0, i32 3
  %1375 = load i8*, i8** %1374, align 8
  call void @free(i8* %1375) #9
  %1376 = getelementptr inbounds %struct.read_buf, %struct.read_buf* %2, i32 0, i32 3
  store i8* null, i8** %1376, align 8
  br label %1377

; <label>:1377:                                   ; preds = %1373, %1369
  %1378 = icmp ne i8* %14, null
  br i1 %1378, label %1379, label %1380

; <label>:1379:                                   ; preds = %1377
  call void @free(i8* %14) #9
  br label %1380

; <label>:1380:                                   ; preds = %1379, %1377
  ret void
}

; Function Attrs: noinline nounwind uwtable
define dso_local float @chrono(%struct.timeval*, i32) #0 {
  %3 = alloca %struct.timeval, align 8
  %4 = call i32 @gettimeofday(%struct.timeval* %3, %struct.vote* null) #9
  %5 = getelementptr inbounds %struct.timeval, %struct.timeval* %3, i32 0, i32 0
  %6 = load i64, i64* %5, align 8
  %7 = getelementptr inbounds %struct.timeval, %struct.timeval* %0, i32 0, i32 0
  %8 = load i64, i64* %7, align 8
  %9 = sub nsw i64 %6, %8
  %10 = sitofp i64 %9 to float
  %11 = getelementptr inbounds %struct.timeval, %struct.timeval* %3, i32 0, i32 1
  %12 = load i64, i64* %11, align 8
  %13 = getelementptr inbounds %struct.timeval, %struct.timeval* %0, i32 0, i32 1
  %14 = load i64, i64* %13, align 8
  %15 = sub nsw i64 %12, %14
  %16 = sitofp i64 %15 to float
  %17 = fdiv float %16, 1.000000e+06
  %18 = fadd float %10, %17
  %19 = icmp ne i32 %1, 0
  br i1 %19, label %20, label %22

; <label>:20:                                     ; preds = %2
  %21 = call i32 @gettimeofday(%struct.timeval* %0, %struct.vote* null) #9
  br label %22

; <label>:22:                                     ; preds = %20, %2
  ret float %18
}

; Function Attrs: nounwind
declare dso_local i32 @gettimeofday(%struct.timeval*, %struct.vote*) #2

; Function Attrs: noinline nounwind uwtable
define dso_local i32 @safe_read(i32, i8*, i64) #0 {
  %4 = icmp ult i64 0, %2
  br i1 %4, label %.lr.ph.preheader, label %.outer._crit_edge

.lr.ph.preheader:                                 ; preds = %3
  br label %.lr.ph

.lr.ph:                                           ; preds = %.lr.ph.preheader, %.outer
  %5 = phi i1 [ %24, %.outer ], [ %4, %.lr.ph.preheader ]
  %.01.ph14 = phi i8* [ %23, %.outer ], [ %1, %.lr.ph.preheader ]
  %.02.ph13 = phi i64 [ %21, %.outer ], [ 0, %.lr.ph.preheader ]
  call void @unroll_loop(i32 50)
  br label %7

; <label>:6:                                      ; preds = %14
  br i1 %5, label %7, label %.outer._crit_edge.loopexit

; <label>:7:                                      ; preds = %.lr.ph, %6
  call void @unroll_loop(i32 51)
  %8 = sub i64 %2, %.02.ph13
  %9 = call i64 @read(i32 %0, i8* %.01.ph14, i64 %8)
  %10 = trunc i64 %9 to i32
  %11 = icmp ne i32 %10, 0
  br i1 %11, label %12, label %.loopexit

; <label>:12:                                     ; preds = %7
  %13 = icmp slt i32 %10, 0
  br i1 %13, label %14, label %18

; <label>:14:                                     ; preds = %12
  %15 = call i32* @__errno_location() #13
  %16 = load i32, i32* %15, align 4
  %17 = icmp eq i32 %16, 4
  br i1 %17, label %6, label %18

; <label>:18:                                     ; preds = %14, %12
  %.lcssa11 = phi i32 [ %10, %14 ], [ %10, %12 ]
  %19 = icmp slt i32 %.lcssa11, 0
  br i1 %19, label %.loopexit1, label %.outer

.outer:                                           ; preds = %18
  %20 = sext i32 %.lcssa11 to i64
  %21 = add i64 %.02.ph13, %20
  %22 = sext i32 %.lcssa11 to i64
  %23 = getelementptr inbounds i8, i8* %.01.ph14, i64 %22
  %24 = icmp ult i64 %21, %2
  br i1 %24, label %.lr.ph, label %.outer._crit_edge.loopexit3

.outer._crit_edge.loopexit:                       ; preds = %6
  %.02.lcssa.ph = phi i64 [ %.02.ph13, %6 ]
  br label %.outer._crit_edge

.outer._crit_edge.loopexit3:                      ; preds = %.outer
  %.02.lcssa.ph4 = phi i64 [ %21, %.outer ]
  br label %.outer._crit_edge

.outer._crit_edge:                                ; preds = %.outer._crit_edge.loopexit3, %.outer._crit_edge.loopexit, %3
  %.02.lcssa = phi i64 [ 0, %3 ], [ %.02.lcssa.ph, %.outer._crit_edge.loopexit ], [ %.02.lcssa.ph4, %.outer._crit_edge.loopexit3 ]
  %25 = trunc i64 %.02.lcssa to i32
  br label %26

.loopexit:                                        ; preds = %7
  %.0.ph = phi i32 [ 0, %7 ]
  br label %26

.loopexit1:                                       ; preds = %18
  %.0.ph2 = phi i32 [ %.lcssa11, %18 ]
  br label %26

; <label>:26:                                     ; preds = %.loopexit1, %.loopexit, %.outer._crit_edge
  %.0 = phi i32 [ %25, %.outer._crit_edge ], [ %.0.ph, %.loopexit ], [ %.0.ph2, %.loopexit1 ]
  ret i32 %.0
}

; Function Attrs: noinline nounwind uwtable
define dso_local i32 @crack_wep_thread(i8*) #0 {
  %2 = alloca [256 x i8], align 16, !track !160
  %3 = alloca [256 x i8], align 16, !track !161
  %4 = alloca [256 x i8], align 16, !track !162
  %5 = alloca [64 x i8], align 16, !track !163
  %6 = alloca i32, align 4
  %7 = alloca [17 x [256 x i32]], align 16, !track !164
  %8 = ptrtoint i8* %0 to i64
  %9 = trunc i64 %8 to i32
  %10 = getelementptr inbounds [256 x i8], [256 x i8]* %3, i32 0, i32 0
  %11 = getelementptr [256 x i8], [256 x i8]* @R, i32 0, i32 0
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 16 %10, i8* align 16 %11, i64 256, i1 false), !track !165
  %12 = getelementptr inbounds [256 x i8], [256 x i8]* %4, i32 0, i32 0
  %13 = getelementptr [256 x i8], [256 x i8]* @R, i32 0, i32 0
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 16 %12, i8* align 16 %13, i64 256, i1 false), !track !166
  br label %14

; <label>:14:                                     ; preds = %651, %1
  %.04 = phi i32 [ 1, %1 ], [ %.37, %651 ]
  %.0 = phi i32 [ 0, %1 ], [ %.3, %651 ]
  call void @unroll_loop(i32 52)
  %15 = icmp ne i32 %.04, 0
  br i1 %15, label %18, label %16

; <label>:16:                                     ; preds = %14
  %17 = load i32, i32* %6, align 4
  br label %18

; <label>:18:                                     ; preds = %16, %14
  %19 = sext i32 %9 to i64
  %20 = getelementptr inbounds [256 x [2 x i32]], [256 x [2 x i32]]* @mc_pipe, i64 0, i64 %19
  %21 = getelementptr inbounds [2 x i32], [2 x i32]* %20, i64 0, i64 0
  %22 = load i32, i32* %21, align 8
  %23 = bitcast i32* %6 to i8*
  %24 = call i32 @safe_read(i32 %22, i8* %23, i64 4)
  %25 = sext i32 %24 to i64
  %26 = icmp ne i64 %25, 4
  br i1 %26, label %27, label %30

; <label>:27:                                     ; preds = %18
  %28 = getelementptr [12 x i8], [12 x i8]* @.str.27, i32 0, i32 0
  call void @perror(i8* %28)
  %29 = call i32 @kill(i32 0, i32 15) #9
  call void @_exit(i32 1) #12
  unreachable

; <label>:30:                                     ; preds = %18
  %31 = load i32, i32* @close_aircrack, align 4
  %32 = icmp ne i32 %31, 0
  br i1 %32, label %664, label %33

; <label>:33:                                     ; preds = %30
  %34 = sext i32 %9 to i64
  %35 = getelementptr %struct.WEP_data, %struct.WEP_data* @wep, i32 0, i32 3
  %36 = load i64, i64* %35, align 8
  %37 = mul nsw i64 %34, %36
  %38 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 5
  %39 = load i32, i32* %38, align 4
  %40 = sext i32 %39 to i64
  %41 = sdiv i64 %37, %40
  %42 = mul nsw i64 5, %41
  %43 = add nsw i32 1, %9
  %44 = sext i32 %43 to i64
  %45 = getelementptr %struct.WEP_data, %struct.WEP_data* @wep, i32 0, i32 3
  %46 = load i64, i64* %45, align 8
  %47 = mul nsw i64 %44, %46
  %48 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 5
  %49 = load i32, i32* %48, align 4
  %50 = sext i32 %49 to i64
  %51 = sdiv i64 %47, %50
  %52 = mul nsw i64 5, %51
  %53 = load i32, i32* %6, align 4
  %54 = add nsw i32 3, %53
  %55 = trunc i32 %54 to i8
  %56 = getelementptr inbounds [64 x i8], [64 x i8]* %5, i32 0, i32 0
  %57 = getelementptr inbounds i8, i8* %56, i64 3
  %58 = load i32, i32* %6, align 4
  %59 = sext i32 %58 to i64
  %60 = getelementptr %struct.WEP_data, %struct.WEP_data* @wep, i32 0, i32 0, i32 0
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %57, i8* align 8 %60, i64 %59, i1 false), !track !167
  %61 = getelementptr inbounds [17 x [256 x i32]], [17 x [256 x i32]]* %7, i32 0, i32 0
  %62 = bitcast [256 x i32]* %61 to i8*
  call void @llvm.memset.p0i8.i64(i8* align 16 %62, i8 0, i64 17408, i1 false)
  %63 = zext i8 %55 to i64
  %64 = icmp slt i64 %42, %52
  br i1 %64, label %.lr.ph31, label %.loopexit

.lr.ph31:                                         ; preds = %33
  %65 = zext i8 %55 to i64
  br label %66

; <label>:66:                                     ; preds = %.lr.ph31, %646
  %.127 = phi i32 [ %.0, %.lr.ph31 ], [ %.2, %646 ]
  %.0126 = phi i64 [ %42, %.lr.ph31 ], [ %647, %646 ]
  %.0225 = phi i32 [ 1, %.lr.ph31 ], [ %.13, %646 ]
  %.1524 = phi i32 [ %.04, %.lr.ph31 ], [ %spec.select, %646 ]
  call void @unroll_loop(i32 53)
  %67 = icmp eq i32 %.1524, 0
  %68 = icmp slt i32 0, %.127
  %or.cond24 = and i1 %67, %68
  br i1 %or.cond24, label %.lr.ph, label %._crit_edge

.lr.ph:                                           ; preds = %66
  %69 = zext i32 %.127 to i64
  br label %70

; <label>:70:                                     ; preds = %.lr.ph, %70
  %indvars.iv = phi i64 [ 0, %.lr.ph ], [ %indvars.iv.next, %70 ]
  call void @unroll_loop(i32 54)
  %71 = trunc i64 %indvars.iv to i32
  %72 = trunc i32 %71 to i8
  %73 = getelementptr inbounds [256 x i8], [256 x i8]* %4, i64 0, i64 %indvars.iv
  store i8 %72, i8* %73, align 1
  %74 = getelementptr inbounds [256 x i8], [256 x i8]* %3, i64 0, i64 %indvars.iv
  store i8 %72, i8* %74, align 1
  %75 = getelementptr inbounds [256 x i8], [256 x i8]* %2, i64 0, i64 %indvars.iv
  %76 = load i8, i8* %75, align 1
  %77 = getelementptr inbounds [256 x i8], [256 x i8]* %2, i64 0, i64 %indvars.iv
  %78 = load i8, i8* %77, align 1
  %79 = zext i8 %78 to i64
  %80 = getelementptr inbounds [256 x i8], [256 x i8]* %4, i64 0, i64 %79
  store i8 %76, i8* %80, align 1
  %81 = getelementptr inbounds [256 x i8], [256 x i8]* %2, i64 0, i64 %indvars.iv
  %82 = load i8, i8* %81, align 1
  %83 = zext i8 %82 to i64
  %84 = getelementptr inbounds [256 x i8], [256 x i8]* %3, i64 0, i64 %83
  store i8 %76, i8* %84, align 1
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond1 = icmp ne i64 %indvars.iv.next, %69
  br i1 %exitcond1, label %70, label %._crit_edge.loopexit

._crit_edge.loopexit:                             ; preds = %70
  br label %._crit_edge

._crit_edge:                                      ; preds = %._crit_edge.loopexit, %66
  %85 = call i32 @pthread_mutex_lock(%union.pthread_mutex_t* @mx_ivb) #9
  %86 = getelementptr inbounds [64 x i8], [64 x i8]* %5, i32 0, i32 0
  %87 = getelementptr %struct.WEP_data, %struct.WEP_data* @wep, i32 0, i32 1
  %88 = load i8*, i8** %87, align 8
  %89 = getelementptr inbounds i8, i8* %88, i64 %.0126
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 16 %86, i8* align 1 %89, i64 3, i1 false), !track !168
  %90 = zext i8 %55 to i32
  %91 = icmp slt i32 0, %90
  br i1 %91, label %.lr.ph16.preheader, label %._crit_edge17

.lr.ph16.preheader:                               ; preds = %._crit_edge
  br label %.lr.ph16

.lr.ph16:                                         ; preds = %.lr.ph16.preheader, %.lr.ph16
  %indvars.iv18 = phi i64 [ %indvars.iv.next19, %.lr.ph16 ], [ 0, %.lr.ph16.preheader ]
  %.0814 = phi i32 [ %100, %.lr.ph16 ], [ 0, %.lr.ph16.preheader ]
  call void @unroll_loop(i32 55)
  %92 = getelementptr inbounds [256 x i8], [256 x i8]* %3, i64 0, i64 %indvars.iv18
  %93 = load i8, i8* %92, align 1
  %94 = zext i8 %93 to i32
  %95 = add nsw i32 %.0814, %94
  %96 = getelementptr inbounds [64 x i8], [64 x i8]* %5, i64 0, i64 %indvars.iv18
  %97 = load i8, i8* %96, align 1
  %98 = zext i8 %97 to i32
  %99 = add nsw i32 %95, %98
  %100 = and i32 %99, 255
  %101 = trunc i32 %100 to i8
  %102 = getelementptr inbounds [256 x i8], [256 x i8]* %2, i64 0, i64 %indvars.iv18
  store i8 %101, i8* %102, align 1
  %103 = getelementptr inbounds [256 x i8], [256 x i8]* %3, i64 0, i64 %indvars.iv18
  %104 = load i8, i8* %103, align 1
  %105 = sext i32 %100 to i64
  %106 = getelementptr inbounds [256 x i8], [256 x i8]* %3, i64 0, i64 %105
  %107 = load i8, i8* %106, align 1
  %108 = getelementptr inbounds [256 x i8], [256 x i8]* %3, i64 0, i64 %indvars.iv18
  store i8 %107, i8* %108, align 1
  %109 = sext i32 %100 to i64
  %110 = getelementptr inbounds [256 x i8], [256 x i8]* %3, i64 0, i64 %109
  store i8 %104, i8* %110, align 1
  %indvars.iv.next19 = add nuw nsw i64 %indvars.iv18, 1
  %exitcond = icmp ne i64 %indvars.iv.next19, %65
  br i1 %exitcond, label %.lr.ph16, label %._crit_edge17.loopexit

._crit_edge17.loopexit:                           ; preds = %.lr.ph16
  br label %._crit_edge17

._crit_edge17:                                    ; preds = %._crit_edge17.loopexit, %._crit_edge
  %sext = sext i32 0 to i64
  br label %111

; <label>:111:                                    ; preds = %111, %._crit_edge17
  %indvars.iv22 = phi i64 [ %indvars.iv.next23, %111 ], [ %63, %._crit_edge17 ]
  call void @unroll_loop(i32 56)
  %indvars.iv.next23 = add nsw i64 %indvars.iv22, -1
  %112 = getelementptr inbounds [256 x i8], [256 x i8]* %4, i64 0, i64 %indvars.iv.next23
  %113 = load i8, i8* %112, align 1
  %114 = getelementptr inbounds [256 x i8], [256 x i8]* %2, i64 0, i64 %indvars.iv.next23
  %115 = load i8, i8* %114, align 1
  %116 = zext i8 %115 to i64
  %117 = getelementptr inbounds [256 x i8], [256 x i8]* %4, i64 0, i64 %116
  %118 = load i8, i8* %117, align 1
  %119 = getelementptr inbounds [256 x i8], [256 x i8]* %4, i64 0, i64 %indvars.iv.next23
  store i8 %118, i8* %119, align 1
  %120 = getelementptr inbounds [256 x i8], [256 x i8]* %2, i64 0, i64 %indvars.iv.next23
  %121 = load i8, i8* %120, align 1
  %122 = zext i8 %121 to i64
  %123 = getelementptr inbounds [256 x i8], [256 x i8]* %4, i64 0, i64 %122
  store i8 %113, i8* %123, align 1
  %124 = icmp ne i64 %indvars.iv.next23, %sext
  br i1 %124, label %111, label %125

; <label>:125:                                    ; preds = %111
  %126 = getelementptr %struct.WEP_data, %struct.WEP_data* @wep, i32 0, i32 1
  %127 = load i8*, i8** %126, align 8
  %128 = add nsw i64 %.0126, 3
  %129 = getelementptr inbounds i8, i8* %127, i64 %128
  %130 = load i8, i8* %129, align 1
  %131 = zext i8 %130 to i32
  %132 = xor i32 %131, 170
  %133 = trunc i32 %132 to i8
  %134 = zext i8 %133 to i64
  %135 = getelementptr inbounds [256 x i8], [256 x i8]* %4, i64 0, i64 %134
  %136 = load i8, i8* %135, align 1
  %137 = getelementptr inbounds [256 x i8], [256 x i8]* %3, i64 0, i64 1
  %138 = load i8, i8* %137, align 1
  %139 = getelementptr %struct.WEP_data, %struct.WEP_data* @wep, i32 0, i32 1
  %140 = load i8*, i8** %139, align 8
  %141 = add nsw i64 %.0126, 4
  %142 = getelementptr inbounds i8, i8* %140, i64 %141
  %143 = load i8, i8* %142, align 1
  %144 = zext i8 %143 to i32
  %145 = xor i32 %144, 170
  %146 = trunc i32 %145 to i8
  %147 = zext i8 %146 to i64
  %148 = getelementptr inbounds [256 x i8], [256 x i8]* %4, i64 0, i64 %147
  %149 = load i8, i8* %148, align 1
  %150 = getelementptr inbounds [256 x i8], [256 x i8]* %3, i64 0, i64 2
  %151 = load i8, i8* %150, align 2
  %152 = call i32 @pthread_mutex_unlock(%union.pthread_mutex_t* @mx_ivb) #9
  %153 = icmp ne i32 %.1524, 0
  %spec.select = select i1 %153, i32 0, i32 %.1524
  %154 = icmp ne i32 %.0225, 0
  %155 = load i32, i32* %6, align 4
  %156 = add nsw i32 3, %155
  %.13 = select i1 %154, i32 0, i32 %.0225
  %.2 = select i1 %154, i32 %156, i32 %.127
  %157 = zext i8 %55 to i64
  %158 = getelementptr inbounds [256 x i8], [256 x i8]* %3, i64 0, i64 %157
  %159 = load i8, i8* %158, align 1
  %160 = zext i8 %159 to i32
  %161 = zext i8 %55 to i32
  %162 = sub nsw i32 %161, 1
  %163 = sext i32 %162 to i64
  %164 = getelementptr inbounds [256 x i8], [256 x i8]* %2, i64 0, i64 %163
  %165 = load i8, i8* %164, align 1
  %166 = zext i8 %165 to i32
  %167 = add nsw i32 %160, %166
  %168 = trunc i32 %167 to i8
  %169 = zext i8 %151 to i32
  %170 = icmp eq i32 %169, 0
  br i1 %170, label %171, label %205

; <label>:171:                                    ; preds = %125
  %172 = zext i8 %138 to i32
  %173 = icmp eq i32 %172, 2
  %174 = zext i8 %133 to i32
  %175 = icmp eq i32 %174, 2
  %or.cond = and i1 %173, %175
  br i1 %or.cond, label %176, label %193

; <label>:176:                                    ; preds = %171
  %177 = zext i8 %168 to i32
  %178 = sub nsw i32 1, %177
  %179 = trunc i32 %178 to i8
  %180 = getelementptr inbounds [17 x [256 x i32]], [17 x [256 x i32]]* %7, i64 0, i64 16
  %181 = zext i8 %179 to i64
  %182 = getelementptr inbounds [256 x i32], [256 x i32]* %180, i64 0, i64 %181
  %183 = load i32, i32* %182, align 4
  %184 = add nsw i32 %183, 1
  store i32 %184, i32* %182, align 4
  %185 = zext i8 %168 to i32
  %186 = sub nsw i32 2, %185
  %187 = trunc i32 %186 to i8
  %188 = getelementptr inbounds [17 x [256 x i32]], [17 x [256 x i32]]* %7, i64 0, i64 16
  %189 = zext i8 %187 to i64
  %190 = getelementptr inbounds [256 x i32], [256 x i32]* %188, i64 0, i64 %189
  %191 = load i32, i32* %190, align 4
  %192 = add nsw i32 %191, 1
  store i32 %192, i32* %190, align 4
  br label %219

; <label>:193:                                    ; preds = %171
  %194 = zext i8 %146 to i32
  %195 = icmp eq i32 %194, 0
  br i1 %195, label %196, label %219

; <label>:196:                                    ; preds = %193
  %197 = zext i8 %168 to i32
  %198 = sub nsw i32 2, %197
  %199 = trunc i32 %198 to i8
  %200 = getelementptr inbounds [17 x [256 x i32]], [17 x [256 x i32]]* %7, i64 0, i64 16
  %201 = zext i8 %199 to i64
  %202 = getelementptr inbounds [256 x i32], [256 x i32]* %200, i64 0, i64 %201
  %203 = load i32, i32* %202, align 4
  %204 = add nsw i32 %203, 1
  store i32 %204, i32* %202, align 4
  br label %219

; <label>:205:                                    ; preds = %125
  %206 = zext i8 %146 to i32
  %207 = icmp eq i32 %206, 0
  %208 = zext i8 %159 to i32
  %209 = icmp eq i32 %208, 0
  %or.cond3 = and i1 %207, %209
  br i1 %or.cond3, label %210, label %219

; <label>:210:                                    ; preds = %205
  %211 = zext i8 %168 to i32
  %212 = sub nsw i32 2, %211
  %213 = trunc i32 %212 to i8
  %214 = getelementptr inbounds [17 x [256 x i32]], [17 x [256 x i32]]* %7, i64 0, i64 0
  %215 = zext i8 %213 to i64
  %216 = getelementptr inbounds [256 x i32], [256 x i32]* %214, i64 0, i64 %215
  %217 = load i32, i32* %216, align 4
  %218 = add nsw i32 %217, 1
  store i32 %218, i32* %216, align 4
  br label %219

; <label>:219:                                    ; preds = %205, %210, %176, %196, %193
  %220 = zext i8 %138 to i32
  %221 = icmp eq i32 %220, 1
  br i1 %221, label %222, label %243

; <label>:222:                                    ; preds = %219
  %223 = zext i8 %133 to i32
  %224 = zext i8 %151 to i32
  %225 = icmp eq i32 %223, %224
  br i1 %225, label %226, label %243

; <label>:226:                                    ; preds = %222
  %227 = zext i8 %168 to i32
  %228 = sub nsw i32 1, %227
  %229 = trunc i32 %228 to i8
  %230 = getelementptr inbounds [17 x [256 x i32]], [17 x [256 x i32]]* %7, i64 0, i64 16
  %231 = zext i8 %229 to i64
  %232 = getelementptr inbounds [256 x i32], [256 x i32]* %230, i64 0, i64 %231
  %233 = load i32, i32* %232, align 4
  %234 = add nsw i32 %233, 1
  store i32 %234, i32* %232, align 4
  %235 = zext i8 %168 to i32
  %236 = sub nsw i32 2, %235
  %237 = trunc i32 %236 to i8
  %238 = getelementptr inbounds [17 x [256 x i32]], [17 x [256 x i32]]* %7, i64 0, i64 16
  %239 = zext i8 %237 to i64
  %240 = getelementptr inbounds [256 x i32], [256 x i32]* %238, i64 0, i64 %239
  %241 = load i32, i32* %240, align 4
  %242 = add nsw i32 %241, 1
  store i32 %242, i32* %240, align 4
  br label %243

; <label>:243:                                    ; preds = %226, %222, %219
  %244 = zext i8 %138 to i32
  %245 = icmp eq i32 %244, 0
  br i1 %245, label %246, label %270

; <label>:246:                                    ; preds = %243
  %247 = getelementptr inbounds [256 x i8], [256 x i8]* %3, i64 0, i64 0
  %248 = load i8, i8* %247, align 16
  %249 = zext i8 %248 to i32
  %250 = icmp eq i32 %249, 1
  %251 = zext i8 %133 to i32
  %252 = icmp eq i32 %251, 1
  %or.cond5 = and i1 %250, %252
  br i1 %or.cond5, label %253, label %270

; <label>:253:                                    ; preds = %246
  %254 = zext i8 %168 to i32
  %255 = sub nsw i32 0, %254
  %256 = trunc i32 %255 to i8
  %257 = getelementptr inbounds [17 x [256 x i32]], [17 x [256 x i32]]* %7, i64 0, i64 16
  %258 = zext i8 %256 to i64
  %259 = getelementptr inbounds [256 x i32], [256 x i32]* %257, i64 0, i64 %258
  %260 = load i32, i32* %259, align 4
  %261 = add nsw i32 %260, 1
  store i32 %261, i32* %259, align 4
  %262 = zext i8 %168 to i32
  %263 = sub nsw i32 1, %262
  %264 = trunc i32 %263 to i8
  %265 = getelementptr inbounds [17 x [256 x i32]], [17 x [256 x i32]]* %7, i64 0, i64 16
  %266 = zext i8 %264 to i64
  %267 = getelementptr inbounds [256 x i32], [256 x i32]* %265, i64 0, i64 %266
  %268 = load i32, i32* %267, align 4
  %269 = add nsw i32 %268, 1
  store i32 %269, i32* %267, align 4
  br label %270

; <label>:270:                                    ; preds = %253, %246, %243
  %271 = zext i8 %138 to i32
  %272 = zext i8 %55 to i32
  %273 = icmp eq i32 %271, %272
  br i1 %273, label %274, label %330

; <label>:274:                                    ; preds = %270
  %275 = zext i8 %133 to i32
  %276 = zext i8 %55 to i32
  %277 = icmp eq i32 %275, %276
  br i1 %277, label %278, label %290

; <label>:278:                                    ; preds = %274
  %279 = getelementptr inbounds [256 x i8], [256 x i8]* %4, i64 0, i64 0
  %280 = load i8, i8* %279, align 16
  %281 = zext i8 %280 to i32
  %282 = zext i8 %168 to i32
  %283 = sub nsw i32 %281, %282
  %284 = trunc i32 %283 to i8
  %285 = getelementptr inbounds [17 x [256 x i32]], [17 x [256 x i32]]* %7, i64 0, i64 1
  %286 = zext i8 %284 to i64
  %287 = getelementptr inbounds [256 x i32], [256 x i32]* %285, i64 0, i64 %286
  %288 = load i32, i32* %287, align 4
  %289 = add nsw i32 %288, 1
  store i32 %289, i32* %287, align 4
  br label %330

; <label>:290:                                    ; preds = %274
  %291 = zext i8 %55 to i32
  %292 = sub nsw i32 1, %291
  %293 = zext i8 %133 to i32
  %294 = sub nsw i32 %292, %293
  %295 = and i32 %294, 255
  %296 = icmp eq i32 %295, 0
  %297 = zext i8 %136 to i32
  br i1 %296, label %298, label %307

; <label>:298:                                    ; preds = %290
  %299 = zext i8 %168 to i32
  %300 = sub nsw i32 %297, %299
  %301 = trunc i32 %300 to i8
  %302 = getelementptr inbounds [17 x [256 x i32]], [17 x [256 x i32]]* %7, i64 0, i64 2
  %303 = zext i8 %301 to i64
  %304 = getelementptr inbounds [256 x i32], [256 x i32]* %302, i64 0, i64 %303
  %305 = load i32, i32* %304, align 4
  %306 = add nsw i32 %305, 1
  store i32 %306, i32* %304, align 4
  br label %330

; <label>:307:                                    ; preds = %290
  %308 = zext i8 %55 to i32
  %309 = icmp slt i32 %297, %308
  br i1 %309, label %310, label %330

; <label>:310:                                    ; preds = %307
  %311 = zext i8 %136 to i32
  %312 = zext i8 %55 to i32
  %313 = sub nsw i32 %311, %312
  %314 = and i32 %313, 255
  %315 = sext i32 %314 to i64
  %316 = getelementptr inbounds [256 x i8], [256 x i8]* %4, i64 0, i64 %315
  %317 = load i8, i8* %316, align 1
  %318 = zext i8 %317 to i32
  %319 = icmp ne i32 %318, 1
  br i1 %319, label %320, label %330

; <label>:320:                                    ; preds = %310
  %321 = zext i8 %317 to i32
  %322 = zext i8 %168 to i32
  %323 = sub nsw i32 %321, %322
  %324 = trunc i32 %323 to i8
  %325 = getelementptr inbounds [17 x [256 x i32]], [17 x [256 x i32]]* %7, i64 0, i64 8
  %326 = zext i8 %324 to i64
  %327 = getelementptr inbounds [256 x i32], [256 x i32]* %325, i64 0, i64 %326
  %328 = load i32, i32* %327, align 4
  %329 = add nsw i32 %328, 1
  store i32 %329, i32* %327, align 4
  br label %330

; <label>:330:                                    ; preds = %278, %307, %320, %310, %298, %270
  %331 = zext i8 %136 to i32
  %332 = icmp eq i32 %331, 2
  br i1 %332, label %333, label %348

; <label>:333:                                    ; preds = %330
  %334 = zext i8 %55 to i64
  %335 = getelementptr inbounds [256 x i8], [256 x i8]* %3, i64 0, i64 %334
  %336 = load i8, i8* %335, align 1
  %337 = zext i8 %336 to i32
  %338 = icmp eq i32 %337, 1
  br i1 %338, label %339, label %348

; <label>:339:                                    ; preds = %333
  %340 = zext i8 %168 to i32
  %341 = sub nsw i32 1, %340
  %342 = trunc i32 %341 to i8
  %343 = getelementptr inbounds [17 x [256 x i32]], [17 x [256 x i32]]* %7, i64 0, i64 9
  %344 = zext i8 %342 to i64
  %345 = getelementptr inbounds [256 x i32], [256 x i32]* %343, i64 0, i64 %344
  %346 = load i32, i32* %345, align 4
  %347 = add nsw i32 %346, 1
  store i32 %347, i32* %345, align 4
  br label %348

; <label>:348:                                    ; preds = %339, %333, %330
  %349 = zext i8 %55 to i64
  %350 = getelementptr inbounds [256 x i8], [256 x i8]* %3, i64 0, i64 %349
  %351 = load i8, i8* %350, align 1
  %352 = zext i8 %351 to i32
  %353 = zext i8 %55 to i32
  %354 = icmp eq i32 %352, %353
  br i1 %354, label %355, label %414

; <label>:355:                                    ; preds = %348
  %356 = zext i8 %138 to i32
  %357 = icmp eq i32 %356, 0
  br i1 %357, label %358, label %371

; <label>:358:                                    ; preds = %355
  %359 = zext i8 %133 to i32
  %360 = zext i8 %55 to i32
  %361 = icmp eq i32 %359, %360
  br i1 %361, label %362, label %371

; <label>:362:                                    ; preds = %358
  %363 = zext i8 %168 to i32
  %364 = sub nsw i32 1, %363
  %365 = trunc i32 %364 to i8
  %366 = getelementptr inbounds [17 x [256 x i32]], [17 x [256 x i32]]* %7, i64 0, i64 3
  %367 = zext i8 %365 to i64
  %368 = getelementptr inbounds [256 x i32], [256 x i32]* %366, i64 0, i64 %367
  %369 = load i32, i32* %368, align 4
  %370 = add nsw i32 %369, 1
  store i32 %370, i32* %368, align 4
  br label %414

; <label>:371:                                    ; preds = %358, %355
  %372 = zext i8 %55 to i32
  %373 = sub nsw i32 1, %372
  %374 = zext i8 %138 to i32
  %375 = sub nsw i32 %373, %374
  %376 = and i32 %375, 255
  %377 = icmp eq i32 %376, 0
  br i1 %377, label %378, label %391

; <label>:378:                                    ; preds = %371
  %379 = zext i8 %133 to i32
  %380 = zext i8 %138 to i32
  %381 = icmp eq i32 %379, %380
  br i1 %381, label %382, label %391

; <label>:382:                                    ; preds = %378
  %383 = zext i8 %168 to i32
  %384 = sub nsw i32 1, %383
  %385 = trunc i32 %384 to i8
  %386 = getelementptr inbounds [17 x [256 x i32]], [17 x [256 x i32]]* %7, i64 0, i64 4
  %387 = zext i8 %385 to i64
  %388 = getelementptr inbounds [256 x i32], [256 x i32]* %386, i64 0, i64 %387
  %389 = load i32, i32* %388, align 4
  %390 = add nsw i32 %389, 1
  store i32 %390, i32* %388, align 4
  br label %414

; <label>:391:                                    ; preds = %378, %371
  %392 = zext i8 %138 to i32
  %393 = zext i8 %55 to i32
  %394 = sub nsw i32 0, %393
  %395 = and i32 %394, 255
  %396 = icmp sge i32 %392, %395
  br i1 %396, label %397, label %414

; <label>:397:                                    ; preds = %391
  %398 = zext i8 %55 to i32
  %399 = zext i8 %138 to i32
  %400 = add nsw i32 %398, %399
  %401 = zext i8 %136 to i32
  %402 = sub nsw i32 %400, %401
  %403 = and i32 %402, 255
  %404 = icmp eq i32 %403, 0
  br i1 %404, label %405, label %414

; <label>:405:                                    ; preds = %397
  %406 = zext i8 %168 to i32
  %407 = sub nsw i32 1, %406
  %408 = trunc i32 %407 to i8
  %409 = getelementptr inbounds [17 x [256 x i32]], [17 x [256 x i32]]* %7, i64 0, i64 10
  %410 = zext i8 %408 to i64
  %411 = getelementptr inbounds [256 x i32], [256 x i32]* %409, i64 0, i64 %410
  %412 = load i32, i32* %411, align 4
  %413 = add nsw i32 %412, 1
  store i32 %413, i32* %411, align 4
  br label %414

; <label>:414:                                    ; preds = %362, %391, %397, %405, %382, %348
  %415 = zext i8 %138 to i32
  %416 = zext i8 %55 to i32
  %417 = icmp slt i32 %415, %416
  br i1 %417, label %418, label %448

; <label>:418:                                    ; preds = %414
  %419 = zext i8 %138 to i32
  %420 = zext i8 %138 to i64
  %421 = getelementptr inbounds [256 x i8], [256 x i8]* %3, i64 0, i64 %420
  %422 = load i8, i8* %421, align 1
  %423 = zext i8 %422 to i32
  %424 = add nsw i32 %419, %423
  %425 = zext i8 %55 to i32
  %426 = sub nsw i32 %424, %425
  %427 = and i32 %426, 255
  %428 = icmp eq i32 %427, 0
  %429 = zext i8 %136 to i32
  %430 = icmp ne i32 %429, 1
  %or.cond7 = and i1 %428, %430
  br i1 %or.cond7, label %431, label %448

; <label>:431:                                    ; preds = %418
  %432 = zext i8 %136 to i32
  %433 = zext i8 %138 to i64
  %434 = getelementptr inbounds [256 x i8], [256 x i8]* %3, i64 0, i64 %433
  %435 = load i8, i8* %434, align 1
  %436 = zext i8 %435 to i32
  %437 = icmp ne i32 %432, %436
  br i1 %437, label %438, label %448

; <label>:438:                                    ; preds = %431
  %439 = zext i8 %136 to i32
  %440 = zext i8 %168 to i32
  %441 = sub nsw i32 %439, %440
  %442 = trunc i32 %441 to i8
  %443 = getelementptr inbounds [17 x [256 x i32]], [17 x [256 x i32]]* %7, i64 0, i64 5
  %444 = zext i8 %442 to i64
  %445 = getelementptr inbounds [256 x i32], [256 x i32]* %443, i64 0, i64 %444
  %446 = load i32, i32* %445, align 4
  %447 = add nsw i32 %446, 1
  store i32 %447, i32* %445, align 4
  br label %448

; <label>:448:                                    ; preds = %438, %431, %418, %414
  %449 = zext i8 %138 to i32
  %450 = zext i8 %55 to i32
  %451 = icmp sgt i32 %449, %450
  br i1 %451, label %452, label %507

; <label>:452:                                    ; preds = %448
  %453 = zext i8 %151 to i32
  %454 = zext i8 %138 to i32
  %455 = add nsw i32 %453, %454
  %456 = zext i8 %55 to i32
  %457 = sub nsw i32 %455, %456
  %458 = and i32 %457, 255
  %459 = icmp eq i32 %458, 0
  br i1 %459, label %460, label %507

; <label>:460:                                    ; preds = %452
  %461 = zext i8 %146 to i32
  %462 = zext i8 %138 to i32
  %463 = icmp eq i32 %461, %462
  br i1 %463, label %464, label %486

; <label>:464:                                    ; preds = %460
  %465 = zext i8 %138 to i32
  %466 = zext i8 %151 to i32
  %467 = sub nsw i32 %465, %466
  %468 = and i32 %467, 255
  %469 = sext i32 %468 to i64
  %470 = getelementptr inbounds [256 x i8], [256 x i8]* %4, i64 0, i64 %469
  %471 = load i8, i8* %470, align 1
  %472 = zext i8 %471 to i32
  %473 = icmp ne i32 %472, 1
  %474 = zext i8 %471 to i32
  %475 = icmp ne i32 %474, 2
  %or.cond9 = and i1 %473, %475
  br i1 %or.cond9, label %476, label %507

; <label>:476:                                    ; preds = %464
  %477 = zext i8 %471 to i32
  %478 = zext i8 %168 to i32
  %479 = sub nsw i32 %477, %478
  %480 = trunc i32 %479 to i8
  %481 = getelementptr inbounds [17 x [256 x i32]], [17 x [256 x i32]]* %7, i64 0, i64 6
  %482 = zext i8 %480 to i64
  %483 = getelementptr inbounds [256 x i32], [256 x i32]* %481, i64 0, i64 %482
  %484 = load i32, i32* %483, align 4
  %485 = add nsw i32 %484, 1
  store i32 %485, i32* %483, align 4
  br label %507

; <label>:486:                                    ; preds = %460
  %487 = zext i8 %146 to i32
  %488 = zext i8 %151 to i32
  %489 = sub nsw i32 2, %488
  %490 = and i32 %489, 255
  %491 = icmp eq i32 %487, %490
  br i1 %491, label %492, label %507

; <label>:492:                                    ; preds = %486
  %493 = zext i8 %149 to i32
  %494 = icmp ne i32 %493, 1
  %495 = zext i8 %149 to i32
  %496 = icmp ne i32 %495, 2
  %or.cond11 = and i1 %494, %496
  br i1 %or.cond11, label %497, label %507

; <label>:497:                                    ; preds = %492
  %498 = zext i8 %149 to i32
  %499 = zext i8 %168 to i32
  %500 = sub nsw i32 %498, %499
  %501 = trunc i32 %500 to i8
  %502 = getelementptr inbounds [17 x [256 x i32]], [17 x [256 x i32]]* %7, i64 0, i64 7
  %503 = zext i8 %501 to i64
  %504 = getelementptr inbounds [256 x i32], [256 x i32]* %502, i64 0, i64 %503
  %505 = load i32, i32* %504, align 4
  %506 = add nsw i32 %505, 1
  store i32 %506, i32* %504, align 4
  br label %507

; <label>:507:                                    ; preds = %476, %464, %492, %497, %486, %452, %448
  %508 = getelementptr inbounds [256 x i8], [256 x i8]* %3, i64 0, i64 1
  %509 = load i8, i8* %508, align 1
  %510 = zext i8 %509 to i32
  %511 = icmp ne i32 %510, 2
  br i1 %511, label %512, label %560

; <label>:512:                                    ; preds = %507
  %513 = getelementptr inbounds [256 x i8], [256 x i8]* %3, i64 0, i64 2
  %514 = load i8, i8* %513, align 2
  %515 = zext i8 %514 to i32
  %516 = icmp ne i32 %515, 0
  br i1 %516, label %517, label %560

; <label>:517:                                    ; preds = %512
  %518 = getelementptr inbounds [256 x i8], [256 x i8]* %3, i64 0, i64 1
  %519 = load i8, i8* %518, align 1
  %520 = zext i8 %519 to i32
  %521 = getelementptr inbounds [256 x i8], [256 x i8]* %3, i64 0, i64 2
  %522 = load i8, i8* %521, align 2
  %523 = zext i8 %522 to i32
  %524 = add nsw i32 %520, %523
  %525 = trunc i32 %524 to i8
  %526 = zext i8 %525 to i32
  %527 = zext i8 %55 to i32
  %528 = icmp slt i32 %526, %527
  br i1 %528, label %529, label %560

; <label>:529:                                    ; preds = %517
  %530 = zext i8 %525 to i64
  %531 = getelementptr inbounds [256 x i8], [256 x i8]* %3, i64 0, i64 %530
  %532 = load i8, i8* %531, align 1
  %533 = zext i8 %532 to i32
  %534 = getelementptr inbounds [256 x i8], [256 x i8]* %3, i64 0, i64 2
  %535 = load i8, i8* %534, align 2
  %536 = zext i8 %535 to i32
  %537 = add nsw i32 %533, %536
  %538 = trunc i32 %537 to i8
  %539 = zext i8 %538 to i32
  %540 = zext i8 %55 to i32
  %541 = icmp eq i32 %539, %540
  %542 = zext i8 %149 to i32
  %543 = icmp ne i32 %542, 1
  %or.cond13 = and i1 %541, %543
  %544 = zext i8 %149 to i32
  %545 = icmp ne i32 %544, 2
  %or.cond15 = and i1 %or.cond13, %545
  br i1 %or.cond15, label %546, label %560

; <label>:546:                                    ; preds = %529
  %547 = zext i8 %149 to i32
  %548 = zext i8 %525 to i32
  %549 = icmp ne i32 %547, %548
  br i1 %549, label %550, label %560

; <label>:550:                                    ; preds = %546
  %551 = zext i8 %149 to i32
  %552 = zext i8 %168 to i32
  %553 = sub nsw i32 %551, %552
  %554 = trunc i32 %553 to i8
  %555 = getelementptr inbounds [17 x [256 x i32]], [17 x [256 x i32]]* %7, i64 0, i64 12
  %556 = zext i8 %554 to i64
  %557 = getelementptr inbounds [256 x i32], [256 x i32]* %555, i64 0, i64 %556
  %558 = load i32, i32* %557, align 4
  %559 = add nsw i32 %558, 1
  store i32 %559, i32* %557, align 4
  br label %560

; <label>:560:                                    ; preds = %517, %550, %546, %529, %512, %507
  %561 = zext i8 %138 to i32
  %562 = icmp eq i32 %561, 2
  br i1 %562, label %563, label %643

; <label>:563:                                    ; preds = %560
  %564 = zext i8 %55 to i32
  %565 = icmp eq i32 %564, 4
  br i1 %565, label %566, label %619

; <label>:566:                                    ; preds = %563
  %567 = zext i8 %146 to i32
  %568 = icmp eq i32 %567, 0
  br i1 %568, label %569, label %581

; <label>:569:                                    ; preds = %566
  %570 = getelementptr inbounds [256 x i8], [256 x i8]* %4, i64 0, i64 0
  %571 = load i8, i8* %570, align 16
  %572 = zext i8 %571 to i32
  %573 = zext i8 %168 to i32
  %574 = sub nsw i32 %572, %573
  %575 = trunc i32 %574 to i8
  %576 = getelementptr inbounds [17 x [256 x i32]], [17 x [256 x i32]]* %7, i64 0, i64 13
  %577 = zext i8 %575 to i64
  %578 = getelementptr inbounds [256 x i32], [256 x i32]* %576, i64 0, i64 %577
  %579 = load i32, i32* %578, align 4
  %580 = add nsw i32 %579, 1
  store i32 %580, i32* %578, align 4
  br label %643

; <label>:581:                                    ; preds = %566
  %582 = getelementptr inbounds [256 x i8], [256 x i8]* %2, i64 0, i64 1
  %583 = load i8, i8* %582, align 1
  %584 = zext i8 %583 to i32
  %585 = icmp eq i32 %584, 2
  %586 = zext i8 %149 to i32
  %587 = icmp eq i32 %586, 0
  %or.cond17 = and i1 %585, %587
  br i1 %or.cond17, label %588, label %600

; <label>:588:                                    ; preds = %581
  %589 = getelementptr inbounds [256 x i8], [256 x i8]* %4, i64 0, i64 254
  %590 = load i8, i8* %589, align 2
  %591 = zext i8 %590 to i32
  %592 = zext i8 %168 to i32
  %593 = sub nsw i32 %591, %592
  %594 = trunc i32 %593 to i8
  %595 = getelementptr inbounds [17 x [256 x i32]], [17 x [256 x i32]]* %7, i64 0, i64 14
  %596 = zext i8 %594 to i64
  %597 = getelementptr inbounds [256 x i32], [256 x i32]* %595, i64 0, i64 %596
  %598 = load i32, i32* %597, align 4
  %599 = add nsw i32 %598, 1
  store i32 %599, i32* %597, align 4
  br label %600

; <label>:600:                                    ; preds = %588, %581
  %601 = getelementptr inbounds [256 x i8], [256 x i8]* %2, i64 0, i64 1
  %602 = load i8, i8* %601, align 1
  %603 = zext i8 %602 to i32
  %604 = icmp eq i32 %603, 2
  %605 = zext i8 %149 to i32
  %606 = icmp eq i32 %605, 2
  %or.cond19 = and i1 %604, %606
  br i1 %or.cond19, label %607, label %643

; <label>:607:                                    ; preds = %600
  %608 = getelementptr inbounds [256 x i8], [256 x i8]* %4, i64 0, i64 255
  %609 = load i8, i8* %608, align 1
  %610 = zext i8 %609 to i32
  %611 = zext i8 %168 to i32
  %612 = sub nsw i32 %610, %611
  %613 = trunc i32 %612 to i8
  %614 = getelementptr inbounds [17 x [256 x i32]], [17 x [256 x i32]]* %7, i64 0, i64 15
  %615 = zext i8 %613 to i64
  %616 = getelementptr inbounds [256 x i32], [256 x i32]* %614, i64 0, i64 %615
  %617 = load i32, i32* %616, align 4
  %618 = add nsw i32 %617, 1
  store i32 %618, i32* %616, align 4
  br label %643

; <label>:619:                                    ; preds = %563
  %620 = zext i8 %55 to i32
  %621 = icmp sgt i32 %620, 4
  br i1 %621, label %622, label %643

; <label>:622:                                    ; preds = %619
  %623 = getelementptr inbounds [256 x i8], [256 x i8]* %3, i64 0, i64 4
  %624 = load i8, i8* %623, align 4
  %625 = zext i8 %624 to i32
  %626 = add nsw i32 %625, 2
  %627 = zext i8 %55 to i32
  %628 = icmp eq i32 %626, %627
  %629 = zext i8 %149 to i32
  %630 = icmp ne i32 %629, 1
  %or.cond21 = and i1 %628, %630
  %631 = zext i8 %149 to i32
  %632 = icmp ne i32 %631, 4
  %or.cond23 = and i1 %or.cond21, %632
  br i1 %or.cond23, label %633, label %643

; <label>:633:                                    ; preds = %622
  %634 = zext i8 %149 to i32
  %635 = zext i8 %168 to i32
  %636 = sub nsw i32 %634, %635
  %637 = trunc i32 %636 to i8
  %638 = getelementptr inbounds [17 x [256 x i32]], [17 x [256 x i32]]* %7, i64 0, i64 11
  %639 = zext i8 %637 to i64
  %640 = getelementptr inbounds [256 x i32], [256 x i32]* %638, i64 0, i64 %639
  %641 = load i32, i32* %640, align 4
  %642 = add nsw i32 %641, 1
  store i32 %642, i32* %640, align 4
  br label %643

; <label>:643:                                    ; preds = %600, %607, %569, %633, %622, %619, %560
  %644 = load i32, i32* @close_aircrack, align 4
  %645 = icmp ne i32 %644, 0
  br i1 %645, label %.loopexit.loopexit, label %646

; <label>:646:                                    ; preds = %643
  %647 = add nsw i64 %.0126, 5
  %648 = icmp slt i64 %647, %52
  br i1 %648, label %66, label %.loopexit.loopexit

.loopexit.loopexit:                               ; preds = %643, %646
  %.37.ph = phi i32 [ %spec.select, %646 ], [ %spec.select, %643 ]
  %.3.ph = phi i32 [ %.2, %646 ], [ %.2, %643 ]
  br label %.loopexit

.loopexit:                                        ; preds = %.loopexit.loopexit, %33
  %.37 = phi i32 [ %.04, %33 ], [ %.37.ph, %.loopexit.loopexit ]
  %.3 = phi i32 [ %.0, %33 ], [ %.3.ph, %.loopexit.loopexit ]
  %649 = load i32, i32* @close_aircrack, align 4
  %650 = icmp ne i32 %649, 0
  br i1 %650, label %664, label %651

; <label>:651:                                    ; preds = %.loopexit
  %652 = sext i32 %9 to i64
  %653 = getelementptr inbounds [256 x [2 x i32]], [256 x [2 x i32]]* @cm_pipe, i64 0, i64 %652
  %654 = getelementptr inbounds [2 x i32], [2 x i32]* %653, i64 0, i64 1
  %655 = load i32, i32* %654, align 4
  %656 = getelementptr inbounds [17 x [256 x i32]], [17 x [256 x i32]]* %7, i32 0, i32 0
  %657 = bitcast [256 x i32]* %656 to i8*
  %658 = call i32 @safe_write(i32 %655, i8* %657, i64 17408)
  %659 = sext i32 %658 to i64
  %660 = icmp ne i64 %659, 17408
  br i1 %660, label %661, label %14

; <label>:661:                                    ; preds = %651
  %662 = getelementptr [13 x i8], [13 x i8]* @.str.28, i32 0, i32 0
  call void @perror(i8* %662)
  %663 = call i32 @kill(i32 0, i32 15) #9
  call void @_exit(i32 1) #12
  unreachable

; <label>:664:                                    ; preds = %.loopexit, %30
  ret i32 0
}

; Function Attrs: noinline nounwind uwtable
define dso_local void @show_wep_stats(i32, i32, [256 x %struct.PTW_tableentry]*, i32*, i32*, i32) #0 {
  %7 = alloca %struct.winsize, align 2
  %8 = call float @chrono(%struct.timeval* @t_stats, i32 0)
  %9 = fpext float %8 to double
  %10 = fcmp olt double %9, 1.510000e+00
  %11 = load i32, i32* @wepkey_crack_success, align 4
  %12 = icmp ne i32 %11, 0
  %or.cond = or i1 %10, %12
  %13 = icmp eq i32 %1, 0
  %or.cond2 = and i1 %or.cond, %13
  br i1 %or.cond2, label %303, label %14

; <label>:14:                                     ; preds = %6
  %15 = call i32 (i32, i64, ...) @ioctl(i32 0, i64 21523, %struct.winsize* %7) #9
  %16 = icmp slt i32 %15, 0
  br i1 %16, label %17, label %20

; <label>:17:                                     ; preds = %14
  %18 = getelementptr inbounds %struct.winsize, %struct.winsize* %7, i32 0, i32 0
  store i16 25, i16* %18, align 2
  %19 = getelementptr inbounds %struct.winsize, %struct.winsize* %7, i32 0, i32 1
  store i16 80, i16* %19, align 2
  br label %20

; <label>:20:                                     ; preds = %17, %14
  %21 = call float @chrono(%struct.timeval* @t_stats, i32 1)
  %22 = call float @chrono(%struct.timeval* @t_begin, i32 0)
  %23 = fdiv float %22, 3.600000e+03
  %24 = fptosi float %23 to i32
  %25 = mul nsw i32 %24, 3600
  %26 = sitofp i32 %25 to float
  %27 = fsub float %22, %26
  %28 = fdiv float %27, 6.000000e+01
  %29 = fptosi float %28 to i32
  %30 = mul nsw i32 %24, 3600
  %31 = sitofp i32 %30 to float
  %32 = fsub float %22, %31
  %33 = mul nsw i32 %29, 60
  %34 = sitofp i32 %33 to float
  %35 = fsub float %32, %34
  %36 = fptosi float %35 to i32
  %37 = load i32, i32* @show_wep_stats.is_cleared, align 4
  %38 = icmp eq i32 %37, 0
  br i1 %38, label %39, label %51

; <label>:39:                                     ; preds = %20
  %40 = load i32, i32* @show_wep_stats.is_cleared, align 4
  %41 = add nsw i32 %40, 1
  store i32 %41, i32* @show_wep_stats.is_cleared, align 4
  %42 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 27
  %43 = load i32, i32* %42, align 4
  %44 = icmp ne i32 %43, 0
  br i1 %44, label %45, label %48

; <label>:45:                                     ; preds = %39
  %46 = getelementptr [6 x i8], [6 x i8]* @.str.29, i32 0, i32 0
  %47 = call i32 (i8*, ...) @printf(i8* %46)
  br label %48

; <label>:48:                                     ; preds = %45, %39
  %49 = getelementptr [5 x i8], [5 x i8]* @.str.30, i32 0, i32 0
  %50 = call i32 (i8*, ...) @printf(i8* %49)
  br label %51

; <label>:51:                                     ; preds = %48, %20
  %52 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 27
  %53 = load i32, i32* %52, align 4
  %54 = icmp ne i32 %53, 0
  br i1 %54, label %55, label %58

; <label>:55:                                     ; preds = %51
  %56 = getelementptr [8 x i8], [8 x i8]* @.str.31, i32 0, i32 0
  %57 = call i32 (i8*, ...) @printf(i8* %56)
  br label %58

; <label>:58:                                     ; preds = %55, %51
  %59 = getelementptr inbounds %struct.winsize, %struct.winsize* %7, i32 0, i32 1
  %60 = load i16, i16* %59, align 2
  %61 = zext i16 %60 to i32
  %62 = sub nsw i32 %61, 12
  %63 = sdiv i32 %62, 2
  %64 = load i8*, i8** @progname, align 8
  %65 = getelementptr [12 x i8], [12 x i8]* @.str.32, i32 0, i32 0
  %66 = call i32 (i8*, ...) @printf(i8* %65, i32 %63, i8* %64)
  %67 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 27
  %68 = load i32, i32* %67, align 4
  %69 = icmp ne i32 %68, 0
  br i1 %69, label %70, label %73

; <label>:70:                                     ; preds = %58
  %71 = getelementptr [8 x i8], [8 x i8]* @.str.33, i32 0, i32 0
  %72 = call i32 (i8*, ...) @printf(i8* %71)
  br label %73

; <label>:73:                                     ; preds = %70, %58
  %74 = icmp ne [256 x %struct.PTW_tableentry]* %2, null
  %75 = getelementptr inbounds %struct.winsize, %struct.winsize* %7, i32 0, i32 1
  %76 = load i16, i16* %75, align 2
  %77 = zext i16 %76 to i32
  %78 = sub nsw i32 %77, 44
  %79 = sdiv i32 %78, 2
  br i1 %74, label %80, label %87

; <label>:80:                                     ; preds = %73
  %81 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 37
  %82 = load %struct.AP_info*, %struct.AP_info** %81, align 8
  %83 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %82, i32 0, i32 7
  %84 = load i64, i64* %83, align 8
  %85 = getelementptr [56 x i8], [56 x i8]* @.str.34, i32 0, i32 0
  %86 = call i32 (i8*, ...) @printf(i8* %85, i32 %79, i32 %24, i32 %29, i32 %36, i32 %5, i64 %84)
  br label %93

; <label>:87:                                     ; preds = %73
  %88 = load i64, i64* @nb_tried, align 8
  %89 = getelementptr %struct.WEP_data, %struct.WEP_data* @wep, i32 0, i32 4
  %90 = load i64, i64* %89, align 8
  %91 = getelementptr [58 x i8], [58 x i8]* @.str.35, i32 0, i32 0
  %92 = call i32 (i8*, ...) @printf(i8* %91, i32 %79, i32 %24, i32 %29, i32 %36, i64 %88, i64 %90)
  br label %93

; <label>:93:                                     ; preds = %87, %80
  %94 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 27
  %95 = load i32, i32* %94, align 4
  %96 = icmp ne i32 %95, 0
  br i1 %96, label %97, label %100

; <label>:97:                                     ; preds = %93
  %98 = getelementptr [9 x i8], [9 x i8]* @.str.36, i32 0, i32 0
  %99 = call i32 (i8*, ...) @printf(i8* %98)
  br label %100

; <label>:100:                                    ; preds = %97, %93
  %101 = getelementptr [32 x i8], [32 x i8]* @.str.37, i32 0, i32 0
  %102 = call i32 (i8*, ...) @printf(i8* %101)
  %103 = icmp sle i32 0, %0
  br i1 %103, label %.lr.ph17.preheader, label %._crit_edge

.lr.ph17.preheader:                               ; preds = %100
  br label %.lr.ph17

.lr.ph17:                                         ; preds = %.lr.ph17.preheader, %288
  %.018 = phi i32 [ %291, %288 ], [ 0, %.lr.ph17.preheader ]
  call void @unroll_loop(i32 57)
  %104 = getelementptr inbounds %struct.winsize, %struct.winsize* %7, i32 0, i32 1
  %105 = load i16, i16* %104, align 2
  %106 = zext i16 %105 to i32
  %107 = sub nsw i32 %106, 20
  %108 = sdiv i32 %107, 11
  %109 = icmp ne [256 x %struct.PTW_tableentry]* %2, null
  br i1 %109, label %128, label %110

; <label>:110:                                    ; preds = %.lr.ph17
  %111 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 27
  %112 = load i32, i32* %111, align 4
  %113 = icmp ne i32 %112, 0
  %114 = sext i32 %.018 to i64
  %115 = getelementptr %struct.WEP_data, %struct.WEP_data* @wep, i32 0, i32 6
  %116 = getelementptr inbounds [64 x i32], [64 x i32]* %115, i64 0, i64 %114
  %117 = load i32, i32* %116, align 4
  %118 = sext i32 %.018 to i64
  %119 = getelementptr %struct.WEP_data, %struct.WEP_data* @wep, i32 0, i32 5
  %120 = getelementptr inbounds [64 x i32], [64 x i32]* %119, i64 0, i64 %118
  %121 = load i32, i32* %120, align 4
  br i1 %113, label %122, label %125

; <label>:122:                                    ; preds = %110
  %123 = getelementptr [28 x i8], [28 x i8]* @.str.38, i32 0, i32 0
  %124 = call i32 (i8*, ...) @printf(i8* %123, i32 %.018, i32 %117, i32 %121)
  br label %137

; <label>:125:                                    ; preds = %110
  %126 = getelementptr [19 x i8], [19 x i8]* @.str.39, i32 0, i32 0
  %127 = call i32 (i8*, ...) @printf(i8* %126, i32 %.018, i32 %117, i32 %121)
  br label %137

; <label>:128:                                    ; preds = %.lr.ph17
  %129 = sext i32 %.018 to i64
  %130 = getelementptr inbounds i32, i32* %4, i64 %129
  %131 = load i32, i32* %130, align 4
  %132 = sext i32 %.018 to i64
  %133 = getelementptr inbounds i32, i32* %3, i64 %132
  %134 = load i32, i32* %133, align 4
  %135 = getelementptr [19 x i8], [19 x i8]* @.str.39, i32 0, i32 0
  %136 = call i32 (i8*, ...) @printf(i8* %135, i32 %.018, i32 %131, i32 %134)
  br label %137

; <label>:137:                                    ; preds = %122, %125, %128
  %138 = icmp ne [256 x %struct.PTW_tableentry]* %2, null
  %139 = sext i32 %.018 to i64
  br i1 %138, label %140, label %177

; <label>:140:                                    ; preds = %137
  %141 = getelementptr inbounds i32, i32* %4, i64 %139
  %142 = load i32, i32* %141, align 4
  %143 = sext i32 %.018 to i64
  %144 = getelementptr inbounds i32, i32* %4, i64 %143
  %145 = load i32, i32* %144, align 4
  %146 = add nsw i32 %108, %145
  %147 = icmp slt i32 %142, %146
  br i1 %147, label %.lr.ph5, label %.loopexit

.lr.ph5:                                          ; preds = %140
  %148 = sext i32 %142 to i64
  br label %149

; <label>:149:                                    ; preds = %.lr.ph5, %172
  %indvars.iv6 = phi i64 [ %148, %.lr.ph5 ], [ %indvars.iv.next7, %172 ]
  call void @unroll_loop(i32 58)
  %150 = icmp sge i64 %indvars.iv6, 256
  br i1 %150, label %.loopexit.loopexit, label %151

; <label>:151:                                    ; preds = %149
  %152 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 27
  %153 = load i32, i32* %152, align 4
  %154 = icmp ne i32 %153, 0
  %155 = sext i32 %.018 to i64
  %156 = getelementptr inbounds [256 x %struct.PTW_tableentry], [256 x %struct.PTW_tableentry]* %2, i64 %155
  %157 = getelementptr inbounds [256 x %struct.PTW_tableentry], [256 x %struct.PTW_tableentry]* %156, i64 0, i64 %indvars.iv6
  %158 = getelementptr inbounds %struct.PTW_tableentry, %struct.PTW_tableentry* %157, i32 0, i32 1
  %159 = load i8, i8* %158, align 4
  %160 = zext i8 %159 to i32
  %161 = sext i32 %.018 to i64
  %162 = getelementptr inbounds [256 x %struct.PTW_tableentry], [256 x %struct.PTW_tableentry]* %2, i64 %161
  %163 = getelementptr inbounds [256 x %struct.PTW_tableentry], [256 x %struct.PTW_tableentry]* %162, i64 0, i64 %indvars.iv6
  %164 = getelementptr inbounds %struct.PTW_tableentry, %struct.PTW_tableentry* %163, i32 0, i32 0
  %165 = load i32, i32* %164, align 4
  br i1 %154, label %166, label %169

; <label>:166:                                    ; preds = %151
  %167 = getelementptr [20 x i8], [20 x i8]* @.str.40, i32 0, i32 0
  %168 = call i32 (i8*, ...) @printf(i8* %167, i32 %160, i32 %165)
  br label %172

; <label>:169:                                    ; preds = %151
  %170 = getelementptr [11 x i8], [11 x i8]* @.str.41, i32 0, i32 0
  %171 = call i32 (i8*, ...) @printf(i8* %170, i32 %160, i32 %165)
  br label %172

; <label>:172:                                    ; preds = %166, %169
  %indvars.iv.next7 = add nsw i64 %indvars.iv6, 1
  %173 = load i32, i32* %144, align 4
  %174 = add nsw i32 %108, %173
  %175 = sext i32 %174 to i64
  %176 = icmp slt i64 %indvars.iv.next7, %175
  br i1 %176, label %149, label %.loopexit.loopexit

; <label>:177:                                    ; preds = %137
  %178 = getelementptr %struct.WEP_data, %struct.WEP_data* @wep, i32 0, i32 6
  %179 = getelementptr inbounds [64 x i32], [64 x i32]* %178, i64 0, i64 %139
  %180 = load i32, i32* %179, align 4
  %181 = sext i32 %.018 to i64
  %182 = getelementptr %struct.WEP_data, %struct.WEP_data* @wep, i32 0, i32 6
  %183 = getelementptr inbounds [64 x i32], [64 x i32]* %182, i64 0, i64 %181
  %184 = load i32, i32* %183, align 4
  %185 = add nsw i32 %108, %184
  %186 = icmp slt i32 %180, %185
  br i1 %186, label %.lr.ph, label %.loopexit

.lr.ph:                                           ; preds = %177
  %187 = sext i32 %180 to i64
  br label %188

; <label>:188:                                    ; preds = %.lr.ph, %227
  %indvars.iv = phi i64 [ %187, %.lr.ph ], [ %indvars.iv.next, %227 ]
  call void @unroll_loop(i32 59)
  %189 = icmp sge i64 %indvars.iv, 256
  br i1 %189, label %.loopexit.loopexit4, label %190

; <label>:190:                                    ; preds = %188
  %191 = sext i32 %.018 to i64
  %192 = getelementptr %struct.WEP_data, %struct.WEP_data* @wep, i32 0, i32 7
  %193 = getelementptr inbounds [64 x [256 x %struct.vote]], [64 x [256 x %struct.vote]]* %192, i64 0, i64 %191
  %194 = getelementptr inbounds [256 x %struct.vote], [256 x %struct.vote]* %193, i64 0, i64 %indvars.iv
  %195 = getelementptr inbounds %struct.vote, %struct.vote* %194, i32 0, i32 1
  %196 = load i32, i32* %195, align 4
  %197 = icmp eq i32 %196, 32767
  %198 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 27
  %199 = load i32, i32* %198, align 4
  %200 = icmp ne i32 %199, 0
  %201 = sext i32 %.018 to i64
  %202 = getelementptr %struct.WEP_data, %struct.WEP_data* @wep, i32 0, i32 7
  %203 = getelementptr inbounds [64 x [256 x %struct.vote]], [64 x [256 x %struct.vote]]* %202, i64 0, i64 %201
  %204 = getelementptr inbounds [256 x %struct.vote], [256 x %struct.vote]* %203, i64 0, i64 %indvars.iv
  %205 = getelementptr inbounds %struct.vote, %struct.vote* %204, i32 0, i32 0
  %206 = load i32, i32* %205, align 8
  br i1 %197, label %207, label %214

; <label>:207:                                    ; preds = %190
  br i1 %200, label %208, label %211

; <label>:208:                                    ; preds = %207
  %209 = getelementptr [21 x i8], [21 x i8]* @.str.42, i32 0, i32 0
  %210 = call i32 (i8*, ...) @printf(i8* %209, i32 %206)
  br label %227

; <label>:211:                                    ; preds = %207
  %212 = getelementptr [12 x i8], [12 x i8]* @.str.43, i32 0, i32 0
  %213 = call i32 (i8*, ...) @printf(i8* %212, i32 %206)
  br label %227

; <label>:214:                                    ; preds = %190
  %215 = sext i32 %.018 to i64
  %216 = getelementptr %struct.WEP_data, %struct.WEP_data* @wep, i32 0, i32 7
  %217 = getelementptr inbounds [64 x [256 x %struct.vote]], [64 x [256 x %struct.vote]]* %216, i64 0, i64 %215
  %218 = getelementptr inbounds [256 x %struct.vote], [256 x %struct.vote]* %217, i64 0, i64 %indvars.iv
  %219 = getelementptr inbounds %struct.vote, %struct.vote* %218, i32 0, i32 1
  %220 = load i32, i32* %219, align 4
  br i1 %200, label %221, label %224

; <label>:221:                                    ; preds = %214
  %222 = getelementptr [20 x i8], [20 x i8]* @.str.40, i32 0, i32 0
  %223 = call i32 (i8*, ...) @printf(i8* %222, i32 %206, i32 %220)
  br label %227

; <label>:224:                                    ; preds = %214
  %225 = getelementptr [11 x i8], [11 x i8]* @.str.41, i32 0, i32 0
  %226 = call i32 (i8*, ...) @printf(i8* %225, i32 %206, i32 %220)
  br label %227

; <label>:227:                                    ; preds = %211, %208, %224, %221
  %indvars.iv.next = add nsw i64 %indvars.iv, 1
  %228 = load i32, i32* %183, align 4
  %229 = add nsw i32 %108, %228
  %230 = sext i32 %229 to i64
  %231 = icmp slt i64 %indvars.iv.next, %230
  br i1 %231, label %188, label %.loopexit.loopexit4

.loopexit.loopexit:                               ; preds = %172, %149
  br label %.loopexit

.loopexit.loopexit4:                              ; preds = %227, %188
  br label %.loopexit

.loopexit:                                        ; preds = %.loopexit.loopexit4, %.loopexit.loopexit, %177, %140
  %.019 = phi i32 [ %.018, %140 ], [ %.018, %177 ], [ %.018, %.loopexit.loopexit ], [ %.018, %.loopexit.loopexit4 ]
  %232 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 26
  %233 = load i32, i32* %232, align 8
  %234 = icmp eq i32 %233, 0
  %235 = icmp ne [256 x %struct.PTW_tableentry]* %2, null
  %or.cond3 = or i1 %234, %235
  br i1 %or.cond3, label %288, label %236

; <label>:236:                                    ; preds = %.loopexit
  %237 = sext i32 %.019 to i64
  %238 = getelementptr %struct.WEP_data, %struct.WEP_data* @wep, i32 0, i32 7
  %239 = getelementptr inbounds [64 x [256 x %struct.vote]], [64 x [256 x %struct.vote]]* %238, i64 0, i64 %237
  %240 = sext i32 %.019 to i64
  %241 = getelementptr %struct.WEP_data, %struct.WEP_data* @wep, i32 0, i32 6
  %242 = getelementptr inbounds [64 x i32], [64 x i32]* %241, i64 0, i64 %240
  %243 = load i32, i32* %242, align 4
  %244 = sext i32 %243 to i64
  %245 = getelementptr inbounds [256 x %struct.vote], [256 x %struct.vote]* %239, i64 0, i64 %244
  %246 = getelementptr inbounds %struct.vote, %struct.vote* %245, i32 0, i32 0
  %247 = load i32, i32* %246, align 8
  %248 = icmp sge i32 %247, 33
  br i1 %248, label %249, label %288

; <label>:249:                                    ; preds = %236
  %250 = sext i32 %.019 to i64
  %251 = getelementptr %struct.WEP_data, %struct.WEP_data* @wep, i32 0, i32 7
  %252 = getelementptr inbounds [64 x [256 x %struct.vote]], [64 x [256 x %struct.vote]]* %251, i64 0, i64 %250
  %253 = sext i32 %.019 to i64
  %254 = getelementptr %struct.WEP_data, %struct.WEP_data* @wep, i32 0, i32 6
  %255 = getelementptr inbounds [64 x i32], [64 x i32]* %254, i64 0, i64 %253
  %256 = load i32, i32* %255, align 4
  %257 = sext i32 %256 to i64
  %258 = getelementptr inbounds [256 x %struct.vote], [256 x %struct.vote]* %252, i64 0, i64 %257
  %259 = getelementptr inbounds %struct.vote, %struct.vote* %258, i32 0, i32 0
  %260 = load i32, i32* %259, align 8
  %261 = icmp sle i32 %260, 126
  br i1 %261, label %262, label %288

; <label>:262:                                    ; preds = %249
  %263 = sext i32 %.019 to i64
  %264 = getelementptr %struct.WEP_data, %struct.WEP_data* @wep, i32 0, i32 7
  %265 = getelementptr inbounds [64 x [256 x %struct.vote]], [64 x [256 x %struct.vote]]* %264, i64 0, i64 %263
  %266 = sext i32 %.019 to i64
  %267 = getelementptr %struct.WEP_data, %struct.WEP_data* @wep, i32 0, i32 6
  %268 = getelementptr inbounds [64 x i32], [64 x i32]* %267, i64 0, i64 %266
  %269 = load i32, i32* %268, align 4
  %270 = sext i32 %269 to i64
  %271 = getelementptr inbounds [256 x %struct.vote], [256 x %struct.vote]* %265, i64 0, i64 %270
  %272 = getelementptr inbounds %struct.vote, %struct.vote* %271, i32 0, i32 1
  %273 = load i32, i32* %272, align 4
  %274 = icmp sge i32 %273, 150
  %275 = sext i32 %.019 to i64
  %276 = getelementptr %struct.WEP_data, %struct.WEP_data* @wep, i32 0, i32 7
  %277 = getelementptr inbounds [64 x [256 x %struct.vote]], [64 x [256 x %struct.vote]]* %276, i64 0, i64 %275
  %278 = sext i32 %.019 to i64
  %279 = getelementptr %struct.WEP_data, %struct.WEP_data* @wep, i32 0, i32 6
  %280 = getelementptr inbounds [64 x i32], [64 x i32]* %279, i64 0, i64 %278
  %281 = load i32, i32* %280, align 4
  %282 = sext i32 %281 to i64
  %283 = getelementptr inbounds [256 x %struct.vote], [256 x %struct.vote]* %277, i64 0, i64 %282
  %284 = getelementptr inbounds %struct.vote, %struct.vote* %283, i32 0, i32 0
  %285 = load i32, i32* %284, align 8
  %286 = getelementptr [5 x i8], [5 x i8]* @.str.44, i32 0, i32 0
  %287 = call i32 (i8*, ...) @printf(i8* %286, i32 %285)
  br label %288

; <label>:288:                                    ; preds = %236, %249, %262, %.loopexit
  %.0114 = phi i32 [ %.019, %.loopexit ], [ %.019, %262 ], [ %.019, %249 ], [ %.019, %236 ]
  %289 = getelementptr [2 x i8], [2 x i8]* @.str.2, i32 0, i32 0
  %290 = call i32 (i8*, ...) @printf(i8* %289)
  %291 = add nsw i32 %.0114, 1
  %292 = icmp sle i32 %291, %0
  br i1 %292, label %.lr.ph17, label %._crit_edge.loopexit

._crit_edge.loopexit:                             ; preds = %288
  br label %._crit_edge

._crit_edge:                                      ; preds = %._crit_edge.loopexit, %100
  %293 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 10
  %294 = load i32, i32* %293, align 4
  %295 = sub nsw i32 %294, 1
  %296 = icmp slt i32 %0, %295
  br i1 %296, label %297, label %300

; <label>:297:                                    ; preds = %._crit_edge
  %298 = getelementptr [4 x i8], [4 x i8]* @.str.45, i32 0, i32 0
  %299 = call i32 (i8*, ...) @printf(i8* %298)
  br label %300

; <label>:300:                                    ; preds = %297, %._crit_edge
  %301 = getelementptr [2 x i8], [2 x i8]* @.str.2, i32 0, i32 0
  %302 = call i32 (i8*, ...) @printf(i8* %301)
  br label %303

; <label>:303:                                    ; preds = %6, %300
  ret void
}

; Function Attrs: nounwind
declare dso_local i32 @ioctl(i32, i64, ...) #2

; Function Attrs: noinline nounwind uwtable
define dso_local i32 @check_wep_key(i8*, i32, i32) #0 {
  %4 = alloca [64 x i8], align 16, !track !169
  %5 = alloca [256 x i8], align 16, !track !170
  %6 = icmp sle i32 %2, 0
  %7 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 10
  %8 = load i32, i32* %7, align 4
  %.04 = select i1 %6, i32 %8, i32 %2
  %9 = load i64, i64* @nb_tried, align 8
  %10 = add nsw i64 %9, 1
  store i64 %10, i64* @nb_tried, align 8
  %11 = getelementptr inbounds [64 x i8], [64 x i8]* %4, i32 0, i32 0
  %12 = getelementptr inbounds i8, i8* %11, i64 3
  %13 = sext i32 %.04 to i64
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %12, i8* align 1 %0, i64 %13, i1 false), !track !171
  %14 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 22
  %15 = load %struct._IO_FILE*, %struct._IO_FILE** %14, align 8
  %16 = icmp ne %struct._IO_FILE* %15, null
  %17 = getelementptr %struct.WEP_data, %struct.WEP_data* @wep, i32 0, i32 3
  %18 = load i64, i64* %17, align 8
  %19 = trunc i64 %18 to i32
  %.01 = select i1 %16, i32 %19, i32 32
  %20 = icmp slt i32 %.01, 4
  %spec.select = select i1 %20, i32 4, i32 %.01
  %21 = icmp sgt i32 %spec.select, 32
  %.2 = select i1 %21, i32 32, i32 %spec.select
  %22 = icmp slt i32 0, %.2
  br i1 %22, label %.lr.ph, label %._crit_edge

.lr.ph:                                           ; preds = %3
  %23 = zext i32 %.2 to i64
  br label %24

; <label>:24:                                     ; preds = %.lr.ph, %159
  %indvars.iv13 = phi i64 [ 0, %.lr.ph ], [ %indvars.iv.next14, %159 ]
  %.0212 = phi i32 [ 0, %.lr.ph ], [ %.13, %159 ]
  call void @unroll_loop(i32 12)
  %25 = mul nuw nsw i64 5, %indvars.iv13
  %26 = call i32 @pthread_mutex_lock(%union.pthread_mutex_t* @mx_ivb) #9
  %27 = getelementptr inbounds [64 x i8], [64 x i8]* %4, i32 0, i32 0
  %28 = getelementptr %struct.WEP_data, %struct.WEP_data* @wep, i32 0, i32 1
  %29 = load i8*, i8** %28, align 8
  %30 = getelementptr inbounds i8, i8* %29, i64 %25
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 16 %27, i8* align 1 %30, i64 3, i1 false), !track !172
  %31 = getelementptr inbounds [256 x i8], [256 x i8]* %5, i32 0, i32 0
  %32 = getelementptr [256 x i8], [256 x i8]* @R, i32 0, i32 0
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 16 %31, i8* align 16 %32, i64 256, i1 false), !track !173
  br label %33

; <label>:33:                                     ; preds = %24, %33
  %indvars.iv = phi i64 [ 0, %24 ], [ %indvars.iv.next, %33 ]
  %.0610 = phi i32 [ 0, %24 ], [ %46, %33 ]
  call void @unroll_loop(i32 13)
  %34 = getelementptr inbounds [256 x i8], [256 x i8]* %5, i64 0, i64 %indvars.iv
  %35 = load i8, i8* %34, align 1
  %36 = zext i8 %35 to i32
  %37 = add nsw i32 %.0610, %36
  %38 = add nsw i32 3, %.04
  %39 = trunc i64 %indvars.iv to i32
  %40 = srem i32 %39, %38
  %41 = sext i32 %40 to i64
  %42 = getelementptr inbounds [64 x i8], [64 x i8]* %4, i64 0, i64 %41
  %43 = load i8, i8* %42, align 1
  %44 = zext i8 %43 to i32
  %45 = add nsw i32 %37, %44
  %46 = and i32 %45, 255
  %47 = getelementptr inbounds [256 x i8], [256 x i8]* %5, i64 0, i64 %indvars.iv
  %48 = load i8, i8* %47, align 1
  %49 = sext i32 %46 to i64
  %50 = getelementptr inbounds [256 x i8], [256 x i8]* %5, i64 0, i64 %49
  %51 = load i8, i8* %50, align 1
  %52 = getelementptr inbounds [256 x i8], [256 x i8]* %5, i64 0, i64 %indvars.iv
  store i8 %51, i8* %52, align 1
  %53 = sext i32 %46 to i64
  %54 = getelementptr inbounds [256 x i8], [256 x i8]* %5, i64 0, i64 %53
  store i8 %48, i8* %54, align 1
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond = icmp ne i64 %indvars.iv.next, 256
  br i1 %exitcond, label %33, label %55

; <label>:55:                                     ; preds = %33
  %56 = sext i32 1 to i64
  %57 = getelementptr inbounds [256 x i8], [256 x i8]* %5, i64 0, i64 %56
  %58 = load i8, i8* %57, align 1
  %59 = zext i8 %58 to i32
  %60 = add nsw i32 0, %59
  %61 = and i32 %60, 255
  %62 = sext i32 1 to i64
  %63 = getelementptr inbounds [256 x i8], [256 x i8]* %5, i64 0, i64 %62
  %64 = load i8, i8* %63, align 1
  %65 = sext i32 %61 to i64
  %66 = getelementptr inbounds [256 x i8], [256 x i8]* %5, i64 0, i64 %65
  %67 = load i8, i8* %66, align 1
  %68 = sext i32 1 to i64
  %69 = getelementptr inbounds [256 x i8], [256 x i8]* %5, i64 0, i64 %68
  store i8 %67, i8* %69, align 1
  %70 = sext i32 %61 to i64
  %71 = getelementptr inbounds [256 x i8], [256 x i8]* %5, i64 0, i64 %70
  store i8 %64, i8* %71, align 1
  %72 = getelementptr %struct.WEP_data, %struct.WEP_data* @wep, i32 0, i32 1
  %73 = load i8*, i8** %72, align 8
  %74 = add nuw nsw i64 %25, 3
  %75 = getelementptr inbounds i8, i8* %73, i64 %74
  %76 = load i8, i8* %75, align 1
  %77 = zext i8 %76 to i32
  %78 = sext i32 1 to i64
  %79 = getelementptr inbounds [256 x i8], [256 x i8]* %5, i64 0, i64 %78
  %80 = load i8, i8* %79, align 1
  %81 = zext i8 %80 to i32
  %82 = sext i32 %61 to i64
  %83 = getelementptr inbounds [256 x i8], [256 x i8]* %5, i64 0, i64 %82
  %84 = load i8, i8* %83, align 1
  %85 = zext i8 %84 to i32
  %86 = add nsw i32 %81, %85
  %87 = and i32 %86, 255
  %88 = sext i32 %87 to i64
  %89 = getelementptr inbounds [256 x i8], [256 x i8]* %5, i64 0, i64 %88
  %90 = load i8, i8* %89, align 1
  %91 = zext i8 %90 to i32
  %92 = xor i32 %77, %91
  %93 = trunc i32 %92 to i8
  %94 = sext i32 2 to i64
  %95 = getelementptr inbounds [256 x i8], [256 x i8]* %5, i64 0, i64 %94
  %96 = load i8, i8* %95, align 1
  %97 = zext i8 %96 to i32
  %98 = add nsw i32 %61, %97
  %99 = and i32 %98, 255
  %100 = sext i32 2 to i64
  %101 = getelementptr inbounds [256 x i8], [256 x i8]* %5, i64 0, i64 %100
  %102 = load i8, i8* %101, align 1
  %103 = sext i32 %99 to i64
  %104 = getelementptr inbounds [256 x i8], [256 x i8]* %5, i64 0, i64 %103
  %105 = load i8, i8* %104, align 1
  %106 = sext i32 2 to i64
  %107 = getelementptr inbounds [256 x i8], [256 x i8]* %5, i64 0, i64 %106
  store i8 %105, i8* %107, align 1
  %108 = sext i32 %99 to i64
  %109 = getelementptr inbounds [256 x i8], [256 x i8]* %5, i64 0, i64 %108
  store i8 %102, i8* %109, align 1
  %110 = getelementptr %struct.WEP_data, %struct.WEP_data* @wep, i32 0, i32 1
  %111 = load i8*, i8** %110, align 8
  %112 = add nuw nsw i64 %25, 4
  %113 = getelementptr inbounds i8, i8* %111, i64 %112
  %114 = load i8, i8* %113, align 1
  %115 = zext i8 %114 to i32
  %116 = sext i32 2 to i64
  %117 = getelementptr inbounds [256 x i8], [256 x i8]* %5, i64 0, i64 %116
  %118 = load i8, i8* %117, align 1
  %119 = zext i8 %118 to i32
  %120 = sext i32 %99 to i64
  %121 = getelementptr inbounds [256 x i8], [256 x i8]* %5, i64 0, i64 %120
  %122 = load i8, i8* %121, align 1
  %123 = zext i8 %122 to i32
  %124 = add nsw i32 %119, %123
  %125 = and i32 %124, 255
  %126 = sext i32 %125 to i64
  %127 = getelementptr inbounds [256 x i8], [256 x i8]* %5, i64 0, i64 %126
  %128 = load i8, i8* %127, align 1
  %129 = zext i8 %128 to i32
  %130 = xor i32 %115, %129
  %131 = trunc i32 %130 to i8
  %132 = call i32 @pthread_mutex_unlock(%union.pthread_mutex_t* @mx_ivb) #9
  %133 = zext i8 %93 to i32
  %134 = icmp ne i32 %133, 170
  %135 = zext i8 %131 to i32
  %136 = icmp ne i32 %135, 170
  %or.cond = or i1 %134, %136
  br i1 %or.cond, label %137, label %153

; <label>:137:                                    ; preds = %55
  %138 = zext i8 %93 to i32
  %139 = icmp ne i32 %138, 224
  %140 = zext i8 %131 to i32
  %141 = icmp ne i32 %140, 224
  %or.cond3 = or i1 %139, %141
  br i1 %or.cond3, label %142, label %153

; <label>:142:                                    ; preds = %137
  %143 = zext i8 %93 to i32
  %144 = icmp ne i32 %143, 66
  %145 = zext i8 %131 to i32
  %146 = icmp ne i32 %145, 66
  %or.cond5 = or i1 %144, %146
  br i1 %or.cond5, label %147, label %153

; <label>:147:                                    ; preds = %142
  %148 = zext i8 %93 to i32
  %149 = icmp ne i32 %148, 2
  %150 = zext i8 %131 to i32
  %151 = icmp ne i32 %150, 170
  %or.cond7 = or i1 %149, %151
  %152 = add nsw i32 %.0212, 1
  %spec.select8 = select i1 %or.cond7, i32 %152, i32 %.0212
  br label %153

; <label>:153:                                    ; preds = %147, %142, %137, %55
  %.13 = phi i32 [ %.0212, %55 ], [ %.0212, %137 ], [ %.0212, %142 ], [ %spec.select8, %147 ]
  %154 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 29
  %155 = load i32, i32* %154, align 4
  %156 = mul nsw i32 %.2, %155
  %157 = sdiv i32 %156, 100
  %158 = icmp sgt i32 %.13, %157
  br i1 %158, label %.loopexit, label %159

; <label>:159:                                    ; preds = %153
  %indvars.iv.next14 = add nuw nsw i64 %indvars.iv13, 1
  %160 = icmp ult i64 %indvars.iv.next14, %23
  br i1 %160, label %24, label %._crit_edge.loopexit

._crit_edge.loopexit:                             ; preds = %159
  %.02.lcssa.ph = phi i32 [ %.13, %159 ]
  br label %._crit_edge

._crit_edge:                                      ; preds = %._crit_edge.loopexit, %3
  %.02.lcssa = phi i32 [ 0, %3 ], [ %.02.lcssa.ph, %._crit_edge.loopexit ]
  %161 = sub nsw i32 %.2, %.02.lcssa
  %162 = mul nsw i32 %161, 100
  %163 = sdiv i32 %162, %.2
  %164 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 29
  store i32 %163, i32* %164, align 4
  call void @key_found(i8* %0, i32 %.04, i32 %1)
  br label %165

.loopexit:                                        ; preds = %153
  %.0.ph = phi i32 [ 1, %153 ]
  br label %165

; <label>:165:                                    ; preds = %.loopexit, %._crit_edge
  %.0 = phi i32 [ 0, %._crit_edge ], [ %.0.ph, %.loopexit ]
  ret i32 %.0
}

; Function Attrs: noinline nounwind uwtable
define internal void @key_found(i8*, i32, i32) #0 {
  %4 = icmp slt i32 0, %1
  br i1 %4, label %.lr.ph26, label %._crit_edge27

.lr.ph26:                                         ; preds = %3
  %5 = zext i32 %1 to i64
  br label %6

; <label>:6:                                      ; preds = %.lr.ph26, %23
  %indvars.iv28 = phi i64 [ 0, %.lr.ph26 ], [ %indvars.iv.next29, %23 ]
  %.024 = phi i32 [ 0, %.lr.ph26 ], [ %.1, %23 ]
  call void @unroll_loop(i32 0)
  %7 = getelementptr inbounds i8, i8* %0, i64 %indvars.iv28
  %8 = load i8, i8* %7, align 1
  %9 = zext i8 %8 to i32
  %10 = icmp eq i32 %9, 0
  br i1 %10, label %21, label %11

; <label>:11:                                     ; preds = %6
  %12 = getelementptr inbounds i8, i8* %0, i64 %indvars.iv28
  %13 = load i8, i8* %12, align 1
  %14 = zext i8 %13 to i32
  %15 = icmp sge i32 %14, 32
  br i1 %15, label %16, label %23

; <label>:16:                                     ; preds = %11
  %17 = getelementptr inbounds i8, i8* %0, i64 %indvars.iv28
  %18 = load i8, i8* %17, align 1
  %19 = zext i8 %18 to i32
  %20 = icmp slt i32 %19, 127
  br i1 %20, label %21, label %23

; <label>:21:                                     ; preds = %16, %6
  %22 = add nsw i32 %.024, 1
  br label %23

; <label>:23:                                     ; preds = %11, %16, %21
  %.1 = phi i32 [ %22, %21 ], [ %.024, %16 ], [ %.024, %11 ]
  %indvars.iv.next29 = add nuw nsw i64 %indvars.iv28, 1
  %exitcond3 = icmp ne i64 %indvars.iv.next29, %5
  br i1 %exitcond3, label %6, label %._crit_edge27.loopexit

._crit_edge27.loopexit:                           ; preds = %23
  %.0.lcssa.ph = phi i32 [ %.1, %23 ]
  br label %._crit_edge27

._crit_edge27:                                    ; preds = %._crit_edge27.loopexit, %3
  %.0.lcssa = phi i32 [ 0, %3 ], [ %.0.lcssa.ph, %._crit_edge27.loopexit ]
  store i32 1, i32* @wepkey_crack_success, align 4
  %24 = sext i32 %1 to i64
  %25 = getelementptr [64 x i8], [64 x i8]* @bf_wepkey, i32 0, i32 0
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 16 %25, i8* align 1 %0, i64 %24, i1 false), !track !174
  %26 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 6
  %27 = load i32, i32* %26, align 8
  %28 = icmp ne i32 %27, 0
  br i1 %28, label %29, label %32

; <label>:29:                                     ; preds = %._crit_edge27
  %30 = getelementptr [14 x i8], [14 x i8]* @.str.150, i32 0, i32 0
  %31 = call i32 (i8*, ...) @printf(i8* %30)
  br label %58

; <label>:32:                                     ; preds = %._crit_edge27
  %33 = icmp ne i32 %2, -1
  br i1 %33, label %34, label %36

; <label>:34:                                     ; preds = %32
  %35 = sub nsw i32 %2, 1
  call void @show_wep_stats(i32 %35, i32 1, [256 x %struct.PTW_tableentry]* null, i32* null, i32* null, i32 0)
  br label %36

; <label>:36:                                     ; preds = %34, %32
  %37 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 27
  %38 = load i32, i32* %37, align 4
  %39 = icmp ne i32 %38, 0
  br i1 %39, label %40, label %43

; <label>:40:                                     ; preds = %36
  %41 = getelementptr [8 x i8], [8 x i8]* @.str.62, i32 0, i32 0
  %42 = call i32 (i8*, ...) @printf(i8* %41)
  br label %43

; <label>:43:                                     ; preds = %40, %36
  %44 = mul nsw i32 %1, 3
  %45 = sub nsw i32 66, %44
  %46 = sdiv i32 %45, 2
  %47 = mul nsw i32 100, %.0.lcssa
  %48 = mul nsw i32 75, %1
  %49 = icmp sgt i32 %47, %48
  br i1 %49, label %50, label %54

; <label>:50:                                     ; preds = %43
  %51 = add nsw i32 %1, 4
  %52 = sdiv i32 %51, 2
  %53 = sub nsw i32 %46, %52
  br label %54

; <label>:54:                                     ; preds = %50, %43
  %.01 = phi i32 [ %53, %50 ], [ %46, %43 ]
  %55 = icmp sle i32 %.01, 0
  %spec.select = select i1 %55, i32 0, i32 %.01
  %56 = getelementptr [22 x i8], [22 x i8]* @.str.151, i32 0, i32 0
  %57 = call i32 (i8*, ...) @printf(i8* %56, i32 %spec.select)
  br label %58

; <label>:58:                                     ; preds = %54, %29
  %.05 = phi i32 [ %.0.lcssa, %54 ], [ %.0.lcssa, %29 ]
  %59 = sub nsw i32 %1, 1
  %60 = icmp slt i32 0, %59
  br i1 %60, label %.lr.ph17, label %73

.lr.ph17:                                         ; preds = %58
  %61 = add i32 %1, -1
  %62 = zext i32 %61 to i64
  br label %63

; <label>:63:                                     ; preds = %.lr.ph17, %63
  %indvars.iv19 = phi i64 [ 0, %.lr.ph17 ], [ %indvars.iv.next20, %63 ]
  call void @unroll_loop(i32 1)
  %64 = getelementptr inbounds i8, i8* %0, i64 %indvars.iv19
  %65 = load i8, i8* %64, align 1
  %66 = zext i8 %65 to i32
  %67 = getelementptr [6 x i8], [6 x i8]* @.str.152, i32 0, i32 0
  %68 = call i32 (i8*, ...) @printf(i8* %67, i32 %66)
  %indvars.iv.next20 = add nuw nsw i64 %indvars.iv19, 1
  %exitcond2 = icmp ne i64 %indvars.iv.next20, %62
  br i1 %exitcond2, label %63, label %._crit_edge18

._crit_edge18:                                    ; preds = %63
  %69 = add i32 %1, -2
  %70 = zext i32 %69 to i64
  %71 = add i64 %70, 1
  %72 = trunc i64 %71 to i32
  br label %73

; <label>:73:                                     ; preds = %._crit_edge18, %58
  %.14.lcssa = phi i32 [ %72, %._crit_edge18 ], [ 0, %58 ]
  %74 = sext i32 %.14.lcssa to i64
  %75 = getelementptr inbounds i8, i8* %0, i64 %74
  %76 = load i8, i8* %75, align 1
  %77 = zext i8 %76 to i32
  %78 = getelementptr [8 x i8], [8 x i8]* @.str.153, i32 0, i32 0
  %79 = call i32 (i8*, ...) @printf(i8* %78, i32 %77)
  %80 = icmp eq i32 %.05, %1
  br i1 %80, label %81, label %111

; <label>:81:                                     ; preds = %73
  %82 = getelementptr [9 x i8], [9 x i8]* @.str.154, i32 0, i32 0
  %83 = call i32 (i8*, ...) @printf(i8* %82)
  %84 = icmp slt i32 0, %1
  br i1 %84, label %.lr.ph11, label %._crit_edge12

.lr.ph11:                                         ; preds = %81
  %85 = sext i32 %1 to i64
  br label %86

; <label>:86:                                     ; preds = %.lr.ph11, %105
  %indvars.iv13 = phi i64 [ 0, %.lr.ph11 ], [ %indvars.iv.next14, %105 ]
  call void @unroll_loop(i32 2)
  %87 = getelementptr inbounds i8, i8* %0, i64 %indvars.iv13
  %88 = load i8, i8* %87, align 1
  %89 = zext i8 %88 to i32
  %90 = icmp sgt i32 %89, 31
  br i1 %90, label %91, label %96

; <label>:91:                                     ; preds = %86
  %92 = getelementptr inbounds i8, i8* %0, i64 %indvars.iv13
  %93 = load i8, i8* %92, align 1
  %94 = zext i8 %93 to i32
  %95 = icmp slt i32 %94, 127
  br i1 %95, label %101, label %96

; <label>:96:                                     ; preds = %91, %86
  %97 = getelementptr inbounds i8, i8* %0, i64 %indvars.iv13
  %98 = load i8, i8* %97, align 1
  %99 = zext i8 %98 to i32
  %100 = icmp sgt i32 %99, 160
  br i1 %100, label %101, label %105

; <label>:101:                                    ; preds = %96, %91
  %102 = getelementptr inbounds i8, i8* %0, i64 %indvars.iv13
  %103 = load i8, i8* %102, align 1
  %104 = zext i8 %103 to i32
  br label %105

; <label>:105:                                    ; preds = %96, %101
  %106 = phi i32 [ %104, %101 ], [ 46, %96 ]
  %107 = getelementptr [3 x i8], [3 x i8]* @.str.155, i32 0, i32 0
  %108 = call i32 (i8*, ...) @printf(i8* %107, i32 %106)
  %indvars.iv.next14 = add nuw nsw i64 %indvars.iv13, 1
  %exitcond = icmp ne i64 %indvars.iv.next14, %85
  br i1 %exitcond, label %86, label %._crit_edge12.loopexit

._crit_edge12.loopexit:                           ; preds = %105
  br label %._crit_edge12

._crit_edge12:                                    ; preds = %._crit_edge12.loopexit, %81
  %109 = getelementptr [3 x i8], [3 x i8]* @.str.156, i32 0, i32 0
  %110 = call i32 (i8*, ...) @printf(i8* %109)
  br label %111

; <label>:111:                                    ; preds = %._crit_edge12, %73
  %112 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 27
  %113 = load i32, i32* %112, align 4
  %114 = icmp ne i32 %113, 0
  br i1 %114, label %115, label %118

; <label>:115:                                    ; preds = %111
  %116 = getelementptr [9 x i8], [9 x i8]* @.str.36, i32 0, i32 0
  %117 = call i32 (i8*, ...) @printf(i8* %116)
  br label %118

; <label>:118:                                    ; preds = %115, %111
  %119 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 29
  %120 = load i32, i32* %119, align 4
  %121 = getelementptr [29 x i8], [29 x i8]* @.str.157, i32 0, i32 0
  %122 = call i32 (i8*, ...) @printf(i8* %121, i32 %120)
  %123 = getelementptr [2 x i8], [2 x i8]* @.str.2, i32 0, i32 0
  %124 = call i32 (i8*, ...) @printf(i8* %123)
  %125 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 42
  %126 = load i8*, i8** %125, align 8
  %127 = icmp ne i8* %126, null
  br i1 %127, label %128, label %144

; <label>:128:                                    ; preds = %118
  %129 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 42
  %130 = load i8*, i8** %129, align 8
  %131 = getelementptr [2 x i8], [2 x i8]* @.str.64, i32 0, i32 0
  %132 = call %struct._IO_FILE* @fopen64(i8* %130, i8* %131), !track !175
  %133 = icmp ne %struct._IO_FILE* %132, null
  br i1 %133, label %134, label %144

; <label>:134:                                    ; preds = %128
  %135 = icmp slt i32 0, %1
  br i1 %135, label %.lr.ph, label %._crit_edge

.lr.ph:                                           ; preds = %134
  %136 = zext i32 %1 to i64
  br label %137

; <label>:137:                                    ; preds = %.lr.ph, %137
  %indvars.iv = phi i64 [ 0, %.lr.ph ], [ %indvars.iv.next, %137 ]
  call void @unroll_loop(i32 3)
  %138 = getelementptr inbounds i8, i8* %0, i64 %indvars.iv
  %139 = load i8, i8* %138, align 1
  %140 = zext i8 %139 to i32
  %141 = getelementptr [5 x i8], [5 x i8]* @.str.158, i32 0, i32 0
  %142 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %132, i8* %141, i32 %140)
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond1 = icmp ne i64 %indvars.iv.next, %136
  br i1 %exitcond1, label %137, label %._crit_edge.loopexit

._crit_edge.loopexit:                             ; preds = %137
  br label %._crit_edge

._crit_edge:                                      ; preds = %._crit_edge.loopexit, %134
  %143 = call i32 @fclose(%struct._IO_FILE* %132)
  br label %144

; <label>:144:                                    ; preds = %128, %._crit_edge, %118
  ret void
}

declare dso_local %struct._IO_FILE* @fopen64(i8*, i8*) #1

declare dso_local i32 @fclose(%struct._IO_FILE*) #1

; Function Attrs: noinline nounwind uwtable
define dso_local i32 @cmp_votes(i8*, i8*) #0 {
  %3 = bitcast i8* %0 to %struct.vote*
  %4 = getelementptr inbounds %struct.vote, %struct.vote* %3, i32 0, i32 1
  %5 = load i32, i32* %4, align 4
  %6 = bitcast i8* %1 to %struct.vote*
  %7 = getelementptr inbounds %struct.vote, %struct.vote* %6, i32 0, i32 1
  %8 = load i32, i32* %7, align 4
  %9 = icmp slt i32 %5, %8
  br i1 %9, label %18, label %10

; <label>:10:                                     ; preds = %2
  %11 = bitcast i8* %0 to %struct.vote*
  %12 = getelementptr inbounds %struct.vote, %struct.vote* %11, i32 0, i32 1
  %13 = load i32, i32* %12, align 4
  %14 = bitcast i8* %1 to %struct.vote*
  %15 = getelementptr inbounds %struct.vote, %struct.vote* %14, i32 0, i32 1
  %16 = load i32, i32* %15, align 4
  %17 = icmp sgt i32 %13, %16
  %. = select i1 %17, i32 -1, i32 0
  br label %18

; <label>:18:                                     ; preds = %10, %2
  %.0 = phi i32 [ 1, %2 ], [ %., %10 ]
  ret i32 %.0
}

; Function Attrs: noinline nounwind uwtable
define dso_local i32 @calc_poll(i32) #0 {
  %2 = alloca i32, align 4
  %3 = alloca [17 x [256 x i32]], align 16
  store i32 %0, i32* %2, align 4
  %4 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 30
  %5 = bitcast [17 x i32]* %4 to i8*
  call void @llvm.memset.p0i8.i64(i8* align 8 %5, i8 0, i64 68, i1 false)
  %6 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 5
  %7 = load i32, i32* %6, align 4
  %8 = icmp slt i32 0, %7
  br i1 %8, label %.lr.ph42.preheader, label %._crit_edge43

.lr.ph42.preheader:                               ; preds = %1
  br label %.lr.ph42

.lr.ph42:                                         ; preds = %.lr.ph42.preheader, %19
  %indvars.iv44 = phi i64 [ %indvars.iv.next45, %19 ], [ 0, %.lr.ph42.preheader ]
  call void @unroll_loop(i32 14)
  %9 = getelementptr inbounds [256 x [2 x i32]], [256 x [2 x i32]]* @mc_pipe, i64 0, i64 %indvars.iv44
  %10 = getelementptr inbounds [2 x i32], [2 x i32]* %9, i64 0, i64 1
  %11 = load i32, i32* %10, align 4
  %12 = bitcast i32* %2 to i8*
  %13 = sext i32 4 to i64
  %14 = call i32 @safe_write(i32 %11, i8* %12, i64 %13)
  %15 = icmp ne i32 %14, 4
  br i1 %15, label %16, label %19

; <label>:16:                                     ; preds = %.lr.ph42
  %17 = getelementptr [13 x i8], [13 x i8]* @.str.28, i32 0, i32 0
  call void @perror(i8* %17)
  %18 = call i32 @kill(i32 0, i32 15) #9
  call void @_exit(i32 1) #12
  unreachable

; <label>:19:                                     ; preds = %.lr.ph42
  %indvars.iv.next45 = add nuw nsw i64 %indvars.iv44, 1
  %20 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 5
  %21 = load i32, i32* %20, align 4
  %22 = sext i32 %21 to i64
  %23 = icmp slt i64 %indvars.iv.next45, %22
  br i1 %23, label %.lr.ph42, label %._crit_edge43.loopexit

._crit_edge43.loopexit:                           ; preds = %19
  br label %._crit_edge43

._crit_edge43:                                    ; preds = %._crit_edge43.loopexit, %1
  br label %24

; <label>:24:                                     ; preds = %._crit_edge43, %24
  %indvars.iv37 = phi i64 [ 0, %._crit_edge43 ], [ %indvars.iv.next38, %24 ]
  call void @unroll_loop(i32 15)
  %25 = load i32, i32* %2, align 4
  %26 = sext i32 %25 to i64
  %27 = getelementptr %struct.WEP_data, %struct.WEP_data* @wep, i32 0, i32 7
  %28 = getelementptr inbounds [64 x [256 x %struct.vote]], [64 x [256 x %struct.vote]]* %27, i64 0, i64 %26
  %29 = getelementptr inbounds [256 x %struct.vote], [256 x %struct.vote]* %28, i64 0, i64 %indvars.iv37
  %30 = getelementptr inbounds %struct.vote, %struct.vote* %29, i32 0, i32 0
  %31 = trunc i64 %indvars.iv37 to i32
  store i32 %31, i32* %30, align 8
  %32 = load i32, i32* %2, align 4
  %33 = sext i32 %32 to i64
  %34 = getelementptr %struct.WEP_data, %struct.WEP_data* @wep, i32 0, i32 7
  %35 = getelementptr inbounds [64 x [256 x %struct.vote]], [64 x [256 x %struct.vote]]* %34, i64 0, i64 %33
  %36 = getelementptr inbounds [256 x %struct.vote], [256 x %struct.vote]* %35, i64 0, i64 %indvars.iv37
  %37 = getelementptr inbounds %struct.vote, %struct.vote* %36, i32 0, i32 1
  store i32 0, i32* %37, align 4
  %indvars.iv.next38 = add nuw nsw i64 %indvars.iv37, 1
  %exitcond39 = icmp ne i64 %indvars.iv.next38, 256
  br i1 %exitcond39, label %24, label %38

; <label>:38:                                     ; preds = %24
  %39 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 5
  %40 = load i32, i32* %39, align 4
  %41 = icmp slt i32 0, %40
  br i1 %41, label %.lr.ph.preheader, label %._crit_edge

.lr.ph.preheader:                                 ; preds = %38
  br label %.lr.ph

.lr.ph:                                           ; preds = %.lr.ph.preheader, %82
  %indvars.iv34 = phi i64 [ %indvars.iv.next35, %82 ], [ 0, %.lr.ph.preheader ]
  call void @unroll_loop(i32 16)
  %42 = getelementptr inbounds [256 x [2 x i32]], [256 x [2 x i32]]* @cm_pipe, i64 0, i64 %indvars.iv34
  %43 = getelementptr inbounds [2 x i32], [2 x i32]* %42, i64 0, i64 0
  %44 = load i32, i32* %43, align 8
  %45 = getelementptr inbounds [17 x [256 x i32]], [17 x [256 x i32]]* %3, i32 0, i32 0
  %46 = bitcast [256 x i32]* %45 to i8*
  %47 = sext i32 17408 to i64
  %48 = call i32 @safe_read(i32 %44, i8* %46, i64 %47)
  %49 = icmp ne i32 %48, 17408
  br i1 %49, label %50, label %53

; <label>:50:                                     ; preds = %.lr.ph
  %51 = getelementptr [12 x i8], [12 x i8]* @.str.27, i32 0, i32 0
  call void @perror(i8* %51)
  %52 = call i32 @kill(i32 0, i32 15) #9
  call void @_exit(i32 1) #12
  unreachable

; <label>:53:                                     ; preds = %.lr.ph
  %54 = getelementptr inbounds [17 x [256 x i32]], [17 x [256 x i32]]* %3, i32 0, i32 0
  %55 = bitcast [256 x i32]* %54 to i32*
  br label %56

; <label>:56:                                     ; preds = %53, %81
  %indvars.iv30 = phi i64 [ 0, %53 ], [ %indvars.iv.next31, %81 ]
  %.0428 = phi i32* [ %55, %53 ], [ %scevgep, %81 ]
  br label %57

; <label>:57:                                     ; preds = %56, %79
  %indvars.iv25 = phi i64 [ 0, %56 ], [ %indvars.iv.next26, %79 ]
  %.1523 = phi i32* [ %.0428, %56 ], [ %80, %79 ]
  call void @unroll_loop(i32 17)
  %58 = load i32, i32* %.1523, align 4
  %59 = getelementptr inbounds [17 x i32], [17 x i32]* @K_COEFF, i64 0, i64 %indvars.iv30
  %60 = load i32, i32* %59, align 4
  %61 = mul nsw i32 %58, %60
  %62 = load i32, i32* %2, align 4
  %63 = sext i32 %62 to i64
  %64 = getelementptr %struct.WEP_data, %struct.WEP_data* @wep, i32 0, i32 7
  %65 = getelementptr inbounds [64 x [256 x %struct.vote]], [64 x [256 x %struct.vote]]* %64, i64 0, i64 %63
  %66 = getelementptr inbounds [256 x %struct.vote], [256 x %struct.vote]* %65, i64 0, i64 %indvars.iv25
  %67 = getelementptr inbounds %struct.vote, %struct.vote* %66, i32 0, i32 1
  %68 = load i32, i32* %67, align 4
  %69 = add nsw i32 %68, %61
  store i32 %69, i32* %67, align 4
  %70 = getelementptr inbounds [17 x i32], [17 x i32]* @K_COEFF, i64 0, i64 %indvars.iv30
  %71 = load i32, i32* %70, align 4
  %72 = icmp ne i32 %71, 0
  br i1 %72, label %73, label %79

; <label>:73:                                     ; preds = %57
  %74 = load i32, i32* %.1523, align 4
  %75 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 30
  %76 = getelementptr inbounds [17 x i32], [17 x i32]* %75, i64 0, i64 %indvars.iv30
  %77 = load i32, i32* %76, align 4
  %78 = add nsw i32 %77, %74
  store i32 %78, i32* %76, align 4
  br label %79

; <label>:79:                                     ; preds = %57, %73
  %indvars.iv.next26 = add nuw nsw i64 %indvars.iv25, 1
  %80 = getelementptr inbounds i32, i32* %.1523, i32 1
  %exitcond27 = icmp ne i64 %indvars.iv.next26, 256
  br i1 %exitcond27, label %57, label %81

; <label>:81:                                     ; preds = %79
  %scevgep = getelementptr i32, i32* %.0428, i64 256
  %indvars.iv.next31 = add nuw nsw i64 %indvars.iv30, 1
  %exitcond32 = icmp ne i64 %indvars.iv.next31, 17
  br i1 %exitcond32, label %56, label %82

; <label>:82:                                     ; preds = %81
  %indvars.iv.next35 = add nuw nsw i64 %indvars.iv34, 1
  %83 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 5
  %84 = load i32, i32* %83, align 4
  %85 = sext i32 %84 to i64
  %86 = icmp slt i64 %indvars.iv.next35, %85
  br i1 %86, label %.lr.ph, label %._crit_edge.loopexit

._crit_edge.loopexit:                             ; preds = %82
  br label %._crit_edge

._crit_edge:                                      ; preds = %._crit_edge.loopexit, %38
  %87 = load i32, i32* %2, align 4
  %88 = sext i32 %87 to i64
  %89 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 8
  %90 = getelementptr inbounds [64 x i32], [64 x i32]* %89, i64 0, i64 %88
  %91 = load i32, i32* %90, align 4
  %92 = icmp ne i32 %91, 0
  br i1 %92, label %93, label %106

; <label>:93:                                     ; preds = %._crit_edge
  %94 = load i32, i32* %2, align 4
  %95 = sext i32 %94 to i64
  %96 = getelementptr %struct.WEP_data, %struct.WEP_data* @wep, i32 0, i32 7
  %97 = getelementptr inbounds [64 x [256 x %struct.vote]], [64 x [256 x %struct.vote]]* %96, i64 0, i64 %95
  %98 = load i32, i32* %2, align 4
  %99 = sext i32 %98 to i64
  %100 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 7
  %101 = getelementptr inbounds [64 x i8], [64 x i8]* %100, i64 0, i64 %99
  %102 = load i8, i8* %101, align 1
  %103 = zext i8 %102 to i64
  %104 = getelementptr inbounds [256 x %struct.vote], [256 x %struct.vote]* %97, i64 0, i64 %103
  %105 = getelementptr inbounds %struct.vote, %struct.vote* %104, i32 0, i32 1
  store i32 32767, i32* %105, align 4
  br label %106

; <label>:106:                                    ; preds = %93, %._crit_edge
  %107 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 15
  %108 = load i32, i32* %107, align 8
  %109 = icmp ne i32 %108, 0
  br i1 %109, label %.preheader6, label %124

.preheader6:                                      ; preds = %106
  br label %110

; <label>:110:                                    ; preds = %.preheader6, %110
  %indvars.iv20 = phi i64 [ %indvars.iv.next21, %110 ], [ 1, %.preheader6 ]
  call void @unroll_loop(i32 18)
  %111 = load i32, i32* %2, align 4
  %112 = sext i32 %111 to i64
  %113 = getelementptr %struct.WEP_data, %struct.WEP_data* @wep, i32 0, i32 7
  %114 = getelementptr inbounds [64 x [256 x %struct.vote]], [64 x [256 x %struct.vote]]* %113, i64 0, i64 %112
  %115 = getelementptr inbounds [256 x %struct.vote], [256 x %struct.vote]* %114, i64 0, i64 %indvars.iv20
  %116 = getelementptr inbounds %struct.vote, %struct.vote* %115, i32 0, i32 1
  store i32 -1, i32* %116, align 4
  %indvars.iv.next21 = add nuw nsw i64 %indvars.iv20, 1
  %exitcond22 = icmp ne i64 %indvars.iv.next21, 32
  br i1 %exitcond22, label %110, label %.preheader4

.preheader4:                                      ; preds = %110
  %indvars.iv16.ph = phi i64 [ 127, %110 ]
  br label %117

; <label>:117:                                    ; preds = %.preheader4, %117
  %indvars.iv16 = phi i64 [ %indvars.iv.next17, %117 ], [ %indvars.iv16.ph, %.preheader4 ]
  call void @unroll_loop(i32 19)
  %118 = load i32, i32* %2, align 4
  %119 = sext i32 %118 to i64
  %120 = getelementptr %struct.WEP_data, %struct.WEP_data* @wep, i32 0, i32 7
  %121 = getelementptr inbounds [64 x [256 x %struct.vote]], [64 x [256 x %struct.vote]]* %120, i64 0, i64 %119
  %122 = getelementptr inbounds [256 x %struct.vote], [256 x %struct.vote]* %121, i64 0, i64 %indvars.iv16
  %123 = getelementptr inbounds %struct.vote, %struct.vote* %122, i32 0, i32 1
  store i32 -1, i32* %123, align 4
  %indvars.iv.next17 = add nuw nsw i64 %indvars.iv16, 1
  %exitcond18 = icmp ne i64 %indvars.iv.next17, 256
  br i1 %exitcond18, label %117, label %.loopexit5

.loopexit5:                                       ; preds = %117
  br label %124

; <label>:124:                                    ; preds = %.loopexit5, %106
  %125 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 14
  %126 = load i32, i32* %125, align 4
  %127 = icmp ne i32 %126, 0
  br i1 %127, label %.preheader3, label %142

.preheader3:                                      ; preds = %124
  br label %128

; <label>:128:                                    ; preds = %.preheader3, %128
  %indvars.iv12 = phi i64 [ %indvars.iv.next13, %128 ], [ 0, %.preheader3 ]
  call void @unroll_loop(i32 20)
  %129 = load i32, i32* %2, align 4
  %130 = sext i32 %129 to i64
  %131 = getelementptr %struct.WEP_data, %struct.WEP_data* @wep, i32 0, i32 7
  %132 = getelementptr inbounds [64 x [256 x %struct.vote]], [64 x [256 x %struct.vote]]* %131, i64 0, i64 %130
  %133 = getelementptr inbounds [256 x %struct.vote], [256 x %struct.vote]* %132, i64 0, i64 %indvars.iv12
  %134 = getelementptr inbounds %struct.vote, %struct.vote* %133, i32 0, i32 1
  store i32 -1, i32* %134, align 4
  %indvars.iv.next13 = add nuw nsw i64 %indvars.iv12, 1
  %exitcond14 = icmp ne i64 %indvars.iv.next13, 48
  br i1 %exitcond14, label %128, label %.preheader1

.preheader1:                                      ; preds = %128
  %indvars.iv8.ph = phi i64 [ 58, %128 ]
  br label %135

; <label>:135:                                    ; preds = %.preheader1, %135
  %indvars.iv8 = phi i64 [ %indvars.iv.next9, %135 ], [ %indvars.iv8.ph, %.preheader1 ]
  call void @unroll_loop(i32 21)
  %136 = load i32, i32* %2, align 4
  %137 = sext i32 %136 to i64
  %138 = getelementptr %struct.WEP_data, %struct.WEP_data* @wep, i32 0, i32 7
  %139 = getelementptr inbounds [64 x [256 x %struct.vote]], [64 x [256 x %struct.vote]]* %138, i64 0, i64 %137
  %140 = getelementptr inbounds [256 x %struct.vote], [256 x %struct.vote]* %139, i64 0, i64 %indvars.iv8
  %141 = getelementptr inbounds %struct.vote, %struct.vote* %140, i32 0, i32 1
  store i32 -1, i32* %141, align 4
  %indvars.iv.next9 = add nuw nsw i64 %indvars.iv8, 1
  %exitcond10 = icmp ne i64 %indvars.iv.next9, 256
  br i1 %exitcond10, label %135, label %.loopexit2

.loopexit2:                                       ; preds = %135
  br label %142

; <label>:142:                                    ; preds = %.loopexit2, %124
  %143 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 16
  %144 = load i32, i32* %143, align 4
  %145 = icmp ne i32 %144, 0
  br i1 %145, label %.preheader, label %160

.preheader:                                       ; preds = %142
  br label %146

; <label>:146:                                    ; preds = %.preheader, %159
  %indvars.iv = phi i64 [ %indvars.iv.next, %159 ], [ 1, %.preheader ]
  call void @unroll_loop(i32 22)
  %147 = icmp ugt i64 %indvars.iv, 153
  br i1 %147, label %152, label %148

; <label>:148:                                    ; preds = %146
  %149 = trunc i64 %indvars.iv to i32
  %150 = and i32 %149, 15
  %151 = icmp sgt i32 %150, 9
  br i1 %151, label %152, label %159

; <label>:152:                                    ; preds = %148, %146
  %153 = load i32, i32* %2, align 4
  %154 = sext i32 %153 to i64
  %155 = getelementptr %struct.WEP_data, %struct.WEP_data* @wep, i32 0, i32 7
  %156 = getelementptr inbounds [64 x [256 x %struct.vote]], [64 x [256 x %struct.vote]]* %155, i64 0, i64 %154
  %157 = getelementptr inbounds [256 x %struct.vote], [256 x %struct.vote]* %156, i64 0, i64 %indvars.iv
  %158 = getelementptr inbounds %struct.vote, %struct.vote* %157, i32 0, i32 1
  store i32 -1, i32* %158, align 4
  br label %159

; <label>:159:                                    ; preds = %148, %152
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond = icmp ne i64 %indvars.iv.next, 256
  br i1 %exitcond, label %146, label %.loopexit

.loopexit:                                        ; preds = %159
  br label %160

; <label>:160:                                    ; preds = %.loopexit, %142
  %161 = load i32, i32* %2, align 4
  %162 = sext i32 %161 to i64
  %163 = getelementptr %struct.WEP_data, %struct.WEP_data* @wep, i32 0, i32 7
  %164 = getelementptr inbounds [64 x [256 x %struct.vote]], [64 x [256 x %struct.vote]]* %163, i64 0, i64 %162
  %165 = getelementptr inbounds [256 x %struct.vote], [256 x %struct.vote]* %164, i32 0, i32 0
  %166 = bitcast %struct.vote* %165 to i8*
  call void @qsort(i8* %166, i64 256, i64 8, i32 (i8*, i8*)* @cmp_votes)
  ret i32 0
}

declare dso_local void @qsort(i8*, i64, i64, i32 (i8*, i8*)*) #1

; Function Attrs: noinline nounwind uwtable
define dso_local i32 @update_ivbuf() #0 {
  %1 = getelementptr %struct.WEP_data, %struct.WEP_data* @wep, i32 0, i32 4
  store i64 0, i64* %1, align 8
  %2 = getelementptr %struct.WEP_data, %struct.WEP_data* @wep, i32 0, i32 2
  store i32 0, i32* %2, align 8
  %3 = load %struct.AP_info*, %struct.AP_info** @ap_1st, align 8
  %4 = icmp ne %struct.AP_info* %3, null
  br i1 %4, label %.lr.ph5.preheader, label %._crit_edge6

.lr.ph5.preheader:                                ; preds = %0
  br label %.lr.ph5

.lr.ph5:                                          ; preds = %.lr.ph5.preheader, %23
  %.013 = phi %struct.AP_info* [ %25, %23 ], [ %3, %.lr.ph5.preheader ]
  call void @unroll_loop(i32 60)
  %5 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.013, i32 0, i32 10
  %6 = load i32, i32* %5, align 8
  %7 = icmp eq i32 %6, 2
  br i1 %7, label %8, label %23

; <label>:8:                                      ; preds = %.lr.ph5
  %9 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.013, i32 0, i32 12
  %10 = load i32, i32* %9, align 8
  %11 = icmp ne i32 %10, 0
  br i1 %11, label %12, label %23

; <label>:12:                                     ; preds = %8
  %13 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.013, i32 0, i32 7
  %14 = load i64, i64* %13, align 8
  %15 = getelementptr %struct.WEP_data, %struct.WEP_data* @wep, i32 0, i32 4
  %16 = load i64, i64* %15, align 8
  %17 = add nsw i64 %16, %14
  %18 = getelementptr %struct.WEP_data, %struct.WEP_data* @wep, i32 0, i32 4
  store i64 %17, i64* %18, align 8
  %19 = getelementptr %struct.WEP_data, %struct.WEP_data* @wep, i32 0, i32 2
  %20 = load i32, i32* %19, align 8
  %21 = add nsw i32 %20, 1
  %22 = getelementptr %struct.WEP_data, %struct.WEP_data* @wep, i32 0, i32 2
  store i32 %21, i32* %22, align 8
  br label %23

; <label>:23:                                     ; preds = %12, %8, %.lr.ph5
  %24 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.013, i32 0, i32 0
  %25 = load %struct.AP_info*, %struct.AP_info** %24, align 8
  %26 = icmp ne %struct.AP_info* %25, null
  br i1 %26, label %.lr.ph5, label %._crit_edge6.loopexit

._crit_edge6.loopexit:                            ; preds = %23
  br label %._crit_edge6

._crit_edge6:                                     ; preds = %._crit_edge6.loopexit, %0
  %27 = getelementptr %struct.WEP_data, %struct.WEP_data* @wep, i32 0, i32 3
  %28 = load i64, i64* %27, align 8
  %29 = icmp eq i64 %28, 0
  br i1 %29, label %52, label %30

; <label>:30:                                     ; preds = %._crit_edge6
  %31 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 10
  %32 = load i32, i32* %31, align 4
  %33 = icmp eq i32 %32, 5
  br i1 %33, label %34, label %41

; <label>:34:                                     ; preds = %30
  %35 = getelementptr %struct.WEP_data, %struct.WEP_data* @wep, i32 0, i32 4
  %36 = load i64, i64* %35, align 8
  %37 = getelementptr %struct.WEP_data, %struct.WEP_data* @wep, i32 0, i32 3
  %38 = load i64, i64* %37, align 8
  %39 = sub nsw i64 %36, %38
  %40 = icmp sgt i64 %39, 20000
  br i1 %40, label %52, label %41

; <label>:41:                                     ; preds = %34, %30
  %42 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 10
  %43 = load i32, i32* %42, align 4
  %44 = icmp sge i32 %43, 13
  br i1 %44, label %45, label %111

; <label>:45:                                     ; preds = %41
  %46 = getelementptr %struct.WEP_data, %struct.WEP_data* @wep, i32 0, i32 4
  %47 = load i64, i64* %46, align 8
  %48 = getelementptr %struct.WEP_data, %struct.WEP_data* @wep, i32 0, i32 3
  %49 = load i64, i64* %48, align 8
  %50 = sub nsw i64 %47, %49
  %51 = icmp sgt i64 %50, 40000
  br i1 %51, label %52, label %111

; <label>:52:                                     ; preds = %45, %34, %._crit_edge6
  %53 = call i32 @pthread_mutex_lock(%union.pthread_mutex_t* @mx_ivb) #9
  %54 = getelementptr %struct.WEP_data, %struct.WEP_data* @wep, i32 0, i32 1
  %55 = load i8*, i8** %54, align 8
  %56 = icmp ne i8* %55, null
  br i1 %56, label %57, label %61

; <label>:57:                                     ; preds = %52
  %58 = getelementptr %struct.WEP_data, %struct.WEP_data* @wep, i32 0, i32 1
  %59 = load i8*, i8** %58, align 8
  call void @free(i8* %59) #9
  %60 = getelementptr %struct.WEP_data, %struct.WEP_data* @wep, i32 0, i32 1
  store i8* null, i8** %60, align 8
  br label %61

; <label>:61:                                     ; preds = %57, %52
  %62 = getelementptr %struct.WEP_data, %struct.WEP_data* @wep, i32 0, i32 3
  store i64 0, i64* %62, align 8
  %63 = load %struct.AP_info*, %struct.AP_info** @ap_1st, align 8
  %64 = icmp ne %struct.AP_info* %63, null
  br i1 %64, label %.lr.ph.preheader, label %._crit_edge

.lr.ph.preheader:                                 ; preds = %61
  br label %.lr.ph

.lr.ph:                                           ; preds = %.lr.ph.preheader, %106
  %.12 = phi %struct.AP_info* [ %108, %106 ], [ %63, %.lr.ph.preheader ]
  call void @unroll_loop(i32 61)
  %65 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.12, i32 0, i32 10
  %66 = load i32, i32* %65, align 8
  %67 = icmp eq i32 %66, 2
  br i1 %67, label %68, label %106

; <label>:68:                                     ; preds = %.lr.ph
  %69 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.12, i32 0, i32 12
  %70 = load i32, i32* %69, align 8
  %71 = icmp ne i32 %70, 0
  br i1 %71, label %72, label %106

; <label>:72:                                     ; preds = %68
  %73 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.12, i32 0, i32 7
  %74 = load i64, i64* %73, align 8
  %75 = trunc i64 %74 to i32
  %76 = getelementptr %struct.WEP_data, %struct.WEP_data* @wep, i32 0, i32 1
  %77 = load i8*, i8** %76, align 8
  %78 = getelementptr %struct.WEP_data, %struct.WEP_data* @wep, i32 0, i32 3
  %79 = load i64, i64* %78, align 8
  %80 = sext i32 %75 to i64
  %81 = add nsw i64 %79, %80
  %82 = mul nsw i64 %81, 5
  %83 = call i8* @realloc(i8* %77, i64 %82) #9, !track !176
  %84 = getelementptr %struct.WEP_data, %struct.WEP_data* @wep, i32 0, i32 1
  store i8* %83, i8** %84, align 8
  %85 = icmp eq i8* %83, null
  br i1 %85, label %86, label %90

; <label>:86:                                     ; preds = %72
  %87 = call i32 @pthread_mutex_unlock(%union.pthread_mutex_t* @mx_ivb) #9
  %88 = getelementptr [15 x i8], [15 x i8]* @.str.25, i32 0, i32 0
  call void @perror(i8* %88)
  %89 = call i32 @kill(i32 0, i32 15) #9
  call void @_exit(i32 1) #12
  unreachable

; <label>:90:                                     ; preds = %72
  %91 = getelementptr %struct.WEP_data, %struct.WEP_data* @wep, i32 0, i32 1
  %92 = load i8*, i8** %91, align 8
  %93 = getelementptr %struct.WEP_data, %struct.WEP_data* @wep, i32 0, i32 3
  %94 = load i64, i64* %93, align 8
  %95 = mul nsw i64 %94, 5
  %96 = getelementptr inbounds i8, i8* %92, i64 %95
  %97 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.12, i32 0, i32 4
  %98 = load i8*, i8** %97, align 8
  %99 = mul nsw i32 5, %75
  %100 = sext i32 %99 to i64
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %96, i8* align 1 %98, i64 %100, i1 false), !track !177
  %101 = sext i32 %75 to i64
  %102 = getelementptr %struct.WEP_data, %struct.WEP_data* @wep, i32 0, i32 3
  %103 = load i64, i64* %102, align 8
  %104 = add nsw i64 %103, %101
  %105 = getelementptr %struct.WEP_data, %struct.WEP_data* @wep, i32 0, i32 3
  store i64 %104, i64* %105, align 8
  br label %106

; <label>:106:                                    ; preds = %90, %68, %.lr.ph
  %107 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.12, i32 0, i32 0
  %108 = load %struct.AP_info*, %struct.AP_info** %107, align 8
  %109 = icmp ne %struct.AP_info* %108, null
  br i1 %109, label %.lr.ph, label %._crit_edge.loopexit

._crit_edge.loopexit:                             ; preds = %106
  br label %._crit_edge

._crit_edge:                                      ; preds = %._crit_edge.loopexit, %61
  %110 = call i32 @pthread_mutex_unlock(%union.pthread_mutex_t* @mx_ivb) #9
  br label %111

; <label>:111:                                    ; preds = %41, %45, %._crit_edge
  %.0 = phi i32 [ 2, %._crit_edge ], [ 0, %45 ], [ 0, %41 ]
  ret i32 %.0
}

; Function Attrs: noinline nounwind uwtable
define dso_local i32 @remove_votes(i32, i8 zeroext) #0 {
  br label %3

; <label>:3:                                      ; preds = %2, %64
  %indvars.iv = phi i64 [ 0, %2 ], [ %indvars.iv.next, %64 ]
  %.03 = phi i32 [ 0, %2 ], [ %spec.select, %64 ]
  call void @unroll_loop(i32 62)
  %4 = sext i32 %0 to i64
  %5 = getelementptr %struct.WEP_data, %struct.WEP_data* @wep, i32 0, i32 7
  %6 = getelementptr inbounds [64 x [256 x %struct.vote]], [64 x [256 x %struct.vote]]* %5, i64 0, i64 %4
  %7 = getelementptr inbounds [256 x %struct.vote], [256 x %struct.vote]* %6, i64 0, i64 %indvars.iv
  %8 = getelementptr inbounds %struct.vote, %struct.vote* %7, i32 0, i32 0
  %9 = load i32, i32* %8, align 8
  %10 = zext i8 %1 to i32
  %11 = icmp eq i32 %9, %10
  %spec.select = select i1 %11, i32 1, i32 %.03
  %12 = icmp ne i32 %spec.select, 0
  br i1 %12, label %13, label %64

; <label>:13:                                     ; preds = %3
  %14 = icmp eq i64 %indvars.iv, 255
  br i1 %14, label %15, label %27

; <label>:15:                                     ; preds = %13
  %16 = zext i8 %1 to i32
  %17 = sext i32 %0 to i64
  %18 = getelementptr %struct.WEP_data, %struct.WEP_data* @wep, i32 0, i32 7
  %19 = getelementptr inbounds [64 x [256 x %struct.vote]], [64 x [256 x %struct.vote]]* %18, i64 0, i64 %17
  %20 = getelementptr inbounds [256 x %struct.vote], [256 x %struct.vote]* %19, i64 0, i64 %indvars.iv
  %21 = getelementptr inbounds %struct.vote, %struct.vote* %20, i32 0, i32 0
  store i32 %16, i32* %21, align 8
  %22 = sext i32 %0 to i64
  %23 = getelementptr %struct.WEP_data, %struct.WEP_data* @wep, i32 0, i32 7
  %24 = getelementptr inbounds [64 x [256 x %struct.vote]], [64 x [256 x %struct.vote]]* %23, i64 0, i64 %22
  %25 = getelementptr inbounds [256 x %struct.vote], [256 x %struct.vote]* %24, i64 0, i64 %indvars.iv
  %26 = getelementptr inbounds %struct.vote, %struct.vote* %25, i32 0, i32 1
  store i32 0, i32* %26, align 4
  br label %64

; <label>:27:                                     ; preds = %13
  %28 = sext i32 %0 to i64
  %29 = getelementptr %struct.WEP_data, %struct.WEP_data* @wep, i32 0, i32 7
  %30 = getelementptr inbounds [64 x [256 x %struct.vote]], [64 x [256 x %struct.vote]]* %29, i64 0, i64 %28
  %31 = add nuw nsw i64 %indvars.iv, 1
  %32 = getelementptr inbounds [256 x %struct.vote], [256 x %struct.vote]* %30, i64 0, i64 %31
  %33 = getelementptr inbounds %struct.vote, %struct.vote* %32, i32 0, i32 0
  %34 = load i32, i32* %33, align 8
  %35 = sext i32 %0 to i64
  %36 = getelementptr %struct.WEP_data, %struct.WEP_data* @wep, i32 0, i32 7
  %37 = getelementptr inbounds [64 x [256 x %struct.vote]], [64 x [256 x %struct.vote]]* %36, i64 0, i64 %35
  %38 = getelementptr inbounds [256 x %struct.vote], [256 x %struct.vote]* %37, i64 0, i64 %indvars.iv
  %39 = getelementptr inbounds %struct.vote, %struct.vote* %38, i32 0, i32 0
  store i32 %34, i32* %39, align 8
  %40 = sext i32 %0 to i64
  %41 = getelementptr %struct.WEP_data, %struct.WEP_data* @wep, i32 0, i32 7
  %42 = getelementptr inbounds [64 x [256 x %struct.vote]], [64 x [256 x %struct.vote]]* %41, i64 0, i64 %40
  %43 = add nuw nsw i64 %indvars.iv, 1
  %44 = getelementptr inbounds [256 x %struct.vote], [256 x %struct.vote]* %42, i64 0, i64 %43
  %45 = getelementptr inbounds %struct.vote, %struct.vote* %44, i32 0, i32 1
  %46 = load i32, i32* %45, align 4
  %47 = sext i32 %0 to i64
  %48 = getelementptr %struct.WEP_data, %struct.WEP_data* @wep, i32 0, i32 7
  %49 = getelementptr inbounds [64 x [256 x %struct.vote]], [64 x [256 x %struct.vote]]* %48, i64 0, i64 %47
  %50 = getelementptr inbounds [256 x %struct.vote], [256 x %struct.vote]* %49, i64 0, i64 %indvars.iv
  %51 = getelementptr inbounds %struct.vote, %struct.vote* %50, i32 0, i32 1
  store i32 %46, i32* %51, align 4
  %52 = icmp eq i64 %indvars.iv, 0
  br i1 %52, label %53, label %64

; <label>:53:                                     ; preds = %27
  %54 = sext i32 %0 to i64
  %55 = getelementptr %struct.WEP_data, %struct.WEP_data* @wep, i32 0, i32 7
  %56 = getelementptr inbounds [64 x [256 x %struct.vote]], [64 x [256 x %struct.vote]]* %55, i64 0, i64 %54
  %57 = getelementptr inbounds [256 x %struct.vote], [256 x %struct.vote]* %56, i64 0, i64 %indvars.iv
  %58 = getelementptr inbounds %struct.vote, %struct.vote* %57, i32 0, i32 0
  %59 = load i32, i32* %58, align 8
  %60 = trunc i32 %59 to i8
  %61 = sext i32 %0 to i64
  %62 = getelementptr %struct.WEP_data, %struct.WEP_data* @wep, i32 0, i32 0
  %63 = getelementptr inbounds [64 x i8], [64 x i8]* %62, i64 0, i64 %61
  store i8 %60, i8* %63, align 1
  br label %64

; <label>:64:                                     ; preds = %3, %27, %53, %15
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond = icmp ne i64 %indvars.iv.next, 256
  br i1 %exitcond, label %3, label %65

; <label>:65:                                     ; preds = %64
  ret i32 0
}

; Function Attrs: noinline nounwind uwtable
define dso_local i32 @do_wep_crack1(i32) #0 {
  %2 = alloca [4 x i8], align 1
  br label %3

; <label>:3:                                      ; preds = %32, %1
  call void @unroll_loop(i32 65)
  %4 = call i32 @update_ivbuf()
  switch i32 %4, label %6 [
    i32 1, label %.loopexit24
    i32 2, label %5
  ]

; <label>:5:                                      ; preds = %3
  br label %454

; <label>:6:                                      ; preds = %3
  %7 = getelementptr %struct.WEP_data, %struct.WEP_data* @wep, i32 0, i32 4
  %8 = load i64, i64* %7, align 8
  %9 = icmp slt i64 %8, 256
  br i1 %9, label %10, label %15

; <label>:10:                                     ; preds = %6
  %11 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 7, i64 0
  %12 = load i8, i8* %11, align 4
  %13 = zext i8 %12 to i32
  %14 = icmp eq i32 %13, 0
  br i1 %14, label %24, label %15

; <label>:15:                                     ; preds = %10, %6
  %16 = getelementptr %struct.WEP_data, %struct.WEP_data* @wep, i32 0, i32 4
  %17 = load i64, i64* %16, align 8
  %18 = icmp slt i64 %17, 32
  br i1 %18, label %19, label %41

; <label>:19:                                     ; preds = %15
  %20 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 7, i64 0
  %21 = load i8, i8* %20, align 4
  %22 = zext i8 %21 to i32
  %23 = icmp ne i32 %22, 0
  br i1 %23, label %24, label %41

; <label>:24:                                     ; preds = %19, %10
  %25 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 24
  %26 = load i32, i32* %25, align 4
  %27 = icmp ne i32 %26, 0
  br i1 %27, label %32, label %28

; <label>:28:                                     ; preds = %24
  %29 = getelementptr [125 x i8], [125 x i8]* @.str.46, i32 0, i32 0
  %30 = call i32 (i8*, ...) @printf(i8* %29)
  %31 = call i32 @kill(i32 0, i32 15) #9
  call void @_exit(i32 1) #12
  unreachable

; <label>:32:                                     ; preds = %24
  %33 = load i64, i64* @nb_pkt, align 8
  %34 = getelementptr %struct.WEP_data, %struct.WEP_data* @wep, i32 0, i32 4
  %35 = load i64, i64* %34, align 8
  %36 = getelementptr [34 x i8], [34 x i8]* @.str.47, i32 0, i32 0
  %37 = call i32 (i8*, ...) @printf(i8* %36, i64 %33, i64 %35)
  %38 = load %struct._IO_FILE*, %struct._IO_FILE** @stdout, align 8
  %39 = call i32 @fflush(%struct._IO_FILE* %38)
  %40 = call i32 @sleep(i32 1)
  br label %3

; <label>:41:                                     ; preds = %19, %15
  %42 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 10
  %43 = load i32, i32* %42, align 4
  %44 = icmp eq i32 %0, %43
  br i1 %44, label %45, label %54

; <label>:45:                                     ; preds = %41
  %46 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 6
  %47 = load i32, i32* %46, align 8
  %48 = icmp ne i32 %47, 0
  br i1 %48, label %51, label %49

; <label>:49:                                     ; preds = %45
  %50 = sub nsw i32 %0, 1
  call void @show_wep_stats(i32 %50, i32 0, [256 x %struct.PTW_tableentry]* null, i32* null, i32* null, i32 0)
  br label %51

; <label>:51:                                     ; preds = %49, %45
  %52 = getelementptr %struct.WEP_data, %struct.WEP_data* @wep, i32 0, i32 0, i32 0
  %53 = call i32 @check_wep_key(i8* %52, i32 %0, i32 0)
  br label %454

; <label>:54:                                     ; preds = %41
  %55 = call i32 @calc_poll(i32 %0)
  %56 = icmp ne i32 %55, 0
  br i1 %56, label %454, label %57

; <label>:57:                                     ; preds = %54
  %58 = sext i32 %0 to i64
  %59 = getelementptr %struct.WEP_data, %struct.WEP_data* @wep, i32 0, i32 5
  %60 = getelementptr inbounds [64 x i32], [64 x i32]* %59, i64 0, i64 %58
  store i32 1, i32* %60, align 4
  %61 = sext i32 %0 to i64
  %62 = getelementptr %struct.WEP_data, %struct.WEP_data* @wep, i32 0, i32 5
  %63 = getelementptr inbounds [64 x i32], [64 x i32]* %62, i64 0, i64 %61
  %64 = load i32, i32* %63, align 4
  %65 = icmp slt i32 %64, 256
  br i1 %65, label %.lr.ph26.preheader, label %.loopexit10

.lr.ph26.preheader:                               ; preds = %57
  %66 = sext i32 %0 to i64
  %67 = getelementptr %struct.WEP_data, %struct.WEP_data* @wep, i32 0, i32 5
  %68 = getelementptr inbounds [64 x i32], [64 x i32]* %67, i64 0, i64 %66
  br label %.lr.ph26

.lr.ph26:                                         ; preds = %.lr.ph26.preheader, %92
  call void @unroll_loop(i32 66)
  %69 = sext i32 %0 to i64
  %70 = getelementptr %struct.WEP_data, %struct.WEP_data* @wep, i32 0, i32 7
  %71 = getelementptr inbounds [64 x [256 x %struct.vote]], [64 x [256 x %struct.vote]]* %70, i64 0, i64 %69
  %72 = sext i32 %0 to i64
  %73 = getelementptr %struct.WEP_data, %struct.WEP_data* @wep, i32 0, i32 5
  %74 = getelementptr inbounds [64 x i32], [64 x i32]* %73, i64 0, i64 %72
  %75 = load i32, i32* %74, align 4
  %76 = sext i32 %75 to i64
  %77 = getelementptr inbounds [256 x %struct.vote], [256 x %struct.vote]* %71, i64 0, i64 %76
  %78 = getelementptr inbounds %struct.vote, %struct.vote* %77, i32 0, i32 1
  %79 = load i32, i32* %78, align 4
  %80 = sitofp i32 %79 to float
  %81 = sext i32 %0 to i64
  %82 = getelementptr %struct.WEP_data, %struct.WEP_data* @wep, i32 0, i32 7
  %83 = getelementptr inbounds [64 x [256 x %struct.vote]], [64 x [256 x %struct.vote]]* %82, i64 0, i64 %81
  %84 = getelementptr inbounds [256 x %struct.vote], [256 x %struct.vote]* %83, i64 0, i64 0
  %85 = getelementptr inbounds %struct.vote, %struct.vote* %84, i32 0, i32 1
  %86 = load i32, i32* %85, align 4
  %87 = sitofp i32 %86 to float
  %88 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 12
  %89 = load float, float* %88, align 4
  %90 = fdiv float %87, %89
  %91 = fcmp olt float %80, %90
  br i1 %91, label %.loopexit10.loopexit, label %92

; <label>:92:                                     ; preds = %.lr.ph26
  %93 = load i32, i32* %68, align 4
  %94 = add nsw i32 %93, 1
  store i32 %94, i32* %68, align 4
  %95 = load i32, i32* %63, align 4
  %96 = icmp slt i32 %95, 256
  br i1 %96, label %.lr.ph26, label %.loopexit10.loopexit

.loopexit10.loopexit:                             ; preds = %.lr.ph26, %92
  br label %.loopexit10

.loopexit10:                                      ; preds = %.loopexit10.loopexit, %57
  %97 = sext i32 %0 to i64
  %98 = getelementptr %struct.WEP_data, %struct.WEP_data* @wep, i32 0, i32 6
  %99 = getelementptr inbounds [64 x i32], [64 x i32]* %98, i64 0, i64 %97
  store i32 0, i32* %99, align 4
  %100 = sext i32 %0 to i64
  %101 = getelementptr %struct.WEP_data, %struct.WEP_data* @wep, i32 0, i32 6
  %102 = getelementptr inbounds [64 x i32], [64 x i32]* %101, i64 0, i64 %100
  %103 = load i32, i32* %102, align 4
  %104 = sext i32 %0 to i64
  %105 = getelementptr %struct.WEP_data, %struct.WEP_data* @wep, i32 0, i32 5
  %106 = getelementptr inbounds [64 x i32], [64 x i32]* %105, i64 0, i64 %104
  %107 = load i32, i32* %106, align 4
  %108 = icmp slt i32 %103, %107
  br i1 %108, label %.lr.ph23.preheader, label %._crit_edge24

.lr.ph23.preheader:                               ; preds = %.loopexit10
  br label %.lr.ph23

.lr.ph23:                                         ; preds = %.lr.ph23.preheader, %417
  call void @unroll_loop(i32 67)
  %109 = call i32 @update_ivbuf()
  switch i32 %109, label %111 [
    i32 1, label %.loopexit22
    i32 2, label %110
  ]

; <label>:110:                                    ; preds = %.lr.ph23
  br label %454

; <label>:111:                                    ; preds = %.lr.ph23
  %112 = sext i32 %0 to i64
  %113 = getelementptr %struct.WEP_data, %struct.WEP_data* @wep, i32 0, i32 7
  %114 = getelementptr inbounds [64 x [256 x %struct.vote]], [64 x [256 x %struct.vote]]* %113, i64 0, i64 %112
  %115 = sext i32 %0 to i64
  %116 = getelementptr %struct.WEP_data, %struct.WEP_data* @wep, i32 0, i32 6
  %117 = getelementptr inbounds [64 x i32], [64 x i32]* %116, i64 0, i64 %115
  %118 = load i32, i32* %117, align 4
  %119 = sext i32 %118 to i64
  %120 = getelementptr inbounds [256 x %struct.vote], [256 x %struct.vote]* %114, i64 0, i64 %119
  %121 = getelementptr inbounds %struct.vote, %struct.vote* %120, i32 0, i32 0
  %122 = load i32, i32* %121, align 8
  %123 = trunc i32 %122 to i8
  %124 = sext i32 %0 to i64
  %125 = getelementptr %struct.WEP_data, %struct.WEP_data* @wep, i32 0, i32 0
  %126 = getelementptr inbounds [64 x i8], [64 x i8]* %125, i64 0, i64 %124
  store i8 %123, i8* %126, align 1
  %127 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 6
  %128 = load i32, i32* %127, align 8
  %129 = icmp ne i32 %128, 0
  br i1 %129, label %131, label %130

; <label>:130:                                    ; preds = %111
  call void @show_wep_stats(i32 %0, i32 0, [256 x %struct.PTW_tableentry]* null, i32* null, i32* null, i32 0)
  br label %131

; <label>:131:                                    ; preds = %130, %111
  %132 = icmp eq i32 %0, 4
  br i1 %132, label %133, label %143

; <label>:133:                                    ; preds = %131
  %134 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 10
  %135 = load i32, i32* %134, align 4
  %136 = icmp eq i32 %135, 13
  br i1 %136, label %137, label %143

; <label>:137:                                    ; preds = %133
  %138 = getelementptr %struct.WEP_data, %struct.WEP_data* @wep, i32 0, i32 0, i32 0
  %139 = call i32 @check_wep_key(i8* %138, i32 %0, i32 5)
  %140 = icmp eq i32 %139, 0
  br i1 %140, label %141, label %143

; <label>:141:                                    ; preds = %137
  %142 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 10
  store i32 5, i32* %142, align 4
  br label %454

; <label>:143:                                    ; preds = %137, %133, %131
  %144 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 17
  %145 = load i32, i32* %144, align 8
  %146 = add nsw i32 %0, %145
  %147 = add nsw i32 %146, 1
  %148 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 10
  %149 = load i32, i32* %148, align 4
  %150 = icmp eq i32 %147, %149
  br i1 %150, label %151, label %413

; <label>:151:                                    ; preds = %143
  %152 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 17
  %153 = load i32, i32* %152, align 8
  %154 = icmp ne i32 %153, 0
  br i1 %154, label %155, label %413

; <label>:155:                                    ; preds = %151
  %156 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 40
  %157 = load i32, i32* %156, align 8
  %158 = icmp eq i32 %157, 1
  br i1 %158, label %.preheader20, label %208

.preheader20:                                     ; preds = %155
  br label %159

; <label>:159:                                    ; preds = %.preheader20, %.backedge
  call void @unroll_loop(i32 68)
  call void @show_wep_stats(i32 %0, i32 1, [256 x %struct.PTW_tableentry]* null, i32* null, i32* null, i32 0)
  %160 = getelementptr [69 x i8], [69 x i8]* @.str.48, i32 0, i32 0
  %161 = call i32 (i8*, ...) @printf(i8* %160)
  %162 = getelementptr inbounds [4 x i8], [4 x i8]* %2, i32 0, i32 0
  call void @llvm.memset.p0i8.i64(i8* align 1 %162, i8 0, i64 4, i1 false)
  %163 = getelementptr inbounds [4 x i8], [4 x i8]* %2, i32 0, i32 0
  %164 = call i32 @readLine(i8* %163, i32 3)
  %165 = getelementptr inbounds [4 x i8], [4 x i8]* %2, i64 0, i64 0
  %166 = load i8, i8* %165, align 1
  %167 = sext i8 %166 to i32
  %168 = icmp eq i32 %167, 0
  %169 = icmp eq i32 %164, 0
  %or.cond = or i1 %168, %169
  br i1 %or.cond, label %.loopexit21, label %170

; <label>:170:                                    ; preds = %159
  %171 = getelementptr inbounds [4 x i8], [4 x i8]* %2, i32 0, i32 0
  %172 = call i32 @atoi(i8* %171) #10
  %173 = call i16** @__ctype_b_loc() #13
  %174 = load i16*, i16** %173, align 8
  %175 = getelementptr inbounds [4 x i8], [4 x i8]* %2, i64 0, i64 0
  %176 = load i8, i8* %175, align 1
  %177 = sext i8 %176 to i32
  %178 = sext i32 %177 to i64
  %179 = getelementptr inbounds i16, i16* %174, i64 %178
  %180 = load i16, i16* %179, align 2
  %181 = zext i16 %180 to i32
  %182 = and i32 %181, 2048
  %183 = icmp eq i32 %182, 0
  %184 = icmp slt i32 %172, 0
  %or.cond1 = or i1 %183, %184
  br i1 %or.cond1, label %.backedge, label %185

; <label>:185:                                    ; preds = %170
  %186 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 10
  %187 = load i32, i32* %186, align 4
  %188 = icmp sge i32 %172, %187
  br i1 %188, label %.backedge, label %189

; <label>:189:                                    ; preds = %185
  %190 = getelementptr [81 x i8], [81 x i8]* @.str.49, i32 0, i32 0
  %191 = call i32 (i8*, ...) @printf(i8* %190)
  %192 = getelementptr inbounds [4 x i8], [4 x i8]* %2, i32 0, i32 0
  call void @llvm.memset.p0i8.i64(i8* align 1 %192, i8 0, i64 4, i1 false)
  %193 = getelementptr inbounds [4 x i8], [4 x i8]* %2, i32 0, i32 0
  %194 = call i32 @readLine(i8* %193, i32 3)
  %195 = getelementptr inbounds [4 x i8], [4 x i8]* %2, i64 0, i64 0
  %196 = load i8, i8* %195, align 1
  %197 = sext i8 %196 to i32
  %198 = icmp eq i32 %197, 0
  %199 = icmp eq i32 %194, 0
  %or.cond2 = or i1 %198, %199
  br i1 %or.cond2, label %.backedge, label %200

; <label>:200:                                    ; preds = %189
  %201 = getelementptr inbounds [4 x i8], [4 x i8]* %2, i32 0, i32 0
  %202 = call i32 @hexToInt(i8* %201, i32 %194)
  %203 = icmp slt i32 %202, 0
  %204 = icmp sgt i32 %202, 255
  %or.cond3 = or i1 %203, %204
  br i1 %or.cond3, label %.backedge, label %205

; <label>:205:                                    ; preds = %200
  %206 = trunc i32 %202 to i8
  %207 = call i32 @remove_votes(i32 %172, i8 zeroext %206)
  br label %.backedge

.backedge:                                        ; preds = %200, %189, %170, %185, %205
  br label %159

.loopexit21:                                      ; preds = %159
  br label %208

; <label>:208:                                    ; preds = %.loopexit21, %155
  %209 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 5
  %210 = load i32, i32* %209, align 4
  %211 = icmp eq i32 %210, 1
  br i1 %211, label %216, label %212

; <label>:212:                                    ; preds = %208
  %213 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 18
  %214 = load i32, i32* %213, align 4
  %215 = icmp eq i32 %214, 0
  br i1 %215, label %216, label %344

; <label>:216:                                    ; preds = %212, %208
  %217 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 17
  %218 = load i32, i32* %217, align 8
  %219 = icmp eq i32 %218, 4
  br i1 %219, label %.preheader, label %264

.preheader:                                       ; preds = %216
  br label %220

; <label>:220:                                    ; preds = %.preheader, %261
  %.0521 = phi i32 [ %262, %261 ], [ 0, %.preheader ]
  call void @unroll_loop(i32 69)
  %221 = trunc i32 %.0521 to i8
  %222 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 31, i64 0
  %223 = load i32, i32* %222, align 4
  %224 = sext i32 %223 to i64
  %225 = getelementptr %struct.WEP_data, %struct.WEP_data* @wep, i32 0, i32 0
  %226 = getelementptr inbounds [64 x i8], [64 x i8]* %225, i64 0, i64 %224
  store i8 %221, i8* %226, align 1
  br label %227

; <label>:227:                                    ; preds = %220, %258
  %.0620 = phi i32 [ 0, %220 ], [ %259, %258 ]
  call void @unroll_loop(i32 70)
  %228 = trunc i32 %.0620 to i8
  %229 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 31, i64 1
  %230 = load i32, i32* %229, align 4
  %231 = sext i32 %230 to i64
  %232 = getelementptr %struct.WEP_data, %struct.WEP_data* @wep, i32 0, i32 0
  %233 = getelementptr inbounds [64 x i8], [64 x i8]* %232, i64 0, i64 %231
  store i8 %228, i8* %233, align 1
  br label %234

; <label>:234:                                    ; preds = %227, %255
  %.0119 = phi i32 [ 0, %227 ], [ %256, %255 ]
  call void @unroll_loop(i32 71)
  %235 = trunc i32 %.0119 to i8
  %236 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 31, i64 2
  %237 = load i32, i32* %236, align 4
  %238 = sext i32 %237 to i64
  %239 = getelementptr %struct.WEP_data, %struct.WEP_data* @wep, i32 0, i32 0
  %240 = getelementptr inbounds [64 x i8], [64 x i8]* %239, i64 0, i64 %238
  store i8 %235, i8* %240, align 1
  br label %241

; <label>:241:                                    ; preds = %234, %252
  %.0218 = phi i32 [ 0, %234 ], [ %253, %252 ]
  call void @unroll_loop(i32 72)
  %242 = trunc i32 %.0218 to i8
  %243 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 31, i64 3
  %244 = load i32, i32* %243, align 4
  %245 = sext i32 %244 to i64
  %246 = getelementptr %struct.WEP_data, %struct.WEP_data* @wep, i32 0, i32 0
  %247 = getelementptr inbounds [64 x i8], [64 x i8]* %246, i64 0, i64 %245
  store i8 %242, i8* %247, align 1
  %248 = add nsw i32 %0, 1
  %249 = getelementptr %struct.WEP_data, %struct.WEP_data* @wep, i32 0, i32 0, i32 0
  %250 = call i32 @check_wep_key(i8* %249, i32 %248, i32 0)
  %251 = icmp eq i32 %250, 0
  br i1 %251, label %.loopexit5, label %252

; <label>:252:                                    ; preds = %241
  %253 = add nuw nsw i32 %.0218, 1
  %254 = icmp ult i32 %253, 256
  br i1 %254, label %241, label %255

; <label>:255:                                    ; preds = %252
  %256 = add nuw nsw i32 %.0119, 1
  %257 = icmp ult i32 %256, 256
  br i1 %257, label %234, label %258

; <label>:258:                                    ; preds = %255
  %259 = add nuw nsw i32 %.0620, 1
  %260 = icmp ult i32 %259, 256
  br i1 %260, label %227, label %261

; <label>:261:                                    ; preds = %258
  %262 = add nuw nsw i32 %.0521, 1
  %263 = icmp ult i32 %262, 256
  br i1 %263, label %220, label %.loopexit11

; <label>:264:                                    ; preds = %216
  %265 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 17
  %266 = load i32, i32* %265, align 8
  %267 = icmp eq i32 %266, 3
  br i1 %267, label %.preheader12, label %302

.preheader12:                                     ; preds = %264
  br label %268

; <label>:268:                                    ; preds = %.preheader12, %299
  %.1717 = phi i32 [ %300, %299 ], [ 0, %.preheader12 ]
  call void @unroll_loop(i32 73)
  %269 = trunc i32 %.1717 to i8
  %270 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 31, i64 0
  %271 = load i32, i32* %270, align 4
  %272 = sext i32 %271 to i64
  %273 = getelementptr %struct.WEP_data, %struct.WEP_data* @wep, i32 0, i32 0
  %274 = getelementptr inbounds [64 x i8], [64 x i8]* %273, i64 0, i64 %272
  store i8 %269, i8* %274, align 1
  br label %275

; <label>:275:                                    ; preds = %268, %296
  %.116 = phi i32 [ 0, %268 ], [ %297, %296 ]
  call void @unroll_loop(i32 74)
  %276 = trunc i32 %.116 to i8
  %277 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 31, i64 1
  %278 = load i32, i32* %277, align 4
  %279 = sext i32 %278 to i64
  %280 = getelementptr %struct.WEP_data, %struct.WEP_data* @wep, i32 0, i32 0
  %281 = getelementptr inbounds [64 x i8], [64 x i8]* %280, i64 0, i64 %279
  store i8 %276, i8* %281, align 1
  br label %282

; <label>:282:                                    ; preds = %275, %293
  %.1315 = phi i32 [ 0, %275 ], [ %294, %293 ]
  call void @unroll_loop(i32 75)
  %283 = trunc i32 %.1315 to i8
  %284 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 31, i64 2
  %285 = load i32, i32* %284, align 4
  %286 = sext i32 %285 to i64
  %287 = getelementptr %struct.WEP_data, %struct.WEP_data* @wep, i32 0, i32 0
  %288 = getelementptr inbounds [64 x i8], [64 x i8]* %287, i64 0, i64 %286
  store i8 %283, i8* %288, align 1
  %289 = add nsw i32 %0, 1
  %290 = getelementptr %struct.WEP_data, %struct.WEP_data* @wep, i32 0, i32 0, i32 0
  %291 = call i32 @check_wep_key(i8* %290, i32 %289, i32 0)
  %292 = icmp eq i32 %291, 0
  br i1 %292, label %.loopexit6, label %293

; <label>:293:                                    ; preds = %282
  %294 = add nuw nsw i32 %.1315, 1
  %295 = icmp ult i32 %294, 256
  br i1 %295, label %282, label %296

; <label>:296:                                    ; preds = %293
  %297 = add nuw nsw i32 %.116, 1
  %298 = icmp ult i32 %297, 256
  br i1 %298, label %275, label %299

; <label>:299:                                    ; preds = %296
  %300 = add nuw nsw i32 %.1717, 1
  %301 = icmp ult i32 %300, 256
  br i1 %301, label %268, label %.loopexit13

; <label>:302:                                    ; preds = %264
  %303 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 17
  %304 = load i32, i32* %303, align 8
  %305 = icmp eq i32 %304, 2
  br i1 %305, label %.preheader14, label %.preheader16

.preheader16:                                     ; preds = %302
  br label %330

.preheader14:                                     ; preds = %302
  br label %306

; <label>:306:                                    ; preds = %.preheader14, %327
  %.214 = phi i32 [ %328, %327 ], [ 0, %.preheader14 ]
  call void @unroll_loop(i32 76)
  %307 = trunc i32 %.214 to i8
  %308 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 31, i64 0
  %309 = load i32, i32* %308, align 4
  %310 = sext i32 %309 to i64
  %311 = getelementptr %struct.WEP_data, %struct.WEP_data* @wep, i32 0, i32 0
  %312 = getelementptr inbounds [64 x i8], [64 x i8]* %311, i64 0, i64 %310
  store i8 %307, i8* %312, align 1
  br label %313

; <label>:313:                                    ; preds = %306, %324
  %.2413 = phi i32 [ 0, %306 ], [ %325, %324 ]
  call void @unroll_loop(i32 77)
  %314 = trunc i32 %.2413 to i8
  %315 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 31, i64 1
  %316 = load i32, i32* %315, align 4
  %317 = sext i32 %316 to i64
  %318 = getelementptr %struct.WEP_data, %struct.WEP_data* @wep, i32 0, i32 0
  %319 = getelementptr inbounds [64 x i8], [64 x i8]* %318, i64 0, i64 %317
  store i8 %314, i8* %319, align 1
  %320 = add nsw i32 %0, 1
  %321 = getelementptr %struct.WEP_data, %struct.WEP_data* @wep, i32 0, i32 0, i32 0
  %322 = call i32 @check_wep_key(i8* %321, i32 %320, i32 0)
  %323 = icmp eq i32 %322, 0
  br i1 %323, label %.loopexit8, label %324

; <label>:324:                                    ; preds = %313
  %325 = add nuw nsw i32 %.2413, 1
  %326 = icmp ult i32 %325, 256
  br i1 %326, label %313, label %327

; <label>:327:                                    ; preds = %324
  %328 = add nuw nsw i32 %.214, 1
  %329 = icmp ult i32 %328, 256
  br i1 %329, label %306, label %.loopexit15

; <label>:330:                                    ; preds = %.preheader16, %341
  %.312 = phi i32 [ %342, %341 ], [ 0, %.preheader16 ]
  call void @unroll_loop(i32 78)
  %331 = trunc i32 %.312 to i8
  %332 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 31, i64 0
  %333 = load i32, i32* %332, align 4
  %334 = sext i32 %333 to i64
  %335 = getelementptr %struct.WEP_data, %struct.WEP_data* @wep, i32 0, i32 0
  %336 = getelementptr inbounds [64 x i8], [64 x i8]* %335, i64 0, i64 %334
  store i8 %331, i8* %336, align 1
  %337 = add nsw i32 %0, 1
  %338 = getelementptr %struct.WEP_data, %struct.WEP_data* @wep, i32 0, i32 0, i32 0
  %339 = call i32 @check_wep_key(i8* %338, i32 %337, i32 0)
  %340 = icmp eq i32 %339, 0
  br i1 %340, label %.loopexit17, label %341

; <label>:341:                                    ; preds = %330
  %342 = add nuw nsw i32 %.312, 1
  %343 = icmp ult i32 %342, 256
  br i1 %343, label %330, label %.loopexit19

; <label>:344:                                    ; preds = %212
  %345 = load i32, i32* @do_wep_crack1.k, align 4
  %346 = add nsw i32 %345, 1
  %347 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 5
  %348 = load i32, i32* %347, align 4
  %349 = srem i32 %346, %348
  store i32 %349, i32* @do_wep_crack1.k, align 4
  br label %350

; <label>:350:                                    ; preds = %401, %344
  call void @unroll_loop(i32 79)
  call void @unroll_loop(i32 80)
  %351 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 5
  %352 = load i32, i32* %351, align 4
  %353 = icmp slt i32 0, %352
  br i1 %353, label %.lr.ph31, label %.loopexit.loopexit

.lr.ph31:                                         ; preds = %350
  br label %354

; <label>:354:                                    ; preds = %.lr.ph31, %368
  %.0829 = phi i32 [ 0, %.lr.ph31 ], [ %370, %368 ]
  %355 = load i32, i32* @wepkey_crack_success, align 4
  %356 = icmp ne i32 %355, 0
  %357 = xor i1 %356, true
  br i1 %357, label %358, label %..loopexit.loopexit_crit_edge

; <label>:358:                                    ; preds = %354
  %359 = load i32, i32* @do_wep_crack1.k, align 4
  %360 = add nsw i32 %.0829, %359
  %361 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 5
  %362 = load i32, i32* %361, align 4
  %363 = srem i32 %360, %362
  %364 = sext i32 %363 to i64
  %365 = getelementptr inbounds [256 x i32], [256 x i32]* @bf_nkeys, i64 0, i64 %364
  %366 = load i32, i32* %365, align 4
  %367 = icmp sgt i32 %366, 16
  br i1 %367, label %368, label %373

; <label>:368:                                    ; preds = %358
  %369 = call i32 @usleep(i32 1)
  %370 = add nuw nsw i32 %.0829, 1
  call void @unroll_loop(i32 80)
  %371 = load i32, i32* %351, align 4
  %372 = icmp slt i32 %370, %371
  br i1 %372, label %354, label %..loopexit.loopexit_crit_edge32

; <label>:373:                                    ; preds = %358
  %.08.lcssa9 = phi i32 [ %.0829, %358 ]
  %374 = load i32, i32* @do_wep_crack1.k, align 4
  %375 = add nsw i32 %.08.lcssa9, %374
  %376 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 5
  %377 = load i32, i32* %376, align 4
  %378 = srem i32 %375, %377
  %379 = sext i32 %378 to i64
  %380 = getelementptr inbounds [256 x i32], [256 x i32]* @bf_nkeys, i64 0, i64 %379
  %381 = load i32, i32* %380, align 4
  %382 = add nsw i32 %381, 1
  store i32 %382, i32* %380, align 4
  %383 = load i32, i32* @do_wep_crack1.k, align 4
  %384 = add nsw i32 %.08.lcssa9, %383
  %385 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 5
  %386 = load i32, i32* %385, align 4
  %387 = srem i32 %384, %386
  %388 = sext i32 %387 to i64
  %389 = getelementptr inbounds [256 x [2 x i32]], [256 x [2 x i32]]* @bf_pipe, i64 0, i64 %388
  %390 = getelementptr inbounds [2 x i32], [2 x i32]* %389, i64 0, i64 1
  %391 = load i32, i32* %390, align 4
  %392 = getelementptr %struct.WEP_data, %struct.WEP_data* @wep, i32 0, i32 0, i32 0
  %393 = call i32 @safe_write(i32 %391, i8* %392, i64 64)
  %394 = icmp ne i32 %393, 64
  br i1 %394, label %395, label %.loopexit

; <label>:395:                                    ; preds = %373
  %396 = getelementptr [17 x i8], [17 x i8]* @.str.50, i32 0, i32 0
  call void @perror(i8* %396)
  %397 = call i32 @kill(i32 0, i32 15) #9
  call void @_exit(i32 1) #12
  unreachable

..loopexit.loopexit_crit_edge:                    ; preds = %354
  %split = phi i32 [ %.0829, %354 ]
  br label %.loopexit.loopexit

..loopexit.loopexit_crit_edge32:                  ; preds = %368
  %split33 = phi i32 [ %370, %368 ]
  br label %.loopexit.loopexit

.loopexit.loopexit:                               ; preds = %..loopexit.loopexit_crit_edge32, %..loopexit.loopexit_crit_edge, %350
  %.08.lcssa.ph = phi i32 [ %split33, %..loopexit.loopexit_crit_edge32 ], [ %split, %..loopexit.loopexit_crit_edge ], [ 0, %350 ]
  br label %.loopexit

.loopexit:                                        ; preds = %.loopexit.loopexit, %373
  %.08.lcssa = phi i32 [ %.08.lcssa9, %373 ], [ %.08.lcssa.ph, %.loopexit.loopexit ]
  %398 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 5
  %399 = load i32, i32* %398, align 4
  %400 = icmp sge i32 %.08.lcssa, %399
  br i1 %400, label %401, label %.critedge

; <label>:401:                                    ; preds = %.loopexit
  %402 = load i32, i32* @wepkey_crack_success, align 4
  %403 = icmp ne i32 %402, 0
  %404 = xor i1 %403, true
  br i1 %404, label %350, label %.critedge

.critedge:                                        ; preds = %.loopexit, %401
  %405 = load i32, i32* @wepkey_crack_success, align 4
  %406 = icmp ne i32 %405, 0
  br i1 %406, label %407, label %417

; <label>:407:                                    ; preds = %.critedge
  %408 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 10
  %409 = load i32, i32* %408, align 4
  %410 = sext i32 %409 to i64
  %411 = getelementptr %struct.WEP_data, %struct.WEP_data* @wep, i32 0, i32 0, i32 0
  %412 = getelementptr [64 x i8], [64 x i8]* @bf_wepkey, i32 0, i32 0
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %411, i8* align 16 %412, i64 %410, i1 false), !track !178
  br label %454

; <label>:413:                                    ; preds = %151, %143
  %414 = add nsw i32 %0, 1
  %415 = call i32 @do_wep_crack1(i32 %414)
  switch i32 %415, label %417 [
    i32 0, label %.loopexit22
    i32 2, label %416
  ]

; <label>:416:                                    ; preds = %413
  br label %454

.loopexit11:                                      ; preds = %261
  br label %417

.loopexit13:                                      ; preds = %299
  br label %417

.loopexit15:                                      ; preds = %327
  br label %417

.loopexit19:                                      ; preds = %341
  br label %417

; <label>:417:                                    ; preds = %.loopexit19, %.loopexit15, %.loopexit13, %.loopexit11, %.critedge, %413
  %418 = sext i32 %0 to i64
  %419 = getelementptr %struct.WEP_data, %struct.WEP_data* @wep, i32 0, i32 6
  %420 = getelementptr inbounds [64 x i32], [64 x i32]* %419, i64 0, i64 %418
  %421 = load i32, i32* %420, align 4
  %422 = add nsw i32 %421, 1
  store i32 %422, i32* %420, align 4
  %423 = load i32, i32* %102, align 4
  %424 = load i32, i32* %106, align 4
  %425 = icmp slt i32 %423, %424
  br i1 %425, label %.lr.ph23, label %._crit_edge24.loopexit

._crit_edge24.loopexit:                           ; preds = %417
  br label %._crit_edge24

._crit_edge24:                                    ; preds = %._crit_edge24.loopexit, %.loopexit10
  %426 = icmp eq i32 %0, 0
  br i1 %426, label %427, label %454

; <label>:427:                                    ; preds = %._crit_edge24
  %428 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 5
  %429 = load i32, i32* %428, align 4
  %430 = icmp slt i32 0, %429
  br i1 %430, label %.lr.ph.preheader, label %._crit_edge

.lr.ph.preheader:                                 ; preds = %427
  br label %.lr.ph

.lr.ph:                                           ; preds = %.lr.ph.preheader, %.critedge4
  %indvars.iv = phi i64 [ %indvars.iv.next, %.critedge4 ], [ 0, %.lr.ph.preheader ]
  call void @unroll_loop(i32 81)
  call void @unroll_loop(i32 82)
  %431 = getelementptr inbounds [256 x i32], [256 x i32]* @bf_nkeys, i64 0, i64 %indvars.iv
  %432 = load i32, i32* %431, align 4
  %433 = icmp sgt i32 %432, 0
  br i1 %433, label %.lr.ph27, label %.critedge4

.lr.ph27:                                         ; preds = %.lr.ph
  br label %434

; <label>:434:                                    ; preds = %.lr.ph27, %438
  %435 = load i32, i32* @wepkey_crack_success, align 4
  %436 = icmp ne i32 %435, 0
  %437 = xor i1 %436, true
  br i1 %437, label %438, label %..critedge4_crit_edge

; <label>:438:                                    ; preds = %434
  %439 = call i32 @usleep(i32 1)
  call void @unroll_loop(i32 82)
  %440 = load i32, i32* %431, align 4
  %441 = icmp sgt i32 %440, 0
  br i1 %441, label %434, label %..critedge4_crit_edge28

..critedge4_crit_edge:                            ; preds = %434
  br label %.critedge4

..critedge4_crit_edge28:                          ; preds = %438
  br label %.critedge4

.critedge4:                                       ; preds = %..critedge4_crit_edge28, %..critedge4_crit_edge, %.lr.ph
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %442 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 5
  %443 = load i32, i32* %442, align 4
  %444 = sext i32 %443 to i64
  %445 = icmp slt i64 %indvars.iv.next, %444
  br i1 %445, label %.lr.ph, label %._crit_edge.loopexit

._crit_edge.loopexit:                             ; preds = %.critedge4
  br label %._crit_edge

._crit_edge:                                      ; preds = %._crit_edge.loopexit, %427
  %446 = load i32, i32* @wepkey_crack_success, align 4
  %447 = icmp ne i32 %446, 0
  br i1 %447, label %448, label %454

; <label>:448:                                    ; preds = %._crit_edge
  %449 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 10
  %450 = load i32, i32* %449, align 4
  %451 = sext i32 %450 to i64
  %452 = getelementptr %struct.WEP_data, %struct.WEP_data* @wep, i32 0, i32 0, i32 0
  %453 = getelementptr [64 x i8], [64 x i8]* @bf_wepkey, i32 0, i32 0
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %452, i8* align 16 %453, i64 %451, i1 false), !track !179
  br label %454

.loopexit5:                                       ; preds = %241
  %.0.ph = phi i32 [ 0, %241 ]
  br label %454

.loopexit6:                                       ; preds = %282
  %.0.ph7 = phi i32 [ 0, %282 ]
  br label %454

.loopexit8:                                       ; preds = %313
  %.0.ph9 = phi i32 [ 0, %313 ]
  br label %454

.loopexit17:                                      ; preds = %330
  %.0.ph18 = phi i32 [ 0, %330 ]
  br label %454

.loopexit22:                                      ; preds = %.lr.ph23, %413
  %.0.ph23 = phi i32 [ 0, %413 ], [ 1, %.lr.ph23 ]
  br label %454

.loopexit24:                                      ; preds = %3
  %.0.ph25 = phi i32 [ 1, %3 ]
  br label %454

; <label>:454:                                    ; preds = %.loopexit24, %.loopexit22, %.loopexit17, %.loopexit8, %.loopexit6, %.loopexit5, %._crit_edge24, %._crit_edge, %54, %448, %416, %407, %141, %110, %51, %5
  %.0 = phi i32 [ %53, %51 ], [ 0, %141 ], [ 0, %407 ], [ 2, %416 ], [ 2, %110 ], [ 0, %448 ], [ 2, %5 ], [ 1, %54 ], [ 1, %._crit_edge ], [ 1, %._crit_edge24 ], [ %.0.ph, %.loopexit5 ], [ %.0.ph7, %.loopexit6 ], [ %.0.ph9, %.loopexit8 ], [ %.0.ph18, %.loopexit17 ], [ %.0.ph23, %.loopexit22 ], [ %.0.ph25, %.loopexit24 ]
  ret i32 %.0
}

declare dso_local i32 @sleep(i32) #1

; Function Attrs: nounwind readonly
declare dso_local i32 @atoi(i8*) #3

; Function Attrs: nounwind readnone
declare dso_local i16** @__ctype_b_loc() #7

; Function Attrs: noinline nounwind uwtable
define dso_local i32 @do_wep_crack2(i32) #0 {
  %2 = call i32 @update_ivbuf()
  switch i32 %2, label %4 [
    i32 1, label %._crit_edge8
    i32 2, label %3
  ]

; <label>:3:                                      ; preds = %1
  br label %._crit_edge8

; <label>:4:                                      ; preds = %1
  %5 = getelementptr %struct.WEP_data, %struct.WEP_data* @wep, i32 0, i32 4
  %6 = load i64, i64* %5, align 8
  %7 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 10
  %8 = load i32, i32* %7, align 4
  %9 = sext i32 %8 to i64
  %10 = sdiv i64 %6, %9
  %11 = icmp slt i64 %10, 60000
  br i1 %11, label %12, label %19

; <label>:12:                                     ; preds = %4
  %13 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 10
  %14 = load i32, i32* %13, align 4
  %15 = mul nsw i32 %14, 60000
  %16 = getelementptr [123 x i8], [123 x i8]* @.str.51, i32 0, i32 0
  %17 = call i32 (i8*, ...) @printf(i8* %16, i32 %15)
  %18 = call i32 @kill(i32 0, i32 15) #9
  call void @_exit(i32 1) #12
  unreachable

; <label>:19:                                     ; preds = %4
  %20 = icmp sle i32 0, %0
  br i1 %20, label %.lr.ph13, label %._crit_edge14

.lr.ph13:                                         ; preds = %19
  %21 = sext i32 %0 to i64
  br label %22

; <label>:22:                                     ; preds = %.lr.ph13, %44
  %indvars.iv15 = phi i64 [ 0, %.lr.ph13 ], [ %indvars.iv.next16, %44 ]
  call void @unroll_loop(i32 63)
  %23 = trunc i64 %indvars.iv15 to i32
  %24 = call i32 @calc_poll(i32 %23)
  %25 = icmp ne i32 %24, 0
  br i1 %25, label %._crit_edge8.loopexit5, label %26

; <label>:26:                                     ; preds = %22
  %27 = getelementptr %struct.WEP_data, %struct.WEP_data* @wep, i32 0, i32 7
  %28 = getelementptr inbounds [64 x [256 x %struct.vote]], [64 x [256 x %struct.vote]]* %27, i64 0, i64 %indvars.iv15
  %29 = getelementptr inbounds [256 x %struct.vote], [256 x %struct.vote]* %28, i64 0, i64 0
  %30 = getelementptr inbounds %struct.vote, %struct.vote* %29, i32 0, i32 0
  %31 = load i32, i32* %30, align 8
  %32 = trunc i32 %31 to i8
  %33 = getelementptr %struct.WEP_data, %struct.WEP_data* @wep, i32 0, i32 0
  %34 = getelementptr inbounds [64 x i8], [64 x i8]* %33, i64 0, i64 %indvars.iv15
  store i8 %32, i8* %34, align 1
  %35 = getelementptr %struct.WEP_data, %struct.WEP_data* @wep, i32 0, i32 5
  %36 = getelementptr inbounds [64 x i32], [64 x i32]* %35, i64 0, i64 %indvars.iv15
  store i32 1, i32* %36, align 4
  %37 = getelementptr %struct.WEP_data, %struct.WEP_data* @wep, i32 0, i32 6
  %38 = getelementptr inbounds [64 x i32], [64 x i32]* %37, i64 0, i64 %indvars.iv15
  store i32 0, i32* %38, align 4
  %39 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 6
  %40 = load i32, i32* %39, align 8
  %41 = icmp ne i32 %40, 0
  br i1 %41, label %44, label %42

; <label>:42:                                     ; preds = %26
  %43 = trunc i64 %indvars.iv15 to i32
  call void @show_wep_stats(i32 %43, i32 0, [256 x %struct.PTW_tableentry]* null, i32* null, i32* null, i32 0)
  br label %44

; <label>:44:                                     ; preds = %26, %42
  %indvars.iv.next16 = add nuw nsw i64 %indvars.iv15, 1
  %45 = icmp sle i64 %indvars.iv.next16, %21
  br i1 %45, label %22, label %._crit_edge14.loopexit

._crit_edge14.loopexit:                           ; preds = %44
  br label %._crit_edge14

._crit_edge14:                                    ; preds = %._crit_edge14.loopexit, %19
  %46 = sext i32 %0 to i64
  %47 = getelementptr %struct.WEP_data, %struct.WEP_data* @wep, i32 0, i32 5
  %48 = getelementptr inbounds [64 x i32], [64 x i32]* %47, i64 0, i64 %46
  store i32 1, i32* %48, align 4
  %49 = sext i32 %0 to i64
  %50 = getelementptr %struct.WEP_data, %struct.WEP_data* @wep, i32 0, i32 5
  %51 = getelementptr inbounds [64 x i32], [64 x i32]* %50, i64 0, i64 %49
  %52 = load i32, i32* %51, align 4
  %53 = icmp slt i32 %52, 256
  br i1 %53, label %.lr.ph10.preheader, label %.loopexit

.lr.ph10.preheader:                               ; preds = %._crit_edge14
  %54 = sext i32 %0 to i64
  %55 = getelementptr %struct.WEP_data, %struct.WEP_data* @wep, i32 0, i32 5
  %56 = getelementptr inbounds [64 x i32], [64 x i32]* %55, i64 0, i64 %54
  br label %.lr.ph10

.lr.ph10:                                         ; preds = %.lr.ph10.preheader, %80
  call void @unroll_loop(i32 64)
  %57 = sext i32 %0 to i64
  %58 = getelementptr %struct.WEP_data, %struct.WEP_data* @wep, i32 0, i32 7
  %59 = getelementptr inbounds [64 x [256 x %struct.vote]], [64 x [256 x %struct.vote]]* %58, i64 0, i64 %57
  %60 = sext i32 %0 to i64
  %61 = getelementptr %struct.WEP_data, %struct.WEP_data* @wep, i32 0, i32 5
  %62 = getelementptr inbounds [64 x i32], [64 x i32]* %61, i64 0, i64 %60
  %63 = load i32, i32* %62, align 4
  %64 = sext i32 %63 to i64
  %65 = getelementptr inbounds [256 x %struct.vote], [256 x %struct.vote]* %59, i64 0, i64 %64
  %66 = getelementptr inbounds %struct.vote, %struct.vote* %65, i32 0, i32 1
  %67 = load i32, i32* %66, align 4
  %68 = sitofp i32 %67 to float
  %69 = sext i32 %0 to i64
  %70 = getelementptr %struct.WEP_data, %struct.WEP_data* @wep, i32 0, i32 7
  %71 = getelementptr inbounds [64 x [256 x %struct.vote]], [64 x [256 x %struct.vote]]* %70, i64 0, i64 %69
  %72 = getelementptr inbounds [256 x %struct.vote], [256 x %struct.vote]* %71, i64 0, i64 0
  %73 = getelementptr inbounds %struct.vote, %struct.vote* %72, i32 0, i32 1
  %74 = load i32, i32* %73, align 4
  %75 = sitofp i32 %74 to float
  %76 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 12
  %77 = load float, float* %76, align 4
  %78 = fdiv float %75, %77
  %79 = fcmp olt float %68, %78
  br i1 %79, label %.loopexit.loopexit, label %80

; <label>:80:                                     ; preds = %.lr.ph10
  %81 = load i32, i32* %56, align 4
  %82 = add nsw i32 %81, 1
  store i32 %82, i32* %56, align 4
  %83 = load i32, i32* %51, align 4
  %84 = icmp slt i32 %83, 256
  br i1 %84, label %.lr.ph10, label %.loopexit.loopexit

.loopexit.loopexit:                               ; preds = %.lr.ph10, %80
  br label %.loopexit

.loopexit:                                        ; preds = %.loopexit.loopexit, %._crit_edge14
  %85 = sext i32 %0 to i64
  %86 = getelementptr %struct.WEP_data, %struct.WEP_data* @wep, i32 0, i32 6
  %87 = getelementptr inbounds [64 x i32], [64 x i32]* %86, i64 0, i64 %85
  store i32 0, i32* %87, align 4
  %88 = add i32 %0, 1
  %89 = sext i32 %88 to i64
  %90 = sext i32 %0 to i64
  %91 = getelementptr %struct.WEP_data, %struct.WEP_data* @wep, i32 0, i32 6
  %92 = getelementptr inbounds [64 x i32], [64 x i32]* %91, i64 0, i64 %90
  %93 = load i32, i32* %92, align 4
  %94 = sext i32 %0 to i64
  %95 = getelementptr %struct.WEP_data, %struct.WEP_data* @wep, i32 0, i32 5
  %96 = getelementptr inbounds [64 x i32], [64 x i32]* %95, i64 0, i64 %94
  %97 = load i32, i32* %96, align 4
  %98 = icmp slt i32 %93, %97
  br i1 %98, label %.lr.ph7.preheader, label %._crit_edge8

.lr.ph7.preheader:                                ; preds = %.loopexit
  br label %.lr.ph7

.lr.ph7:                                          ; preds = %.lr.ph7.preheader, %182
  call void @unroll_loop(i32 83)
  %99 = call i32 @update_ivbuf()
  switch i32 %99, label %101 [
    i32 1, label %._crit_edge8.loopexit3
    i32 2, label %100
  ]

; <label>:100:                                    ; preds = %.lr.ph7
  br label %._crit_edge8

; <label>:101:                                    ; preds = %.lr.ph7
  %102 = sext i32 %0 to i64
  %103 = getelementptr %struct.WEP_data, %struct.WEP_data* @wep, i32 0, i32 7
  %104 = getelementptr inbounds [64 x [256 x %struct.vote]], [64 x [256 x %struct.vote]]* %103, i64 0, i64 %102
  %105 = sext i32 %0 to i64
  %106 = getelementptr %struct.WEP_data, %struct.WEP_data* @wep, i32 0, i32 6
  %107 = getelementptr inbounds [64 x i32], [64 x i32]* %106, i64 0, i64 %105
  %108 = load i32, i32* %107, align 4
  %109 = sext i32 %108 to i64
  %110 = getelementptr inbounds [256 x %struct.vote], [256 x %struct.vote]* %104, i64 0, i64 %109
  %111 = getelementptr inbounds %struct.vote, %struct.vote* %110, i32 0, i32 0
  %112 = load i32, i32* %111, align 8
  %113 = trunc i32 %112 to i8
  %114 = sext i32 %0 to i64
  %115 = getelementptr %struct.WEP_data, %struct.WEP_data* @wep, i32 0, i32 0
  %116 = getelementptr inbounds [64 x i8], [64 x i8]* %115, i64 0, i64 %114
  store i8 %113, i8* %116, align 1
  %117 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 6
  %118 = load i32, i32* %117, align 8
  %119 = icmp ne i32 %118, 0
  br i1 %119, label %121, label %120

; <label>:120:                                    ; preds = %101
  call void @show_wep_stats(i32 %0, i32 0, [256 x %struct.PTW_tableentry]* null, i32* null, i32* null, i32 0)
  br label %121

; <label>:121:                                    ; preds = %120, %101
  %122 = add nsw i32 %0, 1
  %123 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 10
  %124 = load i32, i32* %123, align 4
  %125 = sub nsw i32 %124, 2
  %126 = icmp slt i32 %122, %125
  br i1 %126, label %.lr.ph.preheader, label %._crit_edge

.lr.ph.preheader:                                 ; preds = %121
  br label %.lr.ph

.lr.ph:                                           ; preds = %.lr.ph.preheader, %148
  %indvars.iv = phi i64 [ %indvars.iv.next, %148 ], [ %89, %.lr.ph.preheader ]
  call void @unroll_loop(i32 84)
  %127 = trunc i64 %indvars.iv to i32
  %128 = call i32 @calc_poll(i32 %127)
  %129 = icmp ne i32 %128, 0
  br i1 %129, label %._crit_edge8.loopexit1, label %130

; <label>:130:                                    ; preds = %.lr.ph
  %131 = getelementptr %struct.WEP_data, %struct.WEP_data* @wep, i32 0, i32 7
  %132 = getelementptr inbounds [64 x [256 x %struct.vote]], [64 x [256 x %struct.vote]]* %131, i64 0, i64 %indvars.iv
  %133 = getelementptr inbounds [256 x %struct.vote], [256 x %struct.vote]* %132, i64 0, i64 0
  %134 = getelementptr inbounds %struct.vote, %struct.vote* %133, i32 0, i32 0
  %135 = load i32, i32* %134, align 8
  %136 = trunc i32 %135 to i8
  %137 = getelementptr %struct.WEP_data, %struct.WEP_data* @wep, i32 0, i32 0
  %138 = getelementptr inbounds [64 x i8], [64 x i8]* %137, i64 0, i64 %indvars.iv
  store i8 %136, i8* %138, align 1
  %139 = getelementptr %struct.WEP_data, %struct.WEP_data* @wep, i32 0, i32 5
  %140 = getelementptr inbounds [64 x i32], [64 x i32]* %139, i64 0, i64 %indvars.iv
  store i32 1, i32* %140, align 4
  %141 = getelementptr %struct.WEP_data, %struct.WEP_data* @wep, i32 0, i32 6
  %142 = getelementptr inbounds [64 x i32], [64 x i32]* %141, i64 0, i64 %indvars.iv
  store i32 0, i32* %142, align 4
  %143 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 6
  %144 = load i32, i32* %143, align 8
  %145 = icmp ne i32 %144, 0
  br i1 %145, label %148, label %146

; <label>:146:                                    ; preds = %130
  %147 = trunc i64 %indvars.iv to i32
  call void @show_wep_stats(i32 %147, i32 0, [256 x %struct.PTW_tableentry]* null, i32* null, i32* null, i32 0)
  br label %148

; <label>:148:                                    ; preds = %130, %146
  %indvars.iv.next = add nsw i64 %indvars.iv, 1
  %149 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 10
  %150 = load i32, i32* %149, align 4
  %151 = sub nsw i32 %150, 2
  %152 = sext i32 %151 to i64
  %153 = icmp slt i64 %indvars.iv.next, %152
  br i1 %153, label %.lr.ph, label %._crit_edge.loopexit

._crit_edge.loopexit:                             ; preds = %148
  br label %._crit_edge

._crit_edge:                                      ; preds = %._crit_edge.loopexit, %121
  br label %154

; <label>:154:                                    ; preds = %._crit_edge, %179
  %.25 = phi i32 [ 0, %._crit_edge ], [ %180, %179 ]
  call void @unroll_loop(i32 85)
  %155 = trunc i32 %.25 to i8
  %156 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 10
  %157 = load i32, i32* %156, align 4
  %158 = sub nsw i32 %157, 2
  %159 = sext i32 %158 to i64
  %160 = getelementptr %struct.WEP_data, %struct.WEP_data* @wep, i32 0, i32 0
  %161 = getelementptr inbounds [64 x i8], [64 x i8]* %160, i64 0, i64 %159
  store i8 %155, i8* %161, align 1
  br label %162

; <label>:162:                                    ; preds = %154, %176
  %.014 = phi i32 [ 0, %154 ], [ %177, %176 ]
  call void @unroll_loop(i32 86)
  %163 = trunc i32 %.014 to i8
  %164 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 10
  %165 = load i32, i32* %164, align 4
  %166 = sub nsw i32 %165, 1
  %167 = sext i32 %166 to i64
  %168 = getelementptr %struct.WEP_data, %struct.WEP_data* @wep, i32 0, i32 0
  %169 = getelementptr inbounds [64 x i8], [64 x i8]* %168, i64 0, i64 %167
  store i8 %163, i8* %169, align 1
  %170 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 10
  %171 = load i32, i32* %170, align 4
  %172 = sub nsw i32 %171, 2
  %173 = getelementptr %struct.WEP_data, %struct.WEP_data* @wep, i32 0, i32 0, i32 0
  %174 = call i32 @check_wep_key(i8* %173, i32 %172, i32 0)
  %175 = icmp eq i32 %174, 0
  br i1 %175, label %._crit_edge8.loopexit, label %176

; <label>:176:                                    ; preds = %162
  %177 = add nuw nsw i32 %.014, 1
  %178 = icmp ult i32 %177, 256
  br i1 %178, label %162, label %179

; <label>:179:                                    ; preds = %176
  %180 = add nuw nsw i32 %.25, 1
  %181 = icmp ult i32 %180, 256
  br i1 %181, label %154, label %182

; <label>:182:                                    ; preds = %179
  %183 = sext i32 %0 to i64
  %184 = getelementptr %struct.WEP_data, %struct.WEP_data* @wep, i32 0, i32 6
  %185 = getelementptr inbounds [64 x i32], [64 x i32]* %184, i64 0, i64 %183
  %186 = load i32, i32* %185, align 4
  %187 = add nsw i32 %186, 1
  store i32 %187, i32* %185, align 4
  %188 = load i32, i32* %92, align 4
  %189 = load i32, i32* %96, align 4
  %190 = icmp slt i32 %188, %189
  br i1 %190, label %.lr.ph7, label %._crit_edge8.loopexit3

._crit_edge8.loopexit:                            ; preds = %162
  %.0.ph = phi i32 [ 0, %162 ]
  br label %._crit_edge8

._crit_edge8.loopexit1:                           ; preds = %.lr.ph
  %.0.ph2 = phi i32 [ 1, %.lr.ph ]
  br label %._crit_edge8

._crit_edge8.loopexit3:                           ; preds = %.lr.ph7, %182
  %.0.ph4 = phi i32 [ 1, %182 ], [ 1, %.lr.ph7 ]
  br label %._crit_edge8

._crit_edge8.loopexit5:                           ; preds = %22
  %.0.ph6 = phi i32 [ 1, %22 ]
  br label %._crit_edge8

._crit_edge8:                                     ; preds = %._crit_edge8.loopexit5, %._crit_edge8.loopexit3, %._crit_edge8.loopexit1, %._crit_edge8.loopexit, %.loopexit, %1, %100, %3
  %.0 = phi i32 [ 2, %100 ], [ 2, %3 ], [ 1, %1 ], [ 1, %.loopexit ], [ %.0.ph, %._crit_edge8.loopexit ], [ %.0.ph2, %._crit_edge8.loopexit1 ], [ %.0.ph4, %._crit_edge8.loopexit3 ], [ %.0.ph6, %._crit_edge8.loopexit5 ]
  ret i32 %.0
}

; Function Attrs: noinline nounwind uwtable
define dso_local i32 @inner_bruteforcer_thread(i8*) #0 {
  %2 = alloca [64 x i8], align 16, !track !180
  %3 = ptrtoint i8* %0 to i64
  %4 = load i32, i32* @close_aircrack, align 4
  %5 = icmp ne i32 %4, 0
  br i1 %5, label %._crit_edge, label %.lr.ph.preheader

.lr.ph.preheader:                                 ; preds = %1
  br label %.lr.ph

.lr.ph:                                           ; preds = %.lr.ph.preheader, %153
  call void @unroll_loop(i32 87)
  %6 = load i32, i32* @wepkey_crack_success, align 4
  %7 = icmp ne i32 %6, 0
  br i1 %7, label %._crit_edge.loopexit10, label %8

; <label>:8:                                      ; preds = %.lr.ph
  %9 = getelementptr inbounds [256 x [2 x i32]], [256 x [2 x i32]]* @bf_pipe, i64 0, i64 %3
  %10 = getelementptr inbounds [2 x i32], [2 x i32]* %9, i64 0, i64 0
  %11 = load i32, i32* %10, align 8
  %12 = getelementptr inbounds [64 x i8], [64 x i8]* %2, i32 0, i32 0
  %13 = call i32 @safe_read(i32 %11, i8* %12, i64 64)
  %14 = icmp ne i32 %13, 64
  br i1 %14, label %15, label %18

; <label>:15:                                     ; preds = %8
  %16 = getelementptr [12 x i8], [12 x i8]* @.str.27, i32 0, i32 0
  call void @perror(i8* %16)
  %17 = call i32 @kill(i32 0, i32 15) #9
  call void @_exit(i32 1) #12
  unreachable

; <label>:18:                                     ; preds = %8
  %19 = load i32, i32* @close_aircrack, align 4
  %20 = icmp ne i32 %19, 0
  br i1 %20, label %._crit_edge.loopexit10, label %21

; <label>:21:                                     ; preds = %18
  %22 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 17
  %23 = load i32, i32* %22, align 8
  %24 = icmp eq i32 %23, 4
  br i1 %24, label %.preheader, label %67

.preheader:                                       ; preds = %21
  br label %25

; <label>:25:                                     ; preds = %.preheader, %64
  %.0717 = phi i32 [ %65, %64 ], [ 0, %.preheader ]
  call void @unroll_loop(i32 88)
  %26 = trunc i32 %.0717 to i8
  %27 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 31, i64 0
  %28 = load i32, i32* %27, align 4
  %29 = sext i32 %28 to i64
  %30 = getelementptr inbounds [64 x i8], [64 x i8]* %2, i64 0, i64 %29
  store i8 %26, i8* %30, align 1
  br label %31

; <label>:31:                                     ; preds = %25, %61
  %.0516 = phi i32 [ 0, %25 ], [ %62, %61 ]
  call void @unroll_loop(i32 89)
  %32 = trunc i32 %.0516 to i8
  %33 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 31, i64 1
  %34 = load i32, i32* %33, align 4
  %35 = sext i32 %34 to i64
  %36 = getelementptr inbounds [64 x i8], [64 x i8]* %2, i64 0, i64 %35
  store i8 %32, i8* %36, align 1
  br label %37

; <label>:37:                                     ; preds = %31, %58
  %.0115 = phi i32 [ 0, %31 ], [ %59, %58 ]
  call void @unroll_loop(i32 90)
  %38 = trunc i32 %.0115 to i8
  %39 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 31, i64 2
  %40 = load i32, i32* %39, align 4
  %41 = sext i32 %40 to i64
  %42 = getelementptr inbounds [64 x i8], [64 x i8]* %2, i64 0, i64 %41
  store i8 %38, i8* %42, align 1
  br label %43

; <label>:43:                                     ; preds = %37, %55
  %.0214 = phi i32 [ 0, %37 ], [ %56, %55 ]
  call void @unroll_loop(i32 91)
  %44 = trunc i32 %.0214 to i8
  %45 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 31, i64 3
  %46 = load i32, i32* %45, align 4
  %47 = sext i32 %46 to i64
  %48 = getelementptr inbounds [64 x i8], [64 x i8]* %2, i64 0, i64 %47
  store i8 %44, i8* %48, align 1
  %49 = getelementptr inbounds [64 x i8], [64 x i8]* %2, i32 0, i32 0
  %50 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 10
  %51 = load i32, i32* %50, align 4
  %52 = sub nsw i32 %51, 2
  %53 = call i32 @check_wep_key(i8* %49, i32 %52, i32 0)
  %54 = icmp eq i32 %53, 0
  br i1 %54, label %._crit_edge.loopexit, label %55

; <label>:55:                                     ; preds = %43
  %56 = add nuw nsw i32 %.0214, 1
  %57 = icmp ult i32 %56, 256
  br i1 %57, label %43, label %58

; <label>:58:                                     ; preds = %55
  %59 = add nuw nsw i32 %.0115, 1
  %60 = icmp ult i32 %59, 256
  br i1 %60, label %37, label %61

; <label>:61:                                     ; preds = %58
  %62 = add nuw nsw i32 %.0516, 1
  %63 = icmp ult i32 %62, 256
  br i1 %63, label %31, label %64

; <label>:64:                                     ; preds = %61
  %65 = add nuw nsw i32 %.0717, 1
  %66 = icmp ult i32 %65, 256
  br i1 %66, label %25, label %.loopexit

; <label>:67:                                     ; preds = %21
  %68 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 17
  %69 = load i32, i32* %68, align 8
  %70 = icmp eq i32 %69, 3
  br i1 %70, label %.preheader3, label %104

.preheader3:                                      ; preds = %67
  br label %71

; <label>:71:                                     ; preds = %.preheader3, %101
  %.1613 = phi i32 [ %102, %101 ], [ 0, %.preheader3 ]
  call void @unroll_loop(i32 92)
  %72 = trunc i32 %.1613 to i8
  %73 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 31, i64 0
  %74 = load i32, i32* %73, align 4
  %75 = sext i32 %74 to i64
  %76 = getelementptr inbounds [64 x i8], [64 x i8]* %2, i64 0, i64 %75
  store i8 %72, i8* %76, align 1
  br label %77

; <label>:77:                                     ; preds = %71, %98
  %.112 = phi i32 [ 0, %71 ], [ %99, %98 ]
  call void @unroll_loop(i32 93)
  %78 = trunc i32 %.112 to i8
  %79 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 31, i64 1
  %80 = load i32, i32* %79, align 4
  %81 = sext i32 %80 to i64
  %82 = getelementptr inbounds [64 x i8], [64 x i8]* %2, i64 0, i64 %81
  store i8 %78, i8* %82, align 1
  br label %83

; <label>:83:                                     ; preds = %77, %95
  %.1311 = phi i32 [ 0, %77 ], [ %96, %95 ]
  call void @unroll_loop(i32 94)
  %84 = trunc i32 %.1311 to i8
  %85 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 31, i64 2
  %86 = load i32, i32* %85, align 4
  %87 = sext i32 %86 to i64
  %88 = getelementptr inbounds [64 x i8], [64 x i8]* %2, i64 0, i64 %87
  store i8 %84, i8* %88, align 1
  %89 = getelementptr inbounds [64 x i8], [64 x i8]* %2, i32 0, i32 0
  %90 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 10
  %91 = load i32, i32* %90, align 4
  %92 = sub nsw i32 %91, 2
  %93 = call i32 @check_wep_key(i8* %89, i32 %92, i32 0)
  %94 = icmp eq i32 %93, 0
  br i1 %94, label %._crit_edge.loopexit1, label %95

; <label>:95:                                     ; preds = %83
  %96 = add nuw nsw i32 %.1311, 1
  %97 = icmp ult i32 %96, 256
  br i1 %97, label %83, label %98

; <label>:98:                                     ; preds = %95
  %99 = add nuw nsw i32 %.112, 1
  %100 = icmp ult i32 %99, 256
  br i1 %100, label %77, label %101

; <label>:101:                                    ; preds = %98
  %102 = add nuw nsw i32 %.1613, 1
  %103 = icmp ult i32 %102, 256
  br i1 %103, label %71, label %.loopexit4

; <label>:104:                                    ; preds = %67
  %105 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 17
  %106 = load i32, i32* %105, align 8
  %107 = icmp eq i32 %106, 2
  br i1 %107, label %.preheader5, label %.preheader7

.preheader7:                                      ; preds = %104
  br label %132

.preheader5:                                      ; preds = %104
  br label %108

; <label>:108:                                    ; preds = %.preheader5, %129
  %.210 = phi i32 [ %130, %129 ], [ 0, %.preheader5 ]
  call void @unroll_loop(i32 95)
  %109 = trunc i32 %.210 to i8
  %110 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 31, i64 0
  %111 = load i32, i32* %110, align 4
  %112 = sext i32 %111 to i64
  %113 = getelementptr inbounds [64 x i8], [64 x i8]* %2, i64 0, i64 %112
  store i8 %109, i8* %113, align 1
  br label %114

; <label>:114:                                    ; preds = %108, %126
  %.249 = phi i32 [ 0, %108 ], [ %127, %126 ]
  call void @unroll_loop(i32 96)
  %115 = trunc i32 %.249 to i8
  %116 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 31, i64 1
  %117 = load i32, i32* %116, align 4
  %118 = sext i32 %117 to i64
  %119 = getelementptr inbounds [64 x i8], [64 x i8]* %2, i64 0, i64 %118
  store i8 %115, i8* %119, align 1
  %120 = getelementptr inbounds [64 x i8], [64 x i8]* %2, i32 0, i32 0
  %121 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 10
  %122 = load i32, i32* %121, align 4
  %123 = sub nsw i32 %122, 2
  %124 = call i32 @check_wep_key(i8* %120, i32 %123, i32 0)
  %125 = icmp eq i32 %124, 0
  br i1 %125, label %._crit_edge.loopexit2, label %126

; <label>:126:                                    ; preds = %114
  %127 = add nuw nsw i32 %.249, 1
  %128 = icmp ult i32 %127, 256
  br i1 %128, label %114, label %129

; <label>:129:                                    ; preds = %126
  %130 = add nuw nsw i32 %.210, 1
  %131 = icmp ult i32 %130, 256
  br i1 %131, label %108, label %.loopexit6

; <label>:132:                                    ; preds = %.preheader7, %144
  %.38 = phi i32 [ %145, %144 ], [ 0, %.preheader7 ]
  call void @unroll_loop(i32 97)
  %133 = trunc i32 %.38 to i8
  %134 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 31, i64 0
  %135 = load i32, i32* %134, align 4
  %136 = sext i32 %135 to i64
  %137 = getelementptr inbounds [64 x i8], [64 x i8]* %2, i64 0, i64 %136
  store i8 %133, i8* %137, align 1
  %138 = getelementptr inbounds [64 x i8], [64 x i8]* %2, i32 0, i32 0
  %139 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 10
  %140 = load i32, i32* %139, align 4
  %141 = sub nsw i32 %140, 2
  %142 = call i32 @check_wep_key(i8* %138, i32 %141, i32 0)
  %143 = icmp eq i32 %142, 0
  br i1 %143, label %._crit_edge.loopexit8, label %144

; <label>:144:                                    ; preds = %132
  %145 = add nuw nsw i32 %.38, 1
  %146 = icmp ult i32 %145, 256
  br i1 %146, label %132, label %.loopexit9

.loopexit:                                        ; preds = %64
  br label %147

.loopexit4:                                       ; preds = %101
  br label %147

.loopexit6:                                       ; preds = %129
  br label %147

.loopexit9:                                       ; preds = %144
  br label %147

; <label>:147:                                    ; preds = %.loopexit9, %.loopexit6, %.loopexit4, %.loopexit
  %148 = icmp ne i32 1, 0
  br i1 %148, label %149, label %153

; <label>:149:                                    ; preds = %147
  %150 = getelementptr inbounds [256 x i32], [256 x i32]* @bf_nkeys, i64 0, i64 %3
  %151 = load i32, i32* %150, align 4
  %152 = add nsw i32 %151, -1
  store i32 %152, i32* %150, align 4
  br label %153

; <label>:153:                                    ; preds = %149, %147
  %154 = load i32, i32* @close_aircrack, align 4
  %155 = icmp ne i32 %154, 0
  br i1 %155, label %._crit_edge.loopexit10, label %.lr.ph

._crit_edge.loopexit:                             ; preds = %43
  br label %._crit_edge

._crit_edge.loopexit1:                            ; preds = %83
  br label %._crit_edge

._crit_edge.loopexit2:                            ; preds = %114
  br label %._crit_edge

._crit_edge.loopexit8:                            ; preds = %132
  br label %._crit_edge

._crit_edge.loopexit10:                           ; preds = %153, %.lr.ph, %18
  br label %._crit_edge

._crit_edge:                                      ; preds = %._crit_edge.loopexit10, %._crit_edge.loopexit8, %._crit_edge.loopexit2, %._crit_edge.loopexit1, %._crit_edge.loopexit, %1
  ret i32 0
}

; Function Attrs: noinline nounwind uwtable
define dso_local void @show_wpa_stats(i8*, i32, i8*, i8*, i8*, i32) #0 {
  %7 = alloca [28 x i8], align 16, !track !181
  %8 = call float @chrono(%struct.timeval* @t_stats, i32 0)
  %9 = fpext float %8 to double
  %10 = fcmp olt double %9, 1.500000e-01
  %11 = icmp eq i32 %5, 0
  %or.cond = and i1 %10, %11
  br i1 %or.cond, label %166, label %12

; <label>:12:                                     ; preds = %6
  %13 = icmp ne i32 %5, 0
  br i1 %13, label %14, label %16

; <label>:14:                                     ; preds = %12
  %15 = call i32 @pthread_mutex_lock(%union.pthread_mutex_t* @mx_wpastats) #9
  br label %19

; <label>:16:                                     ; preds = %12
  %17 = call i32 @pthread_mutex_trylock(%union.pthread_mutex_t* @mx_wpastats) #9
  %18 = icmp ne i32 %17, 0
  br i1 %18, label %166, label %19

; <label>:19:                                     ; preds = %16, %14
  %20 = call float @chrono(%struct.timeval* @t_stats, i32 1)
  %21 = call float @chrono(%struct.timeval* @t_begin, i32 0)
  %22 = fdiv float %21, 3.600000e+03
  %23 = fptosi float %22 to i32
  %24 = mul nsw i32 %23, 3600
  %25 = sitofp i32 %24 to float
  %26 = fsub float %21, %25
  %27 = fdiv float %26, 6.000000e+01
  %28 = fptosi float %27 to i32
  %29 = mul nsw i32 %23, 3600
  %30 = sitofp i32 %29 to float
  %31 = fsub float %21, %30
  %32 = mul nsw i32 %28, 60
  %33 = sitofp i32 %32 to float
  %34 = fsub float %31, %33
  %35 = fptosi float %34 to i32
  %36 = call float @chrono(%struct.timeval* @t_kprev, i32 0)
  %37 = fcmp oge float %36, 6.000000e+00
  br i1 %37, label %38, label %51

; <label>:38:                                     ; preds = %19
  %39 = fptosi float %36 to i32
  %40 = getelementptr %struct.timeval, %struct.timeval* @t_kprev, i32 0, i32 0
  %41 = load i64, i64* %40, align 8
  %42 = add nsw i64 %41, 3
  %43 = getelementptr %struct.timeval, %struct.timeval* @t_kprev, i32 0, i32 0
  store i64 %42, i64* %43, align 8
  %44 = call float @chrono(%struct.timeval* @t_kprev, i32 0)
  %45 = sitofp i32 %39 to float
  %46 = fdiv float %44, %45
  %47 = load i64, i64* @nb_kprev, align 8
  %48 = sitofp i64 %47 to float
  %49 = fmul float %48, %46
  %50 = fptosi float %49 to i64
  store i64 %50, i64* @nb_kprev, align 8
  br label %51

; <label>:51:                                     ; preds = %38, %19
  %.01 = phi float [ %44, %38 ], [ %36, %19 ]
  %52 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 27
  %53 = load i32, i32* %52, align 4
  %54 = icmp ne i32 %53, 0
  br i1 %54, label %55, label %58

; <label>:55:                                     ; preds = %51
  %56 = getelementptr [8 x i8], [8 x i8]* @.str.33, i32 0, i32 0
  %57 = call i32 (i8*, ...) @printf(i8* %56)
  br label %58

; <label>:58:                                     ; preds = %55, %51
  %59 = load i64, i64* @nb_tried, align 8
  %60 = load i64, i64* @nb_kprev, align 8
  %61 = sitofp i64 %60 to float
  %62 = fdiv float %61, %.01
  %63 = fpext float %62 to double
  %64 = getelementptr [53 x i8], [53 x i8]* @.str.52, i32 0, i32 0
  %65 = call i32 (i8*, ...) @printf(i8* %64, i32 %23, i32 %28, i32 %35, i64 %59, double %63)
  %66 = getelementptr inbounds [28 x i8], [28 x i8]* %7, i32 0, i32 0
  call void @llvm.memset.p0i8.i64(i8* align 16 %66, i8 32, i64 28, i1 false)
  %67 = getelementptr inbounds [28 x i8], [28 x i8]* %7, i32 0, i32 0
  %68 = icmp sgt i32 %1, 27
  %. = select i1 %68, i32 27, i32 %1
  %69 = sext i32 %. to i64
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 16 %67, i8* align 1 %0, i64 %69, i1 false), !track !182
  %70 = getelementptr inbounds [28 x i8], [28 x i8]* %7, i64 0, i64 27
  store i8 0, i8* %70, align 1
  %71 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 27
  %72 = load i32, i32* %71, align 4
  %73 = icmp ne i32 %72, 0
  br i1 %73, label %74, label %77

; <label>:74:                                     ; preds = %58
  %75 = getelementptr [8 x i8], [8 x i8]* @.str.53, i32 0, i32 0
  %76 = call i32 (i8*, ...) @printf(i8* %75)
  br label %77

; <label>:77:                                     ; preds = %74, %58
  %78 = getelementptr inbounds [28 x i8], [28 x i8]* %7, i32 0, i32 0
  %79 = getelementptr [31 x i8], [31 x i8]* @.str.54, i32 0, i32 0
  %80 = call i32 (i8*, ...) @printf(i8* %79, i8* %78)
  %81 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 27
  %82 = load i32, i32* %81, align 4
  %83 = icmp ne i32 %82, 0
  br i1 %83, label %84, label %87

; <label>:84:                                     ; preds = %77
  %85 = getelementptr [9 x i8], [9 x i8]* @.str.36, i32 0, i32 0
  %86 = call i32 (i8*, ...) @printf(i8* %85)
  br label %87

; <label>:87:                                     ; preds = %84, %77
  %88 = getelementptr [25 x i8], [25 x i8]* @.str.55, i32 0, i32 0
  %89 = call i32 (i8*, ...) @printf(i8* %88)
  %90 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 27
  %91 = load i32, i32* %90, align 4
  %92 = icmp ne i32 %91, 0
  br i1 %92, label %93, label %96

; <label>:93:                                     ; preds = %87
  %94 = getelementptr [8 x i8], [8 x i8]* @.str.56, i32 0, i32 0
  %95 = call i32 (i8*, ...) @printf(i8* %94)
  br label %96

; <label>:96:                                     ; preds = %93, %87
  br label %97

; <label>:97:                                     ; preds = %96, %102
  %indvars.iv8 = phi i64 [ 0, %96 ], [ %indvars.iv.next9, %102 ]
  call void @unroll_loop(i32 98)
  %98 = icmp eq i64 %indvars.iv8, 16
  br i1 %98, label %99, label %102

; <label>:99:                                     ; preds = %97
  %100 = getelementptr [7 x i8], [7 x i8]* @.str.57, i32 0, i32 0
  %101 = call i32 (i8*, ...) @printf(i8* %100)
  br label %102

; <label>:102:                                    ; preds = %99, %97
  %103 = getelementptr inbounds i8, i8* %2, i64 %indvars.iv8
  %104 = load i8, i8* %103, align 1
  %105 = zext i8 %104 to i32
  %106 = getelementptr [6 x i8], [6 x i8]* @.str.58, i32 0, i32 0
  %107 = call i32 (i8*, ...) @printf(i8* %106, i32 %105)
  %indvars.iv.next9 = add nuw nsw i64 %indvars.iv8, 1
  %exitcond10 = icmp ne i64 %indvars.iv.next9, 32
  br i1 %exitcond10, label %97, label %108

; <label>:108:                                    ; preds = %102
  %109 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 27
  %110 = load i32, i32* %109, align 4
  %111 = icmp ne i32 %110, 0
  br i1 %111, label %112, label %115

; <label>:112:                                    ; preds = %108
  %113 = getelementptr [9 x i8], [9 x i8]* @.str.36, i32 0, i32 0
  %114 = call i32 (i8*, ...) @printf(i8* %113)
  br label %115

; <label>:115:                                    ; preds = %112, %108
  %116 = getelementptr [25 x i8], [25 x i8]* @.str.59, i32 0, i32 0
  %117 = call i32 (i8*, ...) @printf(i8* %116)
  %118 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 27
  %119 = load i32, i32* %118, align 4
  %120 = icmp ne i32 %119, 0
  br i1 %120, label %121, label %124

; <label>:121:                                    ; preds = %115
  %122 = getelementptr [8 x i8], [8 x i8]* @.str.56, i32 0, i32 0
  %123 = call i32 (i8*, ...) @printf(i8* %122)
  br label %124

; <label>:124:                                    ; preds = %121, %115
  br label %125

; <label>:125:                                    ; preds = %124, %133
  %indvars.iv4 = phi i64 [ 0, %124 ], [ %indvars.iv.next5, %133 ]
  call void @unroll_loop(i32 99)
  %126 = icmp ugt i64 %indvars.iv4, 0
  br i1 %126, label %127, label %133

; <label>:127:                                    ; preds = %125
  %128 = trunc i64 %indvars.iv4 to i32
  %.urem = urem i32 %128, 16
  %129 = icmp eq i32 %.urem, 0
  br i1 %129, label %130, label %133

; <label>:130:                                    ; preds = %127
  %131 = getelementptr [7 x i8], [7 x i8]* @.str.57, i32 0, i32 0
  %132 = call i32 (i8*, ...) @printf(i8* %131)
  br label %133

; <label>:133:                                    ; preds = %130, %127, %125
  %134 = getelementptr inbounds i8, i8* %3, i64 %indvars.iv4
  %135 = load i8, i8* %134, align 1
  %136 = zext i8 %135 to i32
  %137 = getelementptr [6 x i8], [6 x i8]* @.str.58, i32 0, i32 0
  %138 = call i32 (i8*, ...) @printf(i8* %137, i32 %136)
  %indvars.iv.next5 = add nuw nsw i64 %indvars.iv4, 1
  %exitcond6 = icmp ne i64 %indvars.iv.next5, 64
  br i1 %exitcond6, label %125, label %139

; <label>:139:                                    ; preds = %133
  %140 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 27
  %141 = load i32, i32* %140, align 4
  %142 = icmp ne i32 %141, 0
  br i1 %142, label %143, label %146

; <label>:143:                                    ; preds = %139
  %144 = getelementptr [9 x i8], [9 x i8]* @.str.36, i32 0, i32 0
  %145 = call i32 (i8*, ...) @printf(i8* %144)
  br label %146

; <label>:146:                                    ; preds = %143, %139
  %147 = getelementptr [25 x i8], [25 x i8]* @.str.60, i32 0, i32 0
  %148 = call i32 (i8*, ...) @printf(i8* %147)
  %149 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 27
  %150 = load i32, i32* %149, align 4
  %151 = icmp ne i32 %150, 0
  br i1 %151, label %152, label %155

; <label>:152:                                    ; preds = %146
  %153 = getelementptr [8 x i8], [8 x i8]* @.str.56, i32 0, i32 0
  %154 = call i32 (i8*, ...) @printf(i8* %153)
  br label %155

; <label>:155:                                    ; preds = %152, %146
  br label %156

; <label>:156:                                    ; preds = %155, %156
  %indvars.iv = phi i64 [ 0, %155 ], [ %indvars.iv.next, %156 ]
  call void @unroll_loop(i32 100)
  %157 = getelementptr inbounds i8, i8* %4, i64 %indvars.iv
  %158 = load i8, i8* %157, align 1
  %159 = zext i8 %158 to i32
  %160 = getelementptr [6 x i8], [6 x i8]* @.str.58, i32 0, i32 0
  %161 = call i32 (i8*, ...) @printf(i8* %160, i32 %159)
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond = icmp ne i64 %indvars.iv.next, 16
  br i1 %exitcond, label %156, label %162

; <label>:162:                                    ; preds = %156
  %163 = getelementptr [2 x i8], [2 x i8]* @.str.2, i32 0, i32 0
  %164 = call i32 (i8*, ...) @printf(i8* %163)
  %165 = call i32 @pthread_mutex_unlock(%union.pthread_mutex_t* @mx_wpastats) #9
  br label %166

; <label>:166:                                    ; preds = %16, %6, %162
  ret void
}

; Function Attrs: nounwind
declare dso_local i32 @pthread_mutex_trylock(%union.pthread_mutex_t*) #2

; Function Attrs: noinline nounwind uwtable
define dso_local i32 @crack_wpa_thread(i8*) #0 {
  %2 = alloca [36 x i8], align 16, !track !183
  %3 = alloca [4 x [128 x i8]], align 16, !track !184
  %4 = alloca [4 x [128 x i8]], align 16, !track !185
  %5 = alloca [100 x i8], align 16, !track !186
  %6 = alloca [4 x [80 x i8]], align 16, !track !187
  %7 = alloca [4 x [20 x i8]], align 16, !track !188
  %8 = alloca i32, align 4
  store i32 0, i32* %8, align 4
  %9 = call i32 @shasse2_cpuid()
  %10 = icmp sge i32 %9, 2
  %spec.select = select i1 %10, i32 4, i32 1
  %11 = bitcast i8* %0 to %struct.WPA_data*
  %12 = getelementptr inbounds %struct.WPA_data, %struct.WPA_data* %11, i32 0, i32 0
  %13 = load %struct.AP_info*, %struct.AP_info** %12, align 8
  %14 = getelementptr inbounds %struct.WPA_data, %struct.WPA_data* %11, i32 0, i32 1
  %15 = load i32, i32* %14, align 8
  %16 = getelementptr inbounds [36 x i8], [36 x i8]* %2, i32 0, i32 0
  %17 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %13, i32 0, i32 2
  %18 = getelementptr inbounds [33 x i8], [33 x i8]* %17, i32 0, i32 0
  %19 = call i8* @strncpy(i8* %16, i8* %18, i64 36) #9, !track !189
  %20 = getelementptr inbounds [100 x i8], [100 x i8]* %5, i32 0, i32 0
  %21 = getelementptr [23 x i8], [23 x i8]* @.str.61, i32 0, i32 0
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 16 %20, i8* align 1 %21, i64 23, i1 false), !track !190
  %22 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %13, i32 0, i32 14
  %23 = getelementptr inbounds %struct.WPA_hdsk, %struct.WPA_hdsk* %22, i32 0, i32 0
  %24 = getelementptr inbounds [6 x i8], [6 x i8]* %23, i32 0, i32 0
  %25 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %13, i32 0, i32 1
  %26 = getelementptr inbounds [6 x i8], [6 x i8]* %25, i32 0, i32 0
  %27 = call i32 @memcmp(i8* %24, i8* %26, i64 6) #10
  %28 = icmp slt i32 %27, 0
  %29 = getelementptr inbounds [100 x i8], [100 x i8]* %5, i32 0, i32 0
  %30 = getelementptr inbounds i8, i8* %29, i64 23
  br i1 %28, label %31, label %39

; <label>:31:                                     ; preds = %1
  %32 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %13, i32 0, i32 14
  %33 = getelementptr inbounds %struct.WPA_hdsk, %struct.WPA_hdsk* %32, i32 0, i32 0
  %34 = getelementptr inbounds [6 x i8], [6 x i8]* %33, i32 0, i32 0
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %30, i8* align 8 %34, i64 6, i1 false), !track !191
  %35 = getelementptr inbounds [100 x i8], [100 x i8]* %5, i32 0, i32 0
  %36 = getelementptr inbounds i8, i8* %35, i64 29
  %37 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %13, i32 0, i32 1
  %38 = getelementptr inbounds [6 x i8], [6 x i8]* %37, i32 0, i32 0
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %36, i8* align 8 %38, i64 6, i1 false), !track !192
  br label %47

; <label>:39:                                     ; preds = %1
  %40 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %13, i32 0, i32 1
  %41 = getelementptr inbounds [6 x i8], [6 x i8]* %40, i32 0, i32 0
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %30, i8* align 8 %41, i64 6, i1 false), !track !193
  %42 = getelementptr inbounds [100 x i8], [100 x i8]* %5, i32 0, i32 0
  %43 = getelementptr inbounds i8, i8* %42, i64 29
  %44 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %13, i32 0, i32 14
  %45 = getelementptr inbounds %struct.WPA_hdsk, %struct.WPA_hdsk* %44, i32 0, i32 0
  %46 = getelementptr inbounds [6 x i8], [6 x i8]* %45, i32 0, i32 0
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %43, i8* align 8 %46, i64 6, i1 false), !track !194
  br label %47

; <label>:47:                                     ; preds = %39, %31
  %48 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %13, i32 0, i32 14
  %49 = getelementptr inbounds %struct.WPA_hdsk, %struct.WPA_hdsk* %48, i32 0, i32 1
  %50 = getelementptr inbounds [32 x i8], [32 x i8]* %49, i32 0, i32 0
  %51 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %13, i32 0, i32 14
  %52 = getelementptr inbounds %struct.WPA_hdsk, %struct.WPA_hdsk* %51, i32 0, i32 2
  %53 = getelementptr inbounds [32 x i8], [32 x i8]* %52, i32 0, i32 0
  %54 = call i32 @memcmp(i8* %50, i8* %53, i64 32) #10
  %55 = icmp slt i32 %54, 0
  %56 = getelementptr inbounds [100 x i8], [100 x i8]* %5, i32 0, i32 0
  %57 = getelementptr inbounds i8, i8* %56, i64 35
  %58 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %13, i32 0, i32 14
  br i1 %55, label %59, label %67

; <label>:59:                                     ; preds = %47
  %60 = getelementptr inbounds %struct.WPA_hdsk, %struct.WPA_hdsk* %58, i32 0, i32 1
  %61 = getelementptr inbounds [32 x i8], [32 x i8]* %60, i32 0, i32 0
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %57, i8* align 2 %61, i64 32, i1 false), !track !195
  %62 = getelementptr inbounds [100 x i8], [100 x i8]* %5, i32 0, i32 0
  %63 = getelementptr inbounds i8, i8* %62, i64 67
  %64 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %13, i32 0, i32 14
  %65 = getelementptr inbounds %struct.WPA_hdsk, %struct.WPA_hdsk* %64, i32 0, i32 2
  %66 = getelementptr inbounds [32 x i8], [32 x i8]* %65, i32 0, i32 0
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %63, i8* align 2 %66, i64 32, i1 false), !track !196
  br label %75

; <label>:67:                                     ; preds = %47
  %68 = getelementptr inbounds %struct.WPA_hdsk, %struct.WPA_hdsk* %58, i32 0, i32 2
  %69 = getelementptr inbounds [32 x i8], [32 x i8]* %68, i32 0, i32 0
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %57, i8* align 2 %69, i64 32, i1 false), !track !197
  %70 = getelementptr inbounds [100 x i8], [100 x i8]* %5, i32 0, i32 0
  %71 = getelementptr inbounds i8, i8* %70, i64 67
  %72 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %13, i32 0, i32 14
  %73 = getelementptr inbounds %struct.WPA_hdsk, %struct.WPA_hdsk* %72, i32 0, i32 1
  %74 = getelementptr inbounds [32 x i8], [32 x i8]* %73, i32 0, i32 0
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %71, i8* align 2 %74, i64 32, i1 false), !track !198
  br label %75

; <label>:75:                                     ; preds = %67, %59
  %76 = getelementptr inbounds [36 x i8], [36 x i8]* %2, i32 0, i32 0
  %77 = call i64 @strlen(i8* %76) #10
  %78 = add i64 %77, 4
  %79 = trunc i64 %78 to i32
  %80 = zext i32 %spec.select to i64
  %81 = zext i32 %spec.select to i64
  %82 = load i32, i32* @close_aircrack, align 4
  %83 = icmp ne i32 %82, 0
  br i1 %83, label %._crit_edge27, label %.lr.ph26.preheader

.lr.ph26.preheader:                               ; preds = %75
  br label %.lr.ph26

._crit_edge27.loopexit:                           ; preds = %315
  br label %._crit_edge27

._crit_edge27:                                    ; preds = %._crit_edge27.loopexit, %75
  %84 = bitcast i32* %8 to i8*
  call void @pthread_exit(i8* %84) #12
  unreachable

.lr.ph26:                                         ; preds = %.lr.ph26.preheader, %315
  call void @unroll_loop(i32 101)
  br label %85

; <label>:85:                                     ; preds = %.lr.ph26, %.loopexit
  %indvars.iv13 = phi i64 [ 0, %.lr.ph26 ], [ %indvars.iv.next14, %.loopexit ]
  call void @unroll_loop(i32 102)
  %86 = getelementptr inbounds [4 x [128 x i8]], [4 x [128 x i8]]* %3, i64 0, i64 %indvars.iv13
  %87 = getelementptr inbounds [128 x i8], [128 x i8]* %86, i64 0, i64 0
  store i8 0, i8* %87, align 16
  %88 = getelementptr inbounds [4 x [128 x i8]], [4 x [128 x i8]]* %3, i64 0, i64 %indvars.iv13
  %89 = getelementptr inbounds [128 x i8], [128 x i8]* %88, i32 0, i32 0
  %90 = call i32 @wpa_receive_passphrase(i8* %89, %struct.WPA_data* %11)
  %91 = icmp eq i32 %90, 0
  br i1 %91, label %.lr.ph11.preheader, label %.loopexit

.lr.ph11.preheader:                               ; preds = %85
  br label %.lr.ph11

.lr.ph11:                                         ; preds = %.lr.ph11.preheader, %96
  call void @unroll_loop(i32 103)
  %92 = load i32, i32* @wpa_wordlists_done, align 4
  %93 = icmp eq i32 %92, 1
  br i1 %93, label %94, label %96

; <label>:94:                                     ; preds = %.lr.ph11
  %95 = icmp eq i64 %indvars.iv13, 0
  br i1 %95, label %.loopexit4, label %.loopexit

; <label>:96:                                     ; preds = %.lr.ph11
  %97 = call i32 @sched_yield() #9
  %98 = call i32 @wpa_receive_passphrase(i8* %89, %struct.WPA_data* %11)
  %99 = icmp eq i32 %98, 0
  br i1 %99, label %.lr.ph11, label %.loopexit.loopexit

.loopexit.loopexit:                               ; preds = %96
  br label %.loopexit

.loopexit:                                        ; preds = %.loopexit.loopexit, %85, %94
  %100 = getelementptr inbounds [4 x [128 x i8]], [4 x [128 x i8]]* %3, i64 0, i64 %indvars.iv13
  %101 = getelementptr inbounds [128 x i8], [128 x i8]* %100, i64 0, i64 127
  store i8 0, i8* %101, align 1
  %indvars.iv.next14 = add nuw nsw i64 %indvars.iv13, 1
  %102 = icmp ult i64 %indvars.iv.next14, %80
  br i1 %102, label %85, label %103

; <label>:103:                                    ; preds = %.loopexit
  %104 = icmp eq i32 %spec.select, 4
  br i1 %104, label %105, label %.preheader

.preheader:                                       ; preds = %103
  br label %123

; <label>:105:                                    ; preds = %103
  %106 = getelementptr inbounds [4 x [128 x i8]], [4 x [128 x i8]]* %3, i64 0, i64 0
  %107 = getelementptr inbounds [128 x i8], [128 x i8]* %106, i32 0, i32 0
  %108 = getelementptr inbounds [4 x [128 x i8]], [4 x [128 x i8]]* %3, i64 0, i64 1
  %109 = getelementptr inbounds [128 x i8], [128 x i8]* %108, i32 0, i32 0
  %110 = getelementptr inbounds [4 x [128 x i8]], [4 x [128 x i8]]* %3, i64 0, i64 2
  %111 = getelementptr inbounds [128 x i8], [128 x i8]* %110, i32 0, i32 0
  %112 = getelementptr inbounds [4 x [128 x i8]], [4 x [128 x i8]]* %3, i64 0, i64 3
  %113 = getelementptr inbounds [128 x i8], [128 x i8]* %112, i32 0, i32 0
  %114 = getelementptr inbounds [36 x i8], [36 x i8]* %2, i32 0, i32 0
  %115 = getelementptr inbounds [4 x [128 x i8]], [4 x [128 x i8]]* %4, i64 0, i64 0
  %116 = getelementptr inbounds [128 x i8], [128 x i8]* %115, i32 0, i32 0
  %117 = getelementptr inbounds [4 x [128 x i8]], [4 x [128 x i8]]* %4, i64 0, i64 1
  %118 = getelementptr inbounds [128 x i8], [128 x i8]* %117, i32 0, i32 0
  %119 = getelementptr inbounds [4 x [128 x i8]], [4 x [128 x i8]]* %4, i64 0, i64 2
  %120 = getelementptr inbounds [128 x i8], [128 x i8]* %119, i32 0, i32 0
  %121 = getelementptr inbounds [4 x [128 x i8]], [4 x [128 x i8]]* %4, i64 0, i64 3
  %122 = getelementptr inbounds [128 x i8], [128 x i8]* %121, i32 0, i32 0
  call void @calc_4pmk(i8* %107, i8* %109, i8* %111, i8* %113, i8* %114, i8* %116, i8* %118, i8* %120, i8* %122)
  br label %129

; <label>:123:                                    ; preds = %.preheader, %123
  %indvars.iv16 = phi i64 [ %indvars.iv.next17, %123 ], [ 0, %.preheader ]
  call void @unroll_loop(i32 104)
  %124 = getelementptr inbounds [4 x [128 x i8]], [4 x [128 x i8]]* %3, i64 0, i64 %indvars.iv16
  %125 = getelementptr inbounds [128 x i8], [128 x i8]* %124, i32 0, i32 0
  %126 = getelementptr inbounds [36 x i8], [36 x i8]* %2, i32 0, i32 0
  %127 = getelementptr inbounds [4 x [128 x i8]], [4 x [128 x i8]]* %4, i64 0, i64 %indvars.iv16
  %128 = getelementptr inbounds [128 x i8], [128 x i8]* %127, i32 0, i32 0
  call void @calc_pmk(i8* %125, i8* %126, i8* %128)
  %indvars.iv.next17 = add nuw nsw i64 %indvars.iv16, 1
  %exitcond1 = icmp ne i64 %indvars.iv.next17, %80
  br i1 %exitcond1, label %123, label %.loopexit3

.loopexit3:                                       ; preds = %123
  br label %129

; <label>:129:                                    ; preds = %.loopexit3, %105
  br label %130

; <label>:130:                                    ; preds = %129, %288
  %indvars.iv23 = phi i64 [ 0, %129 ], [ %indvars.iv.next24, %288 ]
  call void @unroll_loop(i32 105)
  br label %131

; <label>:131:                                    ; preds = %130, %131
  %indvars.iv19 = phi i64 [ 0, %130 ], [ %indvars.iv.next20, %131 ]
  %.0618 = phi i32 [ 0, %130 ], [ %143, %131 ]
  call void @unroll_loop(i32 106)
  %132 = trunc i32 %.0618 to i8
  %133 = getelementptr inbounds [100 x i8], [100 x i8]* %5, i64 0, i64 99
  store i8 %132, i8* %133, align 1
  %134 = call %struct.env_md_st* @EVP_sha1()
  %135 = getelementptr inbounds [4 x [128 x i8]], [4 x [128 x i8]]* %4, i64 0, i64 %indvars.iv23
  %136 = getelementptr inbounds [128 x i8], [128 x i8]* %135, i32 0, i32 0
  %137 = getelementptr inbounds [100 x i8], [100 x i8]* %5, i32 0, i32 0
  %138 = getelementptr inbounds [4 x [80 x i8]], [4 x [80 x i8]]* %6, i64 0, i64 %indvars.iv23
  %139 = getelementptr inbounds [80 x i8], [80 x i8]* %138, i32 0, i32 0
  %140 = mul nuw nsw i64 %indvars.iv19, 20
  %141 = getelementptr inbounds i8, i8* %139, i64 %140
  %142 = call i8* @HMAC(%struct.env_md_st* %134, i8* %136, i32 32, i8* %137, i64 100, i8* %141, i32* null)
  %indvars.iv.next20 = add nuw nsw i64 %indvars.iv19, 1
  %143 = add nuw nsw i32 %.0618, 1
  %exitcond21 = icmp ne i64 %indvars.iv.next20, 4
  br i1 %exitcond21, label %131, label %144

; <label>:144:                                    ; preds = %131
  %145 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %13, i32 0, i32 14
  %146 = getelementptr inbounds %struct.WPA_hdsk, %struct.WPA_hdsk* %145, i32 0, i32 6
  %147 = load i32, i32* %146, align 4
  %148 = icmp eq i32 %147, 1
  br i1 %148, label %149, label %163

; <label>:149:                                    ; preds = %144
  %150 = call %struct.env_md_st* @EVP_md5()
  %151 = getelementptr inbounds [4 x [80 x i8]], [4 x [80 x i8]]* %6, i64 0, i64 %indvars.iv23
  %152 = getelementptr inbounds [80 x i8], [80 x i8]* %151, i32 0, i32 0
  %153 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %13, i32 0, i32 14
  %154 = getelementptr inbounds %struct.WPA_hdsk, %struct.WPA_hdsk* %153, i32 0, i32 4
  %155 = getelementptr inbounds [256 x i8], [256 x i8]* %154, i32 0, i32 0
  %156 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %13, i32 0, i32 14
  %157 = getelementptr inbounds %struct.WPA_hdsk, %struct.WPA_hdsk* %156, i32 0, i32 5
  %158 = load i32, i32* %157, align 8
  %159 = sext i32 %158 to i64
  %160 = getelementptr inbounds [4 x [20 x i8]], [4 x [20 x i8]]* %7, i64 0, i64 %indvars.iv23
  %161 = getelementptr inbounds [20 x i8], [20 x i8]* %160, i32 0, i32 0
  %162 = call i8* @HMAC(%struct.env_md_st* %150, i8* %152, i32 16, i8* %155, i64 %159, i8* %161, i32* null)
  br label %177

; <label>:163:                                    ; preds = %144
  %164 = call %struct.env_md_st* @EVP_sha1()
  %165 = getelementptr inbounds [4 x [80 x i8]], [4 x [80 x i8]]* %6, i64 0, i64 %indvars.iv23
  %166 = getelementptr inbounds [80 x i8], [80 x i8]* %165, i32 0, i32 0
  %167 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %13, i32 0, i32 14
  %168 = getelementptr inbounds %struct.WPA_hdsk, %struct.WPA_hdsk* %167, i32 0, i32 4
  %169 = getelementptr inbounds [256 x i8], [256 x i8]* %168, i32 0, i32 0
  %170 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %13, i32 0, i32 14
  %171 = getelementptr inbounds %struct.WPA_hdsk, %struct.WPA_hdsk* %170, i32 0, i32 5
  %172 = load i32, i32* %171, align 8
  %173 = sext i32 %172 to i64
  %174 = getelementptr inbounds [4 x [20 x i8]], [4 x [20 x i8]]* %7, i64 0, i64 %indvars.iv23
  %175 = getelementptr inbounds [20 x i8], [20 x i8]* %174, i32 0, i32 0
  %176 = call i8* @HMAC(%struct.env_md_st* %164, i8* %166, i32 16, i8* %169, i64 %173, i8* %175, i32* null)
  br label %177

; <label>:177:                                    ; preds = %163, %149
  %178 = getelementptr inbounds [4 x [20 x i8]], [4 x [20 x i8]]* %7, i64 0, i64 %indvars.iv23
  %179 = getelementptr inbounds [20 x i8], [20 x i8]* %178, i32 0, i32 0
  %180 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %13, i32 0, i32 14
  %181 = getelementptr inbounds %struct.WPA_hdsk, %struct.WPA_hdsk* %180, i32 0, i32 3
  %182 = getelementptr inbounds [16 x i8], [16 x i8]* %181, i32 0, i32 0
  %183 = call i32 @memcmp(i8* %179, i8* %182, i64 16) #10
  %184 = icmp eq i32 %183, 0
  br i1 %184, label %185, label %288

; <label>:185:                                    ; preds = %177
  %.25.lcssa8.wide = phi i64 [ %indvars.iv23, %177 ]
  %186 = trunc i64 %.25.lcssa8.wide to i32
  %187 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 22
  %188 = load %struct._IO_FILE*, %struct._IO_FILE** %187, align 8
  %189 = icmp ne %struct._IO_FILE* %188, null
  br i1 %189, label %190, label %200

; <label>:190:                                    ; preds = %185
  %191 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 28
  %192 = load i32, i32* %191, align 8
  %193 = icmp ne i32 %192, 0
  br i1 %193, label %198, label %194

; <label>:194:                                    ; preds = %190
  %195 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 22
  %196 = load %struct._IO_FILE*, %struct._IO_FILE** %195, align 8
  %197 = call i32 @fclose(%struct._IO_FILE* %196)
  br label %198

; <label>:198:                                    ; preds = %194, %190
  %199 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 22
  store %struct._IO_FILE* null, %struct._IO_FILE** %199, align 8
  br label %200

; <label>:200:                                    ; preds = %198, %185
  %201 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 5
  %202 = load i32, i32* %201, align 4
  %203 = icmp slt i32 0, %202
  br i1 %203, label %.lr.ph.preheader, label %._crit_edge

.lr.ph.preheader:                                 ; preds = %200
  br label %.lr.ph

.lr.ph:                                           ; preds = %.lr.ph.preheader, %.lr.ph
  %indvars.iv = phi i64 [ %indvars.iv.next, %.lr.ph ], [ 0, %.lr.ph.preheader ]
  call void @unroll_loop(i32 107)
  %204 = getelementptr inbounds [128 x %struct.WPA_data], [128 x %struct.WPA_data]* @wpa_data, i64 0, i64 %indvars.iv
  %205 = getelementptr inbounds %struct.WPA_data, %struct.WPA_data* %204, i32 0, i32 8
  %206 = call i32 @pthread_mutex_lock(%union.pthread_mutex_t* %205) #9
  %207 = getelementptr inbounds [128 x %struct.WPA_data], [128 x %struct.WPA_data]* @wpa_data, i64 0, i64 %indvars.iv
  %208 = getelementptr inbounds %struct.WPA_data, %struct.WPA_data* %207, i32 0, i32 7
  %209 = call i32 @pthread_cond_signal(%union.pthread_cond_t* %208) #9
  %210 = getelementptr inbounds [128 x %struct.WPA_data], [128 x %struct.WPA_data]* @wpa_data, i64 0, i64 %indvars.iv
  %211 = getelementptr inbounds %struct.WPA_data, %struct.WPA_data* %210, i32 0, i32 8
  %212 = call i32 @pthread_mutex_unlock(%union.pthread_mutex_t* %211) #9
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %213 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 5
  %214 = load i32, i32* %213, align 4
  %215 = sext i32 %214 to i64
  %216 = icmp slt i64 %indvars.iv.next, %215
  br i1 %216, label %.lr.ph, label %._crit_edge.loopexit

._crit_edge.loopexit:                             ; preds = %.lr.ph
  br label %._crit_edge

._crit_edge:                                      ; preds = %._crit_edge.loopexit, %200
  %217 = getelementptr inbounds %struct.WPA_data, %struct.WPA_data* %11, i32 0, i32 6
  %218 = getelementptr inbounds [128 x i8], [128 x i8]* %217, i32 0, i32 0
  %219 = sext i32 %186 to i64
  %220 = getelementptr inbounds [4 x [128 x i8]], [4 x [128 x i8]]* %3, i64 0, i64 %219
  %221 = getelementptr inbounds [128 x i8], [128 x i8]* %220, i32 0, i32 0
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %218, i8* align 16 %221, i64 128, i1 false), !track !199
  %222 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 6
  %223 = load i32, i32* %222, align 8
  %224 = icmp ne i32 %223, 0
  br i1 %224, label %318, label %225

; <label>:225:                                    ; preds = %._crit_edge
  %226 = call i32 @pthread_mutex_lock(%union.pthread_mutex_t* @mx_nb) #9
  %227 = load i64, i64* @nb_tried, align 8
  %228 = add nsw i64 %227, 4
  store i64 %228, i64* @nb_tried, align 8
  %229 = load i64, i64* @nb_kprev, align 8
  %230 = add nsw i64 %229, 4
  store i64 %230, i64* @nb_kprev, align 8
  %231 = call i32 @pthread_mutex_unlock(%union.pthread_mutex_t* @mx_nb) #9
  %232 = sext i32 %186 to i64
  %233 = getelementptr inbounds [4 x [128 x i8]], [4 x [128 x i8]]* %3, i64 0, i64 %232
  %234 = getelementptr inbounds [128 x i8], [128 x i8]* %233, i32 0, i32 0
  %235 = call i64 @strlen(i8* %234) #10
  %236 = trunc i64 %235 to i32
  %237 = icmp sgt i32 %236, 64
  %spec.select1 = select i1 %237, i32 64, i32 %236
  %238 = icmp slt i32 %spec.select1, 8
  %.1 = select i1 %238, i32 8, i32 %spec.select1
  %239 = sext i32 %186 to i64
  %240 = getelementptr inbounds [4 x [128 x i8]], [4 x [128 x i8]]* %3, i64 0, i64 %239
  %241 = getelementptr inbounds [128 x i8], [128 x i8]* %240, i32 0, i32 0
  %242 = sext i32 %186 to i64
  %243 = getelementptr inbounds [4 x [128 x i8]], [4 x [128 x i8]]* %4, i64 0, i64 %242
  %244 = getelementptr inbounds [128 x i8], [128 x i8]* %243, i32 0, i32 0
  %245 = sext i32 %186 to i64
  %246 = getelementptr inbounds [4 x [80 x i8]], [4 x [80 x i8]]* %6, i64 0, i64 %245
  %247 = getelementptr inbounds [80 x i8], [80 x i8]* %246, i32 0, i32 0
  %248 = sext i32 %186 to i64
  %249 = getelementptr inbounds [4 x [20 x i8]], [4 x [20 x i8]]* %7, i64 0, i64 %248
  %250 = getelementptr inbounds [20 x i8], [20 x i8]* %249, i32 0, i32 0
  call void @show_wpa_stats(i8* %241, i32 %.1, i8* %244, i8* %247, i8* %250, i32 1)
  %251 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 27
  %252 = load i32, i32* %251, align 4
  %253 = icmp ne i32 %252, 0
  br i1 %253, label %254, label %257

; <label>:254:                                    ; preds = %225
  %255 = getelementptr [8 x i8], [8 x i8]* @.str.62, i32 0, i32 0
  %256 = call i32 (i8*, ...) @printf(i8* %255)
  br label %257

; <label>:257:                                    ; preds = %254, %225
  %258 = sub nsw i32 65, %.1
  %259 = sdiv i32 %258, 2
  %260 = sext i32 %186 to i64
  %261 = getelementptr inbounds [4 x [128 x i8]], [4 x [128 x i8]]* %3, i64 0, i64 %260
  %262 = getelementptr inbounds [128 x i8], [128 x i8]* %261, i32 0, i32 0
  %263 = getelementptr [35 x i8], [35 x i8]* @.str.63, i32 0, i32 0
  %264 = call i32 (i8*, ...) @printf(i8* %263, i32 %259, i8* %262)
  %265 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 27
  %266 = load i32, i32* %265, align 4
  %267 = icmp ne i32 %266, 0
  br i1 %267, label %268, label %271

; <label>:268:                                    ; preds = %257
  %269 = getelementptr [9 x i8], [9 x i8]* @.str.36, i32 0, i32 0
  %270 = call i32 (i8*, ...) @printf(i8* %269)
  br label %271

; <label>:271:                                    ; preds = %268, %257
  %272 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 42
  %273 = load i8*, i8** %272, align 8
  %274 = icmp ne i8* %273, null
  br i1 %274, label %275, label %318

; <label>:275:                                    ; preds = %271
  %276 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 42
  %277 = load i8*, i8** %276, align 8
  %278 = getelementptr [2 x i8], [2 x i8]* @.str.64, i32 0, i32 0
  %279 = call %struct._IO_FILE* @fopen64(i8* %277, i8* %278), !track !200
  %280 = icmp ne %struct._IO_FILE* %279, null
  br i1 %280, label %281, label %318

; <label>:281:                                    ; preds = %275
  %282 = sext i32 %186 to i64
  %283 = getelementptr inbounds [4 x [128 x i8]], [4 x [128 x i8]]* %3, i64 0, i64 %282
  %284 = getelementptr inbounds [128 x i8], [128 x i8]* %283, i32 0, i32 0
  %285 = getelementptr [3 x i8], [3 x i8]* @.str.65, i32 0, i32 0
  %286 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %279, i8* %285, i8* %284)
  %287 = call i32 @fclose(%struct._IO_FILE* %279)
  br label %318

; <label>:288:                                    ; preds = %177
  %indvars.iv.next24 = add nuw nsw i64 %indvars.iv23, 1
  %289 = icmp ult i64 %indvars.iv.next24, %81
  br i1 %289, label %130, label %290

; <label>:290:                                    ; preds = %288
  %291 = call i32 @pthread_mutex_lock(%union.pthread_mutex_t* @mx_nb) #9
  %292 = load i64, i64* @nb_tried, align 8
  %293 = add nsw i64 %292, 4
  store i64 %293, i64* @nb_tried, align 8
  %294 = load i64, i64* @nb_kprev, align 8
  %295 = add nsw i64 %294, 4
  store i64 %295, i64* @nb_kprev, align 8
  %296 = call i32 @pthread_mutex_unlock(%union.pthread_mutex_t* @mx_nb) #9
  %297 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 6
  %298 = load i32, i32* %297, align 8
  %299 = icmp ne i32 %298, 0
  br i1 %299, label %315, label %300

; <label>:300:                                    ; preds = %290
  %301 = getelementptr inbounds [4 x [128 x i8]], [4 x [128 x i8]]* %3, i64 0, i64 0
  %302 = getelementptr inbounds [128 x i8], [128 x i8]* %301, i32 0, i32 0
  %303 = call i64 @strlen(i8* %302) #10
  %304 = trunc i64 %303 to i32
  %305 = icmp sgt i32 %304, 64
  %spec.select2 = select i1 %305, i32 64, i32 %304
  %306 = icmp slt i32 %spec.select2, 8
  %.3 = select i1 %306, i32 8, i32 %spec.select2
  %307 = getelementptr inbounds [4 x [128 x i8]], [4 x [128 x i8]]* %3, i64 0, i64 0
  %308 = getelementptr inbounds [128 x i8], [128 x i8]* %307, i32 0, i32 0
  %309 = getelementptr inbounds [4 x [128 x i8]], [4 x [128 x i8]]* %4, i64 0, i64 0
  %310 = getelementptr inbounds [128 x i8], [128 x i8]* %309, i32 0, i32 0
  %311 = getelementptr inbounds [4 x [80 x i8]], [4 x [80 x i8]]* %6, i64 0, i64 0
  %312 = getelementptr inbounds [80 x i8], [80 x i8]* %311, i32 0, i32 0
  %313 = getelementptr inbounds [4 x [20 x i8]], [4 x [20 x i8]]* %7, i64 0, i64 0
  %314 = getelementptr inbounds [20 x i8], [20 x i8]* %313, i32 0, i32 0
  call void @show_wpa_stats(i8* %308, i32 %.3, i8* %310, i8* %312, i8* %314, i32 0)
  br label %315

; <label>:315:                                    ; preds = %300, %290
  %316 = load i32, i32* @close_aircrack, align 4
  %317 = icmp ne i32 %316, 0
  br i1 %317, label %._crit_edge27.loopexit, label %.lr.ph26

.loopexit4:                                       ; preds = %94
  br label %318

; <label>:318:                                    ; preds = %.loopexit4, %271, %281, %275, %._crit_edge
  ret i32 0
}

declare dso_local i32 @shasse2_cpuid() #1

; Function Attrs: noreturn
declare dso_local void @pthread_exit(i8*) #6

; Function Attrs: nounwind
declare dso_local i32 @sched_yield() #2

declare dso_local %struct.env_md_st* @EVP_md5() #1

; Function Attrs: noinline nounwind uwtable
define dso_local i32 @next_dict(i32) #0 {
  %2 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 22
  %3 = load %struct._IO_FILE*, %struct._IO_FILE** %2, align 8
  %4 = icmp ne %struct._IO_FILE* %3, null
  br i1 %4, label %5, label %15

; <label>:5:                                      ; preds = %1
  %6 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 28
  %7 = load i32, i32* %6, align 8
  %8 = icmp ne i32 %7, 0
  br i1 %8, label %13, label %9

; <label>:9:                                      ; preds = %5
  %10 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 22
  %11 = load %struct._IO_FILE*, %struct._IO_FILE** %10, align 8
  %12 = call i32 @fclose(%struct._IO_FILE* %11)
  br label %13

; <label>:13:                                     ; preds = %9, %5
  %14 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 22
  store %struct._IO_FILE* null, %struct._IO_FILE** %14, align 8
  br label %15

; <label>:15:                                     ; preds = %13, %1
  %16 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 23
  store i32 %0, i32* %16, align 8
  %17 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 23
  %18 = load i32, i32* %17, align 8
  %19 = sext i32 %18 to i64
  %20 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 21
  %21 = getelementptr inbounds [128 x i8*], [128 x i8*]* %20, i64 0, i64 %19
  %22 = load i8*, i8** %21, align 8
  %23 = icmp eq i8* %22, null
  br i1 %23, label %111, label %.preheader

.preheader:                                       ; preds = %15
  call void @unroll_loop(i32 108)
  %24 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 23
  %25 = load i32, i32* %24, align 8
  %26 = icmp slt i32 %25, 128
  br i1 %26, label %.lr.ph, label %.loopexit.loopexit

.lr.ph:                                           ; preds = %.preheader
  br label %27

; <label>:27:                                     ; preds = %.lr.ph, %.backedge
  %28 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 23
  %29 = load i32, i32* %28, align 8
  %30 = sext i32 %29 to i64
  %31 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 21
  %32 = getelementptr inbounds [128 x i8*], [128 x i8*]* %31, i64 0, i64 %30
  %33 = load i8*, i8** %32, align 8
  %34 = icmp ne i8* %33, null
  br i1 %34, label %35, label %..loopexit.loopexit_crit_edge1

; <label>:35:                                     ; preds = %27
  %36 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 23
  %37 = load i32, i32* %36, align 8
  %38 = sext i32 %37 to i64
  %39 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 21
  %40 = getelementptr inbounds [128 x i8*], [128 x i8*]* %39, i64 0, i64 %38
  %41 = load i8*, i8** %40, align 8
  %42 = getelementptr [2 x i8], [2 x i8]* @.str.10, i32 0, i32 0
  %43 = call i32 @strcmp(i8* %41, i8* %42) #10
  %44 = icmp eq i32 %43, 0
  %45 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 28
  br i1 %44, label %46, label %63

; <label>:46:                                     ; preds = %35
  store i32 1, i32* %45, align 8
  %47 = load %struct._IO_FILE*, %struct._IO_FILE** @stdin, align 8
  %48 = call i32 @fileno(%struct._IO_FILE* %47) #9
  %49 = getelementptr [2 x i8], [2 x i8]* @.str.66, i32 0, i32 0
  %50 = call %struct._IO_FILE* @fdopen(i32 %48, i8* %49) #9, !track !201
  %51 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 22
  store %struct._IO_FILE* %50, %struct._IO_FILE** %51, align 8
  %52 = icmp eq %struct._IO_FILE* %50, null
  br i1 %52, label %53, label %61

; <label>:53:                                     ; preds = %46
  %54 = getelementptr [25 x i8], [25 x i8]* @.str.67, i32 0, i32 0
  call void @perror(i8* %54)
  %55 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 23
  %56 = load i32, i32* %55, align 8
  %57 = add nsw i32 %56, 1
  %58 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 23
  store i32 %57, i32* %58, align 8
  br label %.backedge

.backedge:                                        ; preds = %53, %74, %90
  call void @unroll_loop(i32 108)
  %59 = load i32, i32* %24, align 8
  %60 = icmp slt i32 %59, 128
  br i1 %60, label %27, label %..loopexit.loopexit_crit_edge

; <label>:61:                                     ; preds = %46
  %62 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 24
  store i32 1, i32* %62, align 4
  br label %.loopexit

; <label>:63:                                     ; preds = %35
  store i32 0, i32* %45, align 8
  %64 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 23
  %65 = load i32, i32* %64, align 8
  %66 = sext i32 %65 to i64
  %67 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 21
  %68 = getelementptr inbounds [128 x i8*], [128 x i8*]* %67, i64 0, i64 %66
  %69 = load i8*, i8** %68, align 8
  %70 = getelementptr [2 x i8], [2 x i8]* @.str.66, i32 0, i32 0
  %71 = call %struct._IO_FILE* @fopen64(i8* %69, i8* %70), !track !202
  %72 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 22
  store %struct._IO_FILE* %71, %struct._IO_FILE** %72, align 8
  %73 = icmp eq %struct._IO_FILE* %71, null
  br i1 %73, label %74, label %80

; <label>:74:                                     ; preds = %63
  %75 = getelementptr [25 x i8], [25 x i8]* @.str.67, i32 0, i32 0
  call void @perror(i8* %75)
  %76 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 23
  %77 = load i32, i32* %76, align 8
  %78 = add nsw i32 %77, 1
  %79 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 23
  store i32 %78, i32* %79, align 8
  br label %.backedge

; <label>:80:                                     ; preds = %63
  %81 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 22
  %82 = load %struct._IO_FILE*, %struct._IO_FILE** %81, align 8
  %83 = call i32 @fseek(%struct._IO_FILE* %82, i64 0, i32 2)
  %84 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 22
  %85 = load %struct._IO_FILE*, %struct._IO_FILE** %84, align 8
  %86 = call i64 @ftell(%struct._IO_FILE* %85)
  %87 = icmp sle i64 %86, 0
  %88 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 22
  %89 = load %struct._IO_FILE*, %struct._IO_FILE** %88, align 8
  br i1 %87, label %90, label %99

; <label>:90:                                     ; preds = %80
  %91 = call i32 @fclose(%struct._IO_FILE* %89)
  %92 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 22
  store %struct._IO_FILE* null, %struct._IO_FILE** %92, align 8
  %93 = getelementptr [18 x i8], [18 x i8]* @.str.68, i32 0, i32 0
  %94 = call i32 (i8*, ...) @printf(i8* %93)
  %95 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 23
  %96 = load i32, i32* %95, align 8
  %97 = add nsw i32 %96, 1
  %98 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 23
  store i32 %97, i32* %98, align 8
  br label %.backedge

; <label>:99:                                     ; preds = %80
  %.lcssa = phi %struct._IO_FILE* [ %89, %80 ]
  call void @rewind(%struct._IO_FILE* %.lcssa)
  br label %.loopexit

..loopexit.loopexit_crit_edge:                    ; preds = %.backedge
  br label %.loopexit.loopexit

..loopexit.loopexit_crit_edge1:                   ; preds = %27
  br label %.loopexit.loopexit

.loopexit.loopexit:                               ; preds = %..loopexit.loopexit_crit_edge1, %..loopexit.loopexit_crit_edge, %.preheader
  br label %.loopexit

.loopexit:                                        ; preds = %.loopexit.loopexit, %61, %99
  %100 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 23
  %101 = load i32, i32* %100, align 8
  %102 = icmp sge i32 %101, 128
  br i1 %102, label %111, label %103

; <label>:103:                                    ; preds = %.loopexit
  %104 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 23
  %105 = load i32, i32* %104, align 8
  %106 = sext i32 %105 to i64
  %107 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 21
  %108 = getelementptr inbounds [128 x i8*], [128 x i8*]* %107, i64 0, i64 %106
  %109 = load i8*, i8** %108, align 8
  %110 = icmp eq i8* %109, null
  %spec.select = select i1 %110, i32 1, i32 0
  ret i32 %spec.select

; <label>:111:                                    ; preds = %.loopexit, %15
  ret i32 1
}

; Function Attrs: nounwind
declare dso_local i32 @fileno(%struct._IO_FILE*) #2

; Function Attrs: nounwind
declare dso_local %struct._IO_FILE* @fdopen(i32, i8*) #2

declare dso_local i32 @fseek(%struct._IO_FILE*, i64, i32) #1

declare dso_local i64 @ftell(%struct._IO_FILE*) #1

declare dso_local void @rewind(%struct._IO_FILE*) #1

; Function Attrs: noinline nounwind uwtable
define dso_local i32 @do_wpa_crack() #0 {
  %1 = alloca [128 x i8], align 16, !track !203
  %2 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 0
  store i32 2, i32* %2, align 8
  %3 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 5
  %4 = load i32, i32* %3, align 4
  %5 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 6
  %6 = load i32, i32* %5, align 8
  %7 = icmp ne i32 %6, 0
  br i1 %7, label %28, label %8

; <label>:8:                                      ; preds = %0
  %9 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 27
  %10 = load i32, i32* %9, align 4
  %11 = icmp ne i32 %10, 0
  br i1 %11, label %12, label %15

; <label>:12:                                     ; preds = %8
  %13 = getelementptr [9 x i8], [9 x i8]* @.str.69, i32 0, i32 0
  %14 = call i32 (i8*, ...) @printf(i8* %13)
  br label %15

; <label>:15:                                     ; preds = %12, %8
  %16 = getelementptr [5 x i8], [5 x i8]* @.str.30, i32 0, i32 0
  %17 = call i32 (i8*, ...) @printf(i8* %16)
  %18 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 27
  %19 = load i32, i32* %18, align 4
  %20 = icmp ne i32 %19, 0
  br i1 %20, label %21, label %24

; <label>:21:                                     ; preds = %15
  %22 = getelementptr [8 x i8], [8 x i8]* @.str.31, i32 0, i32 0
  %23 = call i32 (i8*, ...) @printf(i8* %22)
  br label %24

; <label>:24:                                     ; preds = %21, %15
  %25 = load i8*, i8** @progname, align 8
  %26 = getelementptr [10 x i8], [10 x i8]* @.str.70, i32 0, i32 0
  %27 = call i32 (i8*, ...) @printf(i8* %26, i8* %25)
  br label %28

; <label>:28:                                     ; preds = %24, %0
  %29 = icmp sgt i32 %4, 0
  br i1 %29, label %.lr.ph26.preheader, label %._crit_edge27

.lr.ph26.preheader:                               ; preds = %28
  br label %.lr.ph26

.lr.ph26:                                         ; preds = %.lr.ph26.preheader, %128
  %.0124 = phi i32 [ %.7.lcssa, %128 ], [ 0, %.lr.ph26.preheader ]
  %.0323 = phi i32 [ %.25, %128 ], [ 0, %.lr.ph26.preheader ]
  %.0622 = phi i32 [ %.28, %128 ], [ 0, %.lr.ph26.preheader ]
  call void @unroll_loop(i32 109)
  %30 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 22
  %31 = load %struct._IO_FILE*, %struct._IO_FILE** %30, align 8
  %32 = icmp eq %struct._IO_FILE* %31, null
  br i1 %32, label %._crit_edge27.loopexit1, label %.preheader

.preheader:                                       ; preds = %.lr.ph26
  br label %33

; <label>:33:                                     ; preds = %.preheader, %._crit_edge
  %.1 = phi i32 [ %.6, %._crit_edge ], [ %.0124, %.preheader ]
  call void @unroll_loop(i32 110)
  %34 = getelementptr inbounds [128 x i8], [128 x i8]* %1, i32 0, i32 0
  call void @llvm.memset.p0i8.i64(i8* align 16 %34, i8 0, i64 128, i1 false)
  %35 = getelementptr inbounds [128 x i8], [128 x i8]* %1, i32 0, i32 0
  %36 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 22
  %37 = load %struct._IO_FILE*, %struct._IO_FILE** %36, align 8
  %38 = call i8* @fgets(i8* %35, i32 128, %struct._IO_FILE* %37), !track !204
  %39 = icmp eq i8* %38, null
  br i1 %39, label %40, label %53

; <label>:40:                                     ; preds = %33
  %41 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 27
  %42 = load i32, i32* %41, align 4
  %43 = icmp ne i32 %42, 0
  br i1 %43, label %44, label %47

; <label>:44:                                     ; preds = %40
  %45 = getelementptr [9 x i8], [9 x i8]* @.str.36, i32 0, i32 0
  %46 = call i32 (i8*, ...) @printf(i8* %45)
  br label %47

; <label>:47:                                     ; preds = %44, %40
  %48 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 23
  %49 = load i32, i32* %48, align 8
  %50 = add nsw i32 %49, 1
  %51 = call i32 @next_dict(i32 %50)
  %52 = icmp ne i32 %51, 0
  br i1 %52, label %._crit_edge27.loopexit, label %._crit_edge

; <label>:53:                                     ; preds = %33
  %54 = getelementptr inbounds [128 x i8], [128 x i8]* %1, i32 0, i32 0
  %55 = call i64 @strlen(i8* %54) #10
  %56 = trunc i64 %55 to i32
  %57 = icmp slt i32 %56, 8
  br i1 %57, label %._crit_edge, label %58

; <label>:58:                                     ; preds = %53
  %59 = icmp sgt i32 %56, 64
  %spec.select = select i1 %59, i32 64, i32 %56
  %60 = sub i32 %spec.select, -1
  %61 = sext i32 %60 to i64
  %62 = add i64 %61, -1
  br label %63

; <label>:63:                                     ; preds = %76, %58
  %indvars.iv = phi i64 [ %indvars.iv.next, %76 ], [ %62, %58 ]
  call void @unroll_loop(i32 111)
  %64 = icmp sgt i64 %indvars.iv, 0
  br i1 %64, label %65, label %76

; <label>:65:                                     ; preds = %63
  %66 = sub nsw i64 %indvars.iv, 1
  %67 = getelementptr inbounds [128 x i8], [128 x i8]* %1, i64 0, i64 %66
  %68 = load i8, i8* %67, align 1
  %69 = sext i8 %68 to i32
  %70 = icmp eq i32 %69, 13
  br i1 %70, label %76, label %71

; <label>:71:                                     ; preds = %65
  %72 = getelementptr inbounds [128 x i8], [128 x i8]* %1, i64 0, i64 %66
  %73 = load i8, i8* %72, align 1
  %74 = sext i8 %73 to i32
  %75 = icmp eq i32 %74, 10
  br label %76

; <label>:76:                                     ; preds = %65, %71, %63
  %77 = phi i1 [ false, %63 ], [ true, %65 ], [ %75, %71 ]
  %indvars.iv.next = add i64 %indvars.iv, -1
  br i1 %77, label %63, label %78

; <label>:78:                                     ; preds = %76
  %.3.lcssa.wide = phi i64 [ %indvars.iv, %76 ]
  %79 = trunc i64 %.3.lcssa.wide to i32
  %80 = icmp eq i32 %79, 0
  br i1 %80, label %._crit_edge, label %81

; <label>:81:                                     ; preds = %78
  %82 = sext i32 %79 to i64
  %83 = getelementptr inbounds [128 x i8], [128 x i8]* %1, i64 0, i64 %82
  store i8 0, i8* %83, align 1
  %84 = icmp slt i32 0, %79
  br i1 %84, label %.lr.ph.preheader, label %._crit_edge

.lr.ph.preheader:                                 ; preds = %81
  br label %.lr.ph

.lr.ph:                                           ; preds = %.lr.ph.preheader, %96
  %indvars.iv13 = phi i64 [ %indvars.iv.next14, %96 ], [ 0, %.lr.ph.preheader ]
  %.412 = phi i32 [ %.5, %96 ], [ %79, %.lr.ph.preheader ]
  call void @unroll_loop(i32 112)
  %85 = getelementptr inbounds [128 x i8], [128 x i8]* %1, i64 0, i64 %indvars.iv13
  %86 = load i8, i8* %85, align 1
  %87 = sext i8 %86 to i32
  %88 = and i32 %87, -128
  %89 = icmp eq i32 %88, 0
  br i1 %89, label %90, label %95

; <label>:90:                                     ; preds = %.lr.ph
  %91 = getelementptr inbounds [128 x i8], [128 x i8]* %1, i64 0, i64 %indvars.iv13
  %92 = load i8, i8* %91, align 1
  %93 = sext i8 %92 to i32
  %94 = icmp slt i32 %93, 32
  br i1 %94, label %95, label %96

; <label>:95:                                     ; preds = %90, %.lr.ph
  br label %96

; <label>:96:                                     ; preds = %90, %95
  %.5 = phi i32 [ 0, %95 ], [ %.412, %90 ]
  %indvars.iv.next14 = add nuw nsw i64 %indvars.iv13, 1
  %97 = sext i32 %.5 to i64
  %98 = icmp slt i64 %indvars.iv.next14, %97
  br i1 %98, label %.lr.ph, label %._crit_edge.loopexit

._crit_edge.loopexit:                             ; preds = %96
  %.6.ph = phi i32 [ %.5, %96 ]
  br label %._crit_edge

._crit_edge:                                      ; preds = %._crit_edge.loopexit, %81, %78, %53, %47
  %.6 = phi i32 [ %.1, %47 ], [ %56, %53 ], [ %79, %78 ], [ %79, %81 ], [ %.6.ph, %._crit_edge.loopexit ]
  %99 = icmp slt i32 %.6, 8
  br i1 %99, label %33, label %100

; <label>:100:                                    ; preds = %._crit_edge
  %101 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 5
  %102 = load i32, i32* %101, align 4
  %103 = icmp slt i32 0, %102
  br i1 %103, label %.lr.ph18.preheader, label %.loopexit

.lr.ph18.preheader:                               ; preds = %100
  br label %.lr.ph18

.lr.ph18:                                         ; preds = %.lr.ph18.preheader, %109
  %.716 = phi i32 [ %114, %109 ], [ 0, %.lr.ph18.preheader ]
  %.1415 = phi i32 [ %113, %109 ], [ %.0323, %.lr.ph18.preheader ]
  call void @unroll_loop(i32 113)
  %104 = getelementptr inbounds [128 x i8], [128 x i8]* %1, i32 0, i32 0
  %105 = sext i32 %.1415 to i64
  %106 = getelementptr inbounds [128 x %struct.WPA_data], [128 x %struct.WPA_data]* @wpa_data, i64 0, i64 %105
  %107 = call i32 @wpa_send_passphrase(i8* %104, %struct.WPA_data* %106, i32 0)
  %108 = icmp ne i32 %107, 0
  br i1 %108, label %.loopexit.loopexit, label %109

; <label>:109:                                    ; preds = %.lr.ph18
  %110 = add nsw i32 %.1415, 1
  %111 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 5
  %112 = load i32, i32* %111, align 4
  %113 = srem i32 %110, %112
  %114 = add nuw nsw i32 %.716, 1
  %115 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 5
  %116 = load i32, i32* %115, align 4
  %117 = icmp slt i32 %114, %116
  br i1 %117, label %.lr.ph18, label %.loopexit.loopexit

.loopexit.loopexit:                               ; preds = %.lr.ph18, %109
  %.14.lcssa.ph = phi i32 [ %113, %109 ], [ %.1415, %.lr.ph18 ]
  %.7.lcssa.ph = phi i32 [ %114, %109 ], [ %.716, %.lr.ph18 ]
  %.28.ph = phi i32 [ %107, %109 ], [ %107, %.lr.ph18 ]
  br label %.loopexit

.loopexit:                                        ; preds = %.loopexit.loopexit, %100
  %.14.lcssa = phi i32 [ %.0323, %100 ], [ %.14.lcssa.ph, %.loopexit.loopexit ]
  %.7.lcssa = phi i32 [ 0, %100 ], [ %.7.lcssa.ph, %.loopexit.loopexit ]
  %.28 = phi i32 [ %.0622, %100 ], [ %.28.ph, %.loopexit.loopexit ]
  %118 = icmp eq i32 %.28, 0
  br i1 %118, label %119, label %128

; <label>:119:                                    ; preds = %.loopexit
  %120 = getelementptr inbounds [128 x i8], [128 x i8]* %1, i32 0, i32 0
  %121 = sext i32 %.14.lcssa to i64
  %122 = getelementptr inbounds [128 x %struct.WPA_data], [128 x %struct.WPA_data]* @wpa_data, i64 0, i64 %121
  %123 = call i32 @wpa_send_passphrase(i8* %120, %struct.WPA_data* %122, i32 1)
  %124 = add nsw i32 %.14.lcssa, 1
  %125 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 5
  %126 = load i32, i32* %125, align 4
  %127 = srem i32 %124, %126
  br label %128

; <label>:128:                                    ; preds = %119, %.loopexit
  %.25 = phi i32 [ %127, %119 ], [ %.14.lcssa, %.loopexit ]
  br i1 %29, label %.lr.ph26, label %._crit_edge27.loopexit1

._crit_edge27.loopexit:                           ; preds = %47
  br label %._crit_edge27

._crit_edge27.loopexit1:                          ; preds = %.lr.ph26, %128
  br label %._crit_edge27

._crit_edge27:                                    ; preds = %._crit_edge27.loopexit1, %._crit_edge27.loopexit, %28
  ret i32 1
}

declare dso_local i8* @fgets(i8*, i32, %struct._IO_FILE*) #1

; Function Attrs: noinline nounwind uwtable
define dso_local i32 @next_key(i8**, i32) #0 {
  %3 = alloca i8*, align 8, !track !205
  %4 = alloca i32, align 4, !track !206
  %5 = call noalias i8* @malloc(i64 1024) #9, !track !207
  store i8* %5, i8** %3, align 8
  %6 = sext i32 %1 to i64
  store i8* %5, i8** %3, align 8
  %7 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 22
  %8 = load %struct._IO_FILE*, %struct._IO_FILE** %7, align 8
  %9 = icmp eq %struct._IO_FILE* %8, null
  br i1 %9, label %._crit_edge, label %.lr.ph.preheader

.lr.ph.preheader:                                 ; preds = %2
  br label %.lr.ph

._crit_edge.loopexit:                             ; preds = %.backedge
  br label %._crit_edge

._crit_edge:                                      ; preds = %._crit_edge.loopexit, %2
  %10 = load i8*, i8** %3, align 8
  call void @free(i8* %10) #9
  store i8* null, i8** %3, align 8
  br label %159

.lr.ph:                                           ; preds = %.lr.ph.preheader, %.backedge
  call void @unroll_loop(i32 114)
  %11 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 23
  %12 = load i32, i32* %11, align 8
  %13 = sext i32 %12 to i64
  %14 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 25
  %15 = getelementptr inbounds [128 x i32], [128 x i32]* %14, i64 0, i64 %13
  %16 = load i32, i32* %15, align 4
  %17 = icmp ne i32 %16, 0
  br i1 %17, label %18, label %100

; <label>:18:                                     ; preds = %.lr.ph
  %19 = load i8*, i8** %3, align 8
  %20 = mul nsw i32 %1, 2
  %21 = sub nsw i32 %1, 1
  %22 = add nsw i32 %20, %21
  %23 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 22
  %24 = load %struct._IO_FILE*, %struct._IO_FILE** %23, align 8
  %25 = call i8* @fgets(i8* %19, i32 %22, %struct._IO_FILE* %24), !track !208
  %26 = icmp eq i8* %25, null
  br i1 %26, label %27, label %42

; <label>:27:                                     ; preds = %18
  %28 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 27
  %29 = load i32, i32* %28, align 4
  %30 = icmp ne i32 %29, 0
  br i1 %30, label %31, label %34

; <label>:31:                                     ; preds = %27
  %32 = getelementptr [9 x i8], [9 x i8]* @.str.36, i32 0, i32 0
  %33 = call i32 (i8*, ...) @printf(i8* %32)
  br label %34

; <label>:34:                                     ; preds = %31, %27
  %35 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 23
  %36 = load i32, i32* %35, align 8
  %37 = add nsw i32 %36, 1
  %38 = call i32 @next_dict(i32 %37)
  %39 = icmp ne i32 %38, 0
  br i1 %39, label %40, label %.backedge

; <label>:40:                                     ; preds = %34
  %41 = load i8*, i8** %3, align 8
  call void @free(i8* %41) #9
  store i8* null, i8** %3, align 8
  br label %159

; <label>:42:                                     ; preds = %18
  %43 = load i8*, i8** %3, align 8
  %44 = call i64 @strlen(i8* %43) #10
  %45 = trunc i64 %44 to i32
  %46 = icmp sle i32 %45, 2
  br i1 %46, label %.backedge, label %47

; <label>:47:                                     ; preds = %42
  %48 = load i8*, i8** %3, align 8
  %49 = sub nsw i32 %45, 1
  %50 = sext i32 %49 to i64
  %51 = getelementptr inbounds i8, i8* %48, i64 %50
  %52 = load i8, i8* %51, align 1
  %53 = sext i8 %52 to i32
  %54 = icmp eq i32 %53, 10
  br i1 %54, label %55, label %60

; <label>:55:                                     ; preds = %47
  %56 = load i8*, i8** %3, align 8
  %57 = add nsw i32 %45, -1
  %58 = sext i32 %57 to i64
  %59 = getelementptr inbounds i8, i8* %56, i64 %58
  store i8 0, i8* %59, align 1
  br label %60

; <label>:60:                                     ; preds = %55, %47
  %.03 = phi i32 [ %57, %55 ], [ %45, %47 ]
  %61 = load i8*, i8** %3, align 8
  %62 = sub nsw i32 %.03, 1
  %63 = sext i32 %62 to i64
  %64 = getelementptr inbounds i8, i8* %61, i64 %63
  %65 = load i8, i8* %64, align 1
  %66 = sext i8 %65 to i32
  %67 = icmp eq i32 %66, 13
  br i1 %67, label %68, label %73

; <label>:68:                                     ; preds = %60
  %69 = load i8*, i8** %3, align 8
  %70 = add nsw i32 %.03, -1
  %71 = sext i32 %70 to i64
  %72 = getelementptr inbounds i8, i8* %69, i64 %71
  store i8 0, i8* %72, align 1
  br label %73

; <label>:73:                                     ; preds = %68, %60
  %.1 = phi i32 [ %70, %68 ], [ %.03, %60 ]
  %74 = icmp sle i32 %.1, 0
  br i1 %74, label %.backedge, label %75

; <label>:75:                                     ; preds = %73
  %76 = getelementptr [2 x i8], [2 x i8]* @.str.71, i32 0, i32 0
  %77 = call i8* @strsep(i8** %3, i8* %76) #9
  %78 = getelementptr [3 x i8], [3 x i8]* @.str.72, i32 0, i32 0
  call void @unroll_loop(i32 115)
  %79 = icmp slt i64 0, %6
  %80 = icmp ne i8* %77, null
  %spec.select1 = select i1 %79, i1 %80, i1 false
  br i1 %spec.select1, label %.lr.ph5, label %.loopexit

.lr.ph5:                                          ; preds = %75
  br label %81

; <label>:81:                                     ; preds = %.lr.ph5, %90
  %.013 = phi i8* [ %77, %.lr.ph5 ], [ %96, %90 ]
  %indvars.iv2 = phi i64 [ 0, %.lr.ph5 ], [ %indvars.iv.next, %90 ]
  %82 = call i64 @strlen(i8* %.013) #10
  %83 = icmp ugt i64 %82, 2
  br i1 %83, label %..loopexit_crit_edge8, label %84

; <label>:84:                                     ; preds = %81
  %85 = call i64 @strlen(i8* %.013) #10
  %86 = icmp eq i64 %85, 0
  br i1 %86, label %..loopexit_crit_edge10, label %87

; <label>:87:                                     ; preds = %84
  %88 = call i32 (i8*, i8*, ...) @sscanf(i8* %.013, i8* %78, i32* %4) #9
  %89 = icmp eq i32 %88, 0
  br i1 %89, label %..loopexit_crit_edge6, label %90

; <label>:90:                                     ; preds = %87
  %91 = load i32, i32* %4, align 4
  %92 = trunc i32 %91 to i8
  %93 = load i8*, i8** %0, align 8
  %94 = getelementptr inbounds i8, i8* %93, i64 %indvars.iv2
  store i8 %92, i8* %94, align 1
  %95 = getelementptr [2 x i8], [2 x i8]* @.str.71, i32 0, i32 0
  %96 = call i8* @strsep(i8** %3, i8* %95) #9
  %indvars.iv.next = add nuw i64 %indvars.iv2, 1
  call void @unroll_loop(i32 115)
  %97 = icmp slt i64 %indvars.iv.next, %6
  %98 = icmp ne i8* %96, null
  %spec.select = select i1 %97, i1 %98, i1 false
  br i1 %spec.select, label %81, label %..loopexit_crit_edge

..loopexit_crit_edge:                             ; preds = %90
  %split = phi i32 [ 0, %90 ]
  br label %.loopexit

..loopexit_crit_edge6:                            ; preds = %87
  %split7 = phi i32 [ 1, %87 ]
  br label %.loopexit

..loopexit_crit_edge8:                            ; preds = %81
  %split9 = phi i32 [ 1, %81 ]
  br label %.loopexit

..loopexit_crit_edge10:                           ; preds = %84
  %split11 = phi i32 [ 1, %84 ]
  br label %.loopexit

.loopexit:                                        ; preds = %..loopexit_crit_edge10, %..loopexit_crit_edge8, %..loopexit_crit_edge6, %..loopexit_crit_edge, %75
  %.02 = phi i32 [ %split11, %..loopexit_crit_edge10 ], [ %split9, %..loopexit_crit_edge8 ], [ %split7, %..loopexit_crit_edge6 ], [ %split, %..loopexit_crit_edge ], [ 0, %75 ]
  %99 = icmp ne i32 %.02, 0
  br i1 %99, label %.backedge, label %157

; <label>:100:                                    ; preds = %.lr.ph
  %101 = load i8*, i8** %0, align 8
  %102 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 22
  %103 = load %struct._IO_FILE*, %struct._IO_FILE** %102, align 8
  %104 = call i8* @fgets(i8* %101, i32 %1, %struct._IO_FILE* %103), !track !209
  %105 = icmp eq i8* %104, null
  br i1 %105, label %106, label %121

; <label>:106:                                    ; preds = %100
  %107 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 27
  %108 = load i32, i32* %107, align 4
  %109 = icmp ne i32 %108, 0
  br i1 %109, label %110, label %113

; <label>:110:                                    ; preds = %106
  %111 = getelementptr [9 x i8], [9 x i8]* @.str.36, i32 0, i32 0
  %112 = call i32 (i8*, ...) @printf(i8* %111)
  br label %113

; <label>:113:                                    ; preds = %110, %106
  %114 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 23
  %115 = load i32, i32* %114, align 8
  %116 = add nsw i32 %115, 1
  %117 = call i32 @next_dict(i32 %116)
  %118 = icmp ne i32 %117, 0
  br i1 %118, label %119, label %.backedge

; <label>:119:                                    ; preds = %113
  %120 = load i8*, i8** %3, align 8
  call void @free(i8* %120) #9
  store i8* null, i8** %3, align 8
  br label %159

; <label>:121:                                    ; preds = %100
  %122 = load i8*, i8** %0, align 8
  %123 = call i64 @strlen(i8* %122) #10
  %124 = trunc i64 %123 to i32
  %125 = icmp sle i32 %124, 2
  br i1 %125, label %.backedge, label %126

; <label>:126:                                    ; preds = %121
  %127 = load i8*, i8** %0, align 8
  %128 = sub nsw i32 %124, 1
  %129 = sext i32 %128 to i64
  %130 = getelementptr inbounds i8, i8* %127, i64 %129
  %131 = load i8, i8* %130, align 1
  %132 = sext i8 %131 to i32
  %133 = icmp eq i32 %132, 10
  br i1 %133, label %134, label %139

; <label>:134:                                    ; preds = %126
  %135 = load i8*, i8** %0, align 8
  %136 = add nsw i32 %124, -1
  %137 = sext i32 %136 to i64
  %138 = getelementptr inbounds i8, i8* %135, i64 %137
  store i8 0, i8* %138, align 1
  br label %139

; <label>:139:                                    ; preds = %134, %126
  %.3 = phi i32 [ %136, %134 ], [ %124, %126 ]
  %140 = load i8*, i8** %0, align 8
  %141 = sub nsw i32 %.3, 1
  %142 = sext i32 %141 to i64
  %143 = getelementptr inbounds i8, i8* %140, i64 %142
  %144 = load i8, i8* %143, align 1
  %145 = sext i8 %144 to i32
  %146 = icmp eq i32 %145, 13
  br i1 %146, label %147, label %152

; <label>:147:                                    ; preds = %139
  %148 = load i8*, i8** %0, align 8
  %149 = add nsw i32 %.3, -1
  %150 = sext i32 %149 to i64
  %151 = getelementptr inbounds i8, i8* %148, i64 %150
  store i8 0, i8* %151, align 1
  br label %152

; <label>:152:                                    ; preds = %147, %139
  %.4 = phi i32 [ %149, %147 ], [ %.3, %139 ]
  %153 = icmp sle i32 %.4, 0
  br i1 %153, label %.backedge, label %157

.backedge:                                        ; preds = %152, %121, %113, %.loopexit, %73, %42, %34
  store i8* %5, i8** %3, align 8
  %154 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 22
  %155 = load %struct._IO_FILE*, %struct._IO_FILE** %154, align 8
  %156 = icmp eq %struct._IO_FILE* %155, null
  br i1 %156, label %._crit_edge.loopexit, label %.lr.ph

; <label>:157:                                    ; preds = %.loopexit, %152
  %158 = load i8*, i8** %3, align 8
  call void @free(i8* %158) #9
  store i8* null, i8** %3, align 8
  br label %159

; <label>:159:                                    ; preds = %157, %119, %40, %._crit_edge
  %.0 = phi i32 [ 1, %._crit_edge ], [ 1, %40 ], [ 0, %157 ], [ 1, %119 ]
  ret i32 %.0
}

; Function Attrs: nounwind
declare dso_local i32 @sscanf(i8*, i8*, ...) #2

; Function Attrs: noinline nounwind uwtable
define dso_local i32 @set_dicts(i8*) #0 {
  %2 = alloca i8*, align 8, !track !210
  store i8* %0, i8** %2, align 8
  %3 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 23
  store i32 0, i32* %3, align 8
  %4 = getelementptr [2 x i8], [2 x i8]* @.str.6, i32 0, i32 0
  %5 = call i8* @strsep(i8** %2, i8* %4) #9
  br label %6

; <label>:6:                                      ; preds = %1, %6
  %indvars.iv = phi i64 [ 0, %1 ], [ %indvars.iv.next, %6 ]
  call void @unroll_loop(i32 116)
  %7 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 21
  %8 = getelementptr inbounds [128 x i8*], [128 x i8*]* %7, i64 0, i64 %indvars.iv
  store i8* null, i8** %8, align 8
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond = icmp ne i64 %indvars.iv.next, 128
  br i1 %exitcond, label %6, label %.preheader

.preheader:                                       ; preds = %6
  %.02.ph = phi i8* [ %5, %6 ]
  call void @unroll_loop(i32 117)
  %9 = icmp ne i8* %.02.ph, null
  %10 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 23
  %11 = load i32, i32* %10, align 8
  %12 = icmp slt i32 %11, 128
  %13 = select i1 %9, i1 %12, i1 false
  br i1 %13, label %.lr.ph, label %74

.lr.ph:                                           ; preds = %.preheader
  br label %14

; <label>:14:                                     ; preds = %.lr.ph, %63
  %.021 = phi i8* [ %.02.ph, %.lr.ph ], [ %65, %63 ]
  %15 = call i64 @strlen(i8* %.021) #10
  %16 = add i64 %15, 1
  %17 = trunc i64 %16 to i32
  %18 = sext i32 %17 to i64
  %19 = mul i64 %18, 1
  %20 = call noalias i8* @malloc(i64 %19) #9, !track !211
  %21 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 23
  %22 = load i32, i32* %21, align 8
  %23 = sext i32 %22 to i64
  %24 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 21
  %25 = getelementptr inbounds [128 x i8*], [128 x i8*]* %24, i64 0, i64 %23
  store i8* %20, i8** %25, align 8
  %26 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 23
  %27 = load i32, i32* %26, align 8
  %28 = sext i32 %27 to i64
  %29 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 21
  %30 = getelementptr inbounds [128 x i8*], [128 x i8*]* %29, i64 0, i64 %28
  %31 = load i8*, i8** %30, align 8
  %32 = icmp eq i8* %31, null
  br i1 %32, label %33, label %35

; <label>:33:                                     ; preds = %14
  %34 = getelementptr [19 x i8], [19 x i8]* @.str.73, i32 0, i32 0
  call void @perror(i8* %34)
  br label %84

; <label>:35:                                     ; preds = %14
  %36 = getelementptr [3 x i8], [3 x i8]* @.str.74, i32 0, i32 0
  %37 = call i32 @strncasecmp(i8* %.021, i8* %36, i64 2) #10
  %38 = icmp eq i32 %37, 0
  %39 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 23
  %40 = load i32, i32* %39, align 8
  %41 = sext i32 %40 to i64
  %42 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 21
  %43 = getelementptr inbounds [128 x i8*], [128 x i8*]* %42, i64 0, i64 %41
  %44 = load i8*, i8** %43, align 8
  br i1 %38, label %45, label %55

; <label>:45:                                     ; preds = %35
  %46 = getelementptr inbounds i8, i8* %.021, i64 2
  %47 = sub nsw i32 %17, 2
  %48 = sext i32 %47 to i64
  %49 = call i8* @strncpy(i8* %44, i8* %46, i64 %48) #9, !track !212
  %50 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 23
  %51 = load i32, i32* %50, align 8
  %52 = sext i32 %51 to i64
  %53 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 25
  %54 = getelementptr inbounds [128 x i32], [128 x i32]* %53, i64 0, i64 %52
  store i32 1, i32* %54, align 4
  br label %63

; <label>:55:                                     ; preds = %35
  %56 = sext i32 %17 to i64
  %57 = call i8* @strncpy(i8* %44, i8* %.021, i64 %56) #9, !track !213
  %58 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 23
  %59 = load i32, i32* %58, align 8
  %60 = sext i32 %59 to i64
  %61 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 25
  %62 = getelementptr inbounds [128 x i32], [128 x i32]* %61, i64 0, i64 %60
  store i32 0, i32* %62, align 4
  br label %63

; <label>:63:                                     ; preds = %55, %45
  %64 = getelementptr [2 x i8], [2 x i8]* @.str.6, i32 0, i32 0
  %65 = call i8* @strsep(i8** %2, i8* %64) #9
  %66 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 23
  %67 = load i32, i32* %66, align 8
  %68 = add nsw i32 %67, 1
  %69 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 23
  store i32 %68, i32* %69, align 8
  call void @unroll_loop(i32 117)
  %70 = icmp ne i8* %65, null
  %71 = load i32, i32* %10, align 8
  %72 = icmp slt i32 %71, 128
  %73 = select i1 %70, i1 %72, i1 false
  br i1 %73, label %14, label %._crit_edge

._crit_edge:                                      ; preds = %63
  br label %74

; <label>:74:                                     ; preds = %._crit_edge, %.preheader
  %75 = call i32 @next_dict(i32 0)
  br label %76

; <label>:76:                                     ; preds = %76, %74
  call void @unroll_loop(i32 118)
  %77 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 23
  %78 = load i32, i32* %77, align 8
  %79 = add nsw i32 %78, 1
  %80 = call i32 @next_dict(i32 %79)
  %81 = icmp eq i32 %80, 0
  br i1 %81, label %76, label %82

; <label>:82:                                     ; preds = %76
  %83 = call i32 @next_dict(i32 0)
  br label %84

; <label>:84:                                     ; preds = %82, %33
  %.0 = phi i32 [ 1, %33 ], [ 0, %82 ]
  ret i32 %.0
}

; Function Attrs: nounwind readonly
declare dso_local i32 @strncasecmp(i8*, i8*, i64) #3

; Function Attrs: noinline nounwind uwtable
define dso_local i32 @crack_wep_dict() #0 {
  %1 = alloca %struct.timeval, align 8
  %2 = alloca %struct.timeval, align 8
  %3 = alloca i8*, align 8, !track !214
  %4 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 10
  %5 = load i32, i32* %4, align 4
  %6 = add nsw i32 %5, 1
  %7 = sext i32 %6 to i64
  %8 = mul i64 1, %7
  %9 = call noalias i8* @malloc(i64 %8) #9, !track !215
  store i8* %9, i8** %3, align 8
  %10 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 10
  %11 = load i32, i32* %10, align 4
  %12 = add nsw i32 %11, 1
  %13 = call i32 @update_ivbuf()
  %14 = getelementptr %struct.WEP_data, %struct.WEP_data* @wep, i32 0, i32 3
  %15 = load i64, i64* %14, align 8
  %16 = icmp slt i64 %15, 4
  br i1 %16, label %17, label %22

; <label>:17:                                     ; preds = %0
  %18 = getelementptr %struct.WEP_data, %struct.WEP_data* @wep, i32 0, i32 3
  %19 = load i64, i64* %18, align 8
  %20 = getelementptr [79 x i8], [79 x i8]* @.str.75, i32 0, i32 0
  %21 = call i32 (i8*, ...) @printf(i8* %20, i64 %19, i32 4)
  br label %._crit_edge11

; <label>:22:                                     ; preds = %0
  %23 = call i32 @gettimeofday(%struct.timeval* %1, %struct.vote* null) #9
  %24 = getelementptr inbounds %struct.timeval, %struct.timeval* %1, i32 0, i32 0
  %25 = load i64, i64* %24, align 8
  %26 = add nsw i64 %25, -1
  store i64 %26, i64* %24, align 8
  %27 = call i32 @next_key(i8** %3, i32 %12)
  %28 = icmp ne i32 %27, 0
  br i1 %28, label %._crit_edge11, label %.lr.ph10.preheader

.lr.ph10.preheader:                               ; preds = %22
  br label %.lr.ph10

; <label>:29:                                     ; preds = %._crit_edge6
  %30 = call i32 @next_key(i8** %3, i32 %12)
  %31 = icmp ne i32 %30, 0
  br i1 %31, label %._crit_edge11.loopexit, label %.lr.ph10

.lr.ph10:                                         ; preds = %.lr.ph10.preheader, %29
  call void @unroll_loop(i32 119)
  %32 = load i8*, i8** %3, align 8
  %33 = call i64 @strlen(i8* %32) #10
  %34 = trunc i64 %33 to i32
  %35 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 10
  %36 = load i32, i32* %35, align 4
  %37 = icmp slt i32 %34, %36
  br i1 %37, label %.lr.ph, label %52

.lr.ph:                                           ; preds = %.lr.ph10
  %38 = sext i32 %34 to i64
  %39 = sext i32 %34 to i64
  br label %40

; <label>:40:                                     ; preds = %.lr.ph, %40
  %indvars.iv = phi i64 [ %38, %.lr.ph ], [ %indvars.iv.next, %40 ]
  call void @unroll_loop(i32 120)
  %41 = load i8*, i8** %3, align 8
  %42 = sub nsw i64 %indvars.iv, %39
  %43 = getelementptr inbounds i8, i8* %41, i64 %42
  %44 = load i8, i8* %43, align 1
  %45 = load i8*, i8** %3, align 8
  %46 = getelementptr inbounds i8, i8* %45, i64 %indvars.iv
  store i8 %44, i8* %46, align 1
  %indvars.iv.next = add nsw i64 %indvars.iv, 1
  %47 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 10
  %48 = load i32, i32* %47, align 4
  %49 = sext i32 %48 to i64
  %50 = icmp slt i64 %indvars.iv.next, %49
  br i1 %50, label %40, label %._crit_edge

._crit_edge:                                      ; preds = %40
  %split.wide = phi i64 [ %indvars.iv.next, %40 ]
  %51 = trunc i64 %split.wide to i32
  br label %52

; <label>:52:                                     ; preds = %._crit_edge, %.lr.ph10
  %.01.lcssa = phi i32 [ %51, %._crit_edge ], [ %34, %.lr.ph10 ]
  %53 = load i8*, i8** %3, align 8
  %54 = sext i32 %.01.lcssa to i64
  %55 = getelementptr inbounds i8, i8* %53, i64 %54
  store i8 0, i8* %55, align 1
  %56 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 6
  %57 = load i32, i32* %56, align 8
  %58 = icmp ne i32 %57, 0
  br i1 %58, label %72, label %59

; <label>:59:                                     ; preds = %52
  %60 = call i32 @gettimeofday(%struct.timeval* %2, %struct.vote* null) #9
  %61 = getelementptr inbounds %struct.timeval, %struct.timeval* %2, i32 0, i32 0
  %62 = load i64, i64* %61, align 8
  %63 = getelementptr inbounds %struct.timeval, %struct.timeval* %1, i32 0, i32 0
  %64 = load i64, i64* %63, align 8
  %65 = sub nsw i64 %62, %64
  %66 = icmp sgt i64 %65, 0
  br i1 %66, label %67, label %72

; <label>:67:                                     ; preds = %59
  %68 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 10
  %69 = load i32, i32* %68, align 4
  %70 = sub nsw i32 %69, 1
  call void @show_wep_stats(i32 %70, i32 1, [256 x %struct.PTW_tableentry]* null, i32* null, i32* null, i32 0)
  %71 = call i32 @gettimeofday(%struct.timeval* %1, %struct.vote* null) #9
  br label %72

; <label>:72:                                     ; preds = %59, %67, %52
  %73 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 10
  %74 = load i32, i32* %73, align 4
  %75 = icmp sle i32 0, %74
  br i1 %75, label %.lr.ph5.preheader, label %._crit_edge6

.lr.ph5.preheader:                                ; preds = %72
  br label %.lr.ph5

.lr.ph5:                                          ; preds = %.lr.ph5.preheader, %.lr.ph5
  %indvars.iv7 = phi i64 [ %indvars.iv.next8, %.lr.ph5 ], [ 0, %.lr.ph5.preheader ]
  call void @unroll_loop(i32 121)
  %76 = load i8*, i8** %3, align 8
  %77 = getelementptr inbounds i8, i8* %76, i64 %indvars.iv7
  %78 = load i8, i8* %77, align 1
  %79 = getelementptr %struct.WEP_data, %struct.WEP_data* @wep, i32 0, i32 0
  %80 = getelementptr inbounds [64 x i8], [64 x i8]* %79, i64 0, i64 %indvars.iv7
  store i8 %78, i8* %80, align 1
  %indvars.iv.next8 = add nuw nsw i64 %indvars.iv7, 1
  %81 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 10
  %82 = load i32, i32* %81, align 4
  %83 = sext i32 %82 to i64
  %84 = icmp sle i64 %indvars.iv.next8, %83
  br i1 %84, label %.lr.ph5, label %._crit_edge6.loopexit

._crit_edge6.loopexit:                            ; preds = %.lr.ph5
  br label %._crit_edge6

._crit_edge6:                                     ; preds = %._crit_edge6.loopexit, %72
  %85 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 10
  %86 = load i32, i32* %85, align 4
  %87 = getelementptr %struct.WEP_data, %struct.WEP_data* @wep, i32 0, i32 0, i32 0
  %88 = call i32 @check_wep_key(i8* %87, i32 %86, i32 0)
  %89 = icmp eq i32 %88, 0
  br i1 %89, label %._crit_edge11.loopexit, label %29

._crit_edge11.loopexit:                           ; preds = %29, %._crit_edge6
  %.0.ph = phi i32 [ 0, %._crit_edge6 ], [ 1, %29 ]
  br label %._crit_edge11

._crit_edge11:                                    ; preds = %._crit_edge11.loopexit, %22, %17
  %.0 = phi i32 [ 1, %17 ], [ 1, %22 ], [ %.0.ph, %._crit_edge11.loopexit ]
  ret i32 %.0
}

; Function Attrs: noinline nounwind uwtable
define dso_local i32 @main(i32, i8**) #0 {
  %3 = call i8* @malloc(i64 40)
  %4 = bitcast i8* %3 to i8**
  store i8** %4, i8*** @__argv_new__
  %5 = load i8**, i8*** @__argv_new__
  %6 = getelementptr i8*, i8** %5, i32 0
  %7 = call i8* @malloc(i64 100)
  store i8* %7, i8** %6
  %8 = load i8*, i8** %6
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %8, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @0, i32 0, i32 0), i64 100, i1 false)
  %9 = getelementptr i8, i8* %8, i32 11
  store i8 0, i8* %9
  %10 = load i8**, i8*** @__argv_new__
  %11 = getelementptr i8*, i8** %10, i32 1
  %12 = call i8* @malloc(i64 100)
  store i8* %12, i8** %11
  %13 = load i8*, i8** %11
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %13, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @1, i32 0, i32 0), i64 100, i1 false)
  %14 = getelementptr i8, i8* %13, i32 2
  store i8 0, i8* %14
  %15 = load i8**, i8*** @__argv_new__
  %16 = getelementptr i8*, i8** %15, i32 2
  %17 = call i8* @malloc(i64 100)
  store i8* %17, i8** %16
  %18 = load i8*, i8** %16
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %18, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @2, i32 0, i32 0), i64 100, i1 false)
  %19 = getelementptr i8, i8* %18, i32 12
  store i8 0, i8* %19
  %20 = load i8**, i8*** @__argv_new__
  %21 = getelementptr i8*, i8** %20, i32 3
  %22 = call i8* @malloc(i64 100)
  store i8* %22, i8** %21
  %23 = load i8*, i8** %21
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %23, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @3, i32 0, i32 0), i64 100, i1 false)
  %24 = getelementptr i8, i8* %23, i32 7
  store i8 0, i8* %24
  %25 = load i8**, i8*** @__argv_new__
  %26 = getelementptr i8*, i8** %25, i32 4
  store i8* null, i8** %26
  %27 = alloca i32, align 4, !track !216
  %28 = alloca [128 x i8], align 16, !track !217
  %29 = alloca [33 x i8], align 16, !track !218
  %30 = alloca i32, align 4
  %31 = call i32 @setsid() #9
  %32 = getelementptr [12 x i8], [12 x i8]* @.str.76, i32 0, i32 0
  %33 = call i8* @getVersion(i8* %32, i32 1, i32 1, i32 0, i32 0, i32 0, i32 0)
  store i8* %33, i8** @progname, align 8
  call void @llvm.memset.p0i8.i64(i8* align 8 bitcast (%struct.options* @opt to i8*), i8 0, i64 2392, i1 false)
  %34 = call i64 @time(i64* null) #9
  %35 = trunc i64 %34 to i32
  call void @srand(i32 %35) #9
  %36 = call i32 (...) bitcast (i32 ()* @get_nb_cpus to i32 (...)*)()
  %37 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 5
  store i32 1, i32* %37, align 4
  %38 = icmp sgt i32 %36, 1
  br i1 %38, label %39, label %41

; <label>:39:                                     ; preds = %2
  %40 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 5
  store i32 %36, i32* %40, align 4
  br label %41

; <label>:41:                                     ; preds = %39, %2
  %42 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 23
  store i32 0, i32* %42, align 8
  %43 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 0
  store i32 0, i32* %43, align 8
  %44 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 17
  store i32 1, i32* %44, align 8
  %45 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 18
  store i32 1, i32* %45, align 4
  %46 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 26
  store i32 0, i32* %46, align 8
  %47 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 29
  store i32 51, i32* %47, align 4
  %48 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 32
  store i32 0, i32* %48, align 4
  %49 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 20
  store i32 1, i32* %49, align 4
  %50 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 33
  store i32 2147483647, i32* %50, align 8
  %51 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 40
  store i32 0, i32* %51, align 8
  %52 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 35
  store i8* null, i8** %52, align 8
  %53 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 36
  store %struct.mergeBSSID* null, %struct.mergeBSSID** %53, align 8
  %54 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 34
  store i8* null, i8** %54, align 8
  %55 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 41
  store i32 0, i32* %55, align 4
  %56 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 42
  store i8* null, i8** %56, align 8
  store i32 0, i32* %30, align 4
  %57 = getelementptr [50 x i8], [50 x i8]* @.str.86, i32 0, i32 0
  %58 = getelementptr [10 x %struct.option], [10 x %struct.option]* @main.long_options, i32 0, i32 0
  %59 = call i32 @getopt_long(i32 4, i8** %25, i8* %57, %struct.option* %58, i32* %30) #9, !track_argc !219
  %60 = icmp slt i32 %59, 0
  br i1 %60, label %._crit_edge142, label %.lr.ph141.preheader

.lr.ph141.preheader:                              ; preds = %41
  br label %.lr.ph141

.lr.ph141:                                        ; preds = %.lr.ph141.preheader, %.loopexit71
  %61 = phi i32 [ %599, %.loopexit71 ], [ %59, %.lr.ph141.preheader ]
  %.026139 = phi i32 [ %.531, %.loopexit71 ], [ 0, %.lr.ph141.preheader ]
  %.033138 = phi i32 [ %.134, %.loopexit71 ], [ 0, %.lr.ph141.preheader ]
  call void @unroll_loop(i32 124)
  switch i32 %61, label %596 [
    i32 58, label %62
    i32 63, label %67
    i32 117, label %72
    i32 86, label %88
    i32 97, label %100
    i32 101, label %133
    i32 98, label %139
    i32 112, label %153
    i32 113, label %174
    i32 99, label %176
    i32 68, label %178
    i32 104, label %180
    i32 116, label %182
    i32 49, label %184
    i32 100, label %186
    i32 109, label %340
    i32 110, label %352
    i32 105, label %391
    i32 102, label %412
    i32 107, label %429
    i32 108, label %456
    i32 77, label %475
    i32 80, label %498
    i32 120, label %519
    i32 88, label %545
    i32 121, label %547
    i32 75, label %549
    i32 115, label %551
    i32 119, label %553
    i32 114, label %562
    i32 48, label %566
    i32 72, label %.loopexit13
    i32 67, label %568
    i32 122, label %585
  ]

; <label>:62:                                     ; preds = %.lr.ph141
  %63 = getelementptr inbounds i8*, i8** %25, i64 0
  %64 = load i8*, i8** %63, align 8
  %65 = getelementptr [23 x i8], [23 x i8]* @.str.87, i32 0, i32 0
  %66 = call i32 (i8*, ...) @printf(i8* %65, i8* %64)
  br label %1507

; <label>:67:                                     ; preds = %.lr.ph141
  %68 = getelementptr inbounds i8*, i8** %25, i64 0
  %69 = load i8*, i8** %68, align 8
  %70 = getelementptr [23 x i8], [23 x i8]* @.str.87, i32 0, i32 0
  %71 = call i32 (i8*, ...) @printf(i8* %70, i8* %69)
  br label %1507

; <label>:72:                                     ; preds = %.lr.ph141
  %73 = getelementptr [21 x i8], [21 x i8]* @.str.88, i32 0, i32 0
  %74 = call i32 (i8*, ...) @printf(i8* %73, i32 %36)
  %75 = call i32 @shasse2_cpuid()
  %76 = icmp eq i32 %75, 1
  br i1 %76, label %77, label %80

; <label>:77:                                     ; preds = %72
  %78 = getelementptr [17 x i8], [17 x i8]* @.str.89, i32 0, i32 0
  %79 = call i32 (i8*, ...) @printf(i8* %78)
  br label %80

; <label>:80:                                     ; preds = %77, %72
  %81 = icmp sge i32 %75, 2
  br i1 %81, label %82, label %85

; <label>:82:                                     ; preds = %80
  %83 = getelementptr [18 x i8], [18 x i8]* @.str.90, i32 0, i32 0
  %84 = call i32 (i8*, ...) @printf(i8* %83)
  br label %85

; <label>:85:                                     ; preds = %82, %80
  %86 = getelementptr [2 x i8], [2 x i8]* @.str.2, i32 0, i32 0
  %87 = call i32 (i8*, ...) @printf(i8* %86)
  br label %1507

; <label>:88:                                     ; preds = %.lr.ph141
  %89 = icmp ne i32 %.033138, 0
  br i1 %89, label %90, label %97

; <label>:90:                                     ; preds = %88
  %91 = getelementptr [47 x i8], [47 x i8]* @.str.91, i32 0, i32 0
  %92 = call i32 (i8*, ...) @printf(i8* %91)
  %93 = getelementptr inbounds i8*, i8** %25, i64 0
  %94 = load i8*, i8** %93, align 8
  %95 = getelementptr [27 x i8], [27 x i8]* @.str.92, i32 0, i32 0
  %96 = call i32 (i8*, ...) @printf(i8* %95, i8* %94)
  br label %1507

; <label>:97:                                     ; preds = %88
  %98 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 40
  store i32 1, i32* %98, align 8
  %99 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 20
  store i32 0, i32* %99, align 4
  br label %.loopexit71

; <label>:100:                                    ; preds = %.lr.ph141
  %101 = load i8*, i8** @optarg, align 8
  %102 = getelementptr [3 x i8], [3 x i8]* @.str.93, i32 0, i32 0
  %103 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 0
  %104 = call i32 (i8*, i8*, ...) @sscanf(i8* %101, i8* %102, i32* %103) #9
  %105 = load i8*, i8** @optarg, align 8
  %106 = getelementptr [4 x i8], [4 x i8]* @.str.94, i32 0, i32 0
  %107 = call i32 @strcasecmp(i8* %105, i8* %106) #10
  %108 = icmp eq i32 %107, 0
  br i1 %108, label %109, label %111

; <label>:109:                                    ; preds = %100
  %110 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 0
  store i32 1, i32* %110, align 8
  br label %118

; <label>:111:                                    ; preds = %100
  %112 = load i8*, i8** @optarg, align 8
  %113 = getelementptr [4 x i8], [4 x i8]* @.str.95, i32 0, i32 0
  %114 = call i32 @strcasecmp(i8* %112, i8* %113) #10
  %115 = icmp eq i32 %114, 0
  br i1 %115, label %116, label %118

; <label>:116:                                    ; preds = %111
  %117 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 0
  store i32 2, i32* %117, align 8
  br label %118

; <label>:118:                                    ; preds = %111, %116, %109
  %119 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 0
  %120 = load i32, i32* %119, align 8
  %121 = icmp ne i32 %120, 1
  br i1 %121, label %122, label %.loopexit71

; <label>:122:                                    ; preds = %118
  %123 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 0
  %124 = load i32, i32* %123, align 8
  %125 = icmp ne i32 %124, 2
  br i1 %125, label %126, label %.loopexit71

; <label>:126:                                    ; preds = %122
  %127 = getelementptr [41 x i8], [41 x i8]* @.str.96, i32 0, i32 0
  %128 = call i32 (i8*, ...) @printf(i8* %127)
  %129 = getelementptr inbounds i8*, i8** %25, i64 0
  %130 = load i8*, i8** %129, align 8
  %131 = getelementptr [23 x i8], [23 x i8]* @.str.87, i32 0, i32 0
  %132 = call i32 (i8*, ...) @printf(i8* %131, i8* %130)
  br label %1507

; <label>:133:                                    ; preds = %.lr.ph141
  %134 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 3, i32 0
  call void @llvm.memset.p0i8.i64(i8* align 4 %134, i8 0, i64 33, i1 false)
  %135 = load i8*, i8** @optarg, align 8
  %136 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 3, i32 0
  %137 = call i8* @strncpy(i8* %136, i8* %135, i64 32) #9, !track !220
  %138 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 1
  store i32 1, i32* %138, align 4
  br label %.loopexit71

; <label>:139:                                    ; preds = %.lr.ph141
  %140 = load i8*, i8** @optarg, align 8
  %141 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 4, i32 0
  %142 = call i32 @getmac(i8* %140, i32 1, i8* %141)
  %143 = icmp ne i32 %142, 0
  br i1 %143, label %144, label %151

; <label>:144:                                    ; preds = %139
  %145 = getelementptr [28 x i8], [28 x i8]* @.str.97, i32 0, i32 0
  %146 = call i32 (i8*, ...) @printf(i8* %145)
  %147 = getelementptr inbounds i8*, i8** %25, i64 0
  %148 = load i8*, i8** %147, align 8
  %149 = getelementptr [23 x i8], [23 x i8]* @.str.87, i32 0, i32 0
  %150 = call i32 (i8*, ...) @printf(i8* %149, i8* %148)
  br label %1507

; <label>:151:                                    ; preds = %139
  %152 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 2
  store i32 1, i32* %152, align 8
  br label %.loopexit71

; <label>:153:                                    ; preds = %.lr.ph141
  %154 = load i8*, i8** @optarg, align 8
  %155 = getelementptr [3 x i8], [3 x i8]* @.str.93, i32 0, i32 0
  %156 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 5
  %157 = call i32 (i8*, i8*, ...) @sscanf(i8* %154, i8* %155, i32* %156) #9
  %158 = icmp ne i32 %157, 1
  br i1 %158, label %167, label %159

; <label>:159:                                    ; preds = %153
  %160 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 5
  %161 = load i32, i32* %160, align 4
  %162 = icmp slt i32 %161, 1
  br i1 %162, label %167, label %163

; <label>:163:                                    ; preds = %159
  %164 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 5
  %165 = load i32, i32* %164, align 4
  %166 = icmp sgt i32 %165, 128
  br i1 %166, label %167, label %.loopexit71

; <label>:167:                                    ; preds = %163, %159, %153
  %168 = getelementptr [47 x i8], [47 x i8]* @.str.98, i32 0, i32 0
  %169 = call i32 (i8*, ...) @printf(i8* %168, i32 %36)
  %170 = getelementptr inbounds i8*, i8** %25, i64 0
  %171 = load i8*, i8** %170, align 8
  %172 = getelementptr [23 x i8], [23 x i8]* @.str.87, i32 0, i32 0
  %173 = call i32 (i8*, ...) @printf(i8* %172, i8* %171)
  br label %1507

; <label>:174:                                    ; preds = %.lr.ph141
  %175 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 6
  store i32 1, i32* %175, align 8
  br label %.loopexit71

; <label>:176:                                    ; preds = %.lr.ph141
  %177 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 15
  store i32 1, i32* %177, align 8
  br label %.loopexit71

; <label>:178:                                    ; preds = %.lr.ph141
  %179 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 38
  store i32 1, i32* %179, align 8
  br label %.loopexit71

; <label>:180:                                    ; preds = %.lr.ph141
  %181 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 14
  store i32 1, i32* %181, align 4
  br label %.loopexit71

; <label>:182:                                    ; preds = %.lr.ph141
  %183 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 16
  store i32 1, i32* %183, align 4
  br label %.loopexit71

; <label>:184:                                    ; preds = %.lr.ph141
  %185 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 41
  store i32 1, i32* %185, align 4
  br label %.loopexit71

; <label>:186:                                    ; preds = %.lr.ph141
  store i32 0, i32* %27, align 4
  %187 = load i8*, i8** @optarg, align 8
  %188 = getelementptr inbounds i8, i8* %187, i64 0
  %189 = load i8, i8* %188, align 1
  %190 = sext i8 %189 to i32
  %191 = icmp ne i32 %190, 0
  br i1 %191, label %.lr.ph136.preheader, label %._crit_edge137

.lr.ph136.preheader:                              ; preds = %186
  br label %.lr.ph136

.lr.ph136:                                        ; preds = %.lr.ph136.preheader, %238
  %.02134 = phi i32 [ %.13, %238 ], [ 0, %.lr.ph136.preheader ]
  call void @unroll_loop(i32 125)
  %192 = sext i32 %.02134 to i64
  %193 = getelementptr inbounds i8, i8* %187, i64 %192
  %194 = load i8, i8* %193, align 1
  %195 = sext i8 %194 to i32
  %196 = icmp eq i32 %195, 120
  br i1 %196, label %197, label %200

; <label>:197:                                    ; preds = %.lr.ph136
  %198 = sext i32 %.02134 to i64
  %199 = getelementptr inbounds i8, i8* %187, i64 %198
  store i8 88, i8* %199, align 1
  br label %200

; <label>:200:                                    ; preds = %197, %.lr.ph136
  %201 = sext i32 %.02134 to i64
  %202 = getelementptr inbounds i8, i8* %187, i64 %201
  %203 = load i8, i8* %202, align 1
  %204 = sext i8 %203 to i32
  %205 = icmp eq i32 %204, 121
  br i1 %205, label %206, label %209

; <label>:206:                                    ; preds = %200
  %207 = sext i32 %.02134 to i64
  %208 = getelementptr inbounds i8, i8* %187, i64 %207
  store i8 89, i8* %208, align 1
  br label %209

; <label>:209:                                    ; preds = %206, %200
  %210 = sext i32 %.02134 to i64
  %211 = getelementptr inbounds i8, i8* %187, i64 %210
  %212 = load i8, i8* %211, align 1
  %213 = sext i8 %212 to i32
  %214 = icmp eq i32 %213, 45
  br i1 %214, label %227, label %215

; <label>:215:                                    ; preds = %209
  %216 = sext i32 %.02134 to i64
  %217 = getelementptr inbounds i8, i8* %187, i64 %216
  %218 = load i8, i8* %217, align 1
  %219 = sext i8 %218 to i32
  %220 = icmp eq i32 %219, 58
  br i1 %220, label %227, label %221

; <label>:221:                                    ; preds = %215
  %222 = sext i32 %.02134 to i64
  %223 = getelementptr inbounds i8, i8* %187, i64 %222
  %224 = load i8, i8* %223, align 1
  %225 = sext i8 %224 to i32
  %226 = icmp eq i32 %225, 32
  br i1 %226, label %227, label %229

; <label>:227:                                    ; preds = %221, %215, %209
  %228 = add nsw i32 %.02134, 1
  br label %238

; <label>:229:                                    ; preds = %221
  %230 = add nsw i32 %.02134, 1
  %231 = sext i32 %.02134 to i64
  %232 = getelementptr inbounds i8, i8* %187, i64 %231
  %233 = load i8, i8* %232, align 1
  %234 = load i32, i32* %27, align 4
  %235 = add nsw i32 %234, 1
  store i32 %235, i32* %27, align 4
  %236 = sext i32 %234 to i64
  %237 = getelementptr inbounds i8, i8* %187, i64 %236
  store i8 %233, i8* %237, align 1
  br label %238

; <label>:238:                                    ; preds = %229, %227
  %.13 = phi i32 [ %228, %227 ], [ %230, %229 ]
  %239 = sext i32 %.13 to i64
  %240 = getelementptr inbounds i8, i8* %187, i64 %239
  %241 = load i8, i8* %240, align 1
  %242 = sext i8 %241 to i32
  %243 = icmp ne i32 %242, 0
  br i1 %243, label %.lr.ph136, label %._crit_edge137.loopexit

._crit_edge137.loopexit:                          ; preds = %238
  br label %._crit_edge137

._crit_edge137:                                   ; preds = %._crit_edge137.loopexit, %186
  %244 = load i32, i32* %27, align 4
  %245 = sext i32 %244 to i64
  %246 = getelementptr inbounds i8, i8* %187, i64 %245
  store i8 0, i8* %246, align 1
  %247 = getelementptr inbounds i8, i8* %187, i64 0
  %248 = load i8, i8* %247, align 1
  %249 = getelementptr inbounds [128 x i8], [128 x i8]* %28, i64 0, i64 0
  store i8 %248, i8* %249, align 16
  %250 = getelementptr inbounds i8, i8* %187, i64 1
  %251 = load i8, i8* %250, align 1
  %252 = getelementptr inbounds [128 x i8], [128 x i8]* %28, i64 0, i64 1
  store i8 %251, i8* %252, align 1
  %253 = getelementptr inbounds [128 x i8], [128 x i8]* %28, i64 0, i64 2
  store i8 0, i8* %253, align 2
  br label %254

; <label>:254:                                    ; preds = %333, %._crit_edge137
  %.127 = phi i32 [ 0, %._crit_edge137 ], [ %.329, %333 ]
  %.025 = phi i8* [ %187, %._crit_edge137 ], [ %334, %333 ]
  %.24 = phi i32 [ 0, %._crit_edge137 ], [ %.46, %333 ]
  call void @unroll_loop(i32 126)
  %255 = getelementptr inbounds [128 x i8], [128 x i8]* %28, i32 0, i32 0
  %256 = getelementptr [3 x i8], [3 x i8]* @.str.72, i32 0, i32 0
  %257 = call i32 (i8*, i8*, ...) @sscanf(i8* %255, i8* %256, i32* %27) #9
  %258 = icmp eq i32 %257, 1
  br i1 %258, label %.critedge, label %259

; <label>:259:                                    ; preds = %254
  %260 = getelementptr inbounds [128 x i8], [128 x i8]* %28, i64 0, i64 0
  %261 = load i8, i8* %260, align 16
  %262 = sext i8 %261 to i32
  %263 = icmp eq i32 %262, 88
  br i1 %263, label %264, label %269

; <label>:264:                                    ; preds = %259
  %265 = getelementptr inbounds [128 x i8], [128 x i8]* %28, i64 0, i64 1
  %266 = load i8, i8* %265, align 1
  %267 = sext i8 %266 to i32
  %268 = icmp eq i32 %267, 88
  br i1 %268, label %.critedge, label %269

; <label>:269:                                    ; preds = %264, %259
  %270 = getelementptr inbounds [128 x i8], [128 x i8]* %28, i64 0, i64 0
  %271 = load i8, i8* %270, align 16
  %272 = sext i8 %271 to i32
  %273 = icmp eq i32 %272, 89
  %274 = getelementptr inbounds [128 x i8], [128 x i8]* %28, i64 0, i64 1
  %275 = load i8, i8* %274, align 1
  %276 = sext i8 %275 to i32
  %277 = icmp eq i32 %276, 89
  %278 = select i1 %273, i1 %277, i1 false
  br i1 %278, label %.critedge, label %.loopexit71.loopexit

.critedge:                                        ; preds = %254, %264, %269
  %279 = getelementptr inbounds [128 x i8], [128 x i8]* %28, i64 0, i64 0
  %280 = load i8, i8* %279, align 16
  %281 = sext i8 %280 to i32
  %282 = icmp eq i32 %281, 88
  br i1 %282, label %283, label %293

; <label>:283:                                    ; preds = %.critedge
  %284 = getelementptr inbounds [128 x i8], [128 x i8]* %28, i64 0, i64 1
  %285 = load i8, i8* %284, align 1
  %286 = sext i8 %285 to i32
  %287 = icmp eq i32 %286, 88
  br i1 %287, label %288, label %293

; <label>:288:                                    ; preds = %283
  %289 = add nsw i32 %.24, 1
  %290 = sext i32 %.24 to i64
  %291 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 8
  %292 = getelementptr inbounds [64 x i32], [64 x i32]* %291, i64 0, i64 %290
  store i32 0, i32* %292, align 4
  br label %331

; <label>:293:                                    ; preds = %283, %.critedge
  %294 = getelementptr inbounds [128 x i8], [128 x i8]* %28, i64 0, i64 0
  %295 = load i8, i8* %294, align 16
  %296 = sext i8 %295 to i32
  %297 = icmp eq i32 %296, 89
  br i1 %297, label %298, label %309

; <label>:298:                                    ; preds = %293
  %299 = getelementptr inbounds [128 x i8], [128 x i8]* %28, i64 0, i64 1
  %300 = load i8, i8* %299, align 1
  %301 = sext i8 %300 to i32
  %302 = icmp eq i32 %301, 89
  br i1 %302, label %303, label %309

; <label>:303:                                    ; preds = %298
  %304 = add nsw i32 %.24, 1
  %305 = add nsw i32 %.127, 1
  %306 = sext i32 %.127 to i64
  %307 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 31
  %308 = getelementptr inbounds [64 x i32], [64 x i32]* %307, i64 0, i64 %306
  store i32 %.24, i32* %308, align 4
  br label %331

; <label>:309:                                    ; preds = %298, %293
  %310 = load i32, i32* %27, align 4
  %311 = icmp slt i32 %310, 0
  %312 = load i32, i32* %27, align 4
  %313 = icmp sgt i32 %312, 255
  %or.cond = or i1 %311, %313
  br i1 %or.cond, label %314, label %321

; <label>:314:                                    ; preds = %309
  %315 = getelementptr [20 x i8], [20 x i8]* @.str.99, i32 0, i32 0
  %316 = call i32 (i8*, ...) @printf(i8* %315)
  %317 = getelementptr inbounds i8*, i8** %25, i64 0
  %318 = load i8*, i8** %317, align 8
  %319 = getelementptr [23 x i8], [23 x i8]* @.str.87, i32 0, i32 0
  %320 = call i32 (i8*, ...) @printf(i8* %319, i8* %318)
  br label %1507

; <label>:321:                                    ; preds = %309
  %322 = load i32, i32* %27, align 4
  %323 = trunc i32 %322 to i8
  %324 = sext i32 %.24 to i64
  %325 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 7
  %326 = getelementptr inbounds [64 x i8], [64 x i8]* %325, i64 0, i64 %324
  store i8 %323, i8* %326, align 1
  %327 = add nsw i32 %.24, 1
  %328 = sext i32 %.24 to i64
  %329 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 8
  %330 = getelementptr inbounds [64 x i32], [64 x i32]* %329, i64 0, i64 %328
  store i32 1, i32* %330, align 4
  br label %331

; <label>:331:                                    ; preds = %303, %321, %288
  %.329 = phi i32 [ %.127, %288 ], [ %305, %303 ], [ %.127, %321 ]
  %.46 = phi i32 [ %289, %288 ], [ %304, %303 ], [ %327, %321 ]
  %332 = icmp sge i32 %.46, 64
  br i1 %332, label %.loopexit71.loopexit, label %333

; <label>:333:                                    ; preds = %331
  %334 = getelementptr inbounds i8, i8* %.025, i64 2
  %335 = load i8, i8* %334, align 1
  %336 = getelementptr inbounds [128 x i8], [128 x i8]* %28, i64 0, i64 0
  store i8 %335, i8* %336, align 16
  %337 = getelementptr inbounds i8, i8* %334, i64 1
  %338 = load i8, i8* %337, align 1
  %339 = getelementptr inbounds [128 x i8], [128 x i8]* %28, i64 0, i64 1
  store i8 %338, i8* %339, align 1
  br label %254

; <label>:340:                                    ; preds = %.lr.ph141
  %341 = load i8*, i8** @optarg, align 8
  %342 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 9, i32 0
  %343 = call i32 @getmac(i8* %341, i32 1, i8* %342)
  %344 = icmp ne i32 %343, 0
  br i1 %344, label %345, label %.loopexit71

; <label>:345:                                    ; preds = %340
  %346 = getelementptr [29 x i8], [29 x i8]* @.str.100, i32 0, i32 0
  %347 = call i32 (i8*, ...) @printf(i8* %346)
  %348 = getelementptr inbounds i8*, i8** %25, i64 0
  %349 = load i8*, i8** %348, align 8
  %350 = getelementptr [23 x i8], [23 x i8]* @.str.87, i32 0, i32 0
  %351 = call i32 (i8*, ...) @printf(i8* %350, i8* %349)
  br label %1507

; <label>:352:                                    ; preds = %.lr.ph141
  %353 = load i8*, i8** @optarg, align 8
  %354 = getelementptr [3 x i8], [3 x i8]* @.str.93, i32 0, i32 0
  %355 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 10
  %356 = call i32 (i8*, i8*, ...) @sscanf(i8* %353, i8* %354, i32* %355) #9
  %357 = icmp ne i32 %356, 1
  br i1 %357, label %378, label %358

; <label>:358:                                    ; preds = %352
  %359 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 10
  %360 = load i32, i32* %359, align 4
  %361 = icmp ne i32 %360, 64
  br i1 %361, label %362, label %385

; <label>:362:                                    ; preds = %358
  %363 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 10
  %364 = load i32, i32* %363, align 4
  %365 = icmp ne i32 %364, 128
  br i1 %365, label %366, label %385

; <label>:366:                                    ; preds = %362
  %367 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 10
  %368 = load i32, i32* %367, align 4
  %369 = icmp ne i32 %368, 152
  br i1 %369, label %370, label %385

; <label>:370:                                    ; preds = %366
  %371 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 10
  %372 = load i32, i32* %371, align 4
  %373 = icmp ne i32 %372, 256
  br i1 %373, label %374, label %385

; <label>:374:                                    ; preds = %370
  %375 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 10
  %376 = load i32, i32* %375, align 4
  %377 = icmp ne i32 %376, 512
  br i1 %377, label %378, label %385

; <label>:378:                                    ; preds = %374, %352
  %379 = getelementptr [46 x i8], [46 x i8]* @.str.101, i32 0, i32 0
  %380 = call i32 (i8*, ...) @printf(i8* %379)
  %381 = getelementptr inbounds i8*, i8** %25, i64 0
  %382 = load i8*, i8** %381, align 8
  %383 = getelementptr [23 x i8], [23 x i8]* @.str.87, i32 0, i32 0
  %384 = call i32 (i8*, ...) @printf(i8* %383, i8* %382)
  br label %1507

; <label>:385:                                    ; preds = %374, %370, %366, %362, %358
  %386 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 10
  %387 = load i32, i32* %386, align 4
  %388 = sdiv i32 %387, 8
  %389 = sub nsw i32 %388, 3
  %390 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 10
  store i32 %389, i32* %390, align 4
  br label %.loopexit71

; <label>:391:                                    ; preds = %.lr.ph141
  %392 = load i8*, i8** @optarg, align 8
  %393 = getelementptr [3 x i8], [3 x i8]* @.str.93, i32 0, i32 0
  %394 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 11
  %395 = call i32 (i8*, i8*, ...) @sscanf(i8* %392, i8* %393, i32* %394) #9
  %396 = icmp ne i32 %395, 1
  br i1 %396, label %405, label %397

; <label>:397:                                    ; preds = %391
  %398 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 11
  %399 = load i32, i32* %398, align 8
  %400 = icmp slt i32 %399, 1
  br i1 %400, label %405, label %401

; <label>:401:                                    ; preds = %397
  %402 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 11
  %403 = load i32, i32* %402, align 8
  %404 = icmp sgt i32 %403, 4
  br i1 %404, label %405, label %.loopexit71

; <label>:405:                                    ; preds = %401, %397, %391
  %406 = getelementptr [30 x i8], [30 x i8]* @.str.102, i32 0, i32 0
  %407 = call i32 (i8*, ...) @printf(i8* %406)
  %408 = getelementptr inbounds i8*, i8** %25, i64 0
  %409 = load i8*, i8** %408, align 8
  %410 = getelementptr [23 x i8], [23 x i8]* @.str.87, i32 0, i32 0
  %411 = call i32 (i8*, ...) @printf(i8* %410, i8* %409)
  br label %1507

; <label>:412:                                    ; preds = %.lr.ph141
  %413 = load i8*, i8** @optarg, align 8
  %414 = getelementptr [3 x i8], [3 x i8]* @.str.103, i32 0, i32 0
  %415 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 12
  %416 = call i32 (i8*, i8*, ...) @sscanf(i8* %413, i8* %414, float* %415) #9
  %417 = icmp ne i32 %416, 1
  br i1 %417, label %422, label %418

; <label>:418:                                    ; preds = %412
  %419 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 12
  %420 = load float, float* %419, align 4
  %421 = fcmp olt float %420, 1.000000e+00
  br i1 %421, label %422, label %.loopexit71

; <label>:422:                                    ; preds = %418, %412
  %423 = getelementptr [29 x i8], [29 x i8]* @.str.104, i32 0, i32 0
  %424 = call i32 (i8*, ...) @printf(i8* %423)
  %425 = getelementptr inbounds i8*, i8** %25, i64 0
  %426 = load i8*, i8** %425, align 8
  %427 = getelementptr [23 x i8], [23 x i8]* @.str.87, i32 0, i32 0
  %428 = call i32 (i8*, ...) @printf(i8* %427, i8* %426)
  br label %1507

; <label>:429:                                    ; preds = %.lr.ph141
  %430 = load i8*, i8** @optarg, align 8
  %431 = getelementptr [3 x i8], [3 x i8]* @.str.93, i32 0, i32 0
  %432 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 13
  %433 = call i32 (i8*, i8*, ...) @sscanf(i8* %430, i8* %431, i32* %432) #9
  %434 = icmp ne i32 %433, 1
  br i1 %434, label %443, label %435

; <label>:435:                                    ; preds = %429
  %436 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 13
  %437 = load i32, i32* %436, align 8
  %438 = icmp slt i32 %437, 1
  br i1 %438, label %443, label %439

; <label>:439:                                    ; preds = %435
  %440 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 13
  %441 = load i32, i32* %440, align 8
  %442 = icmp sgt i32 %441, 17
  br i1 %442, label %443, label %450

; <label>:443:                                    ; preds = %439, %435, %429
  %444 = getelementptr [39 x i8], [39 x i8]* @.str.105, i32 0, i32 0
  %445 = call i32 (i8*, ...) @printf(i8* %444, i32 17)
  %446 = getelementptr inbounds i8*, i8** %25, i64 0
  %447 = load i8*, i8** %446, align 8
  %448 = getelementptr [23 x i8], [23 x i8]* @.str.87, i32 0, i32 0
  %449 = call i32 (i8*, ...) @printf(i8* %448, i8* %447)
  br label %1507

; <label>:450:                                    ; preds = %439
  %451 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 13
  %452 = load i32, i32* %451, align 8
  %453 = sub nsw i32 %452, 1
  %454 = sext i32 %453 to i64
  %455 = getelementptr inbounds [17 x i32], [17 x i32]* @K_COEFF, i64 0, i64 %454
  store i32 0, i32* %455, align 4
  br label %.loopexit71

; <label>:456:                                    ; preds = %.lr.ph141
  %457 = load i8*, i8** @optarg, align 8
  %458 = call i64 @strlen(i8* %457) #10
  %459 = add i64 %458, 1
  %460 = call noalias i8* @calloc(i64 1, i64 %459) #9, !track !221
  %461 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 42
  store i8* %460, i8** %461, align 8
  %462 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 42
  %463 = load i8*, i8** %462, align 8
  %464 = icmp eq i8* %463, null
  br i1 %464, label %465, label %468

; <label>:465:                                    ; preds = %456
  %466 = getelementptr [25 x i8], [25 x i8]* @.str.106, i32 0, i32 0
  %467 = call i32 (i8*, ...) @printf(i8* %466)
  br label %1507

; <label>:468:                                    ; preds = %456
  %469 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 42
  %470 = load i8*, i8** %469, align 8
  %471 = load i8*, i8** @optarg, align 8
  %472 = load i8*, i8** @optarg, align 8
  %473 = call i64 @strlen(i8* %472) #10
  %474 = call i8* @strncpy(i8* %470, i8* %471, i64 %473) #9, !track !222
  br label %.loopexit71

; <label>:475:                                    ; preds = %.lr.ph141
  %476 = load i8*, i8** @optarg, align 8
  %477 = getelementptr [3 x i8], [3 x i8]* @.str.93, i32 0, i32 0
  %478 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 33
  %479 = call i32 (i8*, i8*, ...) @sscanf(i8* %476, i8* %477, i32* %478) #9
  %480 = icmp ne i32 %479, 1
  br i1 %480, label %485, label %481

; <label>:481:                                    ; preds = %475
  %482 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 33
  %483 = load i32, i32* %482, align 8
  %484 = icmp slt i32 %483, 1
  br i1 %484, label %485, label %492

; <label>:485:                                    ; preds = %481, %475
  %486 = getelementptr [33 x i8], [33 x i8]* @.str.107, i32 0, i32 0
  %487 = call i32 (i8*, ...) @printf(i8* %486)
  %488 = getelementptr inbounds i8*, i8** %25, i64 0
  %489 = load i8*, i8** %488, align 8
  %490 = getelementptr [23 x i8], [23 x i8]* @.str.87, i32 0, i32 0
  %491 = call i32 (i8*, ...) @printf(i8* %490, i8* %489)
  br label %1507

; <label>:492:                                    ; preds = %481
  %493 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 13
  %494 = load i32, i32* %493, align 8
  %495 = sub nsw i32 %494, 1
  %496 = sext i32 %495 to i64
  %497 = getelementptr inbounds [17 x i32], [17 x i32]* @K_COEFF, i64 0, i64 %496
  store i32 0, i32* %497, align 4
  br label %.loopexit71

; <label>:498:                                    ; preds = %.lr.ph141
  %499 = load i8*, i8** @optarg, align 8
  %500 = getelementptr [3 x i8], [3 x i8]* @.str.93, i32 0, i32 0
  %501 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 39
  %502 = call i32 (i8*, i8*, ...) @sscanf(i8* %499, i8* %500, i32* %501) #9
  %503 = icmp ne i32 %502, 1
  br i1 %503, label %512, label %504

; <label>:504:                                    ; preds = %498
  %505 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 39
  %506 = load i32, i32* %505, align 4
  %507 = icmp slt i32 %506, 0
  br i1 %507, label %512, label %508

; <label>:508:                                    ; preds = %504
  %509 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 39
  %510 = load i32, i32* %509, align 4
  %511 = icmp sgt i32 %510, 2
  br i1 %511, label %512, label %.loopexit71

; <label>:512:                                    ; preds = %508, %504, %498
  %513 = getelementptr [36 x i8], [36 x i8]* @.str.108, i32 0, i32 0
  %514 = call i32 (i8*, ...) @printf(i8* %513)
  %515 = getelementptr inbounds i8*, i8** %25, i64 0
  %516 = load i8*, i8** %515, align 8
  %517 = getelementptr [23 x i8], [23 x i8]* @.str.87, i32 0, i32 0
  %518 = call i32 (i8*, ...) @printf(i8* %517, i8* %516)
  br label %1507

; <label>:519:                                    ; preds = %.lr.ph141
  %520 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 17
  store i32 0, i32* %520, align 8
  %521 = load i8*, i8** @optarg, align 8
  %522 = icmp ne i8* %521, null
  br i1 %522, label %523, label %.loopexit71

; <label>:523:                                    ; preds = %519
  %524 = load i8*, i8** @optarg, align 8
  %525 = getelementptr [3 x i8], [3 x i8]* @.str.93, i32 0, i32 0
  %526 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 17
  %527 = call i32 (i8*, i8*, ...) @sscanf(i8* %524, i8* %525, i32* %526) #9
  %528 = icmp ne i32 %527, 1
  br i1 %528, label %537, label %529

; <label>:529:                                    ; preds = %523
  %530 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 17
  %531 = load i32, i32* %530, align 8
  %532 = icmp slt i32 %531, 0
  br i1 %532, label %537, label %533

; <label>:533:                                    ; preds = %529
  %534 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 17
  %535 = load i32, i32* %534, align 8
  %536 = icmp sgt i32 %535, 4
  br i1 %536, label %537, label %.loopexit71

; <label>:537:                                    ; preds = %533, %529, %523
  %538 = load i8*, i8** @optarg, align 8
  %539 = getelementptr [28 x i8], [28 x i8]* @.str.109, i32 0, i32 0
  %540 = call i32 (i8*, ...) @printf(i8* %539, i8* %538)
  %541 = getelementptr inbounds i8*, i8** %25, i64 0
  %542 = load i8*, i8** %541, align 8
  %543 = getelementptr [23 x i8], [23 x i8]* @.str.87, i32 0, i32 0
  %544 = call i32 (i8*, ...) @printf(i8* %543, i8* %542)
  br label %1507

; <label>:545:                                    ; preds = %.lr.ph141
  %546 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 18
  store i32 0, i32* %546, align 4
  br label %.loopexit71

; <label>:547:                                    ; preds = %.lr.ph141
  %548 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 19
  store i32 1, i32* %548, align 8
  br label %.loopexit71

; <label>:549:                                    ; preds = %.lr.ph141
  %550 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 20
  store i32 0, i32* %550, align 4
  br label %.loopexit71

; <label>:551:                                    ; preds = %.lr.ph141
  %552 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 26
  store i32 1, i32* %552, align 8
  br label %.loopexit71

; <label>:553:                                    ; preds = %.lr.ph141
  %554 = load i8*, i8** @optarg, align 8
  %555 = call i32 @set_dicts(i8* %554)
  %556 = icmp ne i32 %555, 0
  br i1 %556, label %557, label %.loopexit71

; <label>:557:                                    ; preds = %553
  %558 = getelementptr inbounds i8*, i8** %25, i64 0
  %559 = load i8*, i8** %558, align 8
  %560 = getelementptr [23 x i8], [23 x i8]* @.str.87, i32 0, i32 0
  %561 = call i32 (i8*, ...) @printf(i8* %560, i8* %559)
  br label %1507

; <label>:562:                                    ; preds = %.lr.ph141
  %563 = load %struct._IO_FILE*, %struct._IO_FILE** @stderr, align 8
  %564 = getelementptr [56 x i8], [56 x i8]* @.str.110, i32 0, i32 0
  %565 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %563, i8* %564)
  br label %1507

; <label>:566:                                    ; preds = %.lr.ph141
  %567 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 27
  store i32 1, i32* %567, align 4
  br label %.loopexit71

; <label>:568:                                    ; preds = %.lr.ph141
  %569 = load i8*, i8** @optarg, align 8
  %570 = call i32 @checkbssids(i8* %569)
  %571 = icmp slt i32 %570, 1
  br i1 %571, label %572, label %577

; <label>:572:                                    ; preds = %568
  %573 = getelementptr inbounds i8*, i8** %25, i64 0
  %574 = load i8*, i8** %573, align 8
  %575 = getelementptr [44 x i8], [44 x i8]* @.str.111, i32 0, i32 0
  %576 = call i32 (i8*, ...) @printf(i8* %575, i8* %574)
  br label %1507

; <label>:577:                                    ; preds = %568
  %578 = icmp eq i32 %570, 1
  br i1 %578, label %579, label %582

; <label>:579:                                    ; preds = %577
  %580 = getelementptr [50 x i8], [50 x i8]* @.str.112, i32 0, i32 0
  %581 = call i32 (i8*, ...) @printf(i8* %580)
  br label %.loopexit71

; <label>:582:                                    ; preds = %577
  %583 = load i8*, i8** @optarg, align 8
  %584 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 34
  store i8* %583, i8** %584, align 8
  br label %.loopexit71

; <label>:585:                                    ; preds = %.lr.ph141
  %586 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 40
  %587 = load i32, i32* %586, align 8
  %588 = icmp ne i32 %587, 0
  br i1 %588, label %589, label %.loopexit71

; <label>:589:                                    ; preds = %585
  %590 = getelementptr [47 x i8], [47 x i8]* @.str.91, i32 0, i32 0
  %591 = call i32 (i8*, ...) @printf(i8* %590)
  %592 = getelementptr inbounds i8*, i8** %25, i64 0
  %593 = load i8*, i8** %592, align 8
  %594 = getelementptr [27 x i8], [27 x i8]* @.str.92, i32 0, i32 0
  %595 = call i32 (i8*, ...) @printf(i8* %594, i8* %593)
  br label %1507

; <label>:596:                                    ; preds = %.lr.ph141
  br label %606

.loopexit71.loopexit:                             ; preds = %269, %331
  %.531.ph = phi i32 [ %.127, %269 ], [ %.329, %331 ]
  br label %.loopexit71

.loopexit71:                                      ; preds = %.loopexit71.loopexit, %585, %579, %582, %553, %519, %533, %508, %418, %401, %340, %163, %118, %122, %566, %551, %549, %547, %545, %492, %468, %450, %385, %184, %182, %180, %178, %176, %174, %151, %133, %97
  %.134 = phi i32 [ %.033138, %566 ], [ %.033138, %551 ], [ %.033138, %549 ], [ %.033138, %547 ], [ %.033138, %545 ], [ %.033138, %492 ], [ %.033138, %468 ], [ %.033138, %450 ], [ %.033138, %385 ], [ %.033138, %184 ], [ %.033138, %182 ], [ %.033138, %180 ], [ %.033138, %178 ], [ %.033138, %176 ], [ %.033138, %174 ], [ %.033138, %151 ], [ %.033138, %133 ], [ %.033138, %97 ], [ %.033138, %122 ], [ %.033138, %118 ], [ %.033138, %163 ], [ %.033138, %340 ], [ %.033138, %401 ], [ %.033138, %418 ], [ %.033138, %508 ], [ %.033138, %533 ], [ %.033138, %519 ], [ %.033138, %553 ], [ %.033138, %582 ], [ %.033138, %579 ], [ 1, %585 ], [ %.033138, %.loopexit71.loopexit ]
  %.531 = phi i32 [ %.026139, %566 ], [ %.026139, %551 ], [ %.026139, %549 ], [ %.026139, %547 ], [ %.026139, %545 ], [ %.026139, %492 ], [ %.026139, %468 ], [ %.026139, %450 ], [ %.026139, %385 ], [ %.026139, %184 ], [ %.026139, %182 ], [ %.026139, %180 ], [ %.026139, %178 ], [ %.026139, %176 ], [ %.026139, %174 ], [ %.026139, %151 ], [ %.026139, %133 ], [ %.026139, %97 ], [ %.026139, %122 ], [ %.026139, %118 ], [ %.026139, %163 ], [ %.026139, %340 ], [ %.026139, %401 ], [ %.026139, %418 ], [ %.026139, %508 ], [ %.026139, %533 ], [ %.026139, %519 ], [ %.026139, %553 ], [ %.026139, %582 ], [ %.026139, %579 ], [ %.026139, %585 ], [ %.531.ph, %.loopexit71.loopexit ]
  store i32 0, i32* %30, align 4
  %597 = getelementptr [50 x i8], [50 x i8]* @.str.86, i32 0, i32 0
  %598 = getelementptr [10 x %struct.option], [10 x %struct.option]* @main.long_options, i32 0, i32 0
  %599 = call i32 @getopt_long(i32 4, i8** %25, i8* %597, %struct.option* %598, i32* %30) #9, !track_argc !219
  %600 = icmp slt i32 %599, 0
  br i1 %600, label %._crit_edge142.loopexit, label %.lr.ph141

._crit_edge142.loopexit:                          ; preds = %.loopexit71
  %.026.lcssa.ph = phi i32 [ %.531, %.loopexit71 ]
  br label %._crit_edge142

._crit_edge142:                                   ; preds = %._crit_edge142.loopexit, %41
  %.026.lcssa = phi i32 [ 0, %41 ], [ %.026.lcssa.ph, %._crit_edge142.loopexit ]
  %601 = load i32, i32* @optind, align 4
  %602 = sub nsw i32 4, %601, !track_argc !219
  %603 = icmp slt i32 %602, 1
  br i1 %603, label %604, label %632

; <label>:604:                                    ; preds = %._crit_edge142
  %605 = icmp eq i32 4, 1, !track_argc !219
  br i1 %605, label %606, label %618

.loopexit13:                                      ; preds = %.lr.ph141
  %.036.ph = phi i32 [ 1, %.lr.ph141 ]
  br label %606

; <label>:606:                                    ; preds = %.loopexit13, %604, %596
  %.036 = phi i32 [ 0, %596 ], [ 0, %604 ], [ %.036.ph, %.loopexit13 ]
  %607 = load i8*, i8** @progname, align 8
  %608 = icmp sgt i32 %36, 1
  %609 = icmp eq i32 %36, -1
  %spec.select = select i1 %608, i1 true, i1 %609
  %610 = zext i1 %spec.select to i64
  %611 = getelementptr [58 x i8], [58 x i8]* @.str.113, i32 0, i32 0
  %612 = getelementptr [2 x i8], [2 x i8]* @.str.2, i32 0, i32 0
  %613 = select i1 %spec.select, i8* %611, i8* %612
  %614 = getelementptr [1799 x i8], [1799 x i8]* @usage, i32 0, i32 0
  %615 = call i32 (i8*, ...) @printf(i8* %614, i8* %607, i8* %613)
  %616 = icmp eq i32 %.036, 1
  br i1 %616, label %617, label %618

; <label>:617:                                    ; preds = %606
  call void @exit(i32 0) #11
  unreachable

; <label>:618:                                    ; preds = %606, %604
  %619 = load i32, i32* @optind, align 4
  %620 = sub nsw i32 4, %619, !track_argc !219
  %621 = icmp eq i32 %620, 0
  br i1 %621, label %622, label %625

; <label>:622:                                    ; preds = %618
  %623 = getelementptr [29 x i8], [29 x i8]* @.str.114, i32 0, i32 0
  %624 = call i32 (i8*, ...) @printf(i8* %623)
  br label %625

; <label>:625:                                    ; preds = %622, %618
  %626 = icmp sgt i32 4, 1, !track_argc !219
  br i1 %626, label %627, label %1507

; <label>:627:                                    ; preds = %625
  %628 = getelementptr inbounds i8*, i8** %25, i64 0
  %629 = load i8*, i8** %628, align 8
  %630 = getelementptr [23 x i8], [23 x i8]* @.str.87, i32 0, i32 0
  %631 = call i32 (i8*, ...) @printf(i8* %630, i8* %629)
  br label %1507

; <label>:632:                                    ; preds = %._crit_edge142
  %633 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 0
  %634 = load i32, i32* %633, align 8
  %635 = icmp eq i32 %634, 2
  br i1 %635, label %636, label %643

; <label>:636:                                    ; preds = %632
  %637 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 22
  %638 = load %struct._IO_FILE*, %struct._IO_FILE** %637, align 8
  %639 = icmp eq %struct._IO_FILE* %638, null
  br i1 %639, label %640, label %643

; <label>:640:                                    ; preds = %1320, %636
  %.011 = phi i32 [ 1, %636 ], [ %.1021, %1320 ]
  %641 = getelementptr [42 x i8], [42 x i8]* @.str.115, i32 0, i32 0
  %642 = call i32 (i8*, ...) @printf(i8* %641)
  br label %1497

; <label>:643:                                    ; preds = %636, %632
  %644 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 1
  %645 = load i32, i32* %644, align 4
  %646 = icmp ne i32 %645, 0
  br i1 %646, label %662, label %647

; <label>:647:                                    ; preds = %643
  %648 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 2
  %649 = load i32, i32* %648, align 8
  %650 = icmp ne i32 %649, 0
  br i1 %650, label %662, label %651

; <label>:651:                                    ; preds = %647
  %652 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 6
  %653 = load i32, i32* %652, align 8
  %654 = icmp ne i32 %653, 0
  br i1 %654, label %659, label %655

; <label>:655:                                    ; preds = %651
  %656 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 24
  %657 = load i32, i32* %656, align 4
  %658 = icmp ne i32 %657, 0
  br i1 %658, label %659, label %662

; <label>:659:                                    ; preds = %655, %651
  %660 = getelementptr [35 x i8], [35 x i8]* @.str.116, i32 0, i32 0
  %661 = call i32 (i8*, ...) @printf(i8* %660)
  br label %1497

; <label>:662:                                    ; preds = %655, %647, %643
  %663 = call void (i32)* @signal(i32 2, void (i32)* @sighandler) #9
  %664 = call void (i32)* @signal(i32 3, void (i32)* @sighandler) #9
  %665 = call void (i32)* @signal(i32 15, void (i32)* @sighandler) #9
  %666 = call void (i32)* @signal(i32 14, void (i32)* inttoptr (i64 1 to void (i32)*)) #9
  %667 = call i32 @pthread_mutex_init(%union.pthread_mutex_t* @mx_apl, %union.pthread_mutexattr_t* null) #9
  %668 = call i32 @pthread_mutex_init(%union.pthread_mutex_t* @mx_ivb, %union.pthread_mutexattr_t* null) #9
  %669 = call i32 @pthread_mutex_init(%union.pthread_mutex_t* @mx_eof, %union.pthread_mutexattr_t* null) #9
  %670 = call i32 @pthread_cond_init(%union.pthread_cond_t* @cv_eof, %union.pthread_mutexattr_t* null) #9
  store %struct.AP_info* null, %struct.AP_info** @ap_1st, align 8
  %671 = load i32, i32* @optind, align 4
  %672 = load i32, i32* @optind, align 4
  %673 = sub nsw i32 4, %672, !track_argc !219
  store i32 %673, i32* %27, align 4
  store i32 0, i32* @id, align 4
  %674 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 2
  %675 = load i32, i32* %674, align 8
  %676 = icmp ne i32 %675, 0
  br i1 %676, label %921, label %.preheader12

.preheader12:                                     ; preds = %662
  br label %677

; <label>:677:                                    ; preds = %.preheader12, %712
  call void @unroll_loop(i32 127)
  %678 = load i32, i32* @optind, align 4
  %679 = sext i32 %678 to i64
  %680 = getelementptr inbounds i8*, i8** %25, i64 %679
  %681 = load i8*, i8** %680, align 8
  %682 = getelementptr [2 x i8], [2 x i8]* @.str.10, i32 0, i32 0
  %683 = call i32 @strcmp(i8* %681, i8* %682) #10
  %684 = icmp eq i32 %683, 0
  br i1 %684, label %685, label %687

; <label>:685:                                    ; preds = %677
  %686 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 24
  store i32 1, i32* %686, align 4
  br label %687

; <label>:687:                                    ; preds = %685, %677
  %688 = load i32, i32* @id, align 4
  %689 = sext i32 %688 to i64
  %690 = getelementptr inbounds [128 x i64], [128 x i64]* @tid, i64 0, i64 %689
  %691 = load i32, i32* @optind, align 4
  %692 = sext i32 %691 to i64
  %693 = getelementptr inbounds i8*, i8** %25, i64 %692
  %694 = load i8*, i8** %693, align 8
  %695 = call i32 @pthread_create(i64* %690, %union.pthread_attr_t* null, i8* (i8*)* bitcast (void (i8*)* @check_thread to i8* (i8*)*), i8* %694) #9
  %696 = icmp ne i32 %695, 0
  br i1 %696, label %697, label %699

; <label>:697:                                    ; preds = %687
  %698 = getelementptr [22 x i8], [22 x i8]* @.str.117, i32 0, i32 0
  call void @perror(i8* %698)
  br label %1497

; <label>:699:                                    ; preds = %687
  %700 = call i32 @usleep(i32 131071)
  %701 = load i32, i32* @id, align 4
  %702 = add nsw i32 %701, 1
  store i32 %702, i32* @id, align 4
  %703 = load i32, i32* @id, align 4
  %704 = icmp sge i32 %703, 128
  br i1 %704, label %705, label %712

; <label>:705:                                    ; preds = %699
  %706 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 6
  %707 = load i32, i32* %706, align 8
  %708 = icmp ne i32 %707, 0
  br i1 %708, label %.loopexit70, label %709

; <label>:709:                                    ; preds = %705
  %710 = getelementptr [51 x i8], [51 x i8]* @.str.118, i32 0, i32 0
  %711 = call i32 (i8*, ...) @printf(i8* %710, i32 128)
  br label %.loopexit70

; <label>:712:                                    ; preds = %699
  %713 = load i32, i32* @optind, align 4
  %714 = add nsw i32 %713, 1
  store i32 %714, i32* @optind, align 4
  %715 = icmp slt i32 %714, 4, !track_argc !219
  br i1 %715, label %677, label %.loopexit70.loopexit

.loopexit70.loopexit:                             ; preds = %712
  br label %.loopexit70

.loopexit70:                                      ; preds = %.loopexit70.loopexit, %705, %709
  %716 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 6
  %717 = load i32, i32* %716, align 8
  %718 = icmp ne i32 %717, 0
  br i1 %718, label %724, label %719

; <label>:719:                                    ; preds = %.loopexit70
  %720 = getelementptr [33 x i8], [33 x i8]* @.str.119, i32 0, i32 0
  %721 = call i32 (i8*, ...) @printf(i8* %720)
  %722 = load %struct._IO_FILE*, %struct._IO_FILE** @stdout, align 8
  %723 = call i32 @fflush(%struct._IO_FILE* %722)
  br label %724

; <label>:724:                                    ; preds = %719, %.loopexit70
  store i32 1, i32* @intr_read, align 4
  %725 = load i32, i32* @id, align 4
  %726 = icmp slt i32 0, %725
  br i1 %726, label %.lr.ph130.preheader, label %._crit_edge131

.lr.ph130.preheader:                              ; preds = %724
  br label %.lr.ph130

.lr.ph130:                                        ; preds = %.lr.ph130.preheader, %.lr.ph130
  %indvars.iv132 = phi i64 [ %indvars.iv.next133, %.lr.ph130 ], [ 0, %.lr.ph130.preheader ]
  call void @unroll_loop(i32 128)
  %727 = getelementptr inbounds [128 x i64], [128 x i64]* @tid, i64 0, i64 %indvars.iv132
  %728 = load i64, i64* %727, align 8
  %729 = call i32 @pthread_join(i64 %728, i8** null)
  %indvars.iv.next133 = add nuw nsw i64 %indvars.iv132, 1
  %730 = load i32, i32* @id, align 4
  %731 = sext i32 %730 to i64
  %732 = icmp slt i64 %indvars.iv.next133, %731
  br i1 %732, label %.lr.ph130, label %._crit_edge131.loopexit

._crit_edge131.loopexit:                          ; preds = %.lr.ph130
  br label %._crit_edge131

._crit_edge131:                                   ; preds = %._crit_edge131.loopexit, %724
  store i32 0, i32* @id, align 4
  %733 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 6
  %734 = load i32, i32* %733, align 8
  %735 = icmp ne i32 %734, 0
  br i1 %735, label %744, label %736

; <label>:736:                                    ; preds = %._crit_edge131
  %737 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 24
  %738 = load i32, i32* %737, align 4
  %739 = icmp ne i32 %738, 0
  br i1 %739, label %744, label %740

; <label>:740:                                    ; preds = %736
  %741 = load i64, i64* @nb_pkt, align 8
  %742 = getelementptr [23 x i8], [23 x i8]* @.str.120, i32 0, i32 0
  %743 = call i32 (i8*, ...) @printf(i8* %742, i64 %741)
  br label %744

; <label>:744:                                    ; preds = %740, %736, %._crit_edge131
  %745 = load %struct.AP_info*, %struct.AP_info** @ap_1st, align 8
  %746 = icmp eq %struct.AP_info* %745, null
  br i1 %746, label %747, label %750

; <label>:747:                                    ; preds = %744
  %748 = getelementptr [29 x i8], [29 x i8]* @.str.121, i32 0, i32 0
  %749 = call i32 (i8*, ...) @printf(i8* %748)
  br label %1497

; <label>:750:                                    ; preds = %744
  %751 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 1
  %752 = load i32, i32* %751, align 4
  %753 = icmp ne i32 %752, 0
  br i1 %753, label %920, label %754

; <label>:754:                                    ; preds = %750
  %755 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 2
  %756 = load i32, i32* %755, align 8
  %757 = icmp ne i32 %756, 0
  br i1 %757, label %920, label %758

; <label>:758:                                    ; preds = %754
  %759 = getelementptr [37 x i8], [37 x i8]* @.str.122, i32 0, i32 0
  %760 = getelementptr [1 x i8], [1 x i8]* @.str.123, i32 0, i32 0
  %761 = call i32 (i8*, ...) @printf(i8* %759, i8* %760, i8* %760)
  %762 = load %struct.AP_info*, %struct.AP_info** @ap_1st, align 8
  %763 = icmp ne %struct.AP_info* %762, null
  br i1 %763, label %.lr.ph125.preheader, label %._crit_edge126

.lr.ph125.preheader:                              ; preds = %758
  br label %.lr.ph125

.lr.ph125:                                        ; preds = %.lr.ph125.preheader, %861
  %.01123 = phi %struct.AP_info* [ %864, %861 ], [ %762, %.lr.ph125.preheader ]
  %.68122 = phi i32 [ %862, %861 ], [ 1, %.lr.ph125.preheader ]
  call void @unroll_loop(i32 129)
  %764 = getelementptr inbounds [33 x i8], [33 x i8]* %29, i32 0, i32 0
  call void @llvm.memset.p0i8.i64(i8* align 16 %764, i8 0, i64 33, i1 false)
  %765 = getelementptr inbounds [33 x i8], [33 x i8]* %29, i32 0, i32 0
  %766 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.01123, i32 0, i32 2
  %767 = getelementptr inbounds [33 x i8], [33 x i8]* %766, i32 0, i32 0
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 16 %765, i8* align 2 %767, i64 32, i1 false), !track !223
  br label %768

; <label>:768:                                    ; preds = %.lr.ph125, %785
  %indvars.iv120 = phi i64 [ 0, %.lr.ph125 ], [ %indvars.iv.next121, %785 ]
  call void @unroll_loop(i32 130)
  %769 = getelementptr inbounds [33 x i8], [33 x i8]* %29, i64 0, i64 %indvars.iv120
  %770 = load i8, i8* %769, align 1
  %771 = sext i8 %770 to i32
  %772 = icmp sgt i32 %771, 0
  br i1 %772, label %773, label %778

; <label>:773:                                    ; preds = %768
  %774 = getelementptr inbounds [33 x i8], [33 x i8]* %29, i64 0, i64 %indvars.iv120
  %775 = load i8, i8* %774, align 1
  %776 = sext i8 %775 to i32
  %777 = icmp slt i32 %776, 32
  br i1 %777, label %783, label %778

; <label>:778:                                    ; preds = %773, %768
  %779 = getelementptr inbounds [33 x i8], [33 x i8]* %29, i64 0, i64 %indvars.iv120
  %780 = load i8, i8* %779, align 1
  %781 = sext i8 %780 to i32
  %782 = icmp sgt i32 %781, 126
  br i1 %782, label %783, label %785

; <label>:783:                                    ; preds = %778, %773
  %784 = getelementptr inbounds [33 x i8], [33 x i8]* %29, i64 0, i64 %indvars.iv120
  store i8 63, i8* %784, align 1
  br label %785

; <label>:785:                                    ; preds = %778, %783
  %indvars.iv.next121 = add nuw nsw i64 %indvars.iv120, 1
  %exitcond = icmp ne i64 %indvars.iv.next121, 32
  br i1 %exitcond, label %768, label %786

; <label>:786:                                    ; preds = %785
  %787 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.01123, i32 0, i32 1
  %788 = getelementptr inbounds [6 x i8], [6 x i8]* %787, i64 0, i64 0
  %789 = load i8, i8* %788, align 8
  %790 = zext i8 %789 to i32
  %791 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.01123, i32 0, i32 1
  %792 = getelementptr inbounds [6 x i8], [6 x i8]* %791, i64 0, i64 1
  %793 = load i8, i8* %792, align 1
  %794 = zext i8 %793 to i32
  %795 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.01123, i32 0, i32 1
  %796 = getelementptr inbounds [6 x i8], [6 x i8]* %795, i64 0, i64 2
  %797 = load i8, i8* %796, align 2
  %798 = zext i8 %797 to i32
  %799 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.01123, i32 0, i32 1
  %800 = getelementptr inbounds [6 x i8], [6 x i8]* %799, i64 0, i64 3
  %801 = load i8, i8* %800, align 1
  %802 = zext i8 %801 to i32
  %803 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.01123, i32 0, i32 1
  %804 = getelementptr inbounds [6 x i8], [6 x i8]* %803, i64 0, i64 4
  %805 = load i8, i8* %804, align 4
  %806 = zext i8 %805 to i32
  %807 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.01123, i32 0, i32 1
  %808 = getelementptr inbounds [6 x i8], [6 x i8]* %807, i64 0, i64 5
  %809 = load i8, i8* %808, align 1
  %810 = zext i8 %809 to i32
  %811 = getelementptr inbounds [33 x i8], [33 x i8]* %29, i32 0, i32 0
  %812 = getelementptr [44 x i8], [44 x i8]* @.str.124, i32 0, i32 0
  %813 = call i32 (i8*, ...) @printf(i8* %812, i32 %.68122, i32 %790, i32 %794, i32 %798, i32 %802, i32 %806, i32 %810, i8* %811)
  %814 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.01123, i32 0, i32 11
  %815 = load i32, i32* %814, align 4
  %816 = icmp ne i32 %815, 0
  br i1 %816, label %817, label %820

; <label>:817:                                    ; preds = %786
  %818 = getelementptr [7 x i8], [7 x i8]* @.str.125, i32 0, i32 0
  %819 = call i32 (i8*, ...) @printf(i8* %818)
  br label %820

; <label>:820:                                    ; preds = %817, %786
  %821 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.01123, i32 0, i32 10
  %822 = load i32, i32* %821, align 8
  switch i32 %822, label %858 [
    i32 0, label %823
    i32 1, label %842
    i32 2, label %845
    i32 3, label %850
  ]

; <label>:823:                                    ; preds = %820
  %824 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.01123, i32 0, i32 3
  %825 = getelementptr inbounds [4 x i8], [4 x i8]* %824, i64 0, i64 0
  %826 = load i8, i8* %825, align 1
  %827 = zext i8 %826 to i32
  %828 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.01123, i32 0, i32 3
  %829 = getelementptr inbounds [4 x i8], [4 x i8]* %828, i64 0, i64 1
  %830 = load i8, i8* %829, align 1
  %831 = zext i8 %830 to i32
  %832 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.01123, i32 0, i32 3
  %833 = getelementptr inbounds [4 x i8], [4 x i8]* %832, i64 0, i64 2
  %834 = load i8, i8* %833, align 1
  %835 = zext i8 %834 to i32
  %836 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.01123, i32 0, i32 3
  %837 = getelementptr inbounds [4 x i8], [4 x i8]* %836, i64 0, i64 3
  %838 = load i8, i8* %837, align 1
  %839 = zext i8 %838 to i32
  %840 = getelementptr [20 x i8], [20 x i8]* @.str.126, i32 0, i32 0
  %841 = call i32 (i8*, ...) @printf(i8* %840, i32 %827, i32 %831, i32 %835, i32 %839)
  br label %861

; <label>:842:                                    ; preds = %820
  %843 = getelementptr [22 x i8], [22 x i8]* @.str.127, i32 0, i32 0
  %844 = call i32 (i8*, ...) @printf(i8* %843)
  br label %861

; <label>:845:                                    ; preds = %820
  %846 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.01123, i32 0, i32 7
  %847 = load i64, i64* %846, align 8
  %848 = getelementptr [15 x i8], [15 x i8]* @.str.128, i32 0, i32 0
  %849 = call i32 (i8*, ...) @printf(i8* %848, i64 %847)
  br label %861

; <label>:850:                                    ; preds = %820
  %851 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.01123, i32 0, i32 14
  %852 = getelementptr inbounds %struct.WPA_hdsk, %struct.WPA_hdsk* %851, i32 0, i32 7
  %853 = load i32, i32* %852, align 8
  %854 = icmp eq i32 %853, 7
  %855 = zext i1 %854 to i32
  %856 = getelementptr [20 x i8], [20 x i8]* @.str.129, i32 0, i32 0
  %857 = call i32 (i8*, ...) @printf(i8* %856, i32 %855)
  br label %861

; <label>:858:                                    ; preds = %820
  %859 = getelementptr [9 x i8], [9 x i8]* @.str.130, i32 0, i32 0
  %860 = call i32 (i8*, ...) @printf(i8* %859)
  br label %861

; <label>:861:                                    ; preds = %858, %850, %845, %842, %823
  %862 = add nuw nsw i32 %.68122, 1
  %863 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.01123, i32 0, i32 0
  %864 = load %struct.AP_info*, %struct.AP_info** %863, align 8
  %865 = icmp ne %struct.AP_info* %864, null
  br i1 %865, label %.lr.ph125, label %._crit_edge126.loopexit

._crit_edge126.loopexit:                          ; preds = %861
  %.01.lcssa.ph = phi %struct.AP_info* [ %864, %861 ]
  br label %._crit_edge126

._crit_edge126:                                   ; preds = %._crit_edge126.loopexit, %758
  %.01.lcssa = phi %struct.AP_info* [ %762, %758 ], [ %.01.lcssa.ph, %._crit_edge126.loopexit ]
  %866 = getelementptr [2 x i8], [2 x i8]* @.str.2, i32 0, i32 0
  %867 = call i32 (i8*, ...) @printf(i8* %866)
  %868 = load %struct.AP_info*, %struct.AP_info** @ap_1st, align 8
  %869 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %868, i32 0, i32 0
  %870 = load %struct.AP_info*, %struct.AP_info** %869, align 8
  %871 = icmp ne %struct.AP_info* %870, null
  br i1 %871, label %.preheader10, label %900

.preheader10:                                     ; preds = %._crit_edge126
  br label %872

; <label>:872:                                    ; preds = %.preheader10, %897
  %.1 = phi %struct.AP_info* [ %.3, %897 ], [ %.01.lcssa, %.preheader10 ]
  call void @unroll_loop(i32 131)
  %873 = getelementptr [34 x i8], [34 x i8]* @.str.131, i32 0, i32 0
  %874 = call i32 (i8*, ...) @printf(i8* %873)
  %875 = load %struct._IO_FILE*, %struct._IO_FILE** @stdout, align 8
  %876 = call i32 @fflush(%struct._IO_FILE* %875)
  br label %877

; <label>:877:                                    ; preds = %872, %877
  call void @unroll_loop(i32 132)
  %878 = getelementptr inbounds [128 x i8], [128 x i8]* %28, i32 0, i32 0
  %879 = getelementptr [6 x i8], [6 x i8]* @.str.132, i32 0, i32 0
  %880 = call i32 (i8*, ...) @scanf(i8* %879, i8* %878)
  %881 = icmp ne i32 %880, 0
  %882 = xor i1 %881, true
  br i1 %882, label %877, label %883

; <label>:883:                                    ; preds = %877
  %884 = getelementptr inbounds [128 x i8], [128 x i8]* %28, i32 0, i32 0
  %885 = call i32 @atoi(i8* %884) #10
  %886 = icmp slt i32 %885, 1
  br i1 %886, label %897, label %887

; <label>:887:                                    ; preds = %883
  %888 = load %struct.AP_info*, %struct.AP_info** @ap_1st, align 8
  call void @unroll_loop(i32 133)
  %889 = icmp ne %struct.AP_info* %888, null
  %890 = icmp slt i32 1, %885
  %spec.select317 = select i1 %889, i1 %890, i1 false
  br i1 %spec.select317, label %.lr.ph21, label %.loopexit9

.lr.ph21:                                         ; preds = %887
  br label %891

; <label>:891:                                    ; preds = %.lr.ph21, %891
  %.219 = phi %struct.AP_info* [ %888, %.lr.ph21 ], [ %894, %891 ]
  %.7918 = phi i32 [ 1, %.lr.ph21 ], [ %892, %891 ]
  %892 = add nuw nsw i32 %.7918, 1
  %893 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.219, i32 0, i32 0
  %894 = load %struct.AP_info*, %struct.AP_info** %893, align 8
  call void @unroll_loop(i32 133)
  %895 = icmp ne %struct.AP_info* %894, null
  %896 = icmp slt i32 %892, %885
  %spec.select3 = select i1 %895, i1 %896, i1 false
  br i1 %spec.select3, label %891, label %..loopexit9_crit_edge

..loopexit9_crit_edge:                            ; preds = %891
  %split = phi %struct.AP_info* [ %894, %891 ]
  br label %.loopexit9

.loopexit9:                                       ; preds = %..loopexit9_crit_edge, %887
  %.3.ph = phi %struct.AP_info* [ %split, %..loopexit9_crit_edge ], [ %888, %887 ]
  br label %897

; <label>:897:                                    ; preds = %.loopexit9, %883
  %.3 = phi %struct.AP_info* [ %.1, %883 ], [ %.3.ph, %.loopexit9 ]
  %898 = icmp slt i32 %885, 0
  %899 = icmp eq %struct.AP_info* %.3, null
  %spec.select4 = select i1 %898, i1 true, i1 %899
  br i1 %spec.select4, label %872, label %.loopexit11

; <label>:900:                                    ; preds = %._crit_edge126
  %901 = getelementptr [35 x i8], [35 x i8]* @.str.133, i32 0, i32 0
  %902 = call i32 (i8*, ...) @printf(i8* %901)
  %903 = load %struct.AP_info*, %struct.AP_info** @ap_1st, align 8
  br label %904

.loopexit11:                                      ; preds = %897
  %.4.ph = phi %struct.AP_info* [ %.3, %897 ]
  br label %904

; <label>:904:                                    ; preds = %.loopexit11, %900
  %.4 = phi %struct.AP_info* [ %903, %900 ], [ %.4.ph, %.loopexit11 ]
  %905 = getelementptr [2 x i8], [2 x i8]* @.str.2, i32 0, i32 0
  %906 = call i32 (i8*, ...) @printf(i8* %905)
  %907 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.4, i32 0, i32 1
  %908 = getelementptr inbounds [6 x i8], [6 x i8]* %907, i32 0, i32 0
  %909 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 4, i32 0
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %909, i8* align 8 %908, i64 6, i1 false), !track !224
  %910 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 2
  store i32 1, i32* %910, align 8
  %911 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.4, i32 0, i32 10
  %912 = load i32, i32* %911, align 8
  %913 = icmp eq i32 %912, 2
  br i1 %913, label %914, label %920

; <label>:914:                                    ; preds = %904
  %915 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 22
  %916 = load %struct._IO_FILE*, %struct._IO_FILE** %915, align 8
  %917 = icmp ne %struct._IO_FILE* %916, null
  br i1 %917, label %918, label %920

; <label>:918:                                    ; preds = %914
  %919 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 20
  store i32 0, i32* %919, align 4
  br label %920

; <label>:920:                                    ; preds = %904, %914, %918, %754, %750
  store %struct.AP_info* null, %struct.AP_info** @ap_1st, align 8
  store i32 %671, i32* @optind, align 4
  store i32 0, i32* @id, align 4
  br label %921

; <label>:921:                                    ; preds = %920, %662
  store i32 0, i32* @nb_eof, align 4
  %922 = call void (i32)* @signal(i32 2, void (i32)* @sighandler) #9
  br label %923

; <label>:923:                                    ; preds = %951, %921
  call void @unroll_loop(i32 134)
  %924 = load i32, i32* @optind, align 4
  %925 = sext i32 %924 to i64
  %926 = getelementptr inbounds i8*, i8** %25, i64 %925
  %927 = load i8*, i8** %926, align 8
  %928 = getelementptr [2 x i8], [2 x i8]* @.str.10, i32 0, i32 0
  %929 = call i32 @strcmp(i8* %927, i8* %928) #10
  %930 = icmp eq i32 %929, 0
  br i1 %930, label %931, label %933

; <label>:931:                                    ; preds = %923
  %932 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 24
  store i32 1, i32* %932, align 4
  br label %933

; <label>:933:                                    ; preds = %931, %923
  %934 = load i32, i32* @id, align 4
  %935 = sext i32 %934 to i64
  %936 = getelementptr inbounds [128 x i64], [128 x i64]* @tid, i64 0, i64 %935
  %937 = load i32, i32* @optind, align 4
  %938 = sext i32 %937 to i64
  %939 = getelementptr inbounds i8*, i8** %25, i64 %938
  %940 = load i8*, i8** %939, align 8
  %941 = call i32 @pthread_create(i64* %936, %union.pthread_attr_t* null, i8* (i8*)* bitcast (void (i8*)* @read_thread to i8* (i8*)*), i8* %940) #9
  %942 = icmp ne i32 %941, 0
  br i1 %942, label %943, label %945

; <label>:943:                                    ; preds = %933
  %944 = getelementptr [22 x i8], [22 x i8]* @.str.117, i32 0, i32 0
  call void @perror(i8* %944)
  br label %1497

; <label>:945:                                    ; preds = %933
  %946 = load i32, i32* @id, align 4
  %947 = add nsw i32 %946, 1
  store i32 %947, i32* @id, align 4
  %948 = call i32 @usleep(i32 131071)
  %949 = load i32, i32* @id, align 4
  %950 = icmp sge i32 %949, 128
  br i1 %950, label %.loopexit69, label %951

; <label>:951:                                    ; preds = %945
  %952 = load i32, i32* @optind, align 4
  %953 = add nsw i32 %952, 1
  store i32 %953, i32* @optind, align 4
  %954 = icmp slt i32 %953, 4, !track_argc !219
  br i1 %954, label %923, label %.loopexit69

.loopexit69:                                      ; preds = %951, %945
  store i64 0, i64* @nb_pkt, align 8
  store i32 0, i32* @intr_read, align 4
  %955 = call i32 @pthread_mutex_lock(%union.pthread_mutex_t* @mx_eof) #9
  %956 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 6
  %957 = load i32, i32* %956, align 8
  %958 = icmp ne i32 %957, 0
  br i1 %958, label %964, label %959

; <label>:959:                                    ; preds = %.loopexit69
  %960 = getelementptr [33 x i8], [33 x i8]* @.str.119, i32 0, i32 0
  %961 = call i32 (i8*, ...) @printf(i8* %960)
  %962 = load %struct._IO_FILE*, %struct._IO_FILE** @stdout, align 8
  %963 = call i32 @fflush(%struct._IO_FILE* %962)
  br label %964

; <label>:964:                                    ; preds = %959, %.loopexit69
  call void @unroll_loop(i32 135)
  %965 = load i32, i32* @nb_eof, align 4
  %966 = load i32, i32* %27, align 4
  %967 = icmp slt i32 %965, %966
  br i1 %967, label %.lr.ph15, label %.critedge5

.lr.ph15:                                         ; preds = %964
  br label %968

; <label>:968:                                    ; preds = %.lr.ph15, %972
  %969 = load i32, i32* @intr_read, align 4
  %970 = icmp ne i32 %969, 0
  %971 = xor i1 %970, true
  br i1 %971, label %972, label %..critedge5_crit_edge16

; <label>:972:                                    ; preds = %968
  %973 = call i32 @pthread_cond_wait(%union.pthread_cond_t* @cv_eof, %union.pthread_mutex_t* @mx_eof)
  call void @unroll_loop(i32 135)
  %974 = load i32, i32* @nb_eof, align 4
  %975 = load i32, i32* %27, align 4
  %976 = icmp slt i32 %974, %975
  br i1 %976, label %968, label %..critedge5_crit_edge

..critedge5_crit_edge:                            ; preds = %972
  br label %.critedge5

..critedge5_crit_edge16:                          ; preds = %968
  br label %.critedge5

.critedge5:                                       ; preds = %..critedge5_crit_edge16, %..critedge5_crit_edge, %964
  %977 = call i32 @pthread_mutex_unlock(%union.pthread_mutex_t* @mx_eof) #9
  store i32 1, i32* @intr_read, align 4
  %978 = load %struct.AP_info*, %struct.AP_info** @ap_1st, align 8
  %979 = icmp ne %struct.AP_info* %978, null
  br i1 %979, label %.lr.ph115.preheader, label %._crit_edge116

.lr.ph115.preheader:                              ; preds = %.critedge5
  br label %.lr.ph115

.lr.ph115:                                        ; preds = %.lr.ph115.preheader, %1006
  %.5111 = phi %struct.AP_info* [ %1008, %1006 ], [ %978, %.lr.ph115.preheader ]
  call void @unroll_loop(i32 136)
  %980 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 9, i32 0
  %981 = getelementptr [7 x i8], [7 x i8]* @.str.23, i32 0, i32 0
  %982 = call i32 @memcmp(i8* %980, i8* %981, i64 6) #10
  %983 = icmp eq i32 %982, 0
  br i1 %983, label %1004, label %984

; <label>:984:                                    ; preds = %.lr.ph115
  %985 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 2
  %986 = load i32, i32* %985, align 8
  %987 = icmp ne i32 %986, 0
  br i1 %987, label %988, label %994

; <label>:988:                                    ; preds = %984
  %989 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.5111, i32 0, i32 1
  %990 = getelementptr inbounds [6 x i8], [6 x i8]* %989, i32 0, i32 0
  %991 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 4, i32 0
  %992 = call i32 @memcmp(i8* %991, i8* %990, i64 6) #10
  %993 = icmp ne i32 %992, 0
  br i1 %993, label %994, label %1004

; <label>:994:                                    ; preds = %988, %984
  %995 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 1
  %996 = load i32, i32* %995, align 4
  %997 = icmp ne i32 %996, 0
  br i1 %997, label %998, label %1006

; <label>:998:                                    ; preds = %994
  %999 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.5111, i32 0, i32 2
  %1000 = getelementptr inbounds [33 x i8], [33 x i8]* %999, i32 0, i32 0
  %1001 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 3, i32 0
  %1002 = call i32 @strcmp(i8* %1001, i8* %1000) #10
  %1003 = icmp ne i32 %1002, 0
  br i1 %1003, label %1006, label %1004

; <label>:1004:                                   ; preds = %998, %988, %.lr.ph115
  %1005 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.5111, i32 0, i32 12
  store i32 1, i32* %1005, align 8
  br label %1006

; <label>:1006:                                   ; preds = %1004, %998, %994
  %1007 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.5111, i32 0, i32 0
  %1008 = load %struct.AP_info*, %struct.AP_info** %1007, align 8
  %1009 = icmp ne %struct.AP_info* %1008, null
  br i1 %1009, label %.lr.ph115, label %._crit_edge116.loopexit

._crit_edge116.loopexit:                          ; preds = %1006
  br label %._crit_edge116

._crit_edge116:                                   ; preds = %._crit_edge116.loopexit, %.critedge5
  %1010 = load %struct.AP_info*, %struct.AP_info** @ap_1st, align 8
  %1011 = icmp ne %struct.AP_info* %1010, null
  br i1 %1011, label %.lr.ph109.preheader, label %.loopexit68

.lr.ph109.preheader:                              ; preds = %._crit_edge116
  br label %.lr.ph109

.lr.ph109:                                        ; preds = %.lr.ph109.preheader, %1015
  %.6107 = phi %struct.AP_info* [ %1017, %1015 ], [ %1010, %.lr.ph109.preheader ]
  call void @unroll_loop(i32 137)
  %1012 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.6107, i32 0, i32 12
  %1013 = load i32, i32* %1012, align 8
  %1014 = icmp ne i32 %1013, 0
  br i1 %1014, label %.loopexit68.loopexit, label %1015

; <label>:1015:                                   ; preds = %.lr.ph109
  %1016 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.6107, i32 0, i32 0
  %1017 = load %struct.AP_info*, %struct.AP_info** %1016, align 8
  %1018 = icmp ne %struct.AP_info* %1017, null
  br i1 %1018, label %.lr.ph109, label %.loopexit68.loopexit

.loopexit68.loopexit:                             ; preds = %.lr.ph109, %1015
  %.6.lcssa.ph = phi %struct.AP_info* [ %1017, %1015 ], [ %.6107, %.lr.ph109 ]
  br label %.loopexit68

.loopexit68:                                      ; preds = %.loopexit68.loopexit, %._crit_edge116
  %.6.lcssa = phi %struct.AP_info* [ %1010, %._crit_edge116 ], [ %.6.lcssa.ph, %.loopexit68.loopexit ]
  %1019 = icmp eq %struct.AP_info* %.6.lcssa, null
  br i1 %1019, label %1020, label %1030

; <label>:1020:                                   ; preds = %.loopexit68
  %1021 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 1
  %1022 = load i32, i32* %1021, align 4
  %1023 = icmp ne i32 %1022, 0
  %1024 = zext i1 %1023 to i64
  %1025 = getelementptr [6 x i8], [6 x i8]* @.str.135, i32 0, i32 0
  %1026 = getelementptr [6 x i8], [6 x i8]* @.str.77, i32 0, i32 0
  %1027 = select i1 %1023, i8* %1025, i8* %1026
  %1028 = getelementptr [44 x i8], [44 x i8]* @.str.134, i32 0, i32 0
  %1029 = call i32 (i8*, ...) @printf(i8* %1028, i8* %1027)
  br label %1497

; <label>:1030:                                   ; preds = %.loopexit68
  %1031 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.6.lcssa, i32 0, i32 10
  %1032 = load i32, i32* %1031, align 8
  %1033 = icmp slt i32 %1032, 2
  br i1 %1033, label %1034, label %1043

; <label>:1034:                                   ; preds = %1030
  %1035 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.6.lcssa, i32 0, i32 10
  %1036 = load i32, i32* %1035, align 8
  %cond = icmp eq i32 %1036, 0
  br i1 %cond, label %1037, label %1040

; <label>:1037:                                   ; preds = %1034
  %1038 = getelementptr [40 x i8], [40 x i8]* @.str.136, i32 0, i32 0
  %1039 = call i32 (i8*, ...) @printf(i8* %1038)
  br label %1497

; <label>:1040:                                   ; preds = %1034
  %1041 = getelementptr [42 x i8], [42 x i8]* @.str.137, i32 0, i32 0
  %1042 = call i32 (i8*, ...) @printf(i8* %1041)
  br label %1497

; <label>:1043:                                   ; preds = %1030
  %1044 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 5
  %1045 = load i32, i32* %1044, align 4
  %1046 = icmp slt i32 0, %1045
  br i1 %1046, label %.lr.ph103.preheader, label %._crit_edge104

.lr.ph103.preheader:                              ; preds = %1043
  br label %.lr.ph103

.lr.ph103:                                        ; preds = %.lr.ph103.preheader, %1073
  %indvars.iv105 = phi i64 [ %indvars.iv.next106, %1073 ], [ 0, %.lr.ph103.preheader ]
  call void @unroll_loop(i32 138)
  %1047 = getelementptr inbounds [256 x [2 x i32]], [256 x [2 x i32]]* @mc_pipe, i64 0, i64 %indvars.iv105
  %1048 = getelementptr inbounds [2 x i32], [2 x i32]* %1047, i32 0, i32 0
  %1049 = call i32 @pipe(i32* %1048) #9
  %1050 = getelementptr inbounds [256 x [2 x i32]], [256 x [2 x i32]]* @cm_pipe, i64 0, i64 %indvars.iv105
  %1051 = getelementptr inbounds [2 x i32], [2 x i32]* %1050, i32 0, i32 0
  %1052 = call i32 @pipe(i32* %1051) #9
  %1053 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 0
  %1054 = load i32, i32* %1053, align 8
  %1055 = icmp sle i32 %1054, 1
  br i1 %1055, label %1056, label %1073

; <label>:1056:                                   ; preds = %.lr.ph103
  %1057 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 5
  %1058 = load i32, i32* %1057, align 4
  %1059 = icmp sgt i32 %1058, 1
  br i1 %1059, label %1060, label %1073

; <label>:1060:                                   ; preds = %1056
  %1061 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 17
  %1062 = load i32, i32* %1061, align 8
  %1063 = icmp ne i32 %1062, 0
  br i1 %1063, label %1064, label %1073

; <label>:1064:                                   ; preds = %1060
  %1065 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 18
  %1066 = load i32, i32* %1065, align 4
  %1067 = icmp ne i32 %1066, 0
  br i1 %1067, label %1068, label %1073

; <label>:1068:                                   ; preds = %1064
  %1069 = getelementptr inbounds [256 x [2 x i32]], [256 x [2 x i32]]* @bf_pipe, i64 0, i64 %indvars.iv105
  %1070 = getelementptr inbounds [2 x i32], [2 x i32]* %1069, i32 0, i32 0
  %1071 = call i32 @pipe(i32* %1070) #9
  %1072 = getelementptr inbounds [256 x i32], [256 x i32]* @bf_nkeys, i64 0, i64 %indvars.iv105
  store i32 0, i32* %1072, align 4
  br label %1073

; <label>:1073:                                   ; preds = %.lr.ph103, %1056, %1060, %1064, %1068
  %indvars.iv.next106 = add nuw nsw i64 %indvars.iv105, 1
  %1074 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 5
  %1075 = load i32, i32* %1074, align 4
  %1076 = sext i32 %1075 to i64
  %1077 = icmp slt i64 %indvars.iv.next106, %1076
  br i1 %1077, label %.lr.ph103, label %._crit_edge104.loopexit

._crit_edge104.loopexit:                          ; preds = %1073
  br label %._crit_edge104

._crit_edge104:                                   ; preds = %._crit_edge104.loopexit, %1043
  store i64 0, i64* @nb_tried, align 8
  store i64 0, i64* @nb_kprev, align 8
  %1078 = call float @chrono(%struct.timeval* @t_begin, i32 1)
  %1079 = call float @chrono(%struct.timeval* @t_stats, i32 1)
  %1080 = call float @chrono(%struct.timeval* @t_kprev, i32 1)
  %1081 = call void (i32)* @signal(i32 28, void (i32)* @sighandler) #9
  %1082 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 0
  %1083 = load i32, i32* %1082, align 8
  %1084 = icmp eq i32 %1083, 1
  br i1 %1084, label %1093, label %1085

; <label>:1085:                                   ; preds = %._crit_edge104
  %1086 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 0
  %1087 = load i32, i32* %1086, align 8
  %1088 = icmp eq i32 %1087, 2
  br i1 %1088, label %1320, label %1089

; <label>:1089:                                   ; preds = %1085
  %1090 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.6.lcssa, i32 0, i32 10
  %1091 = load i32, i32* %1090, align 8
  %1092 = icmp eq i32 %1091, 2
  br i1 %1092, label %1093, label %1316

; <label>:1093:                                   ; preds = %1089, %._crit_edge104
  %1094 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 10
  %1095 = load i32, i32* %1094, align 4
  %1096 = icmp eq i32 %1095, 0
  br i1 %1096, label %1097, label %1099

; <label>:1097:                                   ; preds = %1093
  %1098 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 10
  store i32 13, i32* %1098, align 4
  br label %1099

; <label>:1099:                                   ; preds = %1097, %1093
  %1100 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 17
  %1101 = load i32, i32* %1100, align 8
  %1102 = add nsw i32 %.026.lcssa, %1101
  %1103 = icmp sgt i32 %1102, 4
  br i1 %1103, label %1104, label %1107

; <label>:1104:                                   ; preds = %1099
  %1105 = getelementptr [61 x i8], [61 x i8]* @.str.138, i32 0, i32 0
  %1106 = call i32 (i8*, ...) @printf(i8* %1105)
  br label %1497

; <label>:1107:                                   ; preds = %1099
  %1108 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 17
  %1109 = load i32, i32* %1108, align 8
  %1110 = icmp slt i32 0, %1109
  br i1 %1110, label %.lr.ph97, label %._crit_edge98

.lr.ph97:                                         ; preds = %1107
  %1111 = sext i32 %.026.lcssa to i64
  br label %1112

; <label>:1112:                                   ; preds = %.lr.ph97, %1112
  %indvars.iv99 = phi i64 [ 0, %.lr.ph97 ], [ %indvars.iv.next100, %1112 ]
  call void @unroll_loop(i32 139)
  %1113 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 10
  %1114 = load i32, i32* %1113, align 4
  %1115 = sub nsw i32 %1114, 1
  %1116 = trunc i64 %indvars.iv99 to i32
  %1117 = sub nsw i32 %1115, %1116
  %1118 = add nsw i64 %1111, %indvars.iv99
  %1119 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 31
  %1120 = getelementptr inbounds [64 x i32], [64 x i32]* %1119, i64 0, i64 %1118
  store i32 %1117, i32* %1120, align 4
  %indvars.iv.next100 = add nuw nsw i64 %indvars.iv99, 1
  %1121 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 17
  %1122 = load i32, i32* %1121, align 8
  %1123 = sext i32 %1122 to i64
  %1124 = icmp slt i64 %indvars.iv.next100, %1123
  br i1 %1124, label %1112, label %._crit_edge98.loopexit

._crit_edge98.loopexit:                           ; preds = %1112
  br label %._crit_edge98

._crit_edge98:                                    ; preds = %._crit_edge98.loopexit, %1107
  %1125 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 17
  %1126 = load i32, i32* %1125, align 8
  %1127 = add nsw i32 %1126, %.026.lcssa
  %1128 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 17
  store i32 %1127, i32* %1128, align 8
  %1129 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 12
  %1130 = load float, float* %1129, align 4
  %1131 = fcmp oeq float %1130, 0.000000e+00
  br i1 %1131, label %1132, label %1151

; <label>:1132:                                   ; preds = %._crit_edge98
  %1133 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 20
  %1134 = load i32, i32* %1133, align 4
  %1135 = icmp ne i32 %1134, 0
  br i1 %1135, label %1136, label %1138

; <label>:1136:                                   ; preds = %1132
  %1137 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 12
  store float 2.000000e+00, float* %1137, align 4
  br label %1151

; <label>:1138:                                   ; preds = %1132
  %1139 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 19
  %1140 = load i32, i32* %1139, align 8
  %1141 = icmp ne i32 %1140, 0
  br i1 %1141, label %1149, label %1142

; <label>:1142:                                   ; preds = %1138
  %1143 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 10
  %1144 = load i32, i32* %1143, align 4
  %1145 = icmp eq i32 %1144, 5
  %1146 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 12
  br i1 %1145, label %1147, label %1148

; <label>:1147:                                   ; preds = %1142
  store float 5.000000e+00, float* %1146, align 4
  br label %1151

; <label>:1148:                                   ; preds = %1142
  store float 2.000000e+00, float* %1146, align 4
  br label %1151

; <label>:1149:                                   ; preds = %1138
  %1150 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 12
  store float 3.000000e+01, float* %1150, align 4
  br label %1151

; <label>:1151:                                   ; preds = %1136, %1147, %1148, %1149, %._crit_edge98
  %1152 = getelementptr %struct.WEP_data, %struct.WEP_data* @wep, i32 0, i32 0, i32 0
  call void @llvm.memset.p0i8.i64(i8* align 8 %1152, i8 0, i64 131680, i1 false)
  %1153 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 20
  %1154 = load i32, i32* %1153, align 4
  %1155 = icmp ne i32 %1154, 0
  br i1 %1155, label %1156, label %1211

; <label>:1156:                                   ; preds = %1151
  %1157 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 6
  %1158 = load i32, i32* %1157, align 8
  %1159 = icmp ne i32 %1158, 0
  br i1 %1159, label %1163, label %1160

; <label>:1160:                                   ; preds = %1156
  %1161 = getelementptr [49 x i8], [49 x i8]* @.str.139, i32 0, i32 0
  %1162 = call i32 (i8*, ...) @printf(i8* %1161, i32 5000)
  br label %1163

; <label>:1163:                                   ; preds = %1160, %1156
  %1164 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.6.lcssa, i32 0, i32 9
  %1165 = load i64, i64* %1164, align 8
  %1166 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.6.lcssa, i32 0, i32 9
  %1167 = load i64, i64* %1166, align 8
  %1168 = srem i64 %1167, 5000
  %1169 = sub nsw i64 %1165, %1168
  %1170 = trunc i64 %1169 to i32
  %1171 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 32
  store i32 %1170, i32* %1171, align 4
  br label %1172

; <label>:1172:                                   ; preds = %1209, %1163
  %.112 = phi i32 [ 1, %1163 ], [ %.314, %1209 ]
  call void @unroll_loop(i32 140)
  %1173 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.6.lcssa, i32 0, i32 9
  %1174 = load i64, i64* %1173, align 8
  %1175 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 32
  %1176 = load i32, i32* %1175, align 4
  %1177 = sext i32 %1176 to i64
  %1178 = icmp sge i64 %1174, %1177
  br i1 %1178, label %1179, label %1208

; <label>:1179:                                   ; preds = %1172
  %1180 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 6
  %1181 = load i32, i32* %1180, align 8
  %1182 = icmp ne i32 %1181, 0
  br i1 %1182, label %1188, label %1183

; <label>:1183:                                   ; preds = %1179
  %1184 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.6.lcssa, i32 0, i32 9
  %1185 = load i64, i64* %1184, align 8
  %1186 = getelementptr [35 x i8], [35 x i8]* @.str.140, i32 0, i32 0
  %1187 = call i32 (i8*, ...) @printf(i8* %1186, i64 %1185)
  br label %1188

; <label>:1188:                                   ; preds = %1183, %1179
  %1189 = call i32 @crack_wep_ptw(%struct.AP_info* %.6.lcssa)
  %1190 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 41
  %1191 = load i32, i32* %1190, align 4
  %1192 = icmp eq i32 %1191, 1
  %1193 = icmp eq i32 %1189, 1
  %or.cond6 = and i1 %1192, %1193
  br i1 %or.cond6, label %1194, label %1197

; <label>:1194:                                   ; preds = %1188
  %1195 = getelementptr [211 x i8], [211 x i8]* @.str.141, i32 0, i32 0
  %1196 = call i32 (i8*, ...) @printf(i8* %1195)
  br label %1197

; <label>:1197:                                   ; preds = %1194, %1188
  %.213 = phi i32 [ 0, %1194 ], [ %1189, %1188 ]
  %1198 = icmp ne i32 %.213, 0
  br i1 %1198, label %1199, label %1208

; <label>:1199:                                   ; preds = %1197
  %1200 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 32
  %1201 = load i32, i32* %1200, align 4
  %1202 = add nsw i32 %1201, 5000
  %1203 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 32
  store i32 %1202, i32* %1203, align 4
  %1204 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 32
  %1205 = load i32, i32* %1204, align 4
  %1206 = getelementptr [31 x i8], [31 x i8]* @.str.142, i32 0, i32 0
  %1207 = call i32 (i8*, ...) @printf(i8* %1206, i32 %1205)
  br label %1208

; <label>:1208:                                   ; preds = %1197, %1199, %1172
  %.314 = phi i32 [ %.112, %1172 ], [ %.213, %1199 ], [ %.213, %1197 ]
  %cond7 = icmp eq i32 %.314, 0
  br i1 %cond7, label %.loopexit8, label %1209

; <label>:1209:                                   ; preds = %1208
  %1210 = call i32 @usleep(i32 10000)
  br label %1172

; <label>:1211:                                   ; preds = %1151
  %1212 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 22
  %1213 = load %struct._IO_FILE*, %struct._IO_FILE** %1212, align 8
  %1214 = icmp ne %struct._IO_FILE* %1213, null
  br i1 %1214, label %1215, label %1217

; <label>:1215:                                   ; preds = %1211
  %1216 = call i32 @crack_wep_dict()
  br label %1316

; <label>:1217:                                   ; preds = %1211
  %1218 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 5
  %1219 = load i32, i32* %1218, align 4
  %1220 = icmp slt i32 0, %1219
  br i1 %1220, label %.lr.ph91.preheader, label %._crit_edge92

.lr.ph91.preheader:                               ; preds = %1217
  br label %.lr.ph91

.lr.ph91:                                         ; preds = %.lr.ph91.preheader, %1257
  %indvars.iv93 = phi i64 [ %indvars.iv.next94, %1257 ], [ 0, %.lr.ph91.preheader ]
  call void @unroll_loop(i32 141)
  %1221 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 0
  %1222 = load i32, i32* %1221, align 8
  %1223 = icmp sle i32 %1222, 1
  br i1 %1223, label %1224, label %1248

; <label>:1224:                                   ; preds = %.lr.ph91
  %1225 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 5
  %1226 = load i32, i32* %1225, align 4
  %1227 = icmp sgt i32 %1226, 1
  br i1 %1227, label %1228, label %1248

; <label>:1228:                                   ; preds = %1224
  %1229 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 17
  %1230 = load i32, i32* %1229, align 8
  %1231 = icmp ne i32 %1230, 0
  br i1 %1231, label %1232, label %1248

; <label>:1232:                                   ; preds = %1228
  %1233 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 18
  %1234 = load i32, i32* %1233, align 4
  %1235 = icmp ne i32 %1234, 0
  br i1 %1235, label %1236, label %1248

; <label>:1236:                                   ; preds = %1232
  %1237 = load i32, i32* @id, align 4
  %1238 = sext i32 %1237 to i64
  %1239 = getelementptr inbounds [128 x i64], [128 x i64]* @tid, i64 0, i64 %1238
  %1240 = inttoptr i64 %indvars.iv93 to i8*
  %1241 = call i32 @pthread_create(i64* %1239, %union.pthread_attr_t* null, i8* (i8*)* bitcast (i32 (i8*)* @inner_bruteforcer_thread to i8* (i8*)*), i8* %1240) #9
  %1242 = icmp ne i32 %1241, 0
  br i1 %1242, label %1243, label %1245

; <label>:1243:                                   ; preds = %1236
  %1244 = getelementptr [22 x i8], [22 x i8]* @.str.117, i32 0, i32 0
  call void @perror(i8* %1244)
  br label %1497

; <label>:1245:                                   ; preds = %1236
  %1246 = load i32, i32* @id, align 4
  %1247 = add nsw i32 %1246, 1
  store i32 %1247, i32* @id, align 4
  br label %1248

; <label>:1248:                                   ; preds = %1245, %1232, %1228, %1224, %.lr.ph91
  %1249 = load i32, i32* @id, align 4
  %1250 = sext i32 %1249 to i64
  %1251 = getelementptr inbounds [128 x i64], [128 x i64]* @tid, i64 0, i64 %1250
  %1252 = inttoptr i64 %indvars.iv93 to i8*
  %1253 = call i32 @pthread_create(i64* %1251, %union.pthread_attr_t* null, i8* (i8*)* bitcast (i32 (i8*)* @crack_wep_thread to i8* (i8*)*), i8* %1252) #9
  %1254 = icmp ne i32 %1253, 0
  br i1 %1254, label %1255, label %1257

; <label>:1255:                                   ; preds = %1248
  %1256 = getelementptr [22 x i8], [22 x i8]* @.str.117, i32 0, i32 0
  call void @perror(i8* %1256)
  br label %1497

; <label>:1257:                                   ; preds = %1248
  %1258 = load i32, i32* @id, align 4
  %1259 = add nsw i32 %1258, 1
  store i32 %1259, i32* @id, align 4
  %indvars.iv.next94 = add nuw nsw i64 %indvars.iv93, 1
  %1260 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 5
  %1261 = load i32, i32* %1260, align 4
  %1262 = sext i32 %1261 to i64
  %1263 = icmp slt i64 %indvars.iv.next94, %1262
  br i1 %1263, label %.lr.ph91, label %._crit_edge92.loopexit

._crit_edge92.loopexit:                           ; preds = %1257
  br label %._crit_edge92

._crit_edge92:                                    ; preds = %._crit_edge92.loopexit, %1217
  %1264 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 19
  %1265 = load i32, i32* %1264, align 8
  %1266 = icmp ne i32 %1265, 0
  br i1 %1266, label %1284, label %.preheader

.preheader:                                       ; preds = %._crit_edge92
  br label %1267

; <label>:1267:                                   ; preds = %.preheader, %1267
  %1268 = call i32 @do_wep_crack1(i32 0)
  %1269 = icmp eq i32 %1268, 2
  br i1 %1269, label %1267, label %1270

; <label>:1270:                                   ; preds = %1267
  %.lcssa39 = phi i32 [ %1268, %1267 ]
  %1271 = icmp eq i32 %.lcssa39, 1
  br i1 %1271, label %1272, label %1316

; <label>:1272:                                   ; preds = %1270
  %1273 = getelementptr [461 x i8], [461 x i8]* @.str.143, i32 0, i32 0
  %1274 = call i32 (i8*, ...) @printf(i8* %1273)
  %1275 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 19
  %1276 = load i32, i32* %1275, align 8
  %1277 = icmp ne i32 %1276, 0
  br i1 %1277, label %1278, label %1281

; <label>:1278:                                   ; preds = %1272
  %1279 = getelementptr [50 x i8], [50 x i8]* @.str.144, i32 0, i32 0
  %1280 = call i32 (i8*, ...) @printf(i8* %1279)
  br label %1281

; <label>:1281:                                   ; preds = %1278, %1272
  %1282 = getelementptr [2 x i8], [2 x i8]* @.str.2, i32 0, i32 0
  %1283 = call i32 (i8*, ...) @printf(i8* %1282)
  br label %1316

; <label>:1284:                                   ; preds = %._crit_edge92
  %1285 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 10
  %1286 = load i32, i32* %1285, align 4
  %1287 = sub nsw i32 %1286, 3
  %1288 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 10
  %1289 = load i32, i32* %1288, align 4
  %1290 = sub nsw i32 %1289, 2
  %1291 = icmp slt i32 %1287, %1290
  br i1 %1291, label %.lr.ph87.preheader, label %.loopexit67

.lr.ph87.preheader:                               ; preds = %1284
  br label %.lr.ph87

.lr.ph87:                                         ; preds = %.lr.ph87.preheader, %1297
  %.1185 = phi i32 [ %1298, %1297 ], [ %1287, %.lr.ph87.preheader ]
  call void @unroll_loop(i32 142)
  br label %1292

; <label>:1292:                                   ; preds = %1292, %.lr.ph87
  call void @unroll_loop(i32 143)
  %1293 = call i32 @do_wep_crack2(i32 %.1185)
  %1294 = icmp eq i32 %1293, 2
  br i1 %1294, label %1292, label %1295

; <label>:1295:                                   ; preds = %1292
  %.lcssa = phi i32 [ %1293, %1292 ]
  %1296 = icmp eq i32 %.lcssa, 0
  br i1 %1296, label %.loopexit67.loopexit, label %1297

; <label>:1297:                                   ; preds = %1295
  %1298 = add nsw i32 %.1185, 1
  %1299 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 10
  %1300 = load i32, i32* %1299, align 4
  %1301 = sub nsw i32 %1300, 2
  %1302 = icmp slt i32 %1298, %1301
  br i1 %1302, label %.lr.ph87, label %.loopexit67.loopexit

.loopexit67.loopexit:                             ; preds = %1295, %1297
  %.516.ph = phi i32 [ %.lcssa, %1297 ], [ %.lcssa, %1295 ]
  br label %.loopexit67

.loopexit67:                                      ; preds = %.loopexit67.loopexit, %1284
  %.516 = phi i32 [ 1, %1284 ], [ %.516.ph, %.loopexit67.loopexit ]
  %1303 = icmp eq i32 %.516, 1
  br i1 %1303, label %1304, label %1316

; <label>:1304:                                   ; preds = %.loopexit67
  %1305 = getelementptr [461 x i8], [461 x i8]* @.str.143, i32 0, i32 0
  %1306 = call i32 (i8*, ...) @printf(i8* %1305)
  %1307 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 19
  %1308 = load i32, i32* %1307, align 8
  %1309 = icmp ne i32 %1308, 0
  br i1 %1309, label %1310, label %1313

; <label>:1310:                                   ; preds = %1304
  %1311 = getelementptr [56 x i8], [56 x i8]* @.str.145, i32 0, i32 0
  %1312 = call i32 (i8*, ...) @printf(i8* %1311)
  br label %1313

; <label>:1313:                                   ; preds = %1310, %1304
  %1314 = getelementptr [2 x i8], [2 x i8]* @.str.2, i32 0, i32 0
  %1315 = call i32 (i8*, ...) @printf(i8* %1314)
  br label %1316

.loopexit8:                                       ; preds = %1208
  %.920.ph = phi i32 [ %.314, %1208 ]
  br label %1316

; <label>:1316:                                   ; preds = %.loopexit8, %1281, %1270, %1313, %.loopexit67, %1215, %1089
  %.920 = phi i32 [ 1, %1089 ], [ %1216, %1215 ], [ %.lcssa39, %1281 ], [ %.lcssa39, %1270 ], [ %.516, %1313 ], [ %.516, %.loopexit67 ], [ %.920.ph, %.loopexit8 ]
  %1317 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.6.lcssa, i32 0, i32 10
  %1318 = load i32, i32* %1317, align 8
  %1319 = icmp eq i32 %1318, 3
  br i1 %1319, label %1320, label %1497

; <label>:1320:                                   ; preds = %1316, %1085
  %.1021 = phi i32 [ 1, %1085 ], [ %.920, %1316 ]
  %1321 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 22
  %1322 = load %struct._IO_FILE*, %struct._IO_FILE** %1321, align 8
  %1323 = icmp eq %struct._IO_FILE* %1322, null
  br i1 %1323, label %640, label %1324

; <label>:1324:                                   ; preds = %1320
  %1325 = load %struct.AP_info*, %struct.AP_info** @ap_1st, align 8
  %1326 = icmp ne %struct.AP_info* %1325, null
  br i1 %1326, label %.lr.ph84.preheader, label %.loopexit66

.lr.ph84.preheader:                               ; preds = %1324
  br label %.lr.ph84

.lr.ph84:                                         ; preds = %.lr.ph84.preheader, %1335
  %.782 = phi %struct.AP_info* [ %1337, %1335 ], [ %1325, %.lr.ph84.preheader ]
  call void @unroll_loop(i32 144)
  %1327 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.782, i32 0, i32 12
  %1328 = load i32, i32* %1327, align 8
  %1329 = icmp ne i32 %1328, 0
  br i1 %1329, label %1330, label %1335

; <label>:1330:                                   ; preds = %.lr.ph84
  %1331 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.782, i32 0, i32 14
  %1332 = getelementptr inbounds %struct.WPA_hdsk, %struct.WPA_hdsk* %1331, i32 0, i32 7
  %1333 = load i32, i32* %1332, align 8
  %1334 = icmp eq i32 %1333, 7
  br i1 %1334, label %.loopexit66.loopexit, label %1335

; <label>:1335:                                   ; preds = %1330, %.lr.ph84
  %1336 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.782, i32 0, i32 0
  %1337 = load %struct.AP_info*, %struct.AP_info** %1336, align 8
  %1338 = icmp ne %struct.AP_info* %1337, null
  br i1 %1338, label %.lr.ph84, label %.loopexit66.loopexit

.loopexit66.loopexit:                             ; preds = %1330, %1335
  %.7.lcssa.ph = phi %struct.AP_info* [ %1337, %1335 ], [ %.782, %1330 ]
  br label %.loopexit66

.loopexit66:                                      ; preds = %.loopexit66.loopexit, %1324
  %.7.lcssa = phi %struct.AP_info* [ %1325, %1324 ], [ %.7.lcssa.ph, %.loopexit66.loopexit ]
  %1339 = icmp eq %struct.AP_info* %.7.lcssa, null
  br i1 %1339, label %1340, label %1343

; <label>:1340:                                   ; preds = %.loopexit66
  %1341 = getelementptr [32 x i8], [32 x i8]* @.str.146, i32 0, i32 0
  %1342 = call i32 (i8*, ...) @printf(i8* %1341)
  br label %1497

; <label>:1343:                                   ; preds = %.loopexit66
  %1344 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.7.lcssa, i32 0, i32 2
  %1345 = getelementptr inbounds [33 x i8], [33 x i8]* %1344, i32 0, i32 0
  %1346 = getelementptr [32 x i8], [32 x i8]* @ZERO, i32 0, i32 0
  %1347 = call i32 @memcmp(i8* %1345, i8* %1346, i64 32) #10
  %1348 = icmp eq i32 %1347, 0
  br i1 %1348, label %1349, label %1356

; <label>:1349:                                   ; preds = %1343
  %1350 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 1
  %1351 = load i32, i32* %1350, align 4
  %1352 = icmp ne i32 %1351, 0
  br i1 %1352, label %1356, label %1353

; <label>:1353:                                   ; preds = %1349
  %1354 = getelementptr [38 x i8], [38 x i8]* @.str.147, i32 0, i32 0
  %1355 = call i32 (i8*, ...) @printf(i8* %1354)
  br label %1497

; <label>:1356:                                   ; preds = %1349, %1343
  %1357 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 1
  %1358 = load i32, i32* %1357, align 4
  %1359 = icmp ne i32 %1358, 0
  br i1 %1359, label %1360, label %1373

; <label>:1360:                                   ; preds = %1356
  %1361 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.7.lcssa, i32 0, i32 2
  %1362 = getelementptr inbounds [33 x i8], [33 x i8]* %1361, i64 0, i64 0
  %1363 = load i8, i8* %1362, align 2
  %1364 = sext i8 %1363 to i32
  %1365 = icmp eq i32 %1364, 0
  br i1 %1365, label %1366, label %1373

; <label>:1366:                                   ; preds = %1360
  %1367 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.7.lcssa, i32 0, i32 2
  %1368 = getelementptr inbounds [33 x i8], [33 x i8]* %1367, i32 0, i32 0
  call void @llvm.memset.p0i8.i64(i8* align 2 %1368, i8 0, i64 33, i1 false)
  %1369 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %.7.lcssa, i32 0, i32 2
  %1370 = getelementptr inbounds [33 x i8], [33 x i8]* %1369, i32 0, i32 0
  %1371 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 3, i32 0
  %1372 = call i8* @strncpy(i8* %1370, i8* %1371, i64 32) #9, !track !225
  br label %1373

; <label>:1373:                                   ; preds = %1366, %1360, %1356
  %1374 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 5
  %1375 = load i32, i32* %1374, align 4
  %1376 = icmp slt i32 0, %1375
  br i1 %1376, label %.lr.ph78.preheader, label %._crit_edge79

.lr.ph78.preheader:                               ; preds = %1373
  br label %.lr.ph78

.lr.ph78:                                         ; preds = %.lr.ph78.preheader, %1414
  %indvars.iv80 = phi i64 [ %indvars.iv.next81, %1414 ], [ 0, %.lr.ph78.preheader ]
  call void @unroll_loop(i32 145)
  %1377 = getelementptr inbounds [128 x %struct.WPA_data], [128 x %struct.WPA_data]* @wpa_data, i64 0, i64 %indvars.iv80
  %1378 = getelementptr inbounds %struct.WPA_data, %struct.WPA_data* %1377, i32 0, i32 0
  store %struct.AP_info* %.7.lcssa, %struct.AP_info** %1378, align 8
  %1379 = getelementptr inbounds [128 x %struct.WPA_data], [128 x %struct.WPA_data]* @wpa_data, i64 0, i64 %indvars.iv80
  %1380 = getelementptr inbounds %struct.WPA_data, %struct.WPA_data* %1379, i32 0, i32 1
  %1381 = trunc i64 %indvars.iv80 to i32
  store i32 %1381, i32* %1380, align 8
  %1382 = getelementptr inbounds [128 x %struct.WPA_data], [128 x %struct.WPA_data]* @wpa_data, i64 0, i64 %indvars.iv80
  %1383 = getelementptr inbounds %struct.WPA_data, %struct.WPA_data* %1382, i32 0, i32 2
  store i32 17, i32* %1383, align 4
  %1384 = getelementptr inbounds [128 x %struct.WPA_data], [128 x %struct.WPA_data]* @wpa_data, i64 0, i64 %indvars.iv80
  %1385 = getelementptr inbounds %struct.WPA_data, %struct.WPA_data* %1384, i32 0, i32 2
  %1386 = load i32, i32* %1385, align 4
  %1387 = mul nsw i32 %1386, 128
  %1388 = sext i32 %1387 to i64
  %1389 = call noalias i8* @malloc(i64 %1388) #9, !track !226
  %1390 = getelementptr inbounds [128 x %struct.WPA_data], [128 x %struct.WPA_data]* @wpa_data, i64 0, i64 %indvars.iv80
  %1391 = getelementptr inbounds %struct.WPA_data, %struct.WPA_data* %1390, i32 0, i32 3
  store i8* %1389, i8** %1391, align 8
  %1392 = getelementptr inbounds [128 x %struct.WPA_data], [128 x %struct.WPA_data]* @wpa_data, i64 0, i64 %indvars.iv80
  %1393 = getelementptr inbounds %struct.WPA_data, %struct.WPA_data* %1392, i32 0, i32 4
  store i32 0, i32* %1393, align 8
  %1394 = getelementptr inbounds [128 x %struct.WPA_data], [128 x %struct.WPA_data]* @wpa_data, i64 0, i64 %indvars.iv80
  %1395 = getelementptr inbounds %struct.WPA_data, %struct.WPA_data* %1394, i32 0, i32 5
  store i32 0, i32* %1395, align 4
  %1396 = getelementptr inbounds [128 x %struct.WPA_data], [128 x %struct.WPA_data]* @wpa_data, i64 0, i64 %indvars.iv80
  %1397 = getelementptr inbounds %struct.WPA_data, %struct.WPA_data* %1396, i32 0, i32 6
  %1398 = getelementptr inbounds [128 x i8], [128 x i8]* %1397, i32 0, i32 0
  call void @llvm.memset.p0i8.i64(i8* align 8 %1398, i8 0, i64 128, i1 false)
  %1399 = getelementptr inbounds [128 x %struct.WPA_data], [128 x %struct.WPA_data]* @wpa_data, i64 0, i64 %indvars.iv80
  %1400 = getelementptr inbounds %struct.WPA_data, %struct.WPA_data* %1399, i32 0, i32 7
  %1401 = call i32 @pthread_cond_init(%union.pthread_cond_t* %1400, %union.pthread_mutexattr_t* null) #9
  %1402 = getelementptr inbounds [128 x %struct.WPA_data], [128 x %struct.WPA_data]* @wpa_data, i64 0, i64 %indvars.iv80
  %1403 = getelementptr inbounds %struct.WPA_data, %struct.WPA_data* %1402, i32 0, i32 8
  %1404 = call i32 @pthread_mutex_init(%union.pthread_mutex_t* %1403, %union.pthread_mutexattr_t* null) #9
  %1405 = load i32, i32* @id, align 4
  %1406 = sext i32 %1405 to i64
  %1407 = getelementptr inbounds [128 x i64], [128 x i64]* @tid, i64 0, i64 %1406
  %1408 = getelementptr inbounds [128 x %struct.WPA_data], [128 x %struct.WPA_data]* @wpa_data, i64 0, i64 %indvars.iv80
  %1409 = bitcast %struct.WPA_data* %1408 to i8*
  %1410 = call i32 @pthread_create(i64* %1407, %union.pthread_attr_t* null, i8* (i8*)* bitcast (i32 (i8*)* @crack_wpa_thread to i8* (i8*)*), i8* %1409) #9
  %1411 = icmp ne i32 %1410, 0
  br i1 %1411, label %1412, label %1414

; <label>:1412:                                   ; preds = %.lr.ph78
  %1413 = getelementptr [22 x i8], [22 x i8]* @.str.117, i32 0, i32 0
  call void @perror(i8* %1413)
  br label %1497

; <label>:1414:                                   ; preds = %.lr.ph78
  %1415 = load i32, i32* @id, align 4
  %1416 = add nsw i32 %1415, 1
  store i32 %1416, i32* @id, align 4
  %indvars.iv.next81 = add nuw nsw i64 %indvars.iv80, 1
  %1417 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 5
  %1418 = load i32, i32* %1417, align 4
  %1419 = sext i32 %1418 to i64
  %1420 = icmp slt i64 %indvars.iv.next81, %1419
  br i1 %1420, label %.lr.ph78, label %._crit_edge79.loopexit

._crit_edge79.loopexit:                           ; preds = %1414
  br label %._crit_edge79

._crit_edge79:                                    ; preds = %._crit_edge79.loopexit, %1373
  %1421 = call i32 @do_wpa_crack()
  store i32 1, i32* @wpa_wordlists_done, align 4
  %1422 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 5
  %1423 = load i32, i32* %1422, align 4
  %1424 = icmp slt i32 0, %1423
  br i1 %1424, label %.lr.ph75.preheader, label %._crit_edge

.lr.ph75.preheader:                               ; preds = %._crit_edge79
  br label %.lr.ph75

.lr.ph75:                                         ; preds = %.lr.ph75.preheader, %.lr.ph75
  %.131074 = phi i32 [ %1431, %.lr.ph75 ], [ 0, %.lr.ph75.preheader ]
  call void @unroll_loop(i32 146)
  %1425 = load i32, i32* @id, align 4
  %1426 = add nsw i32 %1425, -1
  store i32 %1426, i32* @id, align 4
  %1427 = sext i32 %1426 to i64
  %1428 = getelementptr inbounds [128 x i64], [128 x i64]* @tid, i64 0, i64 %1427
  %1429 = load i64, i64* %1428, align 8
  %1430 = call i32 @pthread_join(i64 %1429, i8** null)
  %1431 = add nuw nsw i32 %.131074, 1
  %1432 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 5
  %1433 = load i32, i32* %1432, align 4
  %1434 = icmp slt i32 %1431, %1433
  br i1 %1434, label %.lr.ph75, label %._crit_edge.loopexit

._crit_edge.loopexit:                             ; preds = %.lr.ph75
  br label %._crit_edge

._crit_edge:                                      ; preds = %._crit_edge.loopexit, %._crit_edge79
  %1435 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 5
  %1436 = load i32, i32* %1435, align 4
  %1437 = icmp slt i32 0, %1436
  br i1 %1437, label %.lr.ph.preheader, label %.loopexit

.lr.ph.preheader:                                 ; preds = %._crit_edge
  br label %.lr.ph

.lr.ph:                                           ; preds = %.lr.ph.preheader, %1446
  %indvars.iv = phi i64 [ %indvars.iv.next, %1446 ], [ 0, %.lr.ph.preheader ]
  call void @unroll_loop(i32 147)
  %1438 = getelementptr inbounds [128 x %struct.WPA_data], [128 x %struct.WPA_data]* @wpa_data, i64 0, i64 %indvars.iv
  %1439 = getelementptr inbounds %struct.WPA_data, %struct.WPA_data* %1438, i32 0, i32 6
  %1440 = getelementptr inbounds [128 x i8], [128 x i8]* %1439, i64 0, i64 0
  %1441 = load i8, i8* %1440, align 8
  %1442 = sext i8 %1441 to i32
  %1443 = icmp ne i32 %1442, 0
  br i1 %1443, label %1444, label %1446

; <label>:1444:                                   ; preds = %.lr.ph
  %.14.lcssa37.wide = phi i64 [ %indvars.iv, %.lr.ph ]
  %1445 = trunc i64 %.14.lcssa37.wide to i32
  br label %.loopexit

; <label>:1446:                                   ; preds = %.lr.ph
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %1447 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 5
  %1448 = load i32, i32* %1447, align 4
  %1449 = sext i32 %1448 to i64
  %1450 = icmp slt i64 %indvars.iv.next, %1449
  br i1 %1450, label %.lr.ph, label %..loopexit_crit_edge

..loopexit_crit_edge:                             ; preds = %1446
  %split.wide = phi i64 [ %indvars.iv.next, %1446 ]
  %split73 = phi i32 [ %1421, %1446 ]
  %1451 = trunc i64 %split.wide to i32
  br label %.loopexit

.loopexit:                                        ; preds = %._crit_edge, %..loopexit_crit_edge, %1444
  %.14.lcssa = phi i32 [ %1445, %1444 ], [ %1451, %..loopexit_crit_edge ], [ 0, %._crit_edge ]
  %.1122 = phi i32 [ 0, %1444 ], [ %split73, %..loopexit_crit_edge ], [ %1421, %._crit_edge ]
  %1452 = icmp eq i32 %.1122, 0
  br i1 %1452, label %1453, label %1492

; <label>:1453:                                   ; preds = %.loopexit
  %1454 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 6
  %1455 = load i32, i32* %1454, align 8
  %1456 = icmp ne i32 %1455, 0
  br i1 %1456, label %1457, label %1464

; <label>:1457:                                   ; preds = %1453
  %1458 = sext i32 %.14.lcssa to i64
  %1459 = getelementptr inbounds [128 x %struct.WPA_data], [128 x %struct.WPA_data]* @wpa_data, i64 0, i64 %1458
  %1460 = getelementptr inbounds %struct.WPA_data, %struct.WPA_data* %1459, i32 0, i32 6
  %1461 = getelementptr inbounds [128 x i8], [128 x i8]* %1460, i32 0, i32 0
  %1462 = getelementptr [19 x i8], [19 x i8]* @.str.148, i32 0, i32 0
  %1463 = call i32 (i8*, ...) @printf(i8* %1462, i8* %1461)
  br label %1507

; <label>:1464:                                   ; preds = %1453
  %1465 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 27
  %1466 = load i32, i32* %1465, align 4
  %1467 = icmp ne i32 %1466, 0
  br i1 %1467, label %1468, label %1471

; <label>:1468:                                   ; preds = %1464
  %1469 = getelementptr [8 x i8], [8 x i8]* @.str.62, i32 0, i32 0
  %1470 = call i32 (i8*, ...) @printf(i8* %1469)
  br label %1471

; <label>:1471:                                   ; preds = %1468, %1464
  %1472 = sext i32 %.14.lcssa to i64
  %1473 = getelementptr inbounds [128 x %struct.WPA_data], [128 x %struct.WPA_data]* @wpa_data, i64 0, i64 %1472
  %1474 = getelementptr inbounds %struct.WPA_data, %struct.WPA_data* %1473, i32 0, i32 6
  %1475 = getelementptr inbounds [128 x i8], [128 x i8]* %1474, i32 0, i32 0
  %1476 = call i64 @strlen(i8* %1475) #10
  %1477 = trunc i64 %1476 to i32
  %1478 = sub nsw i32 65, %1477
  %1479 = sdiv i32 %1478, 2
  %1480 = sext i32 %.14.lcssa to i64
  %1481 = getelementptr inbounds [128 x %struct.WPA_data], [128 x %struct.WPA_data]* @wpa_data, i64 0, i64 %1480
  %1482 = getelementptr inbounds %struct.WPA_data, %struct.WPA_data* %1481, i32 0, i32 6
  %1483 = getelementptr inbounds [128 x i8], [128 x i8]* %1482, i32 0, i32 0
  %1484 = getelementptr [35 x i8], [35 x i8]* @.str.63, i32 0, i32 0
  %1485 = call i32 (i8*, ...) @printf(i8* %1484, i32 %1479, i8* %1483)
  %1486 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 27
  %1487 = load i32, i32* %1486, align 4
  %1488 = icmp ne i32 %1487, 0
  br i1 %1488, label %1489, label %1507

; <label>:1489:                                   ; preds = %1471
  %1490 = getelementptr [9 x i8], [9 x i8]* @.str.36, i32 0, i32 0
  %1491 = call i32 (i8*, ...) @printf(i8* %1490)
  br label %1507

; <label>:1492:                                   ; preds = %.loopexit
  %1493 = getelementptr [32 x i8], [32 x i8]* @.str.149, i32 0, i32 0
  %1494 = call i32 (i8*, ...) @printf(i8* %1493)
  %1495 = getelementptr [2 x i8], [2 x i8]* @.str.2, i32 0, i32 0
  %1496 = call i32 (i8*, ...) @printf(i8* %1495)
  br label %1497

; <label>:1497:                                   ; preds = %1316, %1492, %1037, %1040, %1412, %1353, %1340, %1255, %1243, %1104, %1020, %943, %747, %697, %659, %640
  %.1324 = phi i32 [ %.011, %640 ], [ 1, %943 ], [ 1, %1020 ], [ 1, %1104 ], [ %.1021, %1340 ], [ %.1021, %1412 ], [ %.1021, %1353 ], [ 1, %1243 ], [ 1, %1255 ], [ 1, %697 ], [ 1, %747 ], [ 1, %659 ], [ 1, %1040 ], [ 1, %1037 ], [ %.1122, %1492 ], [ %.920, %1316 ]
  %1498 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 6
  %1499 = load i32, i32* %1498, align 8
  %1500 = icmp ne i32 %1499, 0
  br i1 %1500, label %1504, label %1501

; <label>:1501:                                   ; preds = %1497
  %1502 = getelementptr [2 x i8], [2 x i8]* @.str.2, i32 0, i32 0
  %1503 = call i32 (i8*, ...) @printf(i8* %1502)
  br label %1504

; <label>:1504:                                   ; preds = %1501, %1497
  %1505 = load %struct._IO_FILE*, %struct._IO_FILE** @stdout, align 8
  %1506 = call i32 @fflush(%struct._IO_FILE* %1505)
  call void @clean_exit(i32 %.1324)
  call void @_exit(i32 %.1324) #12
  unreachable

; <label>:1507:                                   ; preds = %1471, %1489, %625, %627, %1457, %589, %572, %562, %557, %537, %512, %485, %465, %443, %422, %405, %378, %345, %314, %167, %144, %126, %90, %85, %67, %62
  %.0 = phi i32 [ 0, %1457 ], [ 1, %589 ], [ 1, %572 ], [ 1, %562 ], [ 1, %557 ], [ 1, %537 ], [ 1, %512 ], [ 1, %485 ], [ 1, %465 ], [ 1, %443 ], [ 1, %422 ], [ 1, %405 ], [ 1, %378 ], [ 1, %345 ], [ 1, %314 ], [ 1, %167 ], [ 1, %144 ], [ 1, %126 ], [ 1, %90 ], [ 0, %85 ], [ 1, %67 ], [ 1, %62 ], [ 1, %627 ], [ 1, %625 ], [ 0, %1489 ], [ 0, %1471 ]
  ret i32 %.0
}

; Function Attrs: nounwind
declare dso_local i32 @setsid() #2

; Function Attrs: nounwind
declare dso_local i64 @time(i64*) #2

; Function Attrs: nounwind
declare dso_local void @srand(i32) #2

; Function Attrs: nounwind
declare dso_local i32 @getopt_long(i32, i8**, i8*, %struct.option*, i32*) #2

; Function Attrs: nounwind readonly
declare dso_local i32 @strcasecmp(i8*, i8*) #3

; Function Attrs: nounwind
declare dso_local noalias i8* @calloc(i64, i64) #2

; Function Attrs: nounwind
declare dso_local i32 @pthread_mutex_init(%union.pthread_mutex_t*, %union.pthread_mutexattr_t*) #2

; Function Attrs: nounwind
declare dso_local i32 @pthread_cond_init(%union.pthread_cond_t*, %union.pthread_mutexattr_t*) #2

; Function Attrs: nounwind
declare dso_local i32 @pthread_create(i64*, %union.pthread_attr_t*, i8* (i8*)*, i8*) #2

declare dso_local i32 @scanf(i8*, ...) #1

; Function Attrs: nounwind
declare dso_local i32 @pipe(i32*) #2

; Function Attrs: noinline nounwind uwtable
define internal i32 @crack_wep_ptw(%struct.AP_info*) #0 {
  %2 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 37
  store %struct.AP_info* %0, %struct.AP_info** %2, align 8
  %3 = call noalias i8* @malloc(i64 32768) #9
  %4 = bitcast i8* %3 to [256 x i32]*
  %5 = icmp eq [256 x i32]* %4, null
  br i1 %5, label %203, label %.preheader4

.preheader4:                                      ; preds = %1
  br label %6

; <label>:6:                                      ; preds = %.preheader4, %10
  %indvars.iv28 = phi i64 [ %indvars.iv.next29, %10 ], [ 0, %.preheader4 ]
  br label %7

; <label>:7:                                      ; preds = %6, %7
  %indvars.iv24 = phi i64 [ 0, %6 ], [ %indvars.iv.next25, %7 ]
  %8 = getelementptr inbounds [256 x i32], [256 x i32]* %4, i64 %indvars.iv28
  %9 = getelementptr inbounds [256 x i32], [256 x i32]* %8, i64 0, i64 %indvars.iv24
  store i32 1, i32* %9, align 4
  %indvars.iv.next25 = add nuw nsw i64 %indvars.iv24, 1
  %exitcond26 = icmp ne i64 %indvars.iv.next25, 256
  br i1 %exitcond26, label %7, label %10

; <label>:10:                                     ; preds = %7
  %indvars.iv.next29 = add nuw nsw i64 %indvars.iv28, 1
  %exitcond30 = icmp ne i64 %indvars.iv.next29, 32
  br i1 %exitcond30, label %6, label %.preheader3

.preheader3:                                      ; preds = %10
  %indvars.iv20.ph = phi i64 [ 0, %10 ]
  br label %11

; <label>:11:                                     ; preds = %.preheader3, %40
  %indvars.iv20 = phi i64 [ %indvars.iv.next21, %40 ], [ %indvars.iv20.ph, %.preheader3 ]
  br label %12

; <label>:12:                                     ; preds = %11, %39
  %indvars.iv17 = phi i64 [ 0, %11 ], [ %indvars.iv.next18, %39 ]
  call void @unroll_loop(i32 122)
  %13 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 15
  %14 = load i32, i32* %13, align 8
  %15 = icmp ne i32 %14, 0
  br i1 %15, label %16, label %19

; <label>:16:                                     ; preds = %12
  %17 = icmp ult i64 %indvars.iv17, 32
  %18 = icmp uge i64 %indvars.iv17, 128
  %or.cond = or i1 %17, %18
  br i1 %or.cond, label %36, label %19

; <label>:19:                                     ; preds = %16, %12
  %20 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 14
  %21 = load i32, i32* %20, align 4
  %22 = icmp ne i32 %21, 0
  br i1 %22, label %23, label %26

; <label>:23:                                     ; preds = %19
  %24 = icmp ult i64 %indvars.iv17, 48
  %25 = icmp uge i64 %indvars.iv17, 58
  %or.cond1 = or i1 %24, %25
  br i1 %or.cond1, label %36, label %26

; <label>:26:                                     ; preds = %23, %19
  %27 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 16
  %28 = load i32, i32* %27, align 4
  %29 = icmp ne i32 %28, 0
  br i1 %29, label %30, label %39

; <label>:30:                                     ; preds = %26
  %31 = icmp ugt i64 %indvars.iv17, 153
  br i1 %31, label %36, label %32

; <label>:32:                                     ; preds = %30
  %33 = trunc i64 %indvars.iv17 to i32
  %34 = and i32 %33, 15
  %35 = icmp sgt i32 %34, 9
  br i1 %35, label %36, label %39

; <label>:36:                                     ; preds = %32, %30, %23, %16
  %37 = getelementptr inbounds [256 x i32], [256 x i32]* %4, i64 %indvars.iv20
  %38 = getelementptr inbounds [256 x i32], [256 x i32]* %37, i64 0, i64 %indvars.iv17
  store i32 0, i32* %38, align 4
  br label %39

; <label>:39:                                     ; preds = %26, %32, %36
  %indvars.iv.next18 = add nuw nsw i64 %indvars.iv17, 1
  %exitcond1 = icmp ne i64 %indvars.iv.next18, 256
  br i1 %exitcond1, label %12, label %40

; <label>:40:                                     ; preds = %39
  %indvars.iv.next21 = add nuw nsw i64 %indvars.iv20, 1
  %exitcond22 = icmp ne i64 %indvars.iv.next21, 32
  br i1 %exitcond22, label %11, label %.preheader

.preheader:                                       ; preds = %40
  %indvars.iv11.ph = phi i64 [ 0, %40 ]
  br label %41

; <label>:41:                                     ; preds = %.preheader, %73
  %indvars.iv11 = phi i64 [ %indvars.iv.next12, %73 ], [ %indvars.iv11.ph, %.preheader ]
  br label %42

; <label>:42:                                     ; preds = %41, %72
  %indvars.iv = phi i64 [ 0, %41 ], [ %indvars.iv.next, %72 ]
  call void @unroll_loop(i32 123)
  %43 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 8
  %44 = getelementptr inbounds [64 x i32], [64 x i32]* %43, i64 0, i64 %indvars.iv11
  %45 = load i32, i32* %44, align 4
  %46 = icmp eq i32 %45, 1
  br i1 %46, label %47, label %57

; <label>:47:                                     ; preds = %42
  %48 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 7
  %49 = getelementptr inbounds [64 x i8], [64 x i8]* %48, i64 0, i64 %indvars.iv11
  %50 = load i8, i8* %49, align 1
  %51 = zext i8 %50 to i32
  %52 = zext i32 %51 to i64
  %53 = icmp ne i64 %52, %indvars.iv
  br i1 %53, label %54, label %57

; <label>:54:                                     ; preds = %47
  %55 = getelementptr inbounds [256 x i32], [256 x i32]* %4, i64 %indvars.iv11
  %56 = getelementptr inbounds [256 x i32], [256 x i32]* %55, i64 0, i64 %indvars.iv
  store i32 0, i32* %56, align 4
  br label %72

; <label>:57:                                     ; preds = %47, %42
  %58 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 8
  %59 = getelementptr inbounds [64 x i32], [64 x i32]* %58, i64 0, i64 %indvars.iv11
  %60 = load i32, i32* %59, align 4
  %61 = icmp eq i32 %60, 1
  br i1 %61, label %62, label %72

; <label>:62:                                     ; preds = %57
  %63 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 7
  %64 = getelementptr inbounds [64 x i8], [64 x i8]* %63, i64 0, i64 %indvars.iv11
  %65 = load i8, i8* %64, align 1
  %66 = zext i8 %65 to i32
  %67 = zext i32 %66 to i64
  %68 = icmp eq i64 %67, %indvars.iv
  br i1 %68, label %69, label %72

; <label>:69:                                     ; preds = %62
  %70 = getelementptr inbounds [256 x i32], [256 x i32]* %4, i64 %indvars.iv11
  %71 = getelementptr inbounds [256 x i32], [256 x i32]* %70, i64 0, i64 %indvars.iv
  store i32 1, i32* %71, align 4
  br label %72

; <label>:72:                                     ; preds = %54, %69, %62, %57
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond = icmp ne i64 %indvars.iv.next, 256
  br i1 %exitcond, label %42, label %73

; <label>:73:                                     ; preds = %72
  %indvars.iv.next12 = add nuw nsw i64 %indvars.iv11, 1
  %exitcond13 = icmp ne i64 %indvars.iv.next12, 32
  br i1 %exitcond13, label %41, label %74

; <label>:74:                                     ; preds = %73
  %75 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %0, i32 0, i32 8
  %76 = load i64, i64* %75, align 8
  %77 = icmp sgt i64 %76, 99
  br i1 %77, label %78, label %136

; <label>:78:                                     ; preds = %74
  %79 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %0, i32 0, i32 8
  %80 = load i64, i64* %79, align 8
  %81 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %0, i32 0, i32 7
  store i64 %80, i64* %81, align 8
  %82 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 10
  %83 = load i32, i32* %82, align 4
  %84 = icmp ne i32 %83, 13
  %85 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %0, i32 0, i32 15
  %86 = load %struct.PTW_attackstate*, %struct.PTW_attackstate** %85, align 8
  br i1 %84, label %87, label %102

; <label>:87:                                     ; preds = %78
  %88 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 10
  %89 = load i32, i32* %88, align 4
  %90 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 12
  %91 = load float, float* %90, align 4
  %92 = fmul float 1.000000e+06, %91
  %93 = fptosi float %92 to i32
  %94 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 39
  %95 = load i32, i32* %94, align 4
  %96 = getelementptr %struct.WEP_data, %struct.WEP_data* @wep, i32 0, i32 0, i32 0
  %97 = getelementptr [29 x i32], [29 x i32]* @PTW_DEFAULTBF, i32 0, i32 0
  %98 = call i32 @PTW_computeKey(%struct.PTW_attackstate* %86, i8* %96, i32 %89, i32 %93, i32* %97, [256 x i32]* %4, i32 %95)
  %99 = icmp eq i32 %98, 1
  %100 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 10
  %101 = load i32, i32* %100, align 4
  %.01 = select i1 %99, i32 %101, i32 0
  br label %136

; <label>:102:                                    ; preds = %78
  %103 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 39
  %104 = load i32, i32* %103, align 4
  %105 = getelementptr %struct.WEP_data, %struct.WEP_data* @wep, i32 0, i32 0, i32 0
  %106 = getelementptr [29 x i32], [29 x i32]* @PTW_DEFAULTBF, i32 0, i32 0
  %107 = call i32 @PTW_computeKey(%struct.PTW_attackstate* %86, i8* %105, i32 5, i32 1000, i32* %106, [256 x i32]* %4, i32 %104)
  %108 = icmp eq i32 %107, 1
  br i1 %108, label %136, label %109

; <label>:109:                                    ; preds = %102
  %110 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %0, i32 0, i32 15
  %111 = load %struct.PTW_attackstate*, %struct.PTW_attackstate** %110, align 8
  %112 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 12
  %113 = load float, float* %112, align 4
  %114 = fmul float 1.000000e+06, %113
  %115 = fptosi float %114 to i32
  %116 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 39
  %117 = load i32, i32* %116, align 4
  %118 = getelementptr %struct.WEP_data, %struct.WEP_data* @wep, i32 0, i32 0, i32 0
  %119 = getelementptr [29 x i32], [29 x i32]* @PTW_DEFAULTBF, i32 0, i32 0
  %120 = call i32 @PTW_computeKey(%struct.PTW_attackstate* %111, i8* %118, i32 13, i32 %115, i32* %119, [256 x i32]* %4, i32 %117)
  %121 = icmp eq i32 %120, 1
  br i1 %121, label %136, label %122

; <label>:122:                                    ; preds = %109
  %123 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %0, i32 0, i32 15
  %124 = load %struct.PTW_attackstate*, %struct.PTW_attackstate** %123, align 8
  %125 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 12
  %126 = load float, float* %125, align 4
  %127 = fmul float 1.000000e+06, %126
  %128 = fdiv float %127, 3.000000e+00
  %129 = fptosi float %128 to i32
  %130 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 39
  %131 = load i32, i32* %130, align 4
  %132 = getelementptr %struct.WEP_data, %struct.WEP_data* @wep, i32 0, i32 0, i32 0
  %133 = getelementptr [29 x i32], [29 x i32]* @PTW_DEFAULTBF, i32 0, i32 0
  %134 = call i32 @PTW_computeKey(%struct.PTW_attackstate* %124, i8* %132, i32 5, i32 %129, i32* %133, [256 x i32]* %4, i32 %131)
  %135 = icmp eq i32 %134, 1
  %spec.select = select i1 %135, i32 5, i32 0
  br label %136

; <label>:136:                                    ; preds = %87, %122, %109, %102, %74
  %.5 = phi i32 [ 0, %74 ], [ %.01, %87 ], [ 5, %102 ], [ %spec.select, %122 ], [ 13, %109 ]
  %137 = icmp ne i32 %.5, 0
  br i1 %137, label %198, label %138

; <label>:138:                                    ; preds = %136
  %139 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %0, i32 0, i32 9
  %140 = load i64, i64* %139, align 8
  %141 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %0, i32 0, i32 7
  store i64 %140, i64* %141, align 8
  %142 = getelementptr [29 x i32], [29 x i32]* @PTW_DEFAULTBF, i64 0, i64 10
  store i32 1, i32* %142, align 8
  %143 = getelementptr [29 x i32], [29 x i32]* @PTW_DEFAULTBF, i64 0, i64 11
  store i32 1, i32* %143, align 4
  %144 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 10
  %145 = load i32, i32* %144, align 4
  %146 = icmp ne i32 %145, 13
  %147 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %0, i32 0, i32 16
  %148 = load %struct.PTW_attackstate*, %struct.PTW_attackstate** %147, align 8
  br i1 %146, label %149, label %164

; <label>:149:                                    ; preds = %138
  %150 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 10
  %151 = load i32, i32* %150, align 4
  %152 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 12
  %153 = load float, float* %152, align 4
  %154 = fmul float 1.000000e+06, %153
  %155 = fptosi float %154 to i32
  %156 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 39
  %157 = load i32, i32* %156, align 4
  %158 = getelementptr %struct.WEP_data, %struct.WEP_data* @wep, i32 0, i32 0, i32 0
  %159 = getelementptr [29 x i32], [29 x i32]* @PTW_DEFAULTBF, i32 0, i32 0
  %160 = call i32 @PTW_computeKey(%struct.PTW_attackstate* %148, i8* %158, i32 %151, i32 %155, i32* %159, [256 x i32]* %4, i32 %157)
  %161 = icmp eq i32 %160, 1
  %162 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 10
  %163 = load i32, i32* %162, align 4
  %.6 = select i1 %161, i32 %163, i32 %.5
  br label %198

; <label>:164:                                    ; preds = %138
  %165 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 39
  %166 = load i32, i32* %165, align 4
  %167 = getelementptr %struct.WEP_data, %struct.WEP_data* @wep, i32 0, i32 0, i32 0
  %168 = getelementptr [29 x i32], [29 x i32]* @PTW_DEFAULTBF, i32 0, i32 0
  %169 = call i32 @PTW_computeKey(%struct.PTW_attackstate* %148, i8* %167, i32 5, i32 1000, i32* %168, [256 x i32]* %4, i32 %166)
  %170 = icmp eq i32 %169, 1
  br i1 %170, label %198, label %171

; <label>:171:                                    ; preds = %164
  %172 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %0, i32 0, i32 16
  %173 = load %struct.PTW_attackstate*, %struct.PTW_attackstate** %172, align 8
  %174 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 12
  %175 = load float, float* %174, align 4
  %176 = fmul float 1.000000e+06, %175
  %177 = fptosi float %176 to i32
  %178 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 39
  %179 = load i32, i32* %178, align 4
  %180 = getelementptr %struct.WEP_data, %struct.WEP_data* @wep, i32 0, i32 0, i32 0
  %181 = getelementptr [29 x i32], [29 x i32]* @PTW_DEFAULTBF, i32 0, i32 0
  %182 = call i32 @PTW_computeKey(%struct.PTW_attackstate* %173, i8* %180, i32 13, i32 %177, i32* %181, [256 x i32]* %4, i32 %179)
  %183 = icmp eq i32 %182, 1
  br i1 %183, label %198, label %184

; <label>:184:                                    ; preds = %171
  %185 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %0, i32 0, i32 16
  %186 = load %struct.PTW_attackstate*, %struct.PTW_attackstate** %185, align 8
  %187 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 12
  %188 = load float, float* %187, align 4
  %189 = fmul float 1.000000e+06, %188
  %190 = fdiv float %189, 1.000000e+01
  %191 = fptosi float %190 to i32
  %192 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 39
  %193 = load i32, i32* %192, align 4
  %194 = getelementptr %struct.WEP_data, %struct.WEP_data* @wep, i32 0, i32 0, i32 0
  %195 = getelementptr [29 x i32], [29 x i32]* @PTW_DEFAULTBF, i32 0, i32 0
  %196 = call i32 @PTW_computeKey(%struct.PTW_attackstate* %186, i8* %194, i32 5, i32 %191, i32* %195, [256 x i32]* %4, i32 %193)
  %197 = icmp eq i32 %196, 1
  %spec.select2 = select i1 %197, i32 5, i32 %.5
  br label %198

; <label>:198:                                    ; preds = %149, %184, %171, %164, %136
  %.11 = phi i32 [ %.5, %136 ], [ %.6, %149 ], [ 5, %164 ], [ %spec.select2, %184 ], [ 13, %171 ]
  %199 = icmp ne i32 %.11, 0
  br i1 %199, label %200, label %203

; <label>:200:                                    ; preds = %198
  %201 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 29
  store i32 100, i32* %201, align 4
  %202 = getelementptr %struct.WEP_data, %struct.WEP_data* @wep, i32 0, i32 0, i32 0
  call void @key_found(i8* %202, i32 %.11, i32 -1)
  br label %203

; <label>:203:                                    ; preds = %198, %1, %200
  %.0 = phi i32 [ 0, %200 ], [ 1, %1 ], [ 1, %198 ]
  ret i32 %.0
}

; Function Attrs: noinline nounwind uwtable
define dso_local i32 @encrypt_wep(i8*, i32, i8*, i32) #0 {
  %5 = alloca %struct.rc4_key_st, align 4
  call void @RC4_set_key(%struct.rc4_key_st* %5, i32 %3, i8* %2)
  %6 = sext i32 %1 to i64
  call void @RC4(%struct.rc4_key_st* %5, i64 %6, i8* %0, i8* %0)
  ret i32 0
}

declare dso_local void @RC4_set_key(%struct.rc4_key_st*, i32, i8*) #1

declare dso_local void @RC4(%struct.rc4_key_st*, i64, i8*, i8*) #1

; Function Attrs: noinline nounwind uwtable
define dso_local i32 @decrypt_wep(i8*, i32, i8*, i32) #0 {
  %5 = call i32 @encrypt_wep(i8* %0, i32 %1, i8* %2, i32 %3)
  %6 = sub nsw i32 %1, 4
  %7 = call i32 @check_crc_buf(i8* %0, i32 %6)
  ret i32 %7
}

; Function Attrs: noinline nounwind uwtable
define dso_local i32 @check_crc_buf(i8*, i32) #0 {
  %3 = call i64 @calc_crc(i8* %0, i32 %1)
  %4 = sext i32 %1 to i64
  %5 = getelementptr inbounds i8, i8* %0, i64 %4
  %6 = and i64 %3, 255
  %7 = getelementptr inbounds i8, i8* %5, i64 0
  %8 = load i8, i8* %7, align 1
  %9 = zext i8 %8 to i64
  %10 = icmp eq i64 %6, %9
  br i1 %10, label %11, label %32

; <label>:11:                                     ; preds = %2
  %12 = lshr i64 %3, 8
  %13 = and i64 %12, 255
  %14 = getelementptr inbounds i8, i8* %5, i64 1
  %15 = load i8, i8* %14, align 1
  %16 = zext i8 %15 to i64
  %17 = icmp eq i64 %13, %16
  br i1 %17, label %18, label %32

; <label>:18:                                     ; preds = %11
  %19 = lshr i64 %3, 16
  %20 = and i64 %19, 255
  %21 = getelementptr inbounds i8, i8* %5, i64 2
  %22 = load i8, i8* %21, align 1
  %23 = zext i8 %22 to i64
  %24 = icmp eq i64 %20, %23
  br i1 %24, label %25, label %32

; <label>:25:                                     ; preds = %18
  %26 = lshr i64 %3, 24
  %27 = and i64 %26, 255
  %28 = getelementptr inbounds i8, i8* %5, i64 3
  %29 = load i8, i8* %28, align 1
  %30 = zext i8 %29 to i64
  %31 = icmp eq i64 %27, %30
  br label %32

; <label>:32:                                     ; preds = %25, %18, %11, %2
  %33 = phi i1 [ false, %18 ], [ false, %11 ], [ false, %2 ], [ %31, %25 ]
  %34 = zext i1 %33 to i32
  ret i32 %34
}

; Function Attrs: noinline nounwind uwtable
define dso_local i64 @calc_crc(i8*, i32) #0 {
  %3 = icmp sgt i32 %1, 0
  br i1 %3, label %.lr.ph.preheader, label %._crit_edge

.lr.ph.preheader:                                 ; preds = %2
  br label %.lr.ph

.lr.ph:                                           ; preds = %.lr.ph.preheader, %.lr.ph
  %.05 = phi i8* [ %13, %.lr.ph ], [ %0, %.lr.ph.preheader ]
  %.014 = phi i32 [ %12, %.lr.ph ], [ %1, %.lr.ph.preheader ]
  %.023 = phi i64 [ %11, %.lr.ph ], [ 4294967295, %.lr.ph.preheader ]
  %4 = load i8, i8* %.05, align 1
  %5 = zext i8 %4 to i64
  %6 = xor i64 %.023, %5
  %7 = and i64 %6, 255
  %8 = getelementptr inbounds [256 x i64], [256 x i64]* @crc_tbl, i64 0, i64 %7
  %9 = load i64, i64* %8, align 8
  %10 = lshr i64 %.023, 8
  %11 = xor i64 %9, %10
  %12 = add nsw i32 %.014, -1
  %13 = getelementptr inbounds i8, i8* %.05, i32 1
  %14 = icmp sgt i32 %12, 0
  br i1 %14, label %.lr.ph, label %._crit_edge.loopexit

._crit_edge.loopexit:                             ; preds = %.lr.ph
  %.02.lcssa.ph = phi i64 [ %11, %.lr.ph ]
  br label %._crit_edge

._crit_edge:                                      ; preds = %._crit_edge.loopexit, %2
  %.02.lcssa = phi i64 [ 4294967295, %2 ], [ %.02.lcssa.ph, %._crit_edge.loopexit ]
  %15 = xor i64 %.02.lcssa, -1
  ret i64 %15
}

; Function Attrs: noinline nounwind uwtable
define dso_local void @rc4_setup(%struct.rc4_key_st*, i8*, i32) #0 {
  %4 = getelementptr inbounds %struct.rc4_key_st, %struct.rc4_key_st* %0, i32 0, i32 0
  store i32 0, i32* %4, align 4
  %5 = getelementptr inbounds %struct.rc4_key_st, %struct.rc4_key_st* %0, i32 0, i32 1
  store i32 0, i32* %5, align 4
  %6 = getelementptr inbounds %struct.rc4_key_st, %struct.rc4_key_st* %0, i32 0, i32 2
  %7 = getelementptr inbounds [256 x i32], [256 x i32]* %6, i32 0, i32 0
  br label %8

; <label>:8:                                      ; preds = %3, %8
  %indvars.iv8 = phi i64 [ 0, %3 ], [ %indvars.iv.next9, %8 ]
  %9 = getelementptr inbounds i32, i32* %7, i64 %indvars.iv8
  %10 = trunc i64 %indvars.iv8 to i32
  store i32 %10, i32* %9, align 4
  %indvars.iv.next9 = add nuw nsw i64 %indvars.iv8, 1
  %exitcond10 = icmp ne i64 %indvars.iv.next9, 256
  br i1 %exitcond10, label %8, label %.preheader

.preheader:                                       ; preds = %8
  %indvars.iv.ph = phi i64 [ 0, %8 ]
  %.06.ph = phi i32 [ 0, %8 ]
  %.015.ph = phi i32 [ 0, %8 ]
  br label %11

; <label>:11:                                     ; preds = %.preheader, %11
  %indvars.iv = phi i64 [ %indvars.iv.next, %11 ], [ %indvars.iv.ph, %.preheader ]
  %.06 = phi i32 [ %spec.select, %11 ], [ %.06.ph, %.preheader ]
  %.015 = phi i32 [ %21, %11 ], [ %.015.ph, %.preheader ]
  %12 = getelementptr inbounds i32, i32* %7, i64 %indvars.iv
  %13 = load i32, i32* %12, align 4
  %14 = add nsw i32 %.015, %13
  %15 = sext i32 %.06 to i64
  %16 = getelementptr inbounds i8, i8* %1, i64 %15
  %17 = load i8, i8* %16, align 1
  %18 = zext i8 %17 to i32
  %19 = add nsw i32 %14, %18
  %20 = trunc i32 %19 to i8
  %21 = zext i8 %20 to i32
  %22 = sext i32 %21 to i64
  %23 = getelementptr inbounds i32, i32* %7, i64 %22
  %24 = load i32, i32* %23, align 4
  %25 = getelementptr inbounds i32, i32* %7, i64 %indvars.iv
  store i32 %24, i32* %25, align 4
  %26 = sext i32 %21 to i64
  %27 = getelementptr inbounds i32, i32* %7, i64 %26
  store i32 %13, i32* %27, align 4
  %28 = add nsw i32 %.06, 1
  %29 = icmp sge i32 %28, %2
  %spec.select = select i1 %29, i32 0, i32 %28
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond = icmp ne i64 %indvars.iv.next, 256
  br i1 %exitcond, label %11, label %30

; <label>:30:                                     ; preds = %11
  ret void
}

; Function Attrs: noinline nounwind uwtable
define dso_local void @rc4_crypt(%struct.rc4_key_st*, i8*, i32) #0 {
  %4 = getelementptr inbounds %struct.rc4_key_st, %struct.rc4_key_st* %0, i32 0, i32 0
  %5 = load i32, i32* %4, align 4
  %6 = getelementptr inbounds %struct.rc4_key_st, %struct.rc4_key_st* %0, i32 0, i32 1
  %7 = load i32, i32* %6, align 4
  %8 = getelementptr inbounds %struct.rc4_key_st, %struct.rc4_key_st* %0, i32 0, i32 2
  %9 = getelementptr inbounds [256 x i32], [256 x i32]* %8, i32 0, i32 0
  %10 = icmp slt i32 0, %2
  br i1 %10, label %.lr.ph, label %._crit_edge

.lr.ph:                                           ; preds = %3
  %11 = zext i32 %2 to i64
  br label %12

; <label>:12:                                     ; preds = %.lr.ph, %12
  %indvars.iv = phi i64 [ 0, %.lr.ph ], [ %indvars.iv.next, %12 ]
  %.05 = phi i32 [ %7, %.lr.ph ], [ %21, %12 ]
  %.014 = phi i32 [ %5, %.lr.ph ], [ %15, %12 ]
  %13 = add nsw i32 %.014, 1
  %14 = trunc i32 %13 to i8
  %15 = zext i8 %14 to i32
  %16 = sext i32 %15 to i64
  %17 = getelementptr inbounds i32, i32* %9, i64 %16
  %18 = load i32, i32* %17, align 4
  %19 = add nsw i32 %.05, %18
  %20 = trunc i32 %19 to i8
  %21 = zext i8 %20 to i32
  %22 = sext i32 %21 to i64
  %23 = getelementptr inbounds i32, i32* %9, i64 %22
  %24 = load i32, i32* %23, align 4
  %25 = sext i32 %15 to i64
  %26 = getelementptr inbounds i32, i32* %9, i64 %25
  store i32 %24, i32* %26, align 4
  %27 = sext i32 %21 to i64
  %28 = getelementptr inbounds i32, i32* %9, i64 %27
  store i32 %18, i32* %28, align 4
  %29 = add nsw i32 %18, %24
  %30 = trunc i32 %29 to i8
  %31 = zext i8 %30 to i64
  %32 = getelementptr inbounds i32, i32* %9, i64 %31
  %33 = load i32, i32* %32, align 4
  %34 = getelementptr inbounds i8, i8* %1, i64 %indvars.iv
  %35 = load i8, i8* %34, align 1
  %36 = zext i8 %35 to i32
  %37 = xor i32 %36, %33
  %38 = trunc i32 %37 to i8
  store i8 %38, i8* %34, align 1
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond1 = icmp ne i64 %indvars.iv.next, %11
  br i1 %exitcond1, label %12, label %._crit_edge.loopexit

._crit_edge.loopexit:                             ; preds = %12
  %.01.lcssa.ph = phi i32 [ %15, %12 ]
  %.0.lcssa.ph = phi i32 [ %21, %12 ]
  br label %._crit_edge

._crit_edge:                                      ; preds = %._crit_edge.loopexit, %3
  %.01.lcssa = phi i32 [ %5, %3 ], [ %.01.lcssa.ph, %._crit_edge.loopexit ]
  %.0.lcssa = phi i32 [ %7, %3 ], [ %.0.lcssa.ph, %._crit_edge.loopexit ]
  %39 = getelementptr inbounds %struct.rc4_key_st, %struct.rc4_key_st* %0, i32 0, i32 0
  store i32 %.01.lcssa, i32* %39, align 4
  %40 = getelementptr inbounds %struct.rc4_key_st, %struct.rc4_key_st* %0, i32 0, i32 1
  store i32 %.0.lcssa, i32* %40, align 4
  ret void
}

; Function Attrs: noinline nounwind uwtable
define dso_local void @calc_pmk(i8*, i8*, i8*) #0 {
  %4 = alloca [65 x i8], align 16, !track !227
  %5 = alloca [37 x i8], align 16, !track !228
  %6 = alloca %struct.SHAstate_st, align 4, !track !229
  %7 = alloca %struct.SHAstate_st, align 4, !track !230
  %8 = alloca %struct.SHAstate_st, align 4, !track !231
  %9 = getelementptr inbounds [37 x i8], [37 x i8]* %5, i32 0, i32 0
  call void @llvm.memset.p0i8.i64(i8* align 16 %9, i8 0, i64 37, i1 false)
  %10 = getelementptr inbounds [37 x i8], [37 x i8]* %5, i32 0, i32 0
  %11 = call i64 @strlen(i8* %1) #10
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 16 %10, i8* align 1 %1, i64 %11, i1 false), !track !232
  %12 = getelementptr inbounds [37 x i8], [37 x i8]* %5, i32 0, i32 0
  %13 = call i64 @strlen(i8* %12) #10
  %14 = getelementptr inbounds [65 x i8], [65 x i8]* %4, i32 0, i32 0
  call void @llvm.memset.p0i8.i64(i8* align 16 %14, i8 0, i64 65, i1 false)
  %15 = getelementptr inbounds [65 x i8], [65 x i8]* %4, i32 0, i32 0
  %16 = call i8* @strncpy(i8* %15, i8* %0, i64 64) #9, !track !233
  br label %17

; <label>:17:                                     ; preds = %3, %17
  %indvars.iv17 = phi i64 [ 0, %3 ], [ %indvars.iv.next18, %17 ]
  call void @unroll_loop(i32 148)
  %18 = getelementptr inbounds [65 x i8], [65 x i8]* %4, i64 0, i64 %indvars.iv17
  %19 = load i8, i8* %18, align 1
  %20 = zext i8 %19 to i32
  %21 = xor i32 %20, 54
  %22 = trunc i32 %21 to i8
  store i8 %22, i8* %18, align 1
  %indvars.iv.next18 = add nuw nsw i64 %indvars.iv17, 1
  %exitcond19 = icmp ne i64 %indvars.iv.next18, 64
  br i1 %exitcond19, label %17, label %23

; <label>:23:                                     ; preds = %17
  %24 = call i32 @SHA1_Init(%struct.SHAstate_st* %6)
  %25 = getelementptr inbounds [65 x i8], [65 x i8]* %4, i32 0, i32 0
  %26 = call i32 @SHA1_Update(%struct.SHAstate_st* %6, i8* %25, i64 64)
  br label %27

; <label>:27:                                     ; preds = %23, %27
  %indvars.iv13 = phi i64 [ 0, %23 ], [ %indvars.iv.next14, %27 ]
  call void @unroll_loop(i32 149)
  %28 = getelementptr inbounds [65 x i8], [65 x i8]* %4, i64 0, i64 %indvars.iv13
  %29 = load i8, i8* %28, align 1
  %30 = zext i8 %29 to i32
  %31 = xor i32 %30, 106
  %32 = trunc i32 %31 to i8
  store i8 %32, i8* %28, align 1
  %indvars.iv.next14 = add nuw nsw i64 %indvars.iv13, 1
  %exitcond15 = icmp ne i64 %indvars.iv.next14, 64
  br i1 %exitcond15, label %27, label %33

; <label>:33:                                     ; preds = %27
  %34 = add i64 %13, 4
  %35 = trunc i64 %34 to i32
  %36 = call i32 @SHA1_Init(%struct.SHAstate_st* %7)
  %37 = getelementptr inbounds [65 x i8], [65 x i8]* %4, i32 0, i32 0
  %38 = call i32 @SHA1_Update(%struct.SHAstate_st* %7, i8* %37, i64 64)
  %39 = sub nsw i32 %35, 1
  %40 = sext i32 %39 to i64
  %41 = getelementptr inbounds [37 x i8], [37 x i8]* %5, i64 0, i64 %40
  store i8 1, i8* %41, align 1
  %42 = call %struct.env_md_st* @EVP_sha1()
  %43 = call i64 @strlen(i8* %0) #10
  %44 = trunc i64 %43 to i32
  %45 = getelementptr inbounds [37 x i8], [37 x i8]* %5, i32 0, i32 0
  %46 = sext i32 %35 to i64
  %47 = call i8* @HMAC(%struct.env_md_st* %42, i8* %0, i32 %44, i8* %45, i64 %46, i8* %2, i32* null)
  %48 = getelementptr inbounds [65 x i8], [65 x i8]* %4, i32 0, i32 0
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 16 %48, i8* align 1 %2, i64 20, i1 false), !track !234
  br label %49

; <label>:49:                                     ; preds = %33, %71
  %.210 = phi i32 [ 1, %33 ], [ %72, %71 ]
  call void @unroll_loop(i32 150)
  %50 = bitcast %struct.SHAstate_st* %8 to i8*
  %51 = bitcast %struct.SHAstate_st* %6 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %50, i8* align 4 %51, i64 96, i1 false), !track !235
  %52 = getelementptr inbounds [65 x i8], [65 x i8]* %4, i32 0, i32 0
  %53 = call i32 @SHA1_Update(%struct.SHAstate_st* %8, i8* %52, i64 20)
  %54 = getelementptr inbounds [65 x i8], [65 x i8]* %4, i32 0, i32 0
  %55 = call i32 @SHA1_Final(i8* %54, %struct.SHAstate_st* %8)
  %56 = bitcast %struct.SHAstate_st* %8 to i8*
  %57 = bitcast %struct.SHAstate_st* %7 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %56, i8* align 4 %57, i64 96, i1 false), !track !236
  %58 = getelementptr inbounds [65 x i8], [65 x i8]* %4, i32 0, i32 0
  %59 = call i32 @SHA1_Update(%struct.SHAstate_st* %8, i8* %58, i64 20)
  %60 = getelementptr inbounds [65 x i8], [65 x i8]* %4, i32 0, i32 0
  %61 = call i32 @SHA1_Final(i8* %60, %struct.SHAstate_st* %8)
  br label %62

; <label>:62:                                     ; preds = %49, %62
  %indvars.iv7 = phi i64 [ 0, %49 ], [ %indvars.iv.next8, %62 ]
  call void @unroll_loop(i32 151)
  %63 = getelementptr inbounds [65 x i8], [65 x i8]* %4, i64 0, i64 %indvars.iv7
  %64 = load i8, i8* %63, align 1
  %65 = zext i8 %64 to i32
  %66 = getelementptr inbounds i8, i8* %2, i64 %indvars.iv7
  %67 = load i8, i8* %66, align 1
  %68 = zext i8 %67 to i32
  %69 = xor i32 %68, %65
  %70 = trunc i32 %69 to i8
  store i8 %70, i8* %66, align 1
  %indvars.iv.next8 = add nuw nsw i64 %indvars.iv7, 1
  %exitcond9 = icmp ne i64 %indvars.iv.next8, 20
  br i1 %exitcond9, label %62, label %71

; <label>:71:                                     ; preds = %62
  %72 = add nuw nsw i32 %.210, 1
  %exitcond11 = icmp ne i32 %72, 4096
  br i1 %exitcond11, label %49, label %73

; <label>:73:                                     ; preds = %71
  %74 = sub nsw i32 %35, 1
  %75 = sext i32 %74 to i64
  %76 = getelementptr inbounds [37 x i8], [37 x i8]* %5, i64 0, i64 %75
  store i8 2, i8* %76, align 1
  %77 = call %struct.env_md_st* @EVP_sha1()
  %78 = call i64 @strlen(i8* %0) #10
  %79 = trunc i64 %78 to i32
  %80 = getelementptr inbounds [37 x i8], [37 x i8]* %5, i32 0, i32 0
  %81 = sext i32 %35 to i64
  %82 = getelementptr inbounds i8, i8* %2, i64 20
  %83 = call i8* @HMAC(%struct.env_md_st* %77, i8* %0, i32 %79, i8* %80, i64 %81, i8* %82, i32* null)
  %84 = getelementptr inbounds [65 x i8], [65 x i8]* %4, i32 0, i32 0
  %85 = getelementptr inbounds i8, i8* %2, i64 20
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 16 %84, i8* align 1 %85, i64 20, i1 false), !track !237
  br label %86

; <label>:86:                                     ; preds = %73, %109
  %.34 = phi i32 [ 1, %73 ], [ %110, %109 ]
  call void @unroll_loop(i32 152)
  %87 = bitcast %struct.SHAstate_st* %8 to i8*
  %88 = bitcast %struct.SHAstate_st* %6 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %87, i8* align 4 %88, i64 96, i1 false), !track !238
  %89 = getelementptr inbounds [65 x i8], [65 x i8]* %4, i32 0, i32 0
  %90 = call i32 @SHA1_Update(%struct.SHAstate_st* %8, i8* %89, i64 20)
  %91 = getelementptr inbounds [65 x i8], [65 x i8]* %4, i32 0, i32 0
  %92 = call i32 @SHA1_Final(i8* %91, %struct.SHAstate_st* %8)
  %93 = bitcast %struct.SHAstate_st* %8 to i8*
  %94 = bitcast %struct.SHAstate_st* %7 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %93, i8* align 4 %94, i64 96, i1 false), !track !239
  %95 = getelementptr inbounds [65 x i8], [65 x i8]* %4, i32 0, i32 0
  %96 = call i32 @SHA1_Update(%struct.SHAstate_st* %8, i8* %95, i64 20)
  %97 = getelementptr inbounds [65 x i8], [65 x i8]* %4, i32 0, i32 0
  %98 = call i32 @SHA1_Final(i8* %97, %struct.SHAstate_st* %8)
  br label %99

; <label>:99:                                     ; preds = %86, %99
  %indvars.iv = phi i64 [ 0, %86 ], [ %indvars.iv.next, %99 ]
  call void @unroll_loop(i32 153)
  %100 = getelementptr inbounds [65 x i8], [65 x i8]* %4, i64 0, i64 %indvars.iv
  %101 = load i8, i8* %100, align 1
  %102 = zext i8 %101 to i32
  %103 = add nuw nsw i64 %indvars.iv, 20
  %104 = getelementptr inbounds i8, i8* %2, i64 %103
  %105 = load i8, i8* %104, align 1
  %106 = zext i8 %105 to i32
  %107 = xor i32 %106, %102
  %108 = trunc i32 %107 to i8
  store i8 %108, i8* %104, align 1
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond = icmp ne i64 %indvars.iv.next, 20
  br i1 %exitcond, label %99, label %109

; <label>:109:                                    ; preds = %99
  %110 = add nuw nsw i32 %.34, 1
  %exitcond5 = icmp ne i32 %110, 4096
  br i1 %exitcond5, label %86, label %111

; <label>:111:                                    ; preds = %109
  ret void
}

declare dso_local i32 @SHA1_Init(%struct.SHAstate_st*) #1

declare dso_local i32 @SHA1_Update(%struct.SHAstate_st*, i8*, i64) #1

declare dso_local i32 @SHA1_Final(i8*, %struct.SHAstate_st*) #1

; Function Attrs: noinline nounwind uwtable
define dso_local void @calc_mic(%struct.AP_info*, i8*, i8*, i8*) #0 {
  %5 = alloca [100 x i8], align 16
  %6 = alloca %struct.hmac_ctx_st, align 8
  %7 = getelementptr inbounds [100 x i8], [100 x i8]* %5, i32 0, i32 0
  %8 = getelementptr [23 x i8], [23 x i8]* @.str.159, i32 0, i32 0
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 16 %7, i8* align 1 %8, i64 23, i1 false)
  %9 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %0, i32 0, i32 14
  %10 = getelementptr inbounds %struct.WPA_hdsk, %struct.WPA_hdsk* %9, i32 0, i32 0
  %11 = getelementptr inbounds [6 x i8], [6 x i8]* %10, i32 0, i32 0
  %12 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %0, i32 0, i32 1
  %13 = getelementptr inbounds [6 x i8], [6 x i8]* %12, i32 0, i32 0
  %14 = call i32 @memcmp(i8* %11, i8* %13, i64 6) #10
  %15 = icmp slt i32 %14, 0
  %16 = getelementptr inbounds [100 x i8], [100 x i8]* %5, i32 0, i32 0
  %17 = getelementptr inbounds i8, i8* %16, i64 23
  br i1 %15, label %18, label %26

; <label>:18:                                     ; preds = %4
  %19 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %0, i32 0, i32 14
  %20 = getelementptr inbounds %struct.WPA_hdsk, %struct.WPA_hdsk* %19, i32 0, i32 0
  %21 = getelementptr inbounds [6 x i8], [6 x i8]* %20, i32 0, i32 0
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %17, i8* align 8 %21, i64 6, i1 false)
  %22 = getelementptr inbounds [100 x i8], [100 x i8]* %5, i32 0, i32 0
  %23 = getelementptr inbounds i8, i8* %22, i64 29
  %24 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %0, i32 0, i32 1
  %25 = getelementptr inbounds [6 x i8], [6 x i8]* %24, i32 0, i32 0
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %23, i8* align 8 %25, i64 6, i1 false)
  br label %34

; <label>:26:                                     ; preds = %4
  %27 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %0, i32 0, i32 1
  %28 = getelementptr inbounds [6 x i8], [6 x i8]* %27, i32 0, i32 0
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %17, i8* align 8 %28, i64 6, i1 false)
  %29 = getelementptr inbounds [100 x i8], [100 x i8]* %5, i32 0, i32 0
  %30 = getelementptr inbounds i8, i8* %29, i64 29
  %31 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %0, i32 0, i32 14
  %32 = getelementptr inbounds %struct.WPA_hdsk, %struct.WPA_hdsk* %31, i32 0, i32 0
  %33 = getelementptr inbounds [6 x i8], [6 x i8]* %32, i32 0, i32 0
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %30, i8* align 8 %33, i64 6, i1 false)
  br label %34

; <label>:34:                                     ; preds = %26, %18
  %35 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %0, i32 0, i32 14
  %36 = getelementptr inbounds %struct.WPA_hdsk, %struct.WPA_hdsk* %35, i32 0, i32 1
  %37 = getelementptr inbounds [32 x i8], [32 x i8]* %36, i32 0, i32 0
  %38 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %0, i32 0, i32 14
  %39 = getelementptr inbounds %struct.WPA_hdsk, %struct.WPA_hdsk* %38, i32 0, i32 2
  %40 = getelementptr inbounds [32 x i8], [32 x i8]* %39, i32 0, i32 0
  %41 = call i32 @memcmp(i8* %37, i8* %40, i64 32) #10
  %42 = icmp slt i32 %41, 0
  %43 = getelementptr inbounds [100 x i8], [100 x i8]* %5, i32 0, i32 0
  %44 = getelementptr inbounds i8, i8* %43, i64 35
  %45 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %0, i32 0, i32 14
  br i1 %42, label %46, label %54

; <label>:46:                                     ; preds = %34
  %47 = getelementptr inbounds %struct.WPA_hdsk, %struct.WPA_hdsk* %45, i32 0, i32 1
  %48 = getelementptr inbounds [32 x i8], [32 x i8]* %47, i32 0, i32 0
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %44, i8* align 2 %48, i64 32, i1 false)
  %49 = getelementptr inbounds [100 x i8], [100 x i8]* %5, i32 0, i32 0
  %50 = getelementptr inbounds i8, i8* %49, i64 67
  %51 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %0, i32 0, i32 14
  %52 = getelementptr inbounds %struct.WPA_hdsk, %struct.WPA_hdsk* %51, i32 0, i32 2
  %53 = getelementptr inbounds [32 x i8], [32 x i8]* %52, i32 0, i32 0
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %50, i8* align 2 %53, i64 32, i1 false)
  br label %62

; <label>:54:                                     ; preds = %34
  %55 = getelementptr inbounds %struct.WPA_hdsk, %struct.WPA_hdsk* %45, i32 0, i32 2
  %56 = getelementptr inbounds [32 x i8], [32 x i8]* %55, i32 0, i32 0
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %44, i8* align 2 %56, i64 32, i1 false)
  %57 = getelementptr inbounds [100 x i8], [100 x i8]* %5, i32 0, i32 0
  %58 = getelementptr inbounds i8, i8* %57, i64 67
  %59 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %0, i32 0, i32 14
  %60 = getelementptr inbounds %struct.WPA_hdsk, %struct.WPA_hdsk* %59, i32 0, i32 1
  %61 = getelementptr inbounds [32 x i8], [32 x i8]* %60, i32 0, i32 0
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %58, i8* align 2 %61, i64 32, i1 false)
  br label %62

; <label>:62:                                     ; preds = %54, %46
  call void @HMAC_CTX_init(%struct.hmac_ctx_st* %6)
  %63 = call %struct.env_md_st* @EVP_sha1()
  %64 = call i32 @HMAC_Init_ex(%struct.hmac_ctx_st* %6, i8* %1, i32 32, %struct.env_md_st* %63, %struct.engine_st* null)
  br label %65

; <label>:65:                                     ; preds = %62, %65
  %indvars.iv = phi i64 [ 0, %62 ], [ %indvars.iv.next, %65 ]
  %.01 = phi i32 [ 0, %62 ], [ %74, %65 ]
  %66 = trunc i32 %.01 to i8
  %67 = getelementptr inbounds [100 x i8], [100 x i8]* %5, i64 0, i64 99
  store i8 %66, i8* %67, align 1
  %68 = call i32 @HMAC_Init_ex(%struct.hmac_ctx_st* %6, i8* null, i32 0, %struct.env_md_st* null, %struct.engine_st* null)
  %69 = getelementptr inbounds [100 x i8], [100 x i8]* %5, i32 0, i32 0
  %70 = call i32 @HMAC_Update(%struct.hmac_ctx_st* %6, i8* %69, i64 100)
  %71 = mul nuw nsw i64 %indvars.iv, 20
  %72 = getelementptr inbounds i8, i8* %2, i64 %71
  %73 = call i32 @HMAC_Final(%struct.hmac_ctx_st* %6, i8* %72, i32* null)
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %74 = add nuw nsw i32 %.01, 1
  %exitcond = icmp ne i64 %indvars.iv.next, 4
  br i1 %exitcond, label %65, label %75

; <label>:75:                                     ; preds = %65
  call void @HMAC_CTX_cleanup(%struct.hmac_ctx_st* %6)
  %76 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %0, i32 0, i32 14
  %77 = getelementptr inbounds %struct.WPA_hdsk, %struct.WPA_hdsk* %76, i32 0, i32 6
  %78 = load i32, i32* %77, align 4
  %79 = icmp eq i32 %78, 1
  br i1 %79, label %80, label %90

; <label>:80:                                     ; preds = %75
  %81 = call %struct.env_md_st* @EVP_md5()
  %82 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %0, i32 0, i32 14
  %83 = getelementptr inbounds %struct.WPA_hdsk, %struct.WPA_hdsk* %82, i32 0, i32 4
  %84 = getelementptr inbounds [256 x i8], [256 x i8]* %83, i32 0, i32 0
  %85 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %0, i32 0, i32 14
  %86 = getelementptr inbounds %struct.WPA_hdsk, %struct.WPA_hdsk* %85, i32 0, i32 5
  %87 = load i32, i32* %86, align 8
  %88 = sext i32 %87 to i64
  %89 = call i8* @HMAC(%struct.env_md_st* %81, i8* %2, i32 16, i8* %84, i64 %88, i8* %3, i32* null)
  br label %100

; <label>:90:                                     ; preds = %75
  %91 = call %struct.env_md_st* @EVP_sha1()
  %92 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %0, i32 0, i32 14
  %93 = getelementptr inbounds %struct.WPA_hdsk, %struct.WPA_hdsk* %92, i32 0, i32 4
  %94 = getelementptr inbounds [256 x i8], [256 x i8]* %93, i32 0, i32 0
  %95 = getelementptr inbounds %struct.AP_info, %struct.AP_info* %0, i32 0, i32 14
  %96 = getelementptr inbounds %struct.WPA_hdsk, %struct.WPA_hdsk* %95, i32 0, i32 5
  %97 = load i32, i32* %96, align 8
  %98 = sext i32 %97 to i64
  %99 = call i8* @HMAC(%struct.env_md_st* %91, i8* %2, i32 16, i8* %94, i64 %98, i8* %3, i32* null)
  br label %100

; <label>:100:                                    ; preds = %90, %80
  ret void
}

declare dso_local void @HMAC_CTX_init(%struct.hmac_ctx_st*) #1

declare dso_local i32 @HMAC_Init_ex(%struct.hmac_ctx_st*, i8*, i32, %struct.env_md_st*, %struct.engine_st*) #1

declare dso_local i32 @HMAC_Update(%struct.hmac_ctx_st*, i8*, i64) #1

declare dso_local i32 @HMAC_Final(%struct.hmac_ctx_st*, i8*, i32*) #1

declare dso_local void @HMAC_CTX_cleanup(%struct.hmac_ctx_st*) #1

; Function Attrs: noinline nounwind uwtable
define dso_local i64 @calc_crc_plain(i8*, i32) #0 {
  %3 = icmp sgt i32 %1, 0
  br i1 %3, label %.lr.ph.preheader, label %._crit_edge

.lr.ph.preheader:                                 ; preds = %2
  br label %.lr.ph

.lr.ph:                                           ; preds = %.lr.ph.preheader, %.lr.ph
  %.05 = phi i8* [ %13, %.lr.ph ], [ %0, %.lr.ph.preheader ]
  %.014 = phi i32 [ %12, %.lr.ph ], [ %1, %.lr.ph.preheader ]
  %.023 = phi i64 [ %11, %.lr.ph ], [ 0, %.lr.ph.preheader ]
  %4 = load i8, i8* %.05, align 1
  %5 = zext i8 %4 to i64
  %6 = xor i64 %.023, %5
  %7 = and i64 %6, 255
  %8 = getelementptr inbounds [256 x i64], [256 x i64]* @crc_tbl, i64 0, i64 %7
  %9 = load i64, i64* %8, align 8
  %10 = lshr i64 %.023, 8
  %11 = xor i64 %9, %10
  %12 = add nsw i32 %.014, -1
  %13 = getelementptr inbounds i8, i8* %.05, i32 1
  %14 = icmp sgt i32 %12, 0
  br i1 %14, label %.lr.ph, label %._crit_edge.loopexit

._crit_edge.loopexit:                             ; preds = %.lr.ph
  %.02.lcssa.ph = phi i64 [ %11, %.lr.ph ]
  br label %._crit_edge

._crit_edge:                                      ; preds = %._crit_edge.loopexit, %2
  %.02.lcssa = phi i64 [ 0, %2 ], [ %.02.lcssa.ph, %._crit_edge.loopexit ]
  ret i64 %.02.lcssa
}

; Function Attrs: noinline nounwind uwtable
define dso_local i32 @add_crc32(i8*, i32) #0 {
  %3 = call i64 @calc_crc(i8* %0, i32 %1)
  %4 = and i64 %3, 255
  %5 = trunc i64 %4 to i8
  %6 = sext i32 %1 to i64
  %7 = getelementptr inbounds i8, i8* %0, i64 %6
  store i8 %5, i8* %7, align 1
  %8 = lshr i64 %3, 8
  %9 = and i64 %8, 255
  %10 = trunc i64 %9 to i8
  %11 = add nsw i32 %1, 1
  %12 = sext i32 %11 to i64
  %13 = getelementptr inbounds i8, i8* %0, i64 %12
  store i8 %10, i8* %13, align 1
  %14 = lshr i64 %3, 16
  %15 = and i64 %14, 255
  %16 = trunc i64 %15 to i8
  %17 = add nsw i32 %1, 2
  %18 = sext i32 %17 to i64
  %19 = getelementptr inbounds i8, i8* %0, i64 %18
  store i8 %16, i8* %19, align 1
  %20 = lshr i64 %3, 24
  %21 = and i64 %20, 255
  %22 = trunc i64 %21 to i8
  %23 = add nsw i32 %1, 3
  %24 = sext i32 %23 to i64
  %25 = getelementptr inbounds i8, i8* %0, i64 %24
  store i8 %22, i8* %25, align 1
  ret i32 0
}

; Function Attrs: noinline nounwind uwtable
define dso_local i32 @add_crc32_plain(i8*, i32) #0 {
  %3 = call i64 @calc_crc_plain(i8* %0, i32 %1)
  %4 = and i64 %3, 255
  %5 = trunc i64 %4 to i8
  %6 = sext i32 %1 to i64
  %7 = getelementptr inbounds i8, i8* %0, i64 %6
  store i8 %5, i8* %7, align 1
  %8 = lshr i64 %3, 8
  %9 = and i64 %8, 255
  %10 = trunc i64 %9 to i8
  %11 = add nsw i32 %1, 1
  %12 = sext i32 %11 to i64
  %13 = getelementptr inbounds i8, i8* %0, i64 %12
  store i8 %10, i8* %13, align 1
  %14 = lshr i64 %3, 16
  %15 = and i64 %14, 255
  %16 = trunc i64 %15 to i8
  %17 = add nsw i32 %1, 2
  %18 = sext i32 %17 to i64
  %19 = getelementptr inbounds i8, i8* %0, i64 %18
  store i8 %16, i8* %19, align 1
  %20 = lshr i64 %3, 24
  %21 = and i64 %20, 255
  %22 = trunc i64 %21 to i8
  %23 = add nsw i32 %1, 3
  %24 = sext i32 %23 to i64
  %25 = getelementptr inbounds i8, i8* %0, i64 %24
  store i8 %22, i8* %25, align 1
  ret i32 0
}

; Function Attrs: noinline nounwind uwtable
define dso_local i32 @calc_crc_buf(i8*, i32) #0 {
  %3 = call i64 @calc_crc(i8* %0, i32 %1)
  %4 = trunc i64 %3 to i32
  ret i32 %4
}

; Function Attrs: noinline nounwind uwtable
define dso_local i8* @get_da(i8*) #0 {
  %2 = getelementptr inbounds i8, i8* %0, i64 1
  %3 = load i8, i8* %2, align 1
  %4 = zext i8 %3 to i32
  %5 = and i32 %4, 2
  %6 = icmp ne i32 %5, 0
  %7 = getelementptr inbounds i8, i8* %0, i64 4
  %8 = getelementptr inbounds i8, i8* %7, i64 12
  %.0 = select i1 %6, i8* %7, i8* %8
  ret i8* %.0
}

; Function Attrs: noinline nounwind uwtable
define dso_local i8* @get_sa(i8*) #8 {
  %2 = getelementptr inbounds i8, i8* %0, i64 1
  %3 = load i8, i8* %2, align 1
  %4 = zext i8 %3 to i32
  %5 = and i32 %4, 2
  %6 = icmp ne i32 %5, 0
  %7 = getelementptr inbounds i8, i8* %0, i64 4
  %8 = getelementptr inbounds i8, i8* %7, i64 12
  %9 = getelementptr inbounds i8, i8* %7, i64 6
  %.0 = select i1 %6, i8* %8, i8* %9
  ret i8* %.0
}

; Function Attrs: noinline nounwind uwtable
define dso_local i32 @is_ipv6(i8*) #0 {
  %2 = getelementptr i8, i8* %0, i64 4
  %3 = getelementptr [3 x i8], [3 x i8]* @.str.1.160, i32 0, i32 0
  %4 = call i32 @memcmp(i8* %2, i8* %3, i64 2) #10
  %5 = icmp eq i32 %4, 0
  br i1 %5, label %11, label %6

; <label>:6:                                      ; preds = %1
  %7 = getelementptr i8, i8* %0, i64 16
  %8 = getelementptr [3 x i8], [3 x i8]* @.str.1.160, i32 0, i32 0
  %9 = call i32 @memcmp(i8* %7, i8* %8, i64 2) #10
  %10 = icmp eq i32 %9, 0
  %spec.select = select i1 %10, i32 1, i32 0
  ret i32 %spec.select

; <label>:11:                                     ; preds = %1
  ret i32 1
}

; Function Attrs: noinline nounwind uwtable
define dso_local i32 @is_dhcp_discover(i8*, i32) #0 {
  %3 = getelementptr i8, i8* %0, i64 4
  %4 = getelementptr [7 x i8], [7 x i8]* @.str.2.161, i32 0, i32 0
  %5 = call i32 @memcmp(i8* %3, i8* %4, i64 6) #10
  %6 = icmp eq i32 %5, 0
  br i1 %6, label %14, label %7

; <label>:7:                                      ; preds = %2
  %8 = getelementptr i8, i8* %0, i64 16
  %9 = getelementptr [7 x i8], [7 x i8]* @.str.2.161, i32 0, i32 0
  %10 = call i32 @memcmp(i8* %8, i8* %9, i64 6) #10
  %11 = icmp eq i32 %10, 0
  %12 = icmp sge i32 %1, 328
  %or.cond = and i1 %11, %12
  %13 = icmp sle i32 %1, 348
  %or.cond2 = and i1 %or.cond, %13
  br i1 %or.cond2, label %16, label %15

; <label>:14:                                     ; preds = %2
  %.old = icmp sge i32 %1, 328
  %.old1 = icmp sle i32 %1, 348
  %or.cond3 = and i1 %.old, %.old1
  br i1 %or.cond3, label %16, label %15

; <label>:15:                                     ; preds = %14, %7
  br label %16

; <label>:16:                                     ; preds = %7, %14, %15
  %.0 = phi i32 [ 0, %15 ], [ 1, %14 ], [ 1, %7 ]
  ret i32 %.0
}

; Function Attrs: noinline nounwind uwtable
define dso_local i32 @is_arp(i8*, i32) #0 {
  %3 = icmp ne i8* %0, null
  switch i32 %1, label %4 [
    i32 36, label %5
    i32 54, label %5
  ]

; <label>:4:                                      ; preds = %2
  br label %5

; <label>:5:                                      ; preds = %2, %2, %4
  %.0 = phi i32 [ 0, %4 ], [ 1, %2 ], [ 1, %2 ]
  ret i32 %.0
}

; Function Attrs: noinline nounwind uwtable
define dso_local i32 @is_qos_arp_tkip(i8*, i32) #0 {
  %3 = getelementptr inbounds i8, i8* %0, i64 1
  %4 = load i8, i8* %3, align 1
  %5 = zext i8 %4 to i32
  %6 = and i32 %5, 3
  %7 = icmp eq i32 %6, 1
  %8 = icmp eq i32 %1, 82
  %or.cond2 = and i1 %7, %8
  br i1 %or.cond2, label %20, label %9

; <label>:9:                                      ; preds = %2
  %10 = getelementptr inbounds i8, i8* %0, i64 1
  %11 = load i8, i8* %10, align 1
  %12 = zext i8 %11 to i32
  %13 = and i32 %12, 3
  %14 = icmp eq i32 %13, 2
  br i1 %14, label %15, label %19

; <label>:15:                                     ; preds = %9
  %16 = icmp eq i32 %1, 82
  %17 = add nsw i32 82, 18
  %18 = icmp eq i32 %1, %17
  %or.cond = or i1 %16, %18
  br i1 %or.cond, label %20, label %19

; <label>:19:                                     ; preds = %15, %9
  br label %20

; <label>:20:                                     ; preds = %2, %15, %19
  %.0 = phi i32 [ 0, %19 ], [ 1, %15 ], [ 1, %2 ]
  ret i32 %.0
}

; Function Attrs: noinline nounwind uwtable
define dso_local i32 @is_spantree(i8*) #0 {
  %2 = getelementptr i8, i8* %0, i64 4
  %3 = getelementptr [7 x i8], [7 x i8]* @.str.3.162, i32 0, i32 0
  %4 = call i32 @memcmp(i8* %2, i8* %3, i64 6) #10
  %5 = icmp eq i32 %4, 0
  br i1 %5, label %11, label %6

; <label>:6:                                      ; preds = %1
  %7 = getelementptr i8, i8* %0, i64 16
  %8 = getelementptr [7 x i8], [7 x i8]* @.str.3.162, i32 0, i32 0
  %9 = call i32 @memcmp(i8* %7, i8* %8, i64 6) #10
  %10 = icmp eq i32 %9, 0
  %spec.select = select i1 %10, i32 1, i32 0
  ret i32 %spec.select

; <label>:11:                                     ; preds = %1
  ret i32 1
}

; Function Attrs: noinline nounwind uwtable
define dso_local i32 @is_cdp_vtp(i8*) #0 {
  %2 = getelementptr i8, i8* %0, i64 4
  %3 = getelementptr [7 x i8], [7 x i8]* @.str.4.163, i32 0, i32 0
  %4 = call i32 @memcmp(i8* %2, i8* %3, i64 6) #10
  %5 = icmp eq i32 %4, 0
  br i1 %5, label %11, label %6

; <label>:6:                                      ; preds = %1
  %7 = getelementptr i8, i8* %0, i64 16
  %8 = getelementptr [7 x i8], [7 x i8]* @.str.4.163, i32 0, i32 0
  %9 = call i32 @memcmp(i8* %7, i8* %8, i64 6) #10
  %10 = icmp eq i32 %9, 0
  %spec.select = select i1 %10, i32 1, i32 0
  ret i32 %spec.select

; <label>:11:                                     ; preds = %1
  ret i32 1
}

; Function Attrs: noinline nounwind uwtable
define dso_local i32 @known_clear(i8*, i32*, i32*, i8*, i32) #0 {
  %6 = alloca i16, align 2, !track !240
  %7 = call i32 @is_arp(i8* %3, i32 %4)
  %8 = icmp ne i32 %7, 0
  br i1 %8, label %9, label %41

; <label>:9:                                      ; preds = %5
  %10 = sext i32 8 to i64
  %11 = getelementptr [9 x i8], [9 x i8]* @.str.5.166, i32 0, i32 0
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %0, i8* align 1 %11, i64 %10, i1 false), !track !241
  %12 = sext i32 8 to i64
  %13 = getelementptr inbounds i8, i8* %0, i64 %12
  %14 = sext i32 6 to i64
  %15 = getelementptr [7 x i8], [7 x i8]* @.str.6.167, i32 0, i32 0
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %13, i8* align 1 %15, i64 %14, i1 false), !track !242
  %16 = sext i32 6 to i64
  %17 = getelementptr inbounds i8, i8* %13, i64 %16
  %18 = call i8* @get_da(i8* %3)
  %19 = getelementptr [7 x i8], [7 x i8]* @.str.2.161, i32 0, i32 0
  %20 = call i32 @memcmp(i8* %18, i8* %19, i64 6) #10
  %21 = icmp eq i32 %20, 0
  %22 = sext i32 2 to i64
  br i1 %21, label %23, label %25

; <label>:23:                                     ; preds = %9
  %24 = getelementptr [3 x i8], [3 x i8]* @.str.7.168, i32 0, i32 0
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %17, i8* align 1 %24, i64 %22, i1 false), !track !243
  br label %27

; <label>:25:                                     ; preds = %9
  %26 = getelementptr [3 x i8], [3 x i8]* @.str.8.169, i32 0, i32 0
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %17, i8* align 1 %26, i64 %22, i1 false), !track !244
  br label %27

; <label>:27:                                     ; preds = %25, %23
  %28 = sext i32 2 to i64
  %29 = getelementptr inbounds i8, i8* %17, i64 %28
  %30 = call i8* @get_sa(i8* %3)
  %31 = sext i32 6 to i64
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %29, i8* align 1 %30, i64 %31, i1 false), !track !245
  %32 = sext i32 6 to i64
  %33 = getelementptr inbounds i8, i8* %29, i64 %32
  %34 = ptrtoint i8* %33 to i64
  %35 = ptrtoint i8* %0 to i64
  %36 = sub i64 %34, %35
  %37 = trunc i64 %36 to i32
  store i32 %37, i32* %1, align 4
  %38 = icmp ne i32* %2, null
  br i1 %38, label %39, label %113

; <label>:39:                                     ; preds = %27
  %40 = getelementptr inbounds i32, i32* %2, i64 0
  store i32 256, i32* %40, align 4
  br label %113

; <label>:41:                                     ; preds = %5
  %42 = call i32 @is_spantree(i8* %3)
  %43 = icmp ne i32 %42, 0
  br i1 %43, label %44, label %56

; <label>:44:                                     ; preds = %41
  %45 = sext i32 8 to i64
  %46 = getelementptr [9 x i8], [9 x i8]* @.str.9.170, i32 0, i32 0
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %0, i8* align 1 %46, i64 %45, i1 false), !track !246
  %47 = sext i32 8 to i64
  %48 = getelementptr inbounds i8, i8* %0, i64 %47
  %49 = ptrtoint i8* %48 to i64
  %50 = ptrtoint i8* %0 to i64
  %51 = sub i64 %49, %50
  %52 = trunc i64 %51 to i32
  store i32 %52, i32* %1, align 4
  %53 = icmp ne i32* %2, null
  br i1 %53, label %54, label %113

; <label>:54:                                     ; preds = %44
  %55 = getelementptr inbounds i32, i32* %2, i64 0
  store i32 256, i32* %55, align 4
  br label %113

; <label>:56:                                     ; preds = %41
  %57 = call i32 @is_cdp_vtp(i8* %3)
  %58 = icmp ne i32 %57, 0
  br i1 %58, label %59, label %71

; <label>:59:                                     ; preds = %56
  %60 = sext i32 7 to i64
  %61 = getelementptr [8 x i8], [8 x i8]* @.str.10.171, i32 0, i32 0
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %0, i8* align 1 %61, i64 %60, i1 false), !track !247
  %62 = sext i32 7 to i64
  %63 = getelementptr inbounds i8, i8* %0, i64 %62
  %64 = ptrtoint i8* %63 to i64
  %65 = ptrtoint i8* %0 to i64
  %66 = sub i64 %64, %65
  %67 = trunc i64 %66 to i32
  store i32 %67, i32* %1, align 4
  %68 = icmp ne i32* %2, null
  br i1 %68, label %69, label %113

; <label>:69:                                     ; preds = %59
  %70 = getelementptr inbounds i32, i32* %2, i64 0
  store i32 256, i32* %70, align 4
  br label %113

; <label>:71:                                     ; preds = %56
  %72 = sub nsw i32 %4, 8
  %73 = trunc i32 %72 to i16
  %74 = call zeroext i16 @htons(i16 zeroext %73) #13
  store i16 %74, i16* %6, align 2
  %75 = sext i32 8 to i64
  %76 = getelementptr [9 x i8], [9 x i8]* @.str.11.172, i32 0, i32 0
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %0, i8* align 1 %76, i64 %75, i1 false), !track !248
  %77 = sext i32 8 to i64
  %78 = getelementptr inbounds i8, i8* %0, i64 %77
  %79 = sext i32 2 to i64
  %80 = getelementptr [3 x i8], [3 x i8]* @.str.12.173, i32 0, i32 0
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %78, i8* align 1 %80, i64 %79, i1 false), !track !249
  %81 = sext i32 2 to i64
  %82 = getelementptr inbounds i8, i8* %78, i64 %81
  %83 = bitcast i16* %6 to i8*
  %84 = sext i32 2 to i64
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %82, i8* align 2 %83, i64 %84, i1 false), !track !250
  %85 = sext i32 2 to i64
  %86 = getelementptr inbounds i8, i8* %82, i64 %85
  %87 = icmp ne i32* %2, null
  br i1 %87, label %93, label %88

; <label>:88:                                     ; preds = %71
  %89 = ptrtoint i8* %86 to i64
  %90 = ptrtoint i8* %0 to i64
  %91 = sub i64 %89, %90
  %92 = trunc i64 %91 to i32
  store i32 %92, i32* %1, align 4
  br label %113

; <label>:93:                                     ; preds = %71
  %94 = sext i32 2 to i64
  %95 = getelementptr [3 x i8], [3 x i8]* @.str.13.174, i32 0, i32 0
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %86, i8* align 1 %95, i64 %94, i1 false), !track !251
  %96 = sext i32 2 to i64
  %97 = getelementptr inbounds i8, i8* %86, i64 %96
  %98 = sext i32 2 to i64
  %99 = getelementptr [3 x i8], [3 x i8]* @.str.14.175, i32 0, i32 0
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %97, i8* align 1 %99, i64 %98, i1 false), !track !252
  %100 = sext i32 2 to i64
  %101 = getelementptr inbounds i8, i8* %97, i64 %100
  %102 = ptrtoint i8* %101 to i64
  %103 = ptrtoint i8* %0 to i64
  %104 = sub i64 %102, %103
  %105 = trunc i64 %104 to i32
  store i32 %105, i32* %1, align 4
  %106 = getelementptr i8, i8* %0, i64 32
  %107 = sext i32 %105 to i64
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %106, i8* align 1 %0, i64 %107, i1 false), !track !253
  %108 = getelementptr i8, i8* %0, i64 32
  %109 = getelementptr i8, i8* %108, i64 14
  %110 = getelementptr [3 x i8], [3 x i8]* @.str.13.174, i32 0, i32 0
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %109, i8* align 1 %110, i64 2, i1 false), !track !254
  %111 = getelementptr inbounds i32, i32* %2, i64 0
  store i32 220, i32* %111, align 4
  %112 = getelementptr inbounds i32, i32* %2, i64 1
  store i32 36, i32* %112, align 4
  br label %113

; <label>:113:                                    ; preds = %59, %69, %44, %54, %27, %39, %93, %88
  %.0 = phi i32 [ 2, %93 ], [ 1, %88 ], [ 1, %39 ], [ 1, %27 ], [ 1, %54 ], [ 1, %44 ], [ 1, %69 ], [ 1, %59 ]
  ret i32 %.0
}

; Function Attrs: nounwind readnone
declare dso_local zeroext i16 @htons(i16 zeroext) #7

; Function Attrs: noreturn nounwind
declare dso_local void @__assert_fail(i8*, i8*, i32, i8*) #5

; Function Attrs: noinline nounwind uwtable
define dso_local i32 @calc_ptk(%struct.WPA_ST_info*, i8*) #0 {
  %3 = alloca [100 x i8], align 16
  %4 = alloca [20 x i8], align 16
  %5 = getelementptr inbounds [100 x i8], [100 x i8]* %3, i32 0, i32 0
  %6 = getelementptr [23 x i8], [23 x i8]* @.str.159, i32 0, i32 0
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 16 %5, i8* align 1 %6, i64 23, i1 false)
  %7 = getelementptr inbounds %struct.WPA_ST_info, %struct.WPA_ST_info* %0, i32 0, i32 1
  %8 = getelementptr inbounds [6 x i8], [6 x i8]* %7, i32 0, i32 0
  %9 = getelementptr inbounds %struct.WPA_ST_info, %struct.WPA_ST_info* %0, i32 0, i32 2
  %10 = getelementptr inbounds [6 x i8], [6 x i8]* %9, i32 0, i32 0
  %11 = call i32 @memcmp(i8* %8, i8* %10, i64 6) #10
  %12 = icmp slt i32 %11, 0
  %13 = getelementptr inbounds [100 x i8], [100 x i8]* %3, i32 0, i32 0
  %14 = getelementptr inbounds i8, i8* %13, i64 23
  br i1 %12, label %15, label %22

; <label>:15:                                     ; preds = %2
  %16 = getelementptr inbounds %struct.WPA_ST_info, %struct.WPA_ST_info* %0, i32 0, i32 1
  %17 = getelementptr inbounds [6 x i8], [6 x i8]* %16, i32 0, i32 0
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %14, i8* align 8 %17, i64 6, i1 false)
  %18 = getelementptr inbounds [100 x i8], [100 x i8]* %3, i32 0, i32 0
  %19 = getelementptr inbounds i8, i8* %18, i64 29
  %20 = getelementptr inbounds %struct.WPA_ST_info, %struct.WPA_ST_info* %0, i32 0, i32 2
  %21 = getelementptr inbounds [6 x i8], [6 x i8]* %20, i32 0, i32 0
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %19, i8* align 2 %21, i64 6, i1 false)
  br label %29

; <label>:22:                                     ; preds = %2
  %23 = getelementptr inbounds %struct.WPA_ST_info, %struct.WPA_ST_info* %0, i32 0, i32 2
  %24 = getelementptr inbounds [6 x i8], [6 x i8]* %23, i32 0, i32 0
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %14, i8* align 2 %24, i64 6, i1 false)
  %25 = getelementptr inbounds [100 x i8], [100 x i8]* %3, i32 0, i32 0
  %26 = getelementptr inbounds i8, i8* %25, i64 29
  %27 = getelementptr inbounds %struct.WPA_ST_info, %struct.WPA_ST_info* %0, i32 0, i32 1
  %28 = getelementptr inbounds [6 x i8], [6 x i8]* %27, i32 0, i32 0
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %26, i8* align 8 %28, i64 6, i1 false)
  br label %29

; <label>:29:                                     ; preds = %22, %15
  %30 = getelementptr inbounds %struct.WPA_ST_info, %struct.WPA_ST_info* %0, i32 0, i32 3
  %31 = getelementptr inbounds [32 x i8], [32 x i8]* %30, i32 0, i32 0
  %32 = getelementptr inbounds %struct.WPA_ST_info, %struct.WPA_ST_info* %0, i32 0, i32 4
  %33 = getelementptr inbounds [32 x i8], [32 x i8]* %32, i32 0, i32 0
  %34 = call i32 @memcmp(i8* %31, i8* %33, i64 32) #10
  %35 = icmp slt i32 %34, 0
  %36 = getelementptr inbounds [100 x i8], [100 x i8]* %3, i32 0, i32 0
  %37 = getelementptr inbounds i8, i8* %36, i64 35
  br i1 %35, label %38, label %45

; <label>:38:                                     ; preds = %29
  %39 = getelementptr inbounds %struct.WPA_ST_info, %struct.WPA_ST_info* %0, i32 0, i32 3
  %40 = getelementptr inbounds [32 x i8], [32 x i8]* %39, i32 0, i32 0
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %37, i8* align 4 %40, i64 32, i1 false)
  %41 = getelementptr inbounds [100 x i8], [100 x i8]* %3, i32 0, i32 0
  %42 = getelementptr inbounds i8, i8* %41, i64 67
  %43 = getelementptr inbounds %struct.WPA_ST_info, %struct.WPA_ST_info* %0, i32 0, i32 4
  %44 = getelementptr inbounds [32 x i8], [32 x i8]* %43, i32 0, i32 0
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %42, i8* align 4 %44, i64 32, i1 false)
  br label %52

; <label>:45:                                     ; preds = %29
  %46 = getelementptr inbounds %struct.WPA_ST_info, %struct.WPA_ST_info* %0, i32 0, i32 4
  %47 = getelementptr inbounds [32 x i8], [32 x i8]* %46, i32 0, i32 0
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %37, i8* align 4 %47, i64 32, i1 false)
  %48 = getelementptr inbounds [100 x i8], [100 x i8]* %3, i32 0, i32 0
  %49 = getelementptr inbounds i8, i8* %48, i64 67
  %50 = getelementptr inbounds %struct.WPA_ST_info, %struct.WPA_ST_info* %0, i32 0, i32 3
  %51 = getelementptr inbounds [32 x i8], [32 x i8]* %50, i32 0, i32 0
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %49, i8* align 4 %51, i64 32, i1 false)
  br label %52

; <label>:52:                                     ; preds = %45, %38
  br label %53

; <label>:53:                                     ; preds = %52, %53
  %indvars.iv = phi i64 [ 0, %52 ], [ %indvars.iv.next, %53 ]
  %.01 = phi i32 [ 0, %52 ], [ %63, %53 ]
  %54 = trunc i32 %.01 to i8
  %55 = getelementptr inbounds [100 x i8], [100 x i8]* %3, i64 0, i64 99
  store i8 %54, i8* %55, align 1
  %56 = call %struct.env_md_st* @EVP_sha1()
  %57 = getelementptr inbounds [100 x i8], [100 x i8]* %3, i32 0, i32 0
  %58 = getelementptr inbounds %struct.WPA_ST_info, %struct.WPA_ST_info* %0, i32 0, i32 7
  %59 = getelementptr inbounds [80 x i8], [80 x i8]* %58, i32 0, i32 0
  %60 = mul nuw nsw i64 %indvars.iv, 20
  %61 = getelementptr inbounds i8, i8* %59, i64 %60
  %62 = call i8* @HMAC(%struct.env_md_st* %56, i8* %1, i32 32, i8* %57, i64 100, i8* %61, i32* null)
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %63 = add nuw nsw i32 %.01, 1
  %exitcond = icmp ne i64 %indvars.iv.next, 4
  br i1 %exitcond, label %53, label %64

; <label>:64:                                     ; preds = %53
  %65 = getelementptr inbounds %struct.WPA_ST_info, %struct.WPA_ST_info* %0, i32 0, i32 11
  %66 = load i32, i32* %65, align 8
  %67 = and i32 %66, 7
  %68 = icmp eq i32 %67, 1
  br i1 %68, label %69, label %80

; <label>:69:                                     ; preds = %64
  %70 = call %struct.env_md_st* @EVP_md5()
  %71 = getelementptr inbounds %struct.WPA_ST_info, %struct.WPA_ST_info* %0, i32 0, i32 7
  %72 = getelementptr inbounds [80 x i8], [80 x i8]* %71, i32 0, i32 0
  %73 = getelementptr inbounds %struct.WPA_ST_info, %struct.WPA_ST_info* %0, i32 0, i32 6
  %74 = getelementptr inbounds [256 x i8], [256 x i8]* %73, i32 0, i32 0
  %75 = getelementptr inbounds %struct.WPA_ST_info, %struct.WPA_ST_info* %0, i32 0, i32 8
  %76 = load i32, i32* %75, align 8
  %77 = sext i32 %76 to i64
  %78 = getelementptr inbounds [20 x i8], [20 x i8]* %4, i32 0, i32 0
  %79 = call i8* @HMAC(%struct.env_md_st* %70, i8* %72, i32 16, i8* %74, i64 %77, i8* %78, i32* null)
  br label %91

; <label>:80:                                     ; preds = %64
  %81 = call %struct.env_md_st* @EVP_sha1()
  %82 = getelementptr inbounds %struct.WPA_ST_info, %struct.WPA_ST_info* %0, i32 0, i32 7
  %83 = getelementptr inbounds [80 x i8], [80 x i8]* %82, i32 0, i32 0
  %84 = getelementptr inbounds %struct.WPA_ST_info, %struct.WPA_ST_info* %0, i32 0, i32 6
  %85 = getelementptr inbounds [256 x i8], [256 x i8]* %84, i32 0, i32 0
  %86 = getelementptr inbounds %struct.WPA_ST_info, %struct.WPA_ST_info* %0, i32 0, i32 8
  %87 = load i32, i32* %86, align 8
  %88 = sext i32 %87 to i64
  %89 = getelementptr inbounds [20 x i8], [20 x i8]* %4, i32 0, i32 0
  %90 = call i8* @HMAC(%struct.env_md_st* %81, i8* %83, i32 16, i8* %85, i64 %88, i8* %89, i32* null)
  br label %91

; <label>:91:                                     ; preds = %80, %69
  %92 = getelementptr inbounds [20 x i8], [20 x i8]* %4, i32 0, i32 0
  %93 = getelementptr inbounds %struct.WPA_ST_info, %struct.WPA_ST_info* %0, i32 0, i32 5
  %94 = getelementptr inbounds [20 x i8], [20 x i8]* %93, i32 0, i32 0
  %95 = call i32 @memcmp(i8* %92, i8* %94, i64 16) #10
  %96 = icmp eq i32 %95, 0
  %97 = zext i1 %96 to i32
  ret i32 %97
}

; Function Attrs: noinline nounwind uwtable
define dso_local i32 @init_michael(%struct.Michael*, i8*) #0 {
  %3 = getelementptr inbounds i8, i8* %1, i64 0
  %4 = load i8, i8* %3, align 1
  %5 = zext i8 %4 to i32
  %6 = shl i32 %5, 0
  %7 = getelementptr inbounds i8, i8* %1, i64 1
  %8 = load i8, i8* %7, align 1
  %9 = zext i8 %8 to i32
  %10 = shl i32 %9, 8
  %11 = or i32 %6, %10
  %12 = getelementptr inbounds i8, i8* %1, i64 2
  %13 = load i8, i8* %12, align 1
  %14 = zext i8 %13 to i32
  %15 = shl i32 %14, 16
  %16 = or i32 %11, %15
  %17 = getelementptr inbounds i8, i8* %1, i64 3
  %18 = load i8, i8* %17, align 1
  %19 = zext i8 %18 to i32
  %20 = shl i32 %19, 24
  %21 = or i32 %16, %20
  %22 = sext i32 %21 to i64
  %23 = getelementptr inbounds %struct.Michael, %struct.Michael* %0, i32 0, i32 0
  store i64 %22, i64* %23, align 8
  %24 = getelementptr inbounds i8, i8* %1, i64 4
  %25 = load i8, i8* %24, align 1
  %26 = zext i8 %25 to i32
  %27 = shl i32 %26, 0
  %28 = getelementptr inbounds i8, i8* %1, i64 5
  %29 = load i8, i8* %28, align 1
  %30 = zext i8 %29 to i32
  %31 = shl i32 %30, 8
  %32 = or i32 %27, %31
  %33 = getelementptr inbounds i8, i8* %1, i64 6
  %34 = load i8, i8* %33, align 1
  %35 = zext i8 %34 to i32
  %36 = shl i32 %35, 16
  %37 = or i32 %32, %36
  %38 = getelementptr inbounds i8, i8* %1, i64 7
  %39 = load i8, i8* %38, align 1
  %40 = zext i8 %39 to i32
  %41 = shl i32 %40, 24
  %42 = or i32 %37, %41
  %43 = sext i32 %42 to i64
  %44 = getelementptr inbounds %struct.Michael, %struct.Michael* %0, i32 0, i32 1
  store i64 %43, i64* %44, align 8
  %45 = getelementptr inbounds %struct.Michael, %struct.Michael* %0, i32 0, i32 0
  %46 = load i64, i64* %45, align 8
  %47 = getelementptr inbounds %struct.Michael, %struct.Michael* %0, i32 0, i32 2
  store i64 %46, i64* %47, align 8
  %48 = getelementptr inbounds %struct.Michael, %struct.Michael* %0, i32 0, i32 1
  %49 = load i64, i64* %48, align 8
  %50 = getelementptr inbounds %struct.Michael, %struct.Michael* %0, i32 0, i32 3
  store i64 %49, i64* %50, align 8
  %51 = getelementptr inbounds %struct.Michael, %struct.Michael* %0, i32 0, i32 4
  store i64 0, i64* %51, align 8
  %52 = getelementptr inbounds %struct.Michael, %struct.Michael* %0, i32 0, i32 5
  store i64 0, i64* %52, align 8
  ret i32 0
}

; Function Attrs: noinline nounwind uwtable
define dso_local i32 @michael_append_byte(%struct.Michael*, i8 zeroext) #0 {
  %3 = zext i8 %1 to i32
  %4 = getelementptr inbounds %struct.Michael, %struct.Michael* %0, i32 0, i32 4
  %5 = load i64, i64* %4, align 8
  %6 = mul i64 8, %5
  %7 = trunc i64 %6 to i32
  %8 = shl i32 %3, %7
  %9 = sext i32 %8 to i64
  %10 = getelementptr inbounds %struct.Michael, %struct.Michael* %0, i32 0, i32 5
  %11 = load i64, i64* %10, align 8
  %12 = or i64 %11, %9
  store i64 %12, i64* %10, align 8
  %13 = getelementptr inbounds %struct.Michael, %struct.Michael* %0, i32 0, i32 4
  %14 = load i64, i64* %13, align 8
  %15 = add i64 %14, 1
  store i64 %15, i64* %13, align 8
  %16 = getelementptr inbounds %struct.Michael, %struct.Michael* %0, i32 0, i32 4
  %17 = load i64, i64* %16, align 8
  %18 = icmp uge i64 %17, 4
  br i1 %18, label %19, label %92

; <label>:19:                                     ; preds = %2
  %20 = getelementptr inbounds %struct.Michael, %struct.Michael* %0, i32 0, i32 5
  %21 = load i64, i64* %20, align 8
  %22 = getelementptr inbounds %struct.Michael, %struct.Michael* %0, i32 0, i32 2
  %23 = load i64, i64* %22, align 8
  %24 = xor i64 %23, %21
  store i64 %24, i64* %22, align 8
  %25 = getelementptr inbounds %struct.Michael, %struct.Michael* %0, i32 0, i32 2
  %26 = load i64, i64* %25, align 8
  %27 = shl i64 %26, 17
  %28 = getelementptr inbounds %struct.Michael, %struct.Michael* %0, i32 0, i32 2
  %29 = load i64, i64* %28, align 8
  %30 = lshr i64 %29, 15
  %31 = and i64 %30, 131071
  %32 = or i64 %27, %31
  %33 = getelementptr inbounds %struct.Michael, %struct.Michael* %0, i32 0, i32 3
  %34 = load i64, i64* %33, align 8
  %35 = xor i64 %34, %32
  store i64 %35, i64* %33, align 8
  %36 = getelementptr inbounds %struct.Michael, %struct.Michael* %0, i32 0, i32 3
  %37 = load i64, i64* %36, align 8
  %38 = getelementptr inbounds %struct.Michael, %struct.Michael* %0, i32 0, i32 2
  %39 = load i64, i64* %38, align 8
  %40 = add i64 %39, %37
  store i64 %40, i64* %38, align 8
  %41 = getelementptr inbounds %struct.Michael, %struct.Michael* %0, i32 0, i32 2
  %42 = load i64, i64* %41, align 8
  %43 = and i64 %42, 4278255360
  %44 = lshr i64 %43, 8
  %45 = getelementptr inbounds %struct.Michael, %struct.Michael* %0, i32 0, i32 2
  %46 = load i64, i64* %45, align 8
  %47 = and i64 %46, 16711935
  %48 = shl i64 %47, 8
  %49 = or i64 %44, %48
  %50 = getelementptr inbounds %struct.Michael, %struct.Michael* %0, i32 0, i32 3
  %51 = load i64, i64* %50, align 8
  %52 = xor i64 %51, %49
  store i64 %52, i64* %50, align 8
  %53 = getelementptr inbounds %struct.Michael, %struct.Michael* %0, i32 0, i32 3
  %54 = load i64, i64* %53, align 8
  %55 = getelementptr inbounds %struct.Michael, %struct.Michael* %0, i32 0, i32 2
  %56 = load i64, i64* %55, align 8
  %57 = add i64 %56, %54
  store i64 %57, i64* %55, align 8
  %58 = getelementptr inbounds %struct.Michael, %struct.Michael* %0, i32 0, i32 2
  %59 = load i64, i64* %58, align 8
  %60 = shl i64 %59, 3
  %61 = getelementptr inbounds %struct.Michael, %struct.Michael* %0, i32 0, i32 2
  %62 = load i64, i64* %61, align 8
  %63 = lshr i64 %62, 29
  %64 = and i64 %63, 7
  %65 = or i64 %60, %64
  %66 = getelementptr inbounds %struct.Michael, %struct.Michael* %0, i32 0, i32 3
  %67 = load i64, i64* %66, align 8
  %68 = xor i64 %67, %65
  store i64 %68, i64* %66, align 8
  %69 = getelementptr inbounds %struct.Michael, %struct.Michael* %0, i32 0, i32 3
  %70 = load i64, i64* %69, align 8
  %71 = getelementptr inbounds %struct.Michael, %struct.Michael* %0, i32 0, i32 2
  %72 = load i64, i64* %71, align 8
  %73 = add i64 %72, %70
  store i64 %73, i64* %71, align 8
  %74 = getelementptr inbounds %struct.Michael, %struct.Michael* %0, i32 0, i32 2
  %75 = load i64, i64* %74, align 8
  %76 = shl i64 %75, 30
  %77 = getelementptr inbounds %struct.Michael, %struct.Michael* %0, i32 0, i32 2
  %78 = load i64, i64* %77, align 8
  %79 = lshr i64 %78, 2
  %80 = and i64 %79, 1073741823
  %81 = or i64 %76, %80
  %82 = getelementptr inbounds %struct.Michael, %struct.Michael* %0, i32 0, i32 3
  %83 = load i64, i64* %82, align 8
  %84 = xor i64 %83, %81
  store i64 %84, i64* %82, align 8
  %85 = getelementptr inbounds %struct.Michael, %struct.Michael* %0, i32 0, i32 3
  %86 = load i64, i64* %85, align 8
  %87 = getelementptr inbounds %struct.Michael, %struct.Michael* %0, i32 0, i32 2
  %88 = load i64, i64* %87, align 8
  %89 = add i64 %88, %86
  store i64 %89, i64* %87, align 8
  %90 = getelementptr inbounds %struct.Michael, %struct.Michael* %0, i32 0, i32 5
  store i64 0, i64* %90, align 8
  %91 = getelementptr inbounds %struct.Michael, %struct.Michael* %0, i32 0, i32 4
  store i64 0, i64* %91, align 8
  br label %92

; <label>:92:                                     ; preds = %19, %2
  ret i32 0
}

; Function Attrs: noinline nounwind uwtable
define dso_local i32 @michael_remove_byte(%struct.Michael*, i8*) #0 {
  %3 = getelementptr inbounds %struct.Michael, %struct.Michael* %0, i32 0, i32 4
  %4 = load i64, i64* %3, align 8
  %5 = icmp eq i64 %4, 0
  br i1 %5, label %6, label %99

; <label>:6:                                      ; preds = %2
  %7 = getelementptr inbounds i8, i8* %1, i64 0
  %8 = load i8, i8* %7, align 1
  %9 = zext i8 %8 to i32
  %10 = shl i32 %9, 0
  %11 = getelementptr inbounds i8, i8* %1, i64 1
  %12 = load i8, i8* %11, align 1
  %13 = zext i8 %12 to i32
  %14 = shl i32 %13, 8
  %15 = or i32 %10, %14
  %16 = getelementptr inbounds i8, i8* %1, i64 2
  %17 = load i8, i8* %16, align 1
  %18 = zext i8 %17 to i32
  %19 = shl i32 %18, 16
  %20 = or i32 %15, %19
  %21 = getelementptr inbounds i8, i8* %1, i64 3
  %22 = load i8, i8* %21, align 1
  %23 = zext i8 %22 to i32
  %24 = shl i32 %23, 24
  %25 = or i32 %20, %24
  %26 = sext i32 %25 to i64
  %27 = getelementptr inbounds %struct.Michael, %struct.Michael* %0, i32 0, i32 5
  store i64 %26, i64* %27, align 8
  %28 = getelementptr inbounds %struct.Michael, %struct.Michael* %0, i32 0, i32 4
  store i64 4, i64* %28, align 8
  %29 = getelementptr inbounds %struct.Michael, %struct.Michael* %0, i32 0, i32 3
  %30 = load i64, i64* %29, align 8
  %31 = getelementptr inbounds %struct.Michael, %struct.Michael* %0, i32 0, i32 2
  %32 = load i64, i64* %31, align 8
  %33 = sub i64 %32, %30
  store i64 %33, i64* %31, align 8
  %34 = getelementptr inbounds %struct.Michael, %struct.Michael* %0, i32 0, i32 2
  %35 = load i64, i64* %34, align 8
  %36 = shl i64 %35, 30
  %37 = getelementptr inbounds %struct.Michael, %struct.Michael* %0, i32 0, i32 2
  %38 = load i64, i64* %37, align 8
  %39 = lshr i64 %38, 2
  %40 = and i64 %39, 1073741823
  %41 = or i64 %36, %40
  %42 = getelementptr inbounds %struct.Michael, %struct.Michael* %0, i32 0, i32 3
  %43 = load i64, i64* %42, align 8
  %44 = xor i64 %43, %41
  store i64 %44, i64* %42, align 8
  %45 = getelementptr inbounds %struct.Michael, %struct.Michael* %0, i32 0, i32 3
  %46 = load i64, i64* %45, align 8
  %47 = getelementptr inbounds %struct.Michael, %struct.Michael* %0, i32 0, i32 2
  %48 = load i64, i64* %47, align 8
  %49 = sub i64 %48, %46
  store i64 %49, i64* %47, align 8
  %50 = getelementptr inbounds %struct.Michael, %struct.Michael* %0, i32 0, i32 2
  %51 = load i64, i64* %50, align 8
  %52 = shl i64 %51, 3
  %53 = getelementptr inbounds %struct.Michael, %struct.Michael* %0, i32 0, i32 2
  %54 = load i64, i64* %53, align 8
  %55 = lshr i64 %54, 29
  %56 = and i64 %55, 7
  %57 = or i64 %52, %56
  %58 = getelementptr inbounds %struct.Michael, %struct.Michael* %0, i32 0, i32 3
  %59 = load i64, i64* %58, align 8
  %60 = xor i64 %59, %57
  store i64 %60, i64* %58, align 8
  %61 = getelementptr inbounds %struct.Michael, %struct.Michael* %0, i32 0, i32 3
  %62 = load i64, i64* %61, align 8
  %63 = getelementptr inbounds %struct.Michael, %struct.Michael* %0, i32 0, i32 2
  %64 = load i64, i64* %63, align 8
  %65 = sub i64 %64, %62
  store i64 %65, i64* %63, align 8
  %66 = getelementptr inbounds %struct.Michael, %struct.Michael* %0, i32 0, i32 2
  %67 = load i64, i64* %66, align 8
  %68 = and i64 %67, 4278255360
  %69 = lshr i64 %68, 8
  %70 = getelementptr inbounds %struct.Michael, %struct.Michael* %0, i32 0, i32 2
  %71 = load i64, i64* %70, align 8
  %72 = and i64 %71, 16711935
  %73 = shl i64 %72, 8
  %74 = or i64 %69, %73
  %75 = getelementptr inbounds %struct.Michael, %struct.Michael* %0, i32 0, i32 3
  %76 = load i64, i64* %75, align 8
  %77 = xor i64 %76, %74
  store i64 %77, i64* %75, align 8
  %78 = getelementptr inbounds %struct.Michael, %struct.Michael* %0, i32 0, i32 3
  %79 = load i64, i64* %78, align 8
  %80 = getelementptr inbounds %struct.Michael, %struct.Michael* %0, i32 0, i32 2
  %81 = load i64, i64* %80, align 8
  %82 = sub i64 %81, %79
  store i64 %82, i64* %80, align 8
  %83 = getelementptr inbounds %struct.Michael, %struct.Michael* %0, i32 0, i32 2
  %84 = load i64, i64* %83, align 8
  %85 = shl i64 %84, 17
  %86 = getelementptr inbounds %struct.Michael, %struct.Michael* %0, i32 0, i32 2
  %87 = load i64, i64* %86, align 8
  %88 = lshr i64 %87, 15
  %89 = and i64 %88, 131071
  %90 = or i64 %85, %89
  %91 = getelementptr inbounds %struct.Michael, %struct.Michael* %0, i32 0, i32 3
  %92 = load i64, i64* %91, align 8
  %93 = xor i64 %92, %90
  store i64 %93, i64* %91, align 8
  %94 = getelementptr inbounds %struct.Michael, %struct.Michael* %0, i32 0, i32 5
  %95 = load i64, i64* %94, align 8
  %96 = getelementptr inbounds %struct.Michael, %struct.Michael* %0, i32 0, i32 2
  %97 = load i64, i64* %96, align 8
  %98 = xor i64 %97, %95
  store i64 %98, i64* %96, align 8
  br label %99

; <label>:99:                                     ; preds = %6, %2
  %100 = getelementptr inbounds %struct.Michael, %struct.Michael* %0, i32 0, i32 4
  %101 = load i64, i64* %100, align 8
  %102 = add i64 %101, -1
  store i64 %102, i64* %100, align 8
  %103 = getelementptr inbounds %struct.Michael, %struct.Michael* %0, i32 0, i32 4
  %104 = load i64, i64* %103, align 8
  %105 = mul i64 8, %104
  %106 = trunc i64 %105 to i32
  %107 = shl i32 255, %106
  %108 = xor i32 %107, -1
  %109 = sext i32 %108 to i64
  %110 = getelementptr inbounds %struct.Michael, %struct.Michael* %0, i32 0, i32 5
  %111 = load i64, i64* %110, align 8
  %112 = and i64 %111, %109
  store i64 %112, i64* %110, align 8
  ret i32 0
}

; Function Attrs: noinline nounwind uwtable
define dso_local i32 @michael_append(%struct.Michael*, i8*, i32) #0 {
  %4 = icmp sgt i32 %2, 0
  br i1 %4, label %.lr.ph.preheader, label %._crit_edge

.lr.ph.preheader:                                 ; preds = %3
  br label %.lr.ph

.lr.ph:                                           ; preds = %.lr.ph.preheader, %.lr.ph
  %.03 = phi i32 [ %8, %.lr.ph ], [ %2, %.lr.ph.preheader ]
  %.012 = phi i8* [ %5, %.lr.ph ], [ %1, %.lr.ph.preheader ]
  %5 = getelementptr inbounds i8, i8* %.012, i32 1
  %6 = load i8, i8* %.012, align 1
  %7 = call i32 @michael_append_byte(%struct.Michael* %0, i8 zeroext %6)
  %8 = add nsw i32 %.03, -1
  %9 = icmp sgt i32 %8, 0
  br i1 %9, label %.lr.ph, label %._crit_edge.loopexit

._crit_edge.loopexit:                             ; preds = %.lr.ph
  br label %._crit_edge

._crit_edge:                                      ; preds = %._crit_edge.loopexit, %3
  ret i32 0
}

; Function Attrs: noinline nounwind uwtable
define dso_local i32 @michael_remove(%struct.Michael*, i8*, i32) #0 {
  %4 = icmp sge i32 %2, 4
  br i1 %4, label %.lr.ph, label %._crit_edge

.lr.ph:                                           ; preds = %3
  %5 = sext i32 %2 to i64
  br label %6

; <label>:6:                                      ; preds = %.lr.ph, %6
  %indvars.iv = phi i64 [ %5, %.lr.ph ], [ %indvars.iv.next, %6 ]
  %7 = getelementptr inbounds i8, i8* %1, i64 %indvars.iv
  %8 = getelementptr inbounds i8, i8* %7, i64 -4
  %9 = call i32 @michael_remove_byte(%struct.Michael* %0, i8* %8)
  %indvars.iv.next = add nsw i64 %indvars.iv, -1
  %10 = icmp sge i64 %indvars.iv.next, 4
  br i1 %10, label %6, label %._crit_edge.loopexit

._crit_edge.loopexit:                             ; preds = %6
  br label %._crit_edge

._crit_edge:                                      ; preds = %._crit_edge.loopexit, %3
  ret i32 0
}

; Function Attrs: noinline nounwind uwtable
define dso_local i32 @michael_finalize(%struct.Michael*) #0 {
  %2 = call i32 @michael_append_byte(%struct.Michael* %0, i8 zeroext 90)
  %3 = call i32 @michael_append_byte(%struct.Michael* %0, i8 zeroext 0)
  %4 = call i32 @michael_append_byte(%struct.Michael* %0, i8 zeroext 0)
  %5 = call i32 @michael_append_byte(%struct.Michael* %0, i8 zeroext 0)
  %6 = call i32 @michael_append_byte(%struct.Michael* %0, i8 zeroext 0)
  %7 = getelementptr inbounds %struct.Michael, %struct.Michael* %0, i32 0, i32 4
  %8 = load i64, i64* %7, align 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %.lr.ph.preheader, label %._crit_edge

.lr.ph.preheader:                                 ; preds = %1
  br label %.lr.ph

.lr.ph:                                           ; preds = %.lr.ph.preheader, %.lr.ph
  %10 = call i32 @michael_append_byte(%struct.Michael* %0, i8 zeroext 0)
  %11 = load i64, i64* %7, align 8
  %12 = icmp ne i64 %11, 0
  br i1 %12, label %.lr.ph, label %._crit_edge.loopexit

._crit_edge.loopexit:                             ; preds = %.lr.ph
  br label %._crit_edge

._crit_edge:                                      ; preds = %._crit_edge.loopexit, %1
  %13 = getelementptr inbounds %struct.Michael, %struct.Michael* %0, i32 0, i32 2
  %14 = load i64, i64* %13, align 8
  %15 = lshr i64 %14, 0
  %16 = and i64 %15, 255
  %17 = trunc i64 %16 to i8
  %18 = getelementptr inbounds %struct.Michael, %struct.Michael* %0, i32 0, i32 6
  %19 = getelementptr inbounds [8 x i8], [8 x i8]* %18, i64 0, i64 0
  store i8 %17, i8* %19, align 8
  %20 = getelementptr inbounds %struct.Michael, %struct.Michael* %0, i32 0, i32 2
  %21 = load i64, i64* %20, align 8
  %22 = lshr i64 %21, 8
  %23 = and i64 %22, 255
  %24 = trunc i64 %23 to i8
  %25 = getelementptr inbounds %struct.Michael, %struct.Michael* %0, i32 0, i32 6
  %26 = getelementptr inbounds [8 x i8], [8 x i8]* %25, i64 0, i64 1
  store i8 %24, i8* %26, align 1
  %27 = getelementptr inbounds %struct.Michael, %struct.Michael* %0, i32 0, i32 2
  %28 = load i64, i64* %27, align 8
  %29 = lshr i64 %28, 16
  %30 = and i64 %29, 255
  %31 = trunc i64 %30 to i8
  %32 = getelementptr inbounds %struct.Michael, %struct.Michael* %0, i32 0, i32 6
  %33 = getelementptr inbounds [8 x i8], [8 x i8]* %32, i64 0, i64 2
  store i8 %31, i8* %33, align 2
  %34 = getelementptr inbounds %struct.Michael, %struct.Michael* %0, i32 0, i32 2
  %35 = load i64, i64* %34, align 8
  %36 = lshr i64 %35, 24
  %37 = and i64 %36, 255
  %38 = trunc i64 %37 to i8
  %39 = getelementptr inbounds %struct.Michael, %struct.Michael* %0, i32 0, i32 6
  %40 = getelementptr inbounds [8 x i8], [8 x i8]* %39, i64 0, i64 3
  store i8 %38, i8* %40, align 1
  %41 = getelementptr inbounds %struct.Michael, %struct.Michael* %0, i32 0, i32 3
  %42 = load i64, i64* %41, align 8
  %43 = lshr i64 %42, 0
  %44 = and i64 %43, 255
  %45 = trunc i64 %44 to i8
  %46 = getelementptr inbounds %struct.Michael, %struct.Michael* %0, i32 0, i32 6
  %47 = getelementptr inbounds [8 x i8], [8 x i8]* %46, i64 0, i64 4
  store i8 %45, i8* %47, align 4
  %48 = getelementptr inbounds %struct.Michael, %struct.Michael* %0, i32 0, i32 3
  %49 = load i64, i64* %48, align 8
  %50 = lshr i64 %49, 8
  %51 = and i64 %50, 255
  %52 = trunc i64 %51 to i8
  %53 = getelementptr inbounds %struct.Michael, %struct.Michael* %0, i32 0, i32 6
  %54 = getelementptr inbounds [8 x i8], [8 x i8]* %53, i64 0, i64 5
  store i8 %52, i8* %54, align 1
  %55 = getelementptr inbounds %struct.Michael, %struct.Michael* %0, i32 0, i32 3
  %56 = load i64, i64* %55, align 8
  %57 = lshr i64 %56, 16
  %58 = and i64 %57, 255
  %59 = trunc i64 %58 to i8
  %60 = getelementptr inbounds %struct.Michael, %struct.Michael* %0, i32 0, i32 6
  %61 = getelementptr inbounds [8 x i8], [8 x i8]* %60, i64 0, i64 6
  store i8 %59, i8* %61, align 2
  %62 = getelementptr inbounds %struct.Michael, %struct.Michael* %0, i32 0, i32 3
  %63 = load i64, i64* %62, align 8
  %64 = lshr i64 %63, 24
  %65 = and i64 %64, 255
  %66 = trunc i64 %65 to i8
  %67 = getelementptr inbounds %struct.Michael, %struct.Michael* %0, i32 0, i32 6
  %68 = getelementptr inbounds [8 x i8], [8 x i8]* %67, i64 0, i64 7
  store i8 %66, i8* %68, align 1
  ret i32 0
}

; Function Attrs: noinline nounwind uwtable
define dso_local i32 @michael_finalize_zero(%struct.Michael*) #0 {
  %2 = call i32 @michael_append_byte(%struct.Michael* %0, i8 zeroext 0)
  %3 = call i32 @michael_append_byte(%struct.Michael* %0, i8 zeroext 0)
  %4 = call i32 @michael_append_byte(%struct.Michael* %0, i8 zeroext 0)
  %5 = call i32 @michael_append_byte(%struct.Michael* %0, i8 zeroext 0)
  %6 = call i32 @michael_append_byte(%struct.Michael* %0, i8 zeroext 0)
  %7 = getelementptr inbounds %struct.Michael, %struct.Michael* %0, i32 0, i32 4
  %8 = load i64, i64* %7, align 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %.lr.ph.preheader, label %._crit_edge

.lr.ph.preheader:                                 ; preds = %1
  br label %.lr.ph

.lr.ph:                                           ; preds = %.lr.ph.preheader, %.lr.ph
  %10 = call i32 @michael_append_byte(%struct.Michael* %0, i8 zeroext 0)
  %11 = load i64, i64* %7, align 8
  %12 = icmp ne i64 %11, 0
  br i1 %12, label %.lr.ph, label %._crit_edge.loopexit

._crit_edge.loopexit:                             ; preds = %.lr.ph
  br label %._crit_edge

._crit_edge:                                      ; preds = %._crit_edge.loopexit, %1
  %13 = getelementptr inbounds %struct.Michael, %struct.Michael* %0, i32 0, i32 2
  %14 = load i64, i64* %13, align 8
  %15 = lshr i64 %14, 0
  %16 = and i64 %15, 255
  %17 = trunc i64 %16 to i8
  %18 = getelementptr inbounds %struct.Michael, %struct.Michael* %0, i32 0, i32 6
  %19 = getelementptr inbounds [8 x i8], [8 x i8]* %18, i64 0, i64 0
  store i8 %17, i8* %19, align 8
  %20 = getelementptr inbounds %struct.Michael, %struct.Michael* %0, i32 0, i32 2
  %21 = load i64, i64* %20, align 8
  %22 = lshr i64 %21, 8
  %23 = and i64 %22, 255
  %24 = trunc i64 %23 to i8
  %25 = getelementptr inbounds %struct.Michael, %struct.Michael* %0, i32 0, i32 6
  %26 = getelementptr inbounds [8 x i8], [8 x i8]* %25, i64 0, i64 1
  store i8 %24, i8* %26, align 1
  %27 = getelementptr inbounds %struct.Michael, %struct.Michael* %0, i32 0, i32 2
  %28 = load i64, i64* %27, align 8
  %29 = lshr i64 %28, 16
  %30 = and i64 %29, 255
  %31 = trunc i64 %30 to i8
  %32 = getelementptr inbounds %struct.Michael, %struct.Michael* %0, i32 0, i32 6
  %33 = getelementptr inbounds [8 x i8], [8 x i8]* %32, i64 0, i64 2
  store i8 %31, i8* %33, align 2
  %34 = getelementptr inbounds %struct.Michael, %struct.Michael* %0, i32 0, i32 2
  %35 = load i64, i64* %34, align 8
  %36 = lshr i64 %35, 24
  %37 = and i64 %36, 255
  %38 = trunc i64 %37 to i8
  %39 = getelementptr inbounds %struct.Michael, %struct.Michael* %0, i32 0, i32 6
  %40 = getelementptr inbounds [8 x i8], [8 x i8]* %39, i64 0, i64 3
  store i8 %38, i8* %40, align 1
  %41 = getelementptr inbounds %struct.Michael, %struct.Michael* %0, i32 0, i32 3
  %42 = load i64, i64* %41, align 8
  %43 = lshr i64 %42, 0
  %44 = and i64 %43, 255
  %45 = trunc i64 %44 to i8
  %46 = getelementptr inbounds %struct.Michael, %struct.Michael* %0, i32 0, i32 6
  %47 = getelementptr inbounds [8 x i8], [8 x i8]* %46, i64 0, i64 4
  store i8 %45, i8* %47, align 4
  %48 = getelementptr inbounds %struct.Michael, %struct.Michael* %0, i32 0, i32 3
  %49 = load i64, i64* %48, align 8
  %50 = lshr i64 %49, 8
  %51 = and i64 %50, 255
  %52 = trunc i64 %51 to i8
  %53 = getelementptr inbounds %struct.Michael, %struct.Michael* %0, i32 0, i32 6
  %54 = getelementptr inbounds [8 x i8], [8 x i8]* %53, i64 0, i64 5
  store i8 %52, i8* %54, align 1
  %55 = getelementptr inbounds %struct.Michael, %struct.Michael* %0, i32 0, i32 3
  %56 = load i64, i64* %55, align 8
  %57 = lshr i64 %56, 16
  %58 = and i64 %57, 255
  %59 = trunc i64 %58 to i8
  %60 = getelementptr inbounds %struct.Michael, %struct.Michael* %0, i32 0, i32 6
  %61 = getelementptr inbounds [8 x i8], [8 x i8]* %60, i64 0, i64 6
  store i8 %59, i8* %61, align 2
  %62 = getelementptr inbounds %struct.Michael, %struct.Michael* %0, i32 0, i32 3
  %63 = load i64, i64* %62, align 8
  %64 = lshr i64 %63, 24
  %65 = and i64 %64, 255
  %66 = trunc i64 %65 to i8
  %67 = getelementptr inbounds %struct.Michael, %struct.Michael* %0, i32 0, i32 6
  %68 = getelementptr inbounds [8 x i8], [8 x i8]* %67, i64 0, i64 7
  store i8 %66, i8* %68, align 1
  ret i32 0
}

; Function Attrs: noinline nounwind uwtable
define dso_local i32 @michael_test(i8*, i8*, i32, i8*) #0 {
  %5 = alloca %struct.Michael, align 8
  %6 = alloca %struct.Michael, align 8
  %7 = alloca %struct.Michael, align 8
  %8 = alloca %struct.Michael, align 8
  %9 = getelementptr [9 x i8], [9 x i8]* @.str.17.178, i32 0, i32 0
  %10 = call i32 @init_michael(%struct.Michael* %5, i8* %9)
  %11 = getelementptr [9 x i8], [9 x i8]* @.str.17.178, i32 0, i32 0
  %12 = call i32 @init_michael(%struct.Michael* %6, i8* %11)
  %13 = getelementptr [9 x i8], [9 x i8]* @.str.17.178, i32 0, i32 0
  %14 = call i32 @init_michael(%struct.Michael* %7, i8* %13)
  %15 = call i32 @michael_append_byte(%struct.Michael* %5, i8 zeroext 2)
  %16 = call i32 @michael_append_byte(%struct.Michael* %6, i8 zeroext 1)
  %17 = call i32 @michael_append_byte(%struct.Michael* %7, i8 zeroext 3)
  %18 = call i32 @michael_finalize(%struct.Michael* %5)
  %19 = call i32 @michael_finalize_zero(%struct.Michael* %6)
  %20 = call i32 @michael_finalize(%struct.Michael* %7)
  %21 = getelementptr [8 x i8], [8 x i8]* @.str.18.179, i32 0, i32 0
  %22 = call i32 (i8*, ...) @printf(i8* %21)
  br label %23

; <label>:23:                                     ; preds = %4, %23
  %indvars.iv7 = phi i64 [ 0, %4 ], [ %indvars.iv.next8, %23 ]
  %24 = getelementptr inbounds %struct.Michael, %struct.Michael* %5, i32 0, i32 6
  %25 = getelementptr inbounds [8 x i8], [8 x i8]* %24, i64 0, i64 %indvars.iv7
  %26 = load i8, i8* %25, align 1
  %27 = zext i8 %26 to i32
  %28 = getelementptr [6 x i8], [6 x i8]* @.str.19.180, i32 0, i32 0
  %29 = call i32 (i8*, ...) @printf(i8* %28, i32 %27)
  %indvars.iv.next8 = add nuw nsw i64 %indvars.iv7, 1
  %exitcond9 = icmp ne i64 %indvars.iv.next8, 8
  br i1 %exitcond9, label %23, label %30

; <label>:30:                                     ; preds = %23
  %31 = getelementptr [2 x i8], [2 x i8]* @.str.20.181, i32 0, i32 0
  %32 = call i32 (i8*, ...) @printf(i8* %31)
  %33 = getelementptr [8 x i8], [8 x i8]* @.str.21.182, i32 0, i32 0
  %34 = call i32 (i8*, ...) @printf(i8* %33)
  br label %35

; <label>:35:                                     ; preds = %30, %35
  %indvars.iv3 = phi i64 [ 0, %30 ], [ %indvars.iv.next4, %35 ]
  %36 = getelementptr inbounds %struct.Michael, %struct.Michael* %6, i32 0, i32 6
  %37 = getelementptr inbounds [8 x i8], [8 x i8]* %36, i64 0, i64 %indvars.iv3
  %38 = load i8, i8* %37, align 1
  %39 = zext i8 %38 to i32
  %40 = getelementptr [6 x i8], [6 x i8]* @.str.19.180, i32 0, i32 0
  %41 = call i32 (i8*, ...) @printf(i8* %40, i32 %39)
  %indvars.iv.next4 = add nuw nsw i64 %indvars.iv3, 1
  %exitcond5 = icmp ne i64 %indvars.iv.next4, 8
  br i1 %exitcond5, label %35, label %42

; <label>:42:                                     ; preds = %35
  %43 = getelementptr [2 x i8], [2 x i8]* @.str.20.181, i32 0, i32 0
  %44 = call i32 (i8*, ...) @printf(i8* %43)
  %45 = getelementptr [8 x i8], [8 x i8]* @.str.22.183, i32 0, i32 0
  %46 = call i32 (i8*, ...) @printf(i8* %45)
  br label %47

; <label>:47:                                     ; preds = %42, %47
  %indvars.iv = phi i64 [ 0, %42 ], [ %indvars.iv.next, %47 ]
  %48 = getelementptr inbounds %struct.Michael, %struct.Michael* %7, i32 0, i32 6
  %49 = getelementptr inbounds [8 x i8], [8 x i8]* %48, i64 0, i64 %indvars.iv
  %50 = load i8, i8* %49, align 1
  %51 = zext i8 %50 to i32
  %52 = getelementptr [6 x i8], [6 x i8]* @.str.19.180, i32 0, i32 0
  %53 = call i32 (i8*, ...) @printf(i8* %52, i32 %51)
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond = icmp ne i64 %indvars.iv.next, 8
  br i1 %exitcond, label %47, label %54

; <label>:54:                                     ; preds = %47
  %55 = getelementptr [2 x i8], [2 x i8]* @.str.20.181, i32 0, i32 0
  %56 = call i32 (i8*, ...) @printf(i8* %55)
  %57 = call i32 @init_michael(%struct.Michael* %8, i8* %0)
  %58 = call i32 @michael_append(%struct.Michael* %8, i8* %1, i32 %2)
  %59 = call i32 @michael_finalize(%struct.Michael* %8)
  %60 = getelementptr inbounds %struct.Michael, %struct.Michael* %8, i32 0, i32 6
  %61 = getelementptr inbounds [8 x i8], [8 x i8]* %60, i32 0, i32 0
  %62 = call i32 @memcmp(i8* %61, i8* %3, i64 8) #10
  %63 = icmp eq i32 %62, 0
  %64 = zext i1 %63 to i32
  ret i32 %64
}

; Function Attrs: noinline nounwind uwtable
define dso_local i32 @calc_tkip_mic_key(i8*, i32, i8*) #0 {
  %4 = alloca [6 x i8], align 1
  %5 = alloca [6 x i8], align 1
  %6 = alloca [6 x i8], align 1
  %7 = alloca [4 x i8], align 1
  %8 = alloca [4096 x i8], align 16
  %9 = alloca %struct.Michael, align 8
  %10 = getelementptr inbounds [4096 x i8], [4096 x i8]* %8, i32 0, i32 0
  call void @llvm.memset.p0i8.i64(i8* align 16 %10, i8 0, i64 4096, i1 false)
  %11 = getelementptr inbounds i8, i8* %0, i64 1
  %12 = load i8, i8* %11, align 1
  %13 = zext i8 %12 to i32
  %14 = and i32 %13, 3
  %15 = icmp ne i32 %14, 3
  %16 = zext i1 %15 to i64
  %17 = select i1 %15, i32 24, i32 30
  %18 = icmp slt i32 %1, %17
  br i1 %18, label %182, label %19

; <label>:19:                                     ; preds = %3
  %20 = getelementptr inbounds i8, i8* %0, i64 0
  %21 = load i8, i8* %20, align 1
  %22 = zext i8 %21 to i32
  %23 = and i32 %22, 128
  %24 = icmp eq i32 %23, 128
  %25 = add nsw i32 %17, 2
  %spec.select = select i1 %24, i32 %25, i32 %17
  %spec.select1 = select i1 %24, i32 1, i32 0
  %26 = getelementptr inbounds [4 x i8], [4 x i8]* %7, i32 0, i32 0
  call void @llvm.memset.p0i8.i64(i8* align 1 %26, i8 0, i64 4, i1 false)
  %27 = icmp ne i32 %spec.select1, 0
  br i1 %27, label %28, label %37

; <label>:28:                                     ; preds = %19
  %29 = sub nsw i32 %spec.select, 2
  %30 = sext i32 %29 to i64
  %31 = getelementptr inbounds i8, i8* %0, i64 %30
  %32 = load i8, i8* %31, align 1
  %33 = zext i8 %32 to i32
  %34 = and i32 %33, 15
  %35 = trunc i32 %34 to i8
  %36 = getelementptr inbounds [4 x i8], [4 x i8]* %7, i64 0, i64 0
  store i8 %35, i8* %36, align 1
  br label %37

; <label>:37:                                     ; preds = %28, %19
  %38 = getelementptr inbounds i8, i8* %0, i64 1
  %39 = load i8, i8* %38, align 1
  %40 = zext i8 %39 to i32
  %41 = and i32 %40, 3
  switch i32 %41, label %63 [
    i32 0, label %42
    i32 1, label %49
    i32 2, label %56
  ]

; <label>:42:                                     ; preds = %37
  %43 = getelementptr inbounds [6 x i8], [6 x i8]* %6, i32 0, i32 0
  %44 = getelementptr inbounds i8, i8* %0, i64 16
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %43, i8* align 1 %44, i64 6, i1 false)
  %45 = getelementptr inbounds [6 x i8], [6 x i8]* %5, i32 0, i32 0
  %46 = getelementptr inbounds i8, i8* %0, i64 4
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %45, i8* align 1 %46, i64 6, i1 false)
  %47 = getelementptr inbounds [6 x i8], [6 x i8]* %4, i32 0, i32 0
  %48 = getelementptr inbounds i8, i8* %0, i64 10
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %47, i8* align 1 %48, i64 6, i1 false)
  br label %70

; <label>:49:                                     ; preds = %37
  %50 = getelementptr inbounds [6 x i8], [6 x i8]* %6, i32 0, i32 0
  %51 = getelementptr inbounds i8, i8* %0, i64 4
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %50, i8* align 1 %51, i64 6, i1 false)
  %52 = getelementptr inbounds [6 x i8], [6 x i8]* %5, i32 0, i32 0
  %53 = getelementptr inbounds i8, i8* %0, i64 16
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %52, i8* align 1 %53, i64 6, i1 false)
  %54 = getelementptr inbounds [6 x i8], [6 x i8]* %4, i32 0, i32 0
  %55 = getelementptr inbounds i8, i8* %0, i64 10
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %54, i8* align 1 %55, i64 6, i1 false)
  br label %70

; <label>:56:                                     ; preds = %37
  %57 = getelementptr inbounds [6 x i8], [6 x i8]* %6, i32 0, i32 0
  %58 = getelementptr inbounds i8, i8* %0, i64 10
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %57, i8* align 1 %58, i64 6, i1 false)
  %59 = getelementptr inbounds [6 x i8], [6 x i8]* %5, i32 0, i32 0
  %60 = getelementptr inbounds i8, i8* %0, i64 4
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %59, i8* align 1 %60, i64 6, i1 false)
  %61 = getelementptr inbounds [6 x i8], [6 x i8]* %4, i32 0, i32 0
  %62 = getelementptr inbounds i8, i8* %0, i64 16
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %61, i8* align 1 %62, i64 6, i1 false)
  br label %70

; <label>:63:                                     ; preds = %37
  %64 = getelementptr inbounds [6 x i8], [6 x i8]* %6, i32 0, i32 0
  %65 = getelementptr inbounds i8, i8* %0, i64 10
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %64, i8* align 1 %65, i64 6, i1 false)
  %66 = getelementptr inbounds [6 x i8], [6 x i8]* %5, i32 0, i32 0
  %67 = getelementptr inbounds i8, i8* %0, i64 16
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %66, i8* align 1 %67, i64 6, i1 false)
  %68 = getelementptr inbounds [6 x i8], [6 x i8]* %4, i32 0, i32 0
  %69 = getelementptr inbounds i8, i8* %0, i64 24
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %68, i8* align 1 %69, i64 6, i1 false)
  br label %70

; <label>:70:                                     ; preds = %63, %56, %49, %42
  %71 = getelementptr inbounds [4096 x i8], [4096 x i8]* %8, i32 0, i32 0
  %72 = getelementptr inbounds [6 x i8], [6 x i8]* %5, i32 0, i32 0
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %71, i8* align 1 %72, i64 6, i1 false)
  %73 = getelementptr inbounds i8, i8* %71, i64 6
  %74 = getelementptr inbounds [6 x i8], [6 x i8]* %4, i32 0, i32 0
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %73, i8* align 1 %74, i64 6, i1 false)
  %75 = getelementptr inbounds i8, i8* %73, i64 6
  %76 = getelementptr inbounds [4 x i8], [4 x i8]* %7, i32 0, i32 0
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %75, i8* align 1 %76, i64 4, i1 false)
  %77 = getelementptr inbounds i8, i8* %75, i64 4
  %78 = sext i32 %spec.select to i64
  %79 = getelementptr inbounds i8, i8* %0, i64 %78
  %80 = sub nsw i32 %1, %spec.select
  %81 = sub nsw i32 %80, 8
  %82 = sext i32 %81 to i64
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %77, i8* align 1 %79, i64 %82, i1 false)
  %83 = sub nsw i32 %1, %spec.select
  %84 = sub nsw i32 %83, 8
  %85 = sext i32 %84 to i64
  %86 = getelementptr inbounds i8, i8* %77, i64 %85
  %87 = getelementptr [2 x i8], [2 x i8]* @.str.23.184, i32 0, i32 0
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %86, i8* align 1 %87, i64 1, i1 false)
  %88 = getelementptr inbounds i8, i8* %86, i64 1
  %89 = getelementptr [32 x i8], [32 x i8]* @ZERO.185, i32 0, i32 0
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %88, i8* align 16 %89, i64 4, i1 false)
  %90 = getelementptr inbounds i8, i8* %88, i64 4
  %91 = getelementptr inbounds [4096 x i8], [4096 x i8]* %8, i32 0, i32 0
  %92 = ptrtoint i8* %90 to i64
  %93 = ptrtoint i8* %91 to i64
  %94 = sub i64 %92, %93
  %95 = srem i64 %94, 4
  %96 = icmp sgt i64 %95, 0
  br i1 %96, label %97, label %105

; <label>:97:                                     ; preds = %70
  %98 = getelementptr inbounds [4096 x i8], [4096 x i8]* %8, i32 0, i32 0
  %99 = ptrtoint i8* %90 to i64
  %100 = ptrtoint i8* %98 to i64
  %101 = sub i64 %99, %100
  %102 = srem i64 %101, 4
  %103 = sub nsw i64 4, %102
  %104 = getelementptr [32 x i8], [32 x i8]* @ZERO.185, i32 0, i32 0
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %90, i8* align 16 %104, i64 %103, i1 false)
  br label %105

; <label>:105:                                    ; preds = %97, %70
  %106 = getelementptr inbounds [4096 x i8], [4096 x i8]* %8, i32 0, i32 0
  %107 = ptrtoint i8* %90 to i64
  %108 = ptrtoint i8* %106 to i64
  %109 = sub i64 %107, %108
  %110 = srem i64 %109, 4
  %111 = sub nsw i64 4, %110
  %112 = getelementptr inbounds i8, i8* %90, i64 %111
  %113 = sext i32 %1 to i64
  %114 = getelementptr inbounds i8, i8* %0, i64 %113
  %115 = getelementptr inbounds i8, i8* %114, i64 -8
  %116 = call i32 @init_michael(%struct.Michael* %9, i8* %115)
  %117 = getelementptr inbounds [4096 x i8], [4096 x i8]* %8, i32 0, i32 0
  %118 = getelementptr inbounds [4096 x i8], [4096 x i8]* %8, i32 0, i32 0
  %119 = ptrtoint i8* %112 to i64
  %120 = ptrtoint i8* %118 to i64
  %121 = sub i64 %119, %120
  %122 = trunc i64 %121 to i32
  %123 = call i32 @michael_remove(%struct.Michael* %9, i8* %117, i32 %122)
  %124 = getelementptr inbounds %struct.Michael, %struct.Michael* %9, i32 0, i32 2
  %125 = load i64, i64* %124, align 8
  %126 = lshr i64 %125, 0
  %127 = and i64 %126, 255
  %128 = trunc i64 %127 to i8
  %129 = getelementptr inbounds %struct.Michael, %struct.Michael* %9, i32 0, i32 6
  %130 = getelementptr inbounds [8 x i8], [8 x i8]* %129, i64 0, i64 0
  store i8 %128, i8* %130, align 8
  %131 = getelementptr inbounds %struct.Michael, %struct.Michael* %9, i32 0, i32 2
  %132 = load i64, i64* %131, align 8
  %133 = lshr i64 %132, 8
  %134 = and i64 %133, 255
  %135 = trunc i64 %134 to i8
  %136 = getelementptr inbounds %struct.Michael, %struct.Michael* %9, i32 0, i32 6
  %137 = getelementptr inbounds [8 x i8], [8 x i8]* %136, i64 0, i64 1
  store i8 %135, i8* %137, align 1
  %138 = getelementptr inbounds %struct.Michael, %struct.Michael* %9, i32 0, i32 2
  %139 = load i64, i64* %138, align 8
  %140 = lshr i64 %139, 16
  %141 = and i64 %140, 255
  %142 = trunc i64 %141 to i8
  %143 = getelementptr inbounds %struct.Michael, %struct.Michael* %9, i32 0, i32 6
  %144 = getelementptr inbounds [8 x i8], [8 x i8]* %143, i64 0, i64 2
  store i8 %142, i8* %144, align 2
  %145 = getelementptr inbounds %struct.Michael, %struct.Michael* %9, i32 0, i32 2
  %146 = load i64, i64* %145, align 8
  %147 = lshr i64 %146, 24
  %148 = and i64 %147, 255
  %149 = trunc i64 %148 to i8
  %150 = getelementptr inbounds %struct.Michael, %struct.Michael* %9, i32 0, i32 6
  %151 = getelementptr inbounds [8 x i8], [8 x i8]* %150, i64 0, i64 3
  store i8 %149, i8* %151, align 1
  %152 = getelementptr inbounds %struct.Michael, %struct.Michael* %9, i32 0, i32 3
  %153 = load i64, i64* %152, align 8
  %154 = lshr i64 %153, 0
  %155 = and i64 %154, 255
  %156 = trunc i64 %155 to i8
  %157 = getelementptr inbounds %struct.Michael, %struct.Michael* %9, i32 0, i32 6
  %158 = getelementptr inbounds [8 x i8], [8 x i8]* %157, i64 0, i64 4
  store i8 %156, i8* %158, align 4
  %159 = getelementptr inbounds %struct.Michael, %struct.Michael* %9, i32 0, i32 3
  %160 = load i64, i64* %159, align 8
  %161 = lshr i64 %160, 8
  %162 = and i64 %161, 255
  %163 = trunc i64 %162 to i8
  %164 = getelementptr inbounds %struct.Michael, %struct.Michael* %9, i32 0, i32 6
  %165 = getelementptr inbounds [8 x i8], [8 x i8]* %164, i64 0, i64 5
  store i8 %163, i8* %165, align 1
  %166 = getelementptr inbounds %struct.Michael, %struct.Michael* %9, i32 0, i32 3
  %167 = load i64, i64* %166, align 8
  %168 = lshr i64 %167, 16
  %169 = and i64 %168, 255
  %170 = trunc i64 %169 to i8
  %171 = getelementptr inbounds %struct.Michael, %struct.Michael* %9, i32 0, i32 6
  %172 = getelementptr inbounds [8 x i8], [8 x i8]* %171, i64 0, i64 6
  store i8 %170, i8* %172, align 2
  %173 = getelementptr inbounds %struct.Michael, %struct.Michael* %9, i32 0, i32 3
  %174 = load i64, i64* %173, align 8
  %175 = lshr i64 %174, 24
  %176 = and i64 %175, 255
  %177 = trunc i64 %176 to i8
  %178 = getelementptr inbounds %struct.Michael, %struct.Michael* %9, i32 0, i32 6
  %179 = getelementptr inbounds [8 x i8], [8 x i8]* %178, i64 0, i64 7
  store i8 %177, i8* %179, align 1
  %180 = getelementptr inbounds %struct.Michael, %struct.Michael* %9, i32 0, i32 6
  %181 = getelementptr inbounds [8 x i8], [8 x i8]* %180, i32 0, i32 0
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %2, i8* align 8 %181, i64 8, i1 false)
  br label %182

; <label>:182:                                    ; preds = %3, %105
  ret i32 0
}

; Function Attrs: noinline nounwind uwtable
define dso_local i32 @calc_tkip_mic(i8*, i32, i8*, i8*) #0 {
  %5 = alloca [6 x i8], align 1
  %6 = alloca [6 x i8], align 1
  %7 = alloca [6 x i8], align 1
  %8 = alloca [4 x i8], align 1
  %9 = alloca %struct.Michael, align 8
  %10 = getelementptr inbounds i8, i8* %0, i64 1
  %11 = load i8, i8* %10, align 1
  %12 = zext i8 %11 to i32
  %13 = and i32 %12, 3
  %14 = icmp ne i32 %13, 3
  %15 = zext i1 %14 to i64
  %16 = select i1 %14, i32 24, i32 30
  %17 = icmp slt i32 %1, %16
  br i1 %17, label %87, label %18

; <label>:18:                                     ; preds = %4
  %19 = getelementptr inbounds i8, i8* %0, i64 0
  %20 = load i8, i8* %19, align 1
  %21 = zext i8 %20 to i32
  %22 = and i32 %21, 128
  %23 = icmp eq i32 %22, 128
  %24 = add nsw i32 %16, 2
  %spec.select = select i1 %23, i32 %24, i32 %16
  %spec.select1 = select i1 %23, i32 1, i32 0
  %25 = getelementptr inbounds i8, i8* %0, i64 1
  %26 = load i8, i8* %25, align 1
  %27 = zext i8 %26 to i32
  %28 = and i32 %27, 3
  switch i32 %28, label %50 [
    i32 0, label %29
    i32 1, label %36
    i32 2, label %43
  ]

; <label>:29:                                     ; preds = %18
  %30 = getelementptr inbounds [6 x i8], [6 x i8]* %7, i32 0, i32 0
  %31 = getelementptr inbounds i8, i8* %0, i64 16
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %30, i8* align 1 %31, i64 6, i1 false)
  %32 = getelementptr inbounds [6 x i8], [6 x i8]* %6, i32 0, i32 0
  %33 = getelementptr inbounds i8, i8* %0, i64 4
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %32, i8* align 1 %33, i64 6, i1 false)
  %34 = getelementptr inbounds [6 x i8], [6 x i8]* %5, i32 0, i32 0
  %35 = getelementptr inbounds i8, i8* %0, i64 10
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %34, i8* align 1 %35, i64 6, i1 false)
  br label %57

; <label>:36:                                     ; preds = %18
  %37 = getelementptr inbounds [6 x i8], [6 x i8]* %7, i32 0, i32 0
  %38 = getelementptr inbounds i8, i8* %0, i64 4
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %37, i8* align 1 %38, i64 6, i1 false)
  %39 = getelementptr inbounds [6 x i8], [6 x i8]* %6, i32 0, i32 0
  %40 = getelementptr inbounds i8, i8* %0, i64 16
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %39, i8* align 1 %40, i64 6, i1 false)
  %41 = getelementptr inbounds [6 x i8], [6 x i8]* %5, i32 0, i32 0
  %42 = getelementptr inbounds i8, i8* %0, i64 10
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %41, i8* align 1 %42, i64 6, i1 false)
  br label %57

; <label>:43:                                     ; preds = %18
  %44 = getelementptr inbounds [6 x i8], [6 x i8]* %7, i32 0, i32 0
  %45 = getelementptr inbounds i8, i8* %0, i64 10
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %44, i8* align 1 %45, i64 6, i1 false)
  %46 = getelementptr inbounds [6 x i8], [6 x i8]* %6, i32 0, i32 0
  %47 = getelementptr inbounds i8, i8* %0, i64 4
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %46, i8* align 1 %47, i64 6, i1 false)
  %48 = getelementptr inbounds [6 x i8], [6 x i8]* %5, i32 0, i32 0
  %49 = getelementptr inbounds i8, i8* %0, i64 16
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %48, i8* align 1 %49, i64 6, i1 false)
  br label %57

; <label>:50:                                     ; preds = %18
  %51 = getelementptr inbounds [6 x i8], [6 x i8]* %7, i32 0, i32 0
  %52 = getelementptr inbounds i8, i8* %0, i64 10
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %51, i8* align 1 %52, i64 6, i1 false)
  %53 = getelementptr inbounds [6 x i8], [6 x i8]* %6, i32 0, i32 0
  %54 = getelementptr inbounds i8, i8* %0, i64 16
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %53, i8* align 1 %54, i64 6, i1 false)
  %55 = getelementptr inbounds [6 x i8], [6 x i8]* %5, i32 0, i32 0
  %56 = getelementptr inbounds i8, i8* %0, i64 24
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %55, i8* align 1 %56, i64 6, i1 false)
  br label %57

; <label>:57:                                     ; preds = %50, %43, %36, %29
  %.02 = phi i32 [ 0, %50 ], [ 48, %43 ], [ 56, %36 ], [ 0, %29 ]
  switch i32 %.02, label %87 [
    i32 48, label %58
    i32 56, label %58
  ]

; <label>:58:                                     ; preds = %57, %57
  %59 = sext i32 %.02 to i64
  %60 = getelementptr inbounds i8, i8* %2, i64 %59
  %61 = call i32 @init_michael(%struct.Michael* %9, i8* %60)
  %62 = getelementptr inbounds [6 x i8], [6 x i8]* %6, i32 0, i32 0
  %63 = call i32 @michael_append(%struct.Michael* %9, i8* %62, i32 6)
  %64 = getelementptr inbounds [6 x i8], [6 x i8]* %5, i32 0, i32 0
  %65 = call i32 @michael_append(%struct.Michael* %9, i8* %64, i32 6)
  %66 = getelementptr inbounds [4 x i8], [4 x i8]* %8, i32 0, i32 0
  call void @llvm.memset.p0i8.i64(i8* align 1 %66, i8 0, i64 4, i1 false)
  %67 = icmp ne i32 %spec.select1, 0
  br i1 %67, label %68, label %77

; <label>:68:                                     ; preds = %58
  %69 = sub nsw i32 %spec.select, 2
  %70 = sext i32 %69 to i64
  %71 = getelementptr inbounds i8, i8* %0, i64 %70
  %72 = load i8, i8* %71, align 1
  %73 = zext i8 %72 to i32
  %74 = and i32 %73, 15
  %75 = trunc i32 %74 to i8
  %76 = getelementptr inbounds [4 x i8], [4 x i8]* %8, i64 0, i64 0
  store i8 %75, i8* %76, align 1
  br label %77

; <label>:77:                                     ; preds = %68, %58
  %78 = getelementptr inbounds [4 x i8], [4 x i8]* %8, i32 0, i32 0
  %79 = call i32 @michael_append(%struct.Michael* %9, i8* %78, i32 4)
  %80 = sext i32 %spec.select to i64
  %81 = getelementptr inbounds i8, i8* %0, i64 %80
  %82 = sub nsw i32 %1, %spec.select
  %83 = call i32 @michael_append(%struct.Michael* %9, i8* %81, i32 %82)
  %84 = call i32 @michael_finalize(%struct.Michael* %9)
  %85 = getelementptr inbounds %struct.Michael, %struct.Michael* %9, i32 0, i32 6
  %86 = getelementptr inbounds [8 x i8], [8 x i8]* %85, i32 0, i32 0
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %3, i8* align 8 %86, i64 8, i1 false)
  br label %87

; <label>:87:                                     ; preds = %57, %4, %77
  %.0 = phi i32 [ 0, %77 ], [ 0, %4 ], [ 1, %57 ]
  ret i32 %.0
}

; Function Attrs: noinline nounwind uwtable
define dso_local i32 @calc_tkip_ppk(i8*, i32, i8*, i8*) #0 {
  %5 = alloca [6 x i16], align 2
  %6 = getelementptr inbounds i8, i8* %0, i64 1
  %7 = load i8, i8* %6, align 1
  %8 = zext i8 %7 to i32
  %9 = and i32 %8, 3
  %10 = icmp ne i32 %9, 3
  %11 = select i1 %10, i32 24, i32 30
  %12 = getelementptr inbounds i8, i8* %0, i64 0
  %13 = load i8, i8* %12, align 1
  %14 = zext i8 %13 to i32
  %15 = and i32 %14, 240
  %16 = ashr i32 %15, 4
  %17 = shl i32 %16, 4
  %18 = icmp eq i32 %17, 128
  %19 = add nsw i32 %11, 2
  %.0 = select i1 %18, i32 %19, i32 %11
  %20 = add nsw i32 %.0, 2
  %21 = sext i32 %20 to i64
  %22 = getelementptr inbounds i8, i8* %0, i64 %21
  %23 = load i8, i8* %22, align 1
  %24 = sext i32 %.0 to i64
  %25 = getelementptr inbounds i8, i8* %0, i64 %24
  %26 = load i8, i8* %25, align 1
  %27 = zext i8 %26 to i32
  %28 = and i32 %27, 255
  %29 = add nsw i32 %.0, 4
  %30 = sext i32 %29 to i64
  %31 = getelementptr inbounds i8, i8* %0, i64 %30
  %32 = load i8, i8* %31, align 1
  %33 = zext i8 %32 to i32
  %34 = add nsw i32 %.0, 5
  %35 = sext i32 %34 to i64
  %36 = getelementptr inbounds i8, i8* %0, i64 %35
  %37 = load i8, i8* %36, align 1
  %38 = zext i8 %37 to i32
  %39 = shl i32 %38, 8
  %40 = or i32 %33, %39
  %41 = add nsw i32 %.0, 6
  %42 = sext i32 %41 to i64
  %43 = getelementptr inbounds i8, i8* %0, i64 %42
  %44 = load i8, i8* %43, align 1
  %45 = zext i8 %44 to i32
  %46 = shl i32 %45, 16
  %47 = or i32 %40, %46
  %48 = add nsw i32 %.0, 7
  %49 = sext i32 %48 to i64
  %50 = getelementptr inbounds i8, i8* %0, i64 %49
  %51 = load i8, i8* %50, align 1
  %52 = zext i8 %51 to i32
  %53 = shl i32 %52, 24
  %54 = or i32 %47, %53
  %55 = and i32 %54, 65535
  %56 = trunc i32 %55 to i16
  %57 = getelementptr inbounds [6 x i16], [6 x i16]* %5, i64 0, i64 0
  store i16 %56, i16* %57, align 2
  %58 = lshr i32 %54, 16
  %59 = and i32 %58, 65535
  %60 = trunc i32 %59 to i16
  %61 = getelementptr inbounds [6 x i16], [6 x i16]* %5, i64 0, i64 1
  store i16 %60, i16* %61, align 2
  %62 = getelementptr inbounds i8, i8* %0, i64 10
  %63 = load i8, i8* %62, align 1
  %64 = zext i8 %63 to i32
  %65 = getelementptr inbounds i8, i8* %0, i64 11
  %66 = load i8, i8* %65, align 1
  %67 = zext i8 %66 to i32
  %68 = and i32 %67, 255
  %69 = shl i32 %68, 8
  %70 = xor i32 %64, %69
  %71 = trunc i32 %70 to i16
  %72 = getelementptr inbounds [6 x i16], [6 x i16]* %5, i64 0, i64 2
  store i16 %71, i16* %72, align 2
  %73 = getelementptr inbounds i8, i8* %0, i64 12
  %74 = load i8, i8* %73, align 1
  %75 = zext i8 %74 to i32
  %76 = getelementptr inbounds i8, i8* %0, i64 13
  %77 = load i8, i8* %76, align 1
  %78 = zext i8 %77 to i32
  %79 = and i32 %78, 255
  %80 = shl i32 %79, 8
  %81 = xor i32 %75, %80
  %82 = trunc i32 %81 to i16
  %83 = getelementptr inbounds [6 x i16], [6 x i16]* %5, i64 0, i64 3
  store i16 %82, i16* %83, align 2
  %84 = getelementptr inbounds i8, i8* %0, i64 14
  %85 = load i8, i8* %84, align 1
  %86 = zext i8 %85 to i32
  %87 = getelementptr inbounds i8, i8* %0, i64 15
  %88 = load i8, i8* %87, align 1
  %89 = zext i8 %88 to i32
  %90 = and i32 %89, 255
  %91 = shl i32 %90, 8
  %92 = xor i32 %86, %91
  %93 = trunc i32 %92 to i16
  %94 = getelementptr inbounds [6 x i16], [6 x i16]* %5, i64 0, i64 4
  store i16 %93, i16* %94, align 2
  br label %95

; <label>:95:                                     ; preds = %4, %95
  %.013 = phi i32 [ 0, %4 ], [ %412, %95 ]
  %96 = getelementptr inbounds [6 x i16], [6 x i16]* %5, i64 0, i64 4
  %97 = load i16, i16* %96, align 2
  %98 = zext i16 %97 to i32
  %99 = and i32 %.013, 1
  %100 = add nsw i32 %99, 0
  %101 = mul nsw i32 2, %100
  %102 = sext i32 %101 to i64
  %103 = getelementptr inbounds i8, i8* %2, i64 %102
  %104 = load i8, i8* %103, align 1
  %105 = zext i8 %104 to i32
  %106 = and i32 %.013, 1
  %107 = add nsw i32 %106, 0
  %108 = mul nsw i32 2, %107
  %109 = add nsw i32 %108, 1
  %110 = sext i32 %109 to i64
  %111 = getelementptr inbounds i8, i8* %2, i64 %110
  %112 = load i8, i8* %111, align 1
  %113 = zext i8 %112 to i32
  %114 = and i32 %113, 255
  %115 = shl i32 %114, 8
  %116 = xor i32 %105, %115
  %117 = xor i32 %98, %116
  %118 = and i32 %117, 255
  %119 = sext i32 %118 to i64
  %120 = getelementptr [2 x [256 x i16]], [2 x [256 x i16]]* @TkipSbox, i64 0, i64 0
  %121 = getelementptr inbounds [256 x i16], [256 x i16]* %120, i64 0, i64 %119
  %122 = load i16, i16* %121, align 2
  %123 = sext i16 %122 to i32
  %124 = getelementptr inbounds [6 x i16], [6 x i16]* %5, i64 0, i64 4
  %125 = load i16, i16* %124, align 2
  %126 = zext i16 %125 to i32
  %127 = and i32 %.013, 1
  %128 = add nsw i32 %127, 0
  %129 = mul nsw i32 2, %128
  %130 = sext i32 %129 to i64
  %131 = getelementptr inbounds i8, i8* %2, i64 %130
  %132 = load i8, i8* %131, align 1
  %133 = zext i8 %132 to i32
  %134 = and i32 %.013, 1
  %135 = add nsw i32 %134, 0
  %136 = mul nsw i32 2, %135
  %137 = add nsw i32 %136, 1
  %138 = sext i32 %137 to i64
  %139 = getelementptr inbounds i8, i8* %2, i64 %138
  %140 = load i8, i8* %139, align 1
  %141 = zext i8 %140 to i32
  %142 = and i32 %141, 255
  %143 = shl i32 %142, 8
  %144 = xor i32 %133, %143
  %145 = xor i32 %126, %144
  %146 = ashr i32 %145, 8
  %147 = and i32 %146, 255
  %148 = sext i32 %147 to i64
  %149 = getelementptr [2 x [256 x i16]], [2 x [256 x i16]]* @TkipSbox, i64 0, i64 1
  %150 = getelementptr inbounds [256 x i16], [256 x i16]* %149, i64 0, i64 %148
  %151 = load i16, i16* %150, align 2
  %152 = sext i16 %151 to i32
  %153 = xor i32 %123, %152
  %154 = getelementptr inbounds [6 x i16], [6 x i16]* %5, i64 0, i64 0
  %155 = load i16, i16* %154, align 2
  %156 = zext i16 %155 to i32
  %157 = add nsw i32 %156, %153
  %158 = trunc i32 %157 to i16
  store i16 %158, i16* %154, align 2
  %159 = getelementptr inbounds [6 x i16], [6 x i16]* %5, i64 0, i64 0
  %160 = load i16, i16* %159, align 2
  %161 = zext i16 %160 to i32
  %162 = and i32 %.013, 1
  %163 = add nsw i32 %162, 2
  %164 = mul nsw i32 2, %163
  %165 = sext i32 %164 to i64
  %166 = getelementptr inbounds i8, i8* %2, i64 %165
  %167 = load i8, i8* %166, align 1
  %168 = zext i8 %167 to i32
  %169 = and i32 %.013, 1
  %170 = add nsw i32 %169, 2
  %171 = mul nsw i32 2, %170
  %172 = add nsw i32 %171, 1
  %173 = sext i32 %172 to i64
  %174 = getelementptr inbounds i8, i8* %2, i64 %173
  %175 = load i8, i8* %174, align 1
  %176 = zext i8 %175 to i32
  %177 = and i32 %176, 255
  %178 = shl i32 %177, 8
  %179 = xor i32 %168, %178
  %180 = xor i32 %161, %179
  %181 = and i32 %180, 255
  %182 = sext i32 %181 to i64
  %183 = getelementptr [2 x [256 x i16]], [2 x [256 x i16]]* @TkipSbox, i64 0, i64 0
  %184 = getelementptr inbounds [256 x i16], [256 x i16]* %183, i64 0, i64 %182
  %185 = load i16, i16* %184, align 2
  %186 = sext i16 %185 to i32
  %187 = getelementptr inbounds [6 x i16], [6 x i16]* %5, i64 0, i64 0
  %188 = load i16, i16* %187, align 2
  %189 = zext i16 %188 to i32
  %190 = and i32 %.013, 1
  %191 = add nsw i32 %190, 2
  %192 = mul nsw i32 2, %191
  %193 = sext i32 %192 to i64
  %194 = getelementptr inbounds i8, i8* %2, i64 %193
  %195 = load i8, i8* %194, align 1
  %196 = zext i8 %195 to i32
  %197 = and i32 %.013, 1
  %198 = add nsw i32 %197, 2
  %199 = mul nsw i32 2, %198
  %200 = add nsw i32 %199, 1
  %201 = sext i32 %200 to i64
  %202 = getelementptr inbounds i8, i8* %2, i64 %201
  %203 = load i8, i8* %202, align 1
  %204 = zext i8 %203 to i32
  %205 = and i32 %204, 255
  %206 = shl i32 %205, 8
  %207 = xor i32 %196, %206
  %208 = xor i32 %189, %207
  %209 = ashr i32 %208, 8
  %210 = and i32 %209, 255
  %211 = sext i32 %210 to i64
  %212 = getelementptr [2 x [256 x i16]], [2 x [256 x i16]]* @TkipSbox, i64 0, i64 1
  %213 = getelementptr inbounds [256 x i16], [256 x i16]* %212, i64 0, i64 %211
  %214 = load i16, i16* %213, align 2
  %215 = sext i16 %214 to i32
  %216 = xor i32 %186, %215
  %217 = getelementptr inbounds [6 x i16], [6 x i16]* %5, i64 0, i64 1
  %218 = load i16, i16* %217, align 2
  %219 = zext i16 %218 to i32
  %220 = add nsw i32 %219, %216
  %221 = trunc i32 %220 to i16
  store i16 %221, i16* %217, align 2
  %222 = getelementptr inbounds [6 x i16], [6 x i16]* %5, i64 0, i64 1
  %223 = load i16, i16* %222, align 2
  %224 = zext i16 %223 to i32
  %225 = and i32 %.013, 1
  %226 = add nsw i32 %225, 4
  %227 = mul nsw i32 2, %226
  %228 = sext i32 %227 to i64
  %229 = getelementptr inbounds i8, i8* %2, i64 %228
  %230 = load i8, i8* %229, align 1
  %231 = zext i8 %230 to i32
  %232 = and i32 %.013, 1
  %233 = add nsw i32 %232, 4
  %234 = mul nsw i32 2, %233
  %235 = add nsw i32 %234, 1
  %236 = sext i32 %235 to i64
  %237 = getelementptr inbounds i8, i8* %2, i64 %236
  %238 = load i8, i8* %237, align 1
  %239 = zext i8 %238 to i32
  %240 = and i32 %239, 255
  %241 = shl i32 %240, 8
  %242 = xor i32 %231, %241
  %243 = xor i32 %224, %242
  %244 = and i32 %243, 255
  %245 = sext i32 %244 to i64
  %246 = getelementptr [2 x [256 x i16]], [2 x [256 x i16]]* @TkipSbox, i64 0, i64 0
  %247 = getelementptr inbounds [256 x i16], [256 x i16]* %246, i64 0, i64 %245
  %248 = load i16, i16* %247, align 2
  %249 = sext i16 %248 to i32
  %250 = getelementptr inbounds [6 x i16], [6 x i16]* %5, i64 0, i64 1
  %251 = load i16, i16* %250, align 2
  %252 = zext i16 %251 to i32
  %253 = and i32 %.013, 1
  %254 = add nsw i32 %253, 4
  %255 = mul nsw i32 2, %254
  %256 = sext i32 %255 to i64
  %257 = getelementptr inbounds i8, i8* %2, i64 %256
  %258 = load i8, i8* %257, align 1
  %259 = zext i8 %258 to i32
  %260 = and i32 %.013, 1
  %261 = add nsw i32 %260, 4
  %262 = mul nsw i32 2, %261
  %263 = add nsw i32 %262, 1
  %264 = sext i32 %263 to i64
  %265 = getelementptr inbounds i8, i8* %2, i64 %264
  %266 = load i8, i8* %265, align 1
  %267 = zext i8 %266 to i32
  %268 = and i32 %267, 255
  %269 = shl i32 %268, 8
  %270 = xor i32 %259, %269
  %271 = xor i32 %252, %270
  %272 = ashr i32 %271, 8
  %273 = and i32 %272, 255
  %274 = sext i32 %273 to i64
  %275 = getelementptr [2 x [256 x i16]], [2 x [256 x i16]]* @TkipSbox, i64 0, i64 1
  %276 = getelementptr inbounds [256 x i16], [256 x i16]* %275, i64 0, i64 %274
  %277 = load i16, i16* %276, align 2
  %278 = sext i16 %277 to i32
  %279 = xor i32 %249, %278
  %280 = getelementptr inbounds [6 x i16], [6 x i16]* %5, i64 0, i64 2
  %281 = load i16, i16* %280, align 2
  %282 = zext i16 %281 to i32
  %283 = add nsw i32 %282, %279
  %284 = trunc i32 %283 to i16
  store i16 %284, i16* %280, align 2
  %285 = getelementptr inbounds [6 x i16], [6 x i16]* %5, i64 0, i64 2
  %286 = load i16, i16* %285, align 2
  %287 = zext i16 %286 to i32
  %288 = and i32 %.013, 1
  %289 = add nsw i32 %288, 6
  %290 = mul nsw i32 2, %289
  %291 = sext i32 %290 to i64
  %292 = getelementptr inbounds i8, i8* %2, i64 %291
  %293 = load i8, i8* %292, align 1
  %294 = zext i8 %293 to i32
  %295 = and i32 %.013, 1
  %296 = add nsw i32 %295, 6
  %297 = mul nsw i32 2, %296
  %298 = add nsw i32 %297, 1
  %299 = sext i32 %298 to i64
  %300 = getelementptr inbounds i8, i8* %2, i64 %299
  %301 = load i8, i8* %300, align 1
  %302 = zext i8 %301 to i32
  %303 = and i32 %302, 255
  %304 = shl i32 %303, 8
  %305 = xor i32 %294, %304
  %306 = xor i32 %287, %305
  %307 = and i32 %306, 255
  %308 = sext i32 %307 to i64
  %309 = getelementptr [2 x [256 x i16]], [2 x [256 x i16]]* @TkipSbox, i64 0, i64 0
  %310 = getelementptr inbounds [256 x i16], [256 x i16]* %309, i64 0, i64 %308
  %311 = load i16, i16* %310, align 2
  %312 = sext i16 %311 to i32
  %313 = getelementptr inbounds [6 x i16], [6 x i16]* %5, i64 0, i64 2
  %314 = load i16, i16* %313, align 2
  %315 = zext i16 %314 to i32
  %316 = and i32 %.013, 1
  %317 = add nsw i32 %316, 6
  %318 = mul nsw i32 2, %317
  %319 = sext i32 %318 to i64
  %320 = getelementptr inbounds i8, i8* %2, i64 %319
  %321 = load i8, i8* %320, align 1
  %322 = zext i8 %321 to i32
  %323 = and i32 %.013, 1
  %324 = add nsw i32 %323, 6
  %325 = mul nsw i32 2, %324
  %326 = add nsw i32 %325, 1
  %327 = sext i32 %326 to i64
  %328 = getelementptr inbounds i8, i8* %2, i64 %327
  %329 = load i8, i8* %328, align 1
  %330 = zext i8 %329 to i32
  %331 = and i32 %330, 255
  %332 = shl i32 %331, 8
  %333 = xor i32 %322, %332
  %334 = xor i32 %315, %333
  %335 = ashr i32 %334, 8
  %336 = and i32 %335, 255
  %337 = sext i32 %336 to i64
  %338 = getelementptr [2 x [256 x i16]], [2 x [256 x i16]]* @TkipSbox, i64 0, i64 1
  %339 = getelementptr inbounds [256 x i16], [256 x i16]* %338, i64 0, i64 %337
  %340 = load i16, i16* %339, align 2
  %341 = sext i16 %340 to i32
  %342 = xor i32 %312, %341
  %343 = getelementptr inbounds [6 x i16], [6 x i16]* %5, i64 0, i64 3
  %344 = load i16, i16* %343, align 2
  %345 = zext i16 %344 to i32
  %346 = add nsw i32 %345, %342
  %347 = trunc i32 %346 to i16
  store i16 %347, i16* %343, align 2
  %348 = getelementptr inbounds [6 x i16], [6 x i16]* %5, i64 0, i64 3
  %349 = load i16, i16* %348, align 2
  %350 = zext i16 %349 to i32
  %351 = and i32 %.013, 1
  %352 = add nsw i32 %351, 0
  %353 = mul nsw i32 2, %352
  %354 = sext i32 %353 to i64
  %355 = getelementptr inbounds i8, i8* %2, i64 %354
  %356 = load i8, i8* %355, align 1
  %357 = zext i8 %356 to i32
  %358 = and i32 %.013, 1
  %359 = add nsw i32 %358, 0
  %360 = mul nsw i32 2, %359
  %361 = add nsw i32 %360, 1
  %362 = sext i32 %361 to i64
  %363 = getelementptr inbounds i8, i8* %2, i64 %362
  %364 = load i8, i8* %363, align 1
  %365 = zext i8 %364 to i32
  %366 = and i32 %365, 255
  %367 = shl i32 %366, 8
  %368 = xor i32 %357, %367
  %369 = xor i32 %350, %368
  %370 = and i32 %369, 255
  %371 = sext i32 %370 to i64
  %372 = getelementptr [2 x [256 x i16]], [2 x [256 x i16]]* @TkipSbox, i64 0, i64 0
  %373 = getelementptr inbounds [256 x i16], [256 x i16]* %372, i64 0, i64 %371
  %374 = load i16, i16* %373, align 2
  %375 = sext i16 %374 to i32
  %376 = getelementptr inbounds [6 x i16], [6 x i16]* %5, i64 0, i64 3
  %377 = load i16, i16* %376, align 2
  %378 = zext i16 %377 to i32
  %379 = and i32 %.013, 1
  %380 = add nsw i32 %379, 0
  %381 = mul nsw i32 2, %380
  %382 = sext i32 %381 to i64
  %383 = getelementptr inbounds i8, i8* %2, i64 %382
  %384 = load i8, i8* %383, align 1
  %385 = zext i8 %384 to i32
  %386 = and i32 %.013, 1
  %387 = add nsw i32 %386, 0
  %388 = mul nsw i32 2, %387
  %389 = add nsw i32 %388, 1
  %390 = sext i32 %389 to i64
  %391 = getelementptr inbounds i8, i8* %2, i64 %390
  %392 = load i8, i8* %391, align 1
  %393 = zext i8 %392 to i32
  %394 = and i32 %393, 255
  %395 = shl i32 %394, 8
  %396 = xor i32 %385, %395
  %397 = xor i32 %378, %396
  %398 = ashr i32 %397, 8
  %399 = and i32 %398, 255
  %400 = sext i32 %399 to i64
  %401 = getelementptr [2 x [256 x i16]], [2 x [256 x i16]]* @TkipSbox, i64 0, i64 1
  %402 = getelementptr inbounds [256 x i16], [256 x i16]* %401, i64 0, i64 %400
  %403 = load i16, i16* %402, align 2
  %404 = sext i16 %403 to i32
  %405 = xor i32 %375, %404
  %406 = add nsw i32 %405, %.013
  %407 = getelementptr inbounds [6 x i16], [6 x i16]* %5, i64 0, i64 4
  %408 = load i16, i16* %407, align 2
  %409 = zext i16 %408 to i32
  %410 = add nsw i32 %409, %406
  %411 = trunc i32 %410 to i16
  store i16 %411, i16* %407, align 2
  %412 = add nuw nsw i32 %.013, 1
  %exitcond4 = icmp ne i32 %412, 8
  br i1 %exitcond4, label %95, label %413

; <label>:413:                                    ; preds = %95
  %414 = icmp ne i32 %1, 0
  %415 = zext i1 %10 to i64
  %416 = shl i32 %28, 8
  %417 = zext i8 %23 to i32
  %418 = xor i32 %417, %416
  %419 = trunc i32 %418 to i16
  %420 = getelementptr inbounds [6 x i16], [6 x i16]* %5, i64 0, i64 4
  %421 = load i16, i16* %420, align 2
  %422 = zext i16 %421 to i32
  %423 = zext i16 %419 to i32
  %424 = add nsw i32 %422, %423
  %425 = trunc i32 %424 to i16
  %426 = getelementptr inbounds [6 x i16], [6 x i16]* %5, i64 0, i64 5
  store i16 %425, i16* %426, align 2
  %427 = getelementptr inbounds [6 x i16], [6 x i16]* %5, i64 0, i64 5
  %428 = load i16, i16* %427, align 2
  %429 = zext i16 %428 to i32
  %430 = getelementptr inbounds i8, i8* %2, i64 0
  %431 = load i8, i8* %430, align 1
  %432 = zext i8 %431 to i32
  %433 = getelementptr inbounds i8, i8* %2, i64 1
  %434 = load i8, i8* %433, align 1
  %435 = zext i8 %434 to i32
  %436 = and i32 %435, 255
  %437 = shl i32 %436, 8
  %438 = xor i32 %432, %437
  %439 = xor i32 %429, %438
  %440 = and i32 %439, 255
  %441 = sext i32 %440 to i64
  %442 = getelementptr [2 x [256 x i16]], [2 x [256 x i16]]* @TkipSbox, i64 0, i64 0
  %443 = getelementptr inbounds [256 x i16], [256 x i16]* %442, i64 0, i64 %441
  %444 = load i16, i16* %443, align 2
  %445 = sext i16 %444 to i32
  %446 = getelementptr inbounds [6 x i16], [6 x i16]* %5, i64 0, i64 5
  %447 = load i16, i16* %446, align 2
  %448 = zext i16 %447 to i32
  %449 = getelementptr inbounds i8, i8* %2, i64 0
  %450 = load i8, i8* %449, align 1
  %451 = zext i8 %450 to i32
  %452 = getelementptr inbounds i8, i8* %2, i64 1
  %453 = load i8, i8* %452, align 1
  %454 = zext i8 %453 to i32
  %455 = and i32 %454, 255
  %456 = shl i32 %455, 8
  %457 = xor i32 %451, %456
  %458 = xor i32 %448, %457
  %459 = ashr i32 %458, 8
  %460 = and i32 %459, 255
  %461 = sext i32 %460 to i64
  %462 = getelementptr [2 x [256 x i16]], [2 x [256 x i16]]* @TkipSbox, i64 0, i64 1
  %463 = getelementptr inbounds [256 x i16], [256 x i16]* %462, i64 0, i64 %461
  %464 = load i16, i16* %463, align 2
  %465 = sext i16 %464 to i32
  %466 = xor i32 %445, %465
  %467 = getelementptr inbounds [6 x i16], [6 x i16]* %5, i64 0, i64 0
  %468 = load i16, i16* %467, align 2
  %469 = zext i16 %468 to i32
  %470 = add nsw i32 %469, %466
  %471 = trunc i32 %470 to i16
  store i16 %471, i16* %467, align 2
  %472 = getelementptr inbounds [6 x i16], [6 x i16]* %5, i64 0, i64 0
  %473 = load i16, i16* %472, align 2
  %474 = zext i16 %473 to i32
  %475 = getelementptr inbounds i8, i8* %2, i64 2
  %476 = load i8, i8* %475, align 1
  %477 = zext i8 %476 to i32
  %478 = getelementptr inbounds i8, i8* %2, i64 3
  %479 = load i8, i8* %478, align 1
  %480 = zext i8 %479 to i32
  %481 = and i32 %480, 255
  %482 = shl i32 %481, 8
  %483 = xor i32 %477, %482
  %484 = xor i32 %474, %483
  %485 = and i32 %484, 255
  %486 = sext i32 %485 to i64
  %487 = getelementptr [2 x [256 x i16]], [2 x [256 x i16]]* @TkipSbox, i64 0, i64 0
  %488 = getelementptr inbounds [256 x i16], [256 x i16]* %487, i64 0, i64 %486
  %489 = load i16, i16* %488, align 2
  %490 = sext i16 %489 to i32
  %491 = getelementptr inbounds [6 x i16], [6 x i16]* %5, i64 0, i64 0
  %492 = load i16, i16* %491, align 2
  %493 = zext i16 %492 to i32
  %494 = getelementptr inbounds i8, i8* %2, i64 2
  %495 = load i8, i8* %494, align 1
  %496 = zext i8 %495 to i32
  %497 = getelementptr inbounds i8, i8* %2, i64 3
  %498 = load i8, i8* %497, align 1
  %499 = zext i8 %498 to i32
  %500 = and i32 %499, 255
  %501 = shl i32 %500, 8
  %502 = xor i32 %496, %501
  %503 = xor i32 %493, %502
  %504 = ashr i32 %503, 8
  %505 = and i32 %504, 255
  %506 = sext i32 %505 to i64
  %507 = getelementptr [2 x [256 x i16]], [2 x [256 x i16]]* @TkipSbox, i64 0, i64 1
  %508 = getelementptr inbounds [256 x i16], [256 x i16]* %507, i64 0, i64 %506
  %509 = load i16, i16* %508, align 2
  %510 = sext i16 %509 to i32
  %511 = xor i32 %490, %510
  %512 = getelementptr inbounds [6 x i16], [6 x i16]* %5, i64 0, i64 1
  %513 = load i16, i16* %512, align 2
  %514 = zext i16 %513 to i32
  %515 = add nsw i32 %514, %511
  %516 = trunc i32 %515 to i16
  store i16 %516, i16* %512, align 2
  %517 = getelementptr inbounds [6 x i16], [6 x i16]* %5, i64 0, i64 1
  %518 = load i16, i16* %517, align 2
  %519 = zext i16 %518 to i32
  %520 = getelementptr inbounds i8, i8* %2, i64 4
  %521 = load i8, i8* %520, align 1
  %522 = zext i8 %521 to i32
  %523 = getelementptr inbounds i8, i8* %2, i64 5
  %524 = load i8, i8* %523, align 1
  %525 = zext i8 %524 to i32
  %526 = and i32 %525, 255
  %527 = shl i32 %526, 8
  %528 = xor i32 %522, %527
  %529 = xor i32 %519, %528
  %530 = and i32 %529, 255
  %531 = sext i32 %530 to i64
  %532 = getelementptr [2 x [256 x i16]], [2 x [256 x i16]]* @TkipSbox, i64 0, i64 0
  %533 = getelementptr inbounds [256 x i16], [256 x i16]* %532, i64 0, i64 %531
  %534 = load i16, i16* %533, align 2
  %535 = sext i16 %534 to i32
  %536 = getelementptr inbounds [6 x i16], [6 x i16]* %5, i64 0, i64 1
  %537 = load i16, i16* %536, align 2
  %538 = zext i16 %537 to i32
  %539 = getelementptr inbounds i8, i8* %2, i64 4
  %540 = load i8, i8* %539, align 1
  %541 = zext i8 %540 to i32
  %542 = getelementptr inbounds i8, i8* %2, i64 5
  %543 = load i8, i8* %542, align 1
  %544 = zext i8 %543 to i32
  %545 = and i32 %544, 255
  %546 = shl i32 %545, 8
  %547 = xor i32 %541, %546
  %548 = xor i32 %538, %547
  %549 = ashr i32 %548, 8
  %550 = and i32 %549, 255
  %551 = sext i32 %550 to i64
  %552 = getelementptr [2 x [256 x i16]], [2 x [256 x i16]]* @TkipSbox, i64 0, i64 1
  %553 = getelementptr inbounds [256 x i16], [256 x i16]* %552, i64 0, i64 %551
  %554 = load i16, i16* %553, align 2
  %555 = sext i16 %554 to i32
  %556 = xor i32 %535, %555
  %557 = getelementptr inbounds [6 x i16], [6 x i16]* %5, i64 0, i64 2
  %558 = load i16, i16* %557, align 2
  %559 = zext i16 %558 to i32
  %560 = add nsw i32 %559, %556
  %561 = trunc i32 %560 to i16
  store i16 %561, i16* %557, align 2
  %562 = getelementptr inbounds [6 x i16], [6 x i16]* %5, i64 0, i64 2
  %563 = load i16, i16* %562, align 2
  %564 = zext i16 %563 to i32
  %565 = getelementptr inbounds i8, i8* %2, i64 6
  %566 = load i8, i8* %565, align 1
  %567 = zext i8 %566 to i32
  %568 = getelementptr inbounds i8, i8* %2, i64 7
  %569 = load i8, i8* %568, align 1
  %570 = zext i8 %569 to i32
  %571 = and i32 %570, 255
  %572 = shl i32 %571, 8
  %573 = xor i32 %567, %572
  %574 = xor i32 %564, %573
  %575 = and i32 %574, 255
  %576 = sext i32 %575 to i64
  %577 = getelementptr [2 x [256 x i16]], [2 x [256 x i16]]* @TkipSbox, i64 0, i64 0
  %578 = getelementptr inbounds [256 x i16], [256 x i16]* %577, i64 0, i64 %576
  %579 = load i16, i16* %578, align 2
  %580 = sext i16 %579 to i32
  %581 = getelementptr inbounds [6 x i16], [6 x i16]* %5, i64 0, i64 2
  %582 = load i16, i16* %581, align 2
  %583 = zext i16 %582 to i32
  %584 = getelementptr inbounds i8, i8* %2, i64 6
  %585 = load i8, i8* %584, align 1
  %586 = zext i8 %585 to i32
  %587 = getelementptr inbounds i8, i8* %2, i64 7
  %588 = load i8, i8* %587, align 1
  %589 = zext i8 %588 to i32
  %590 = and i32 %589, 255
  %591 = shl i32 %590, 8
  %592 = xor i32 %586, %591
  %593 = xor i32 %583, %592
  %594 = ashr i32 %593, 8
  %595 = and i32 %594, 255
  %596 = sext i32 %595 to i64
  %597 = getelementptr [2 x [256 x i16]], [2 x [256 x i16]]* @TkipSbox, i64 0, i64 1
  %598 = getelementptr inbounds [256 x i16], [256 x i16]* %597, i64 0, i64 %596
  %599 = load i16, i16* %598, align 2
  %600 = sext i16 %599 to i32
  %601 = xor i32 %580, %600
  %602 = getelementptr inbounds [6 x i16], [6 x i16]* %5, i64 0, i64 3
  %603 = load i16, i16* %602, align 2
  %604 = zext i16 %603 to i32
  %605 = add nsw i32 %604, %601
  %606 = trunc i32 %605 to i16
  store i16 %606, i16* %602, align 2
  %607 = getelementptr inbounds [6 x i16], [6 x i16]* %5, i64 0, i64 3
  %608 = load i16, i16* %607, align 2
  %609 = zext i16 %608 to i32
  %610 = getelementptr inbounds i8, i8* %2, i64 8
  %611 = load i8, i8* %610, align 1
  %612 = zext i8 %611 to i32
  %613 = getelementptr inbounds i8, i8* %2, i64 9
  %614 = load i8, i8* %613, align 1
  %615 = zext i8 %614 to i32
  %616 = and i32 %615, 255
  %617 = shl i32 %616, 8
  %618 = xor i32 %612, %617
  %619 = xor i32 %609, %618
  %620 = and i32 %619, 255
  %621 = sext i32 %620 to i64
  %622 = getelementptr [2 x [256 x i16]], [2 x [256 x i16]]* @TkipSbox, i64 0, i64 0
  %623 = getelementptr inbounds [256 x i16], [256 x i16]* %622, i64 0, i64 %621
  %624 = load i16, i16* %623, align 2
  %625 = sext i16 %624 to i32
  %626 = getelementptr inbounds [6 x i16], [6 x i16]* %5, i64 0, i64 3
  %627 = load i16, i16* %626, align 2
  %628 = zext i16 %627 to i32
  %629 = getelementptr inbounds i8, i8* %2, i64 8
  %630 = load i8, i8* %629, align 1
  %631 = zext i8 %630 to i32
  %632 = getelementptr inbounds i8, i8* %2, i64 9
  %633 = load i8, i8* %632, align 1
  %634 = zext i8 %633 to i32
  %635 = and i32 %634, 255
  %636 = shl i32 %635, 8
  %637 = xor i32 %631, %636
  %638 = xor i32 %628, %637
  %639 = ashr i32 %638, 8
  %640 = and i32 %639, 255
  %641 = sext i32 %640 to i64
  %642 = getelementptr [2 x [256 x i16]], [2 x [256 x i16]]* @TkipSbox, i64 0, i64 1
  %643 = getelementptr inbounds [256 x i16], [256 x i16]* %642, i64 0, i64 %641
  %644 = load i16, i16* %643, align 2
  %645 = sext i16 %644 to i32
  %646 = xor i32 %625, %645
  %647 = getelementptr inbounds [6 x i16], [6 x i16]* %5, i64 0, i64 4
  %648 = load i16, i16* %647, align 2
  %649 = zext i16 %648 to i32
  %650 = add nsw i32 %649, %646
  %651 = trunc i32 %650 to i16
  store i16 %651, i16* %647, align 2
  %652 = getelementptr inbounds [6 x i16], [6 x i16]* %5, i64 0, i64 4
  %653 = load i16, i16* %652, align 2
  %654 = zext i16 %653 to i32
  %655 = getelementptr inbounds i8, i8* %2, i64 10
  %656 = load i8, i8* %655, align 1
  %657 = zext i8 %656 to i32
  %658 = getelementptr inbounds i8, i8* %2, i64 11
  %659 = load i8, i8* %658, align 1
  %660 = zext i8 %659 to i32
  %661 = and i32 %660, 255
  %662 = shl i32 %661, 8
  %663 = xor i32 %657, %662
  %664 = xor i32 %654, %663
  %665 = and i32 %664, 255
  %666 = sext i32 %665 to i64
  %667 = getelementptr [2 x [256 x i16]], [2 x [256 x i16]]* @TkipSbox, i64 0, i64 0
  %668 = getelementptr inbounds [256 x i16], [256 x i16]* %667, i64 0, i64 %666
  %669 = load i16, i16* %668, align 2
  %670 = sext i16 %669 to i32
  %671 = getelementptr inbounds [6 x i16], [6 x i16]* %5, i64 0, i64 4
  %672 = load i16, i16* %671, align 2
  %673 = zext i16 %672 to i32
  %674 = getelementptr inbounds i8, i8* %2, i64 10
  %675 = load i8, i8* %674, align 1
  %676 = zext i8 %675 to i32
  %677 = getelementptr inbounds i8, i8* %2, i64 11
  %678 = load i8, i8* %677, align 1
  %679 = zext i8 %678 to i32
  %680 = and i32 %679, 255
  %681 = shl i32 %680, 8
  %682 = xor i32 %676, %681
  %683 = xor i32 %673, %682
  %684 = ashr i32 %683, 8
  %685 = and i32 %684, 255
  %686 = sext i32 %685 to i64
  %687 = getelementptr [2 x [256 x i16]], [2 x [256 x i16]]* @TkipSbox, i64 0, i64 1
  %688 = getelementptr inbounds [256 x i16], [256 x i16]* %687, i64 0, i64 %686
  %689 = load i16, i16* %688, align 2
  %690 = sext i16 %689 to i32
  %691 = xor i32 %670, %690
  %692 = getelementptr inbounds [6 x i16], [6 x i16]* %5, i64 0, i64 5
  %693 = load i16, i16* %692, align 2
  %694 = zext i16 %693 to i32
  %695 = add nsw i32 %694, %691
  %696 = trunc i32 %695 to i16
  store i16 %696, i16* %692, align 2
  %697 = getelementptr inbounds [6 x i16], [6 x i16]* %5, i64 0, i64 5
  %698 = load i16, i16* %697, align 2
  %699 = zext i16 %698 to i32
  %700 = getelementptr inbounds i8, i8* %2, i64 12
  %701 = load i8, i8* %700, align 1
  %702 = zext i8 %701 to i32
  %703 = getelementptr inbounds i8, i8* %2, i64 13
  %704 = load i8, i8* %703, align 1
  %705 = zext i8 %704 to i32
  %706 = and i32 %705, 255
  %707 = shl i32 %706, 8
  %708 = xor i32 %702, %707
  %709 = xor i32 %699, %708
  %710 = ashr i32 %709, 1
  %711 = and i32 %710, 32767
  %712 = getelementptr inbounds [6 x i16], [6 x i16]* %5, i64 0, i64 5
  %713 = load i16, i16* %712, align 2
  %714 = zext i16 %713 to i32
  %715 = getelementptr inbounds i8, i8* %2, i64 12
  %716 = load i8, i8* %715, align 1
  %717 = zext i8 %716 to i32
  %718 = getelementptr inbounds i8, i8* %2, i64 13
  %719 = load i8, i8* %718, align 1
  %720 = zext i8 %719 to i32
  %721 = and i32 %720, 255
  %722 = shl i32 %721, 8
  %723 = xor i32 %717, %722
  %724 = xor i32 %714, %723
  %725 = and i32 %724, 1
  %726 = shl i32 %725, 15
  %727 = xor i32 %711, %726
  %728 = getelementptr inbounds [6 x i16], [6 x i16]* %5, i64 0, i64 0
  %729 = load i16, i16* %728, align 2
  %730 = zext i16 %729 to i32
  %731 = add nsw i32 %730, %727
  %732 = trunc i32 %731 to i16
  store i16 %732, i16* %728, align 2
  %733 = getelementptr inbounds [6 x i16], [6 x i16]* %5, i64 0, i64 0
  %734 = load i16, i16* %733, align 2
  %735 = zext i16 %734 to i32
  %736 = getelementptr inbounds i8, i8* %2, i64 14
  %737 = load i8, i8* %736, align 1
  %738 = zext i8 %737 to i32
  %739 = getelementptr inbounds i8, i8* %2, i64 15
  %740 = load i8, i8* %739, align 1
  %741 = zext i8 %740 to i32
  %742 = and i32 %741, 255
  %743 = shl i32 %742, 8
  %744 = xor i32 %738, %743
  %745 = xor i32 %735, %744
  %746 = ashr i32 %745, 1
  %747 = and i32 %746, 32767
  %748 = getelementptr inbounds [6 x i16], [6 x i16]* %5, i64 0, i64 0
  %749 = load i16, i16* %748, align 2
  %750 = zext i16 %749 to i32
  %751 = getelementptr inbounds i8, i8* %2, i64 14
  %752 = load i8, i8* %751, align 1
  %753 = zext i8 %752 to i32
  %754 = getelementptr inbounds i8, i8* %2, i64 15
  %755 = load i8, i8* %754, align 1
  %756 = zext i8 %755 to i32
  %757 = and i32 %756, 255
  %758 = shl i32 %757, 8
  %759 = xor i32 %753, %758
  %760 = xor i32 %750, %759
  %761 = and i32 %760, 1
  %762 = shl i32 %761, 15
  %763 = xor i32 %747, %762
  %764 = getelementptr inbounds [6 x i16], [6 x i16]* %5, i64 0, i64 1
  %765 = load i16, i16* %764, align 2
  %766 = zext i16 %765 to i32
  %767 = add nsw i32 %766, %763
  %768 = trunc i32 %767 to i16
  store i16 %768, i16* %764, align 2
  %769 = getelementptr inbounds [6 x i16], [6 x i16]* %5, i64 0, i64 1
  %770 = load i16, i16* %769, align 2
  %771 = zext i16 %770 to i32
  %772 = ashr i32 %771, 1
  %773 = and i32 %772, 32767
  %774 = getelementptr inbounds [6 x i16], [6 x i16]* %5, i64 0, i64 1
  %775 = load i16, i16* %774, align 2
  %776 = zext i16 %775 to i32
  %777 = and i32 %776, 1
  %778 = shl i32 %777, 15
  %779 = xor i32 %773, %778
  %780 = getelementptr inbounds [6 x i16], [6 x i16]* %5, i64 0, i64 2
  %781 = load i16, i16* %780, align 2
  %782 = zext i16 %781 to i32
  %783 = add nsw i32 %782, %779
  %784 = trunc i32 %783 to i16
  store i16 %784, i16* %780, align 2
  %785 = getelementptr inbounds [6 x i16], [6 x i16]* %5, i64 0, i64 2
  %786 = load i16, i16* %785, align 2
  %787 = zext i16 %786 to i32
  %788 = ashr i32 %787, 1
  %789 = and i32 %788, 32767
  %790 = getelementptr inbounds [6 x i16], [6 x i16]* %5, i64 0, i64 2
  %791 = load i16, i16* %790, align 2
  %792 = zext i16 %791 to i32
  %793 = and i32 %792, 1
  %794 = shl i32 %793, 15
  %795 = xor i32 %789, %794
  %796 = getelementptr inbounds [6 x i16], [6 x i16]* %5, i64 0, i64 3
  %797 = load i16, i16* %796, align 2
  %798 = zext i16 %797 to i32
  %799 = add nsw i32 %798, %795
  %800 = trunc i32 %799 to i16
  store i16 %800, i16* %796, align 2
  %801 = getelementptr inbounds [6 x i16], [6 x i16]* %5, i64 0, i64 3
  %802 = load i16, i16* %801, align 2
  %803 = zext i16 %802 to i32
  %804 = ashr i32 %803, 1
  %805 = and i32 %804, 32767
  %806 = getelementptr inbounds [6 x i16], [6 x i16]* %5, i64 0, i64 3
  %807 = load i16, i16* %806, align 2
  %808 = zext i16 %807 to i32
  %809 = and i32 %808, 1
  %810 = shl i32 %809, 15
  %811 = xor i32 %805, %810
  %812 = getelementptr inbounds [6 x i16], [6 x i16]* %5, i64 0, i64 4
  %813 = load i16, i16* %812, align 2
  %814 = zext i16 %813 to i32
  %815 = add nsw i32 %814, %811
  %816 = trunc i32 %815 to i16
  store i16 %816, i16* %812, align 2
  %817 = getelementptr inbounds [6 x i16], [6 x i16]* %5, i64 0, i64 4
  %818 = load i16, i16* %817, align 2
  %819 = zext i16 %818 to i32
  %820 = ashr i32 %819, 1
  %821 = and i32 %820, 32767
  %822 = getelementptr inbounds [6 x i16], [6 x i16]* %5, i64 0, i64 4
  %823 = load i16, i16* %822, align 2
  %824 = zext i16 %823 to i32
  %825 = and i32 %824, 1
  %826 = shl i32 %825, 15
  %827 = xor i32 %821, %826
  %828 = getelementptr inbounds [6 x i16], [6 x i16]* %5, i64 0, i64 5
  %829 = load i16, i16* %828, align 2
  %830 = zext i16 %829 to i32
  %831 = add nsw i32 %830, %827
  %832 = trunc i32 %831 to i16
  store i16 %832, i16* %828, align 2
  %833 = zext i16 %419 to i32
  %834 = ashr i32 %833, 8
  %835 = and i32 %834, 255
  %836 = trunc i32 %835 to i8
  %837 = getelementptr inbounds i8, i8* %3, i64 0
  store i8 %836, i8* %837, align 1
  %838 = zext i16 %419 to i32
  %839 = ashr i32 %838, 8
  %840 = and i32 %839, 255
  %841 = or i32 %840, 32
  %842 = and i32 %841, 127
  %843 = trunc i32 %842 to i8
  %844 = getelementptr inbounds i8, i8* %3, i64 1
  store i8 %843, i8* %844, align 1
  %845 = zext i16 %419 to i32
  %846 = and i32 %845, 255
  %847 = trunc i32 %846 to i8
  %848 = getelementptr inbounds i8, i8* %3, i64 2
  store i8 %847, i8* %848, align 1
  %849 = getelementptr inbounds [6 x i16], [6 x i16]* %5, i64 0, i64 5
  %850 = load i16, i16* %849, align 2
  %851 = zext i16 %850 to i32
  %852 = getelementptr inbounds i8, i8* %2, i64 0
  %853 = load i8, i8* %852, align 1
  %854 = zext i8 %853 to i32
  %855 = getelementptr inbounds i8, i8* %2, i64 1
  %856 = load i8, i8* %855, align 1
  %857 = zext i8 %856 to i32
  %858 = and i32 %857, 255
  %859 = shl i32 %858, 8
  %860 = xor i32 %854, %859
  %861 = xor i32 %851, %860
  %862 = ashr i32 %861, 1
  %863 = and i32 %862, 255
  %864 = trunc i32 %863 to i8
  %865 = getelementptr inbounds i8, i8* %3, i64 3
  store i8 %864, i8* %865, align 1
  br label %866

; <label>:866:                                    ; preds = %413, %866
  %indvars.iv = phi i64 [ 0, %413 ], [ %indvars.iv.next, %866 ]
  %867 = getelementptr inbounds [6 x i16], [6 x i16]* %5, i64 0, i64 %indvars.iv
  %868 = load i16, i16* %867, align 2
  %869 = zext i16 %868 to i32
  %870 = and i32 %869, 255
  %871 = trunc i32 %870 to i8
  %872 = mul nuw nsw i64 2, %indvars.iv
  %873 = add nuw nsw i64 4, %872
  %874 = getelementptr inbounds i8, i8* %3, i64 %873
  store i8 %871, i8* %874, align 1
  %875 = getelementptr inbounds [6 x i16], [6 x i16]* %5, i64 0, i64 %indvars.iv
  %876 = load i16, i16* %875, align 2
  %877 = zext i16 %876 to i32
  %878 = ashr i32 %877, 8
  %879 = and i32 %878, 255
  %880 = trunc i32 %879 to i8
  %881 = mul nuw nsw i64 2, %indvars.iv
  %882 = add nuw nsw i64 5, %881
  %883 = getelementptr inbounds i8, i8* %3, i64 %882
  store i8 %880, i8* %883, align 1
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond = icmp ne i64 %indvars.iv.next, 6
  br i1 %exitcond, label %866, label %884

; <label>:884:                                    ; preds = %866
  ret i32 0
}

; Function Attrs: noinline nounwind uwtable
define dso_local i32 @decrypt_tkip(i8*, i32, i8*) #0 {
  %4 = alloca [16 x i8], align 16
  %5 = getelementptr inbounds i8, i8* %0, i64 1
  %6 = load i8, i8* %5, align 1
  %7 = zext i8 %6 to i32
  %8 = and i32 %7, 3
  %9 = icmp ne i32 %8, 3
  %10 = zext i1 %9 to i64
  %11 = select i1 %9, i32 24, i32 30
  %12 = getelementptr inbounds i8, i8* %0, i64 0
  %13 = load i8, i8* %12, align 1
  %14 = zext i8 %13 to i32
  %15 = and i32 %14, 240
  %16 = ashr i32 %15, 4
  %17 = shl i32 %16, 4
  %18 = icmp eq i32 %17, 128
  %19 = add nsw i32 %11, 2
  %spec.select = select i1 %18, i32 %19, i32 %11
  %20 = getelementptr inbounds [16 x i8], [16 x i8]* %4, i32 0, i32 0
  %21 = call i32 @calc_tkip_ppk(i8* %0, i32 %1, i8* %2, i8* %20)
  %22 = sext i32 %spec.select to i64
  %23 = getelementptr inbounds i8, i8* %0, i64 %22
  %24 = getelementptr inbounds i8, i8* %23, i64 8
  %25 = sub nsw i32 %1, %spec.select
  %26 = sub nsw i32 %25, 8
  %27 = getelementptr inbounds [16 x i8], [16 x i8]* %4, i32 0, i32 0
  %28 = call i32 @decrypt_wep(i8* %24, i32 %26, i8* %27, i32 16)
  ret i32 %28
}

; Function Attrs: noinline nounwind uwtable
define dso_local i32 @decrypt_ccmp(i8*, i32, i8*) #0 {
  %4 = alloca [16 x i8], align 16
  %5 = alloca [16 x i8], align 16
  %6 = alloca [16 x i8], align 16
  %7 = alloca [6 x i8], align 1
  %8 = alloca [32 x i8], align 16
  %9 = alloca %struct.aes_key_st, align 4
  %10 = getelementptr inbounds i8, i8* %0, i64 1
  %11 = load i8, i8* %10, align 1
  %12 = zext i8 %11 to i32
  %13 = and i32 %12, 3
  %14 = icmp eq i32 %13, 3
  %15 = zext i1 %14 to i32
  %16 = mul nsw i32 6, %15
  %17 = add nsw i32 24, %16
  %18 = add nsw i32 %17, 7
  %19 = sext i32 %18 to i64
  %20 = getelementptr inbounds i8, i8* %0, i64 %19
  %21 = load i8, i8* %20, align 1
  %22 = getelementptr inbounds [6 x i8], [6 x i8]* %7, i64 0, i64 0
  store i8 %21, i8* %22, align 1
  %23 = add nsw i32 %17, 6
  %24 = sext i32 %23 to i64
  %25 = getelementptr inbounds i8, i8* %0, i64 %24
  %26 = load i8, i8* %25, align 1
  %27 = getelementptr inbounds [6 x i8], [6 x i8]* %7, i64 0, i64 1
  store i8 %26, i8* %27, align 1
  %28 = add nsw i32 %17, 5
  %29 = sext i32 %28 to i64
  %30 = getelementptr inbounds i8, i8* %0, i64 %29
  %31 = load i8, i8* %30, align 1
  %32 = getelementptr inbounds [6 x i8], [6 x i8]* %7, i64 0, i64 2
  store i8 %31, i8* %32, align 1
  %33 = add nsw i32 %17, 4
  %34 = sext i32 %33 to i64
  %35 = getelementptr inbounds i8, i8* %0, i64 %34
  %36 = load i8, i8* %35, align 1
  %37 = getelementptr inbounds [6 x i8], [6 x i8]* %7, i64 0, i64 3
  store i8 %36, i8* %37, align 1
  %38 = add nsw i32 %17, 1
  %39 = sext i32 %38 to i64
  %40 = getelementptr inbounds i8, i8* %0, i64 %39
  %41 = load i8, i8* %40, align 1
  %42 = getelementptr inbounds [6 x i8], [6 x i8]* %7, i64 0, i64 4
  store i8 %41, i8* %42, align 1
  %43 = add nsw i32 %17, 0
  %44 = sext i32 %43 to i64
  %45 = getelementptr inbounds i8, i8* %0, i64 %44
  %46 = load i8, i8* %45, align 1
  %47 = getelementptr inbounds [6 x i8], [6 x i8]* %7, i64 0, i64 5
  store i8 %46, i8* %47, align 1
  %48 = sub nsw i32 %1, %17
  %49 = sub nsw i32 %48, 8
  %50 = sub nsw i32 %49, 8
  %51 = getelementptr inbounds [16 x i8], [16 x i8]* %4, i64 0, i64 0
  store i8 89, i8* %51, align 16
  %52 = getelementptr inbounds [16 x i8], [16 x i8]* %4, i64 0, i64 1
  store i8 0, i8* %52, align 1
  %53 = getelementptr inbounds [16 x i8], [16 x i8]* %4, i32 0, i32 0
  %54 = getelementptr inbounds i8, i8* %53, i64 2
  %55 = getelementptr inbounds i8, i8* %0, i64 10
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %54, i8* align 1 %55, i64 6, i1 false)
  %56 = getelementptr inbounds [16 x i8], [16 x i8]* %4, i32 0, i32 0
  %57 = getelementptr inbounds i8, i8* %56, i64 8
  %58 = getelementptr inbounds [6 x i8], [6 x i8]* %7, i32 0, i32 0
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %57, i8* align 1 %58, i64 6, i1 false)
  %59 = ashr i32 %50, 8
  %60 = and i32 %59, 255
  %61 = trunc i32 %60 to i8
  %62 = getelementptr inbounds [16 x i8], [16 x i8]* %4, i64 0, i64 14
  store i8 %61, i8* %62, align 2
  %63 = and i32 %50, 255
  %64 = trunc i32 %63 to i8
  %65 = getelementptr inbounds [16 x i8], [16 x i8]* %4, i64 0, i64 15
  store i8 %64, i8* %65, align 1
  %66 = getelementptr inbounds [32 x i8], [32 x i8]* %8, i32 0, i32 0
  call void @llvm.memset.p0i8.i64(i8* align 16 %66, i8 0, i64 32, i1 false)
  %67 = mul nsw i32 6, %15
  %68 = add nsw i32 22, %67
  %69 = trunc i32 %68 to i8
  %70 = getelementptr inbounds [32 x i8], [32 x i8]* %8, i64 0, i64 1
  store i8 %69, i8* %70, align 1
  %71 = getelementptr inbounds i8, i8* %0, i64 0
  %72 = load i8, i8* %71, align 1
  %73 = zext i8 %72 to i32
  %74 = and i32 %73, 143
  %75 = trunc i32 %74 to i8
  %76 = getelementptr inbounds [32 x i8], [32 x i8]* %8, i64 0, i64 2
  store i8 %75, i8* %76, align 2
  %77 = getelementptr inbounds i8, i8* %0, i64 1
  %78 = load i8, i8* %77, align 1
  %79 = zext i8 %78 to i32
  %80 = and i32 %79, 199
  %81 = trunc i32 %80 to i8
  %82 = getelementptr inbounds [32 x i8], [32 x i8]* %8, i64 0, i64 3
  store i8 %81, i8* %82, align 1
  %83 = getelementptr inbounds [32 x i8], [32 x i8]* %8, i32 0, i32 0
  %84 = getelementptr inbounds i8, i8* %83, i64 4
  %85 = getelementptr inbounds i8, i8* %0, i64 4
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %84, i8* align 1 %85, i64 18, i1 false)
  %86 = getelementptr inbounds i8, i8* %0, i64 22
  %87 = load i8, i8* %86, align 1
  %88 = zext i8 %87 to i32
  %89 = and i32 %88, 15
  %90 = trunc i32 %89 to i8
  %91 = getelementptr inbounds [32 x i8], [32 x i8]* %8, i64 0, i64 22
  store i8 %90, i8* %91, align 2
  %92 = icmp ne i32 %15, 0
  br i1 %92, label %93, label %97

; <label>:93:                                     ; preds = %3
  %94 = getelementptr inbounds [32 x i8], [32 x i8]* %8, i32 0, i32 0
  %95 = getelementptr inbounds i8, i8* %94, i64 24
  %96 = getelementptr inbounds i8, i8* %0, i64 24
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %95, i8* align 1 %96, i64 6, i1 false)
  br label %97

; <label>:97:                                     ; preds = %93, %3
  %98 = call i32 @AES_set_encrypt_key(i8* %2, i32 128, %struct.aes_key_st* %9)
  %99 = getelementptr inbounds [16 x i8], [16 x i8]* %4, i32 0, i32 0
  %100 = getelementptr inbounds [16 x i8], [16 x i8]* %6, i32 0, i32 0
  call void @AES_encrypt(i8* %99, i8* %100, %struct.aes_key_st* %9)
  %101 = getelementptr inbounds [16 x i8], [16 x i8]* %6, i32 0, i32 0
  %102 = getelementptr inbounds [32 x i8], [32 x i8]* %8, i32 0, i32 0
  call void @XOR(i8* %101, i8* %102, i32 16)
  %103 = getelementptr inbounds [16 x i8], [16 x i8]* %6, i32 0, i32 0
  %104 = getelementptr inbounds [16 x i8], [16 x i8]* %6, i32 0, i32 0
  call void @AES_encrypt(i8* %103, i8* %104, %struct.aes_key_st* %9)
  %105 = getelementptr inbounds [16 x i8], [16 x i8]* %6, i32 0, i32 0
  %106 = getelementptr inbounds [32 x i8], [32 x i8]* %8, i32 0, i32 0
  %107 = getelementptr inbounds i8, i8* %106, i64 16
  call void @XOR(i8* %105, i8* %107, i32 16)
  %108 = getelementptr inbounds [16 x i8], [16 x i8]* %6, i32 0, i32 0
  %109 = getelementptr inbounds [16 x i8], [16 x i8]* %6, i32 0, i32 0
  call void @AES_encrypt(i8* %108, i8* %109, %struct.aes_key_st* %9)
  %110 = getelementptr inbounds [16 x i8], [16 x i8]* %4, i64 0, i64 0
  %111 = load i8, i8* %110, align 16
  %112 = zext i8 %111 to i32
  %113 = and i32 %112, 7
  %114 = trunc i32 %113 to i8
  store i8 %114, i8* %110, align 16
  %115 = getelementptr inbounds [16 x i8], [16 x i8]* %4, i64 0, i64 15
  store i8 0, i8* %115, align 1
  %116 = getelementptr inbounds [16 x i8], [16 x i8]* %4, i64 0, i64 14
  store i8 0, i8* %116, align 2
  %117 = getelementptr inbounds [16 x i8], [16 x i8]* %4, i32 0, i32 0
  %118 = getelementptr inbounds [16 x i8], [16 x i8]* %5, i32 0, i32 0
  call void @AES_encrypt(i8* %117, i8* %118, %struct.aes_key_st* %9)
  %119 = sext i32 %1 to i64
  %120 = getelementptr inbounds i8, i8* %0, i64 %119
  %121 = getelementptr inbounds i8, i8* %120, i64 -8
  %122 = getelementptr inbounds [16 x i8], [16 x i8]* %5, i32 0, i32 0
  call void @XOR(i8* %121, i8* %122, i32 8)
  %123 = add nsw i32 %50, 16
  %124 = sub nsw i32 %123, 1
  %125 = sdiv i32 %124, 16
  %126 = srem i32 %50, 16
  %127 = add nsw i32 %17, 8
  %128 = icmp sle i32 1, %125
  br i1 %128, label %.lr.ph.preheader, label %._crit_edge

.lr.ph.preheader:                                 ; preds = %97
  br label %.lr.ph

.lr.ph:                                           ; preds = %.lr.ph.preheader, %.lr.ph
  %.03 = phi i32 [ %149, %.lr.ph ], [ %127, %.lr.ph.preheader ]
  %.012 = phi i32 [ %150, %.lr.ph ], [ 1, %.lr.ph.preheader ]
  %129 = icmp sgt i32 %126, 0
  %130 = icmp eq i32 %.012, %125
  %or.cond = and i1 %129, %130
  %131 = select i1 %or.cond, i32 %126, i32 16
  %132 = ashr i32 %.012, 8
  %133 = and i32 %132, 255
  %134 = trunc i32 %133 to i8
  %135 = getelementptr inbounds [16 x i8], [16 x i8]* %4, i64 0, i64 14
  store i8 %134, i8* %135, align 2
  %136 = and i32 %.012, 255
  %137 = trunc i32 %136 to i8
  %138 = getelementptr inbounds [16 x i8], [16 x i8]* %4, i64 0, i64 15
  store i8 %137, i8* %138, align 1
  %139 = getelementptr inbounds [16 x i8], [16 x i8]* %4, i32 0, i32 0
  %140 = getelementptr inbounds [16 x i8], [16 x i8]* %5, i32 0, i32 0
  call void @AES_encrypt(i8* %139, i8* %140, %struct.aes_key_st* %9)
  %141 = sext i32 %.03 to i64
  %142 = getelementptr inbounds i8, i8* %0, i64 %141
  %143 = getelementptr inbounds [16 x i8], [16 x i8]* %5, i32 0, i32 0
  call void @XOR(i8* %142, i8* %143, i32 %131)
  %144 = getelementptr inbounds [16 x i8], [16 x i8]* %6, i32 0, i32 0
  %145 = sext i32 %.03 to i64
  %146 = getelementptr inbounds i8, i8* %0, i64 %145
  call void @XOR(i8* %144, i8* %146, i32 %131)
  %147 = getelementptr inbounds [16 x i8], [16 x i8]* %6, i32 0, i32 0
  %148 = getelementptr inbounds [16 x i8], [16 x i8]* %6, i32 0, i32 0
  call void @AES_encrypt(i8* %147, i8* %148, %struct.aes_key_st* %9)
  %149 = add nsw i32 %.03, %131
  %150 = add nuw nsw i32 %.012, 1
  %151 = icmp sle i32 %150, %125
  br i1 %151, label %.lr.ph, label %._crit_edge.loopexit

._crit_edge.loopexit:                             ; preds = %.lr.ph
  %.0.lcssa.ph = phi i32 [ %149, %.lr.ph ]
  br label %._crit_edge

._crit_edge:                                      ; preds = %._crit_edge.loopexit, %97
  %.0.lcssa = phi i32 [ %127, %97 ], [ %.0.lcssa.ph, %._crit_edge.loopexit ]
  %152 = sext i32 %.0.lcssa to i64
  %153 = getelementptr inbounds i8, i8* %0, i64 %152
  %154 = getelementptr inbounds [16 x i8], [16 x i8]* %6, i32 0, i32 0
  %155 = call i32 @memcmp(i8* %153, i8* %154, i64 8) #10
  %156 = icmp eq i32 %155, 0
  %157 = zext i1 %156 to i32
  ret i32 %157
}

declare dso_local i32 @AES_set_encrypt_key(i8*, i32, %struct.aes_key_st*) #1

declare dso_local void @AES_encrypt(i8*, i8*, %struct.aes_key_st*) #1

; Function Attrs: noinline nounwind uwtable
define internal void @XOR(i8*, i8*, i32) #0 {
  %4 = icmp slt i32 0, %2
  br i1 %4, label %.lr.ph, label %._crit_edge

.lr.ph:                                           ; preds = %3
  %5 = zext i32 %2 to i64
  br label %6

; <label>:6:                                      ; preds = %.lr.ph, %6
  %indvars.iv = phi i64 [ 0, %.lr.ph ], [ %indvars.iv.next, %6 ]
  %7 = getelementptr inbounds i8, i8* %1, i64 %indvars.iv
  %8 = load i8, i8* %7, align 1
  %9 = zext i8 %8 to i32
  %10 = getelementptr inbounds i8, i8* %0, i64 %indvars.iv
  %11 = load i8, i8* %10, align 1
  %12 = zext i8 %11 to i32
  %13 = xor i32 %12, %9
  %14 = trunc i32 %13 to i8
  store i8 %14, i8* %10, align 1
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond1 = icmp ne i64 %indvars.iv.next, %5
  br i1 %exitcond1, label %6, label %._crit_edge.loopexit

._crit_edge.loopexit:                             ; preds = %6
  br label %._crit_edge

._crit_edge:                                      ; preds = %._crit_edge.loopexit, %3
  ret void
}

; Function Attrs: noinline nounwind uwtable
define dso_local i32 @get_ram_size() #0 {
  %1 = alloca [256 x i8], align 16
  %2 = alloca i32, align 4
  store i32 0, i32* %2, align 4
  %3 = getelementptr [14 x i8], [14 x i8]* @.str.186, i32 0, i32 0
  %4 = getelementptr [2 x i8], [2 x i8]* @.str.1.187, i32 0, i32 0
  %5 = call %struct._IO_FILE* @fopen64(i8* %3, i8* %4)
  %6 = icmp ne %struct._IO_FILE* %5, null
  br i1 %6, label %9, label %7

; <label>:7:                                      ; preds = %0
  %8 = getelementptr [12 x i8], [12 x i8]* @.str.2.188, i32 0, i32 0
  call void @perror(i8* %8)
  br label %26

; <label>:9:                                      ; preds = %0
  %10 = getelementptr inbounds [256 x i8], [256 x i8]* %1, i32 0, i32 0
  call void @llvm.memset.p0i8.i64(i8* align 16 %10, i8 0, i64 256, i1 false)
  %11 = getelementptr inbounds [256 x i8], [256 x i8]* %1, i32 0, i32 0
  %12 = getelementptr [6 x i8], [6 x i8]* @.str.3.189, i32 0, i32 0
  %13 = call i32 (%struct._IO_FILE*, i8*, ...) @__isoc99_fscanf(%struct._IO_FILE* %5, i8* %12, i8* %11, i32* %2)
  %14 = icmp ne i32 %13, 0
  %spec.select2 = select i1 %14, i1 true, i1 false
  br i1 %spec.select2, label %.lr.ph, label %24

.lr.ph:                                           ; preds = %9
  br label %15

; <label>:15:                                     ; preds = %.lr.ph, %15
  %.013 = phi i32 [ -1, %.lr.ph ], [ %spec.select1, %15 ]
  %16 = getelementptr inbounds [256 x i8], [256 x i8]* %1, i32 0, i32 0
  %17 = getelementptr [9 x i8], [9 x i8]* @.str.4.190, i32 0, i32 0
  %18 = call i32 @strncmp(i8* %16, i8* %17, i64 8) #10
  %19 = icmp ne i32 %18, 0
  %20 = load i32, i32* %2, align 4
  %spec.select1 = select i1 %19, i32 %.013, i32 %20
  %21 = call i32 (%struct._IO_FILE*, i8*, ...) @__isoc99_fscanf(%struct._IO_FILE* %5, i8* %12, i8* %11, i32* %2)
  %22 = icmp ne i32 %21, 0
  %23 = icmp eq i32 %spec.select1, -1
  %spec.select = select i1 %22, i1 %23, i1 false
  br i1 %spec.select, label %15, label %._crit_edge

._crit_edge:                                      ; preds = %15
  %split = phi i32 [ %spec.select1, %15 ]
  br label %24

; <label>:24:                                     ; preds = %._crit_edge, %9
  %.01.lcssa = phi i32 [ %split, %._crit_edge ], [ -1, %9 ]
  %25 = call i32 @fclose(%struct._IO_FILE* %5)
  br label %26

; <label>:26:                                     ; preds = %24, %7
  %.0 = phi i32 [ %.01.lcssa, %24 ], [ -1, %7 ]
  ret i32 %.0
}

declare dso_local i32 @__isoc99_fscanf(%struct._IO_FILE*, i8*, ...) #1

; Function Attrs: nounwind readonly
declare dso_local i32 @strncmp(i8*, i8*, i64) #3

; Function Attrs: noinline nounwind uwtable
define dso_local i8* @getVersion(i8*, i32, i32, i32, i32, i32, i32) #8 {
  %8 = call noalias i8* @calloc(i64 1, i64 20) #9
  %9 = call i64 @strlen(i8* %0) #10
  %10 = add i64 %9, 200
  %11 = trunc i64 %10 to i32
  %12 = sext i32 %11 to i64
  %13 = call noalias i8* @calloc(i64 1, i64 %12) #9
  %14 = sext i32 %11 to i64
  %15 = getelementptr [9 x i8], [9 x i8]* @.str.5.193, i32 0, i32 0
  %16 = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %13, i64 %14, i8* %15, i8* %0, i32 %1, i32 %2) #9
  %17 = icmp sgt i32 %3, 0
  br i1 %17, label %18, label %25

; <label>:18:                                     ; preds = %7
  %19 = getelementptr [4 x i8], [4 x i8]* @.str.6.194, i32 0, i32 0
  %20 = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %8, i64 20, i8* %19, i32 %3) #9
  %21 = sext i32 %11 to i64
  %22 = call i64 @strlen(i8* %13) #10
  %23 = sub i64 %21, %22
  %24 = call i8* @strncat(i8* %13, i8* %8, i64 %23) #9
  call void @llvm.memset.p0i8.i64(i8* align 1 %8, i8 0, i64 20, i1 false)
  br label %25

; <label>:25:                                     ; preds = %18, %7
  %26 = icmp sgt i32 %6, 0
  br i1 %26, label %27, label %34

; <label>:27:                                     ; preds = %25
  %28 = getelementptr [6 x i8], [6 x i8]* @.str.7.195, i32 0, i32 0
  %29 = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %8, i64 20, i8* %28, i32 %6) #9
  %30 = sext i32 %11 to i64
  %31 = call i64 @strlen(i8* %13) #10
  %32 = sub i64 %30, %31
  %33 = call i8* @strncat(i8* %13, i8* %8, i64 %32) #9
  call void @llvm.memset.p0i8.i64(i8* align 1 %8, i8 0, i64 20, i1 false)
  br label %43

; <label>:34:                                     ; preds = %25
  %35 = icmp sgt i32 %5, 0
  br i1 %35, label %36, label %43

; <label>:36:                                     ; preds = %34
  %37 = getelementptr [8 x i8], [8 x i8]* @.str.8.196, i32 0, i32 0
  %38 = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %8, i64 20, i8* %37, i32 %5) #9
  %39 = sext i32 %11 to i64
  %40 = call i64 @strlen(i8* %13) #10
  %41 = sub i64 %39, %40
  %42 = call i8* @strncat(i8* %13, i8* %8, i64 %41) #9
  call void @llvm.memset.p0i8.i64(i8* align 1 %8, i8 0, i64 20, i1 false)
  br label %43

; <label>:43:                                     ; preds = %34, %36, %27
  %44 = icmp sgt i32 %4, 0
  br i1 %44, label %45, label %52

; <label>:45:                                     ; preds = %43
  %46 = getelementptr [5 x i8], [5 x i8]* @.str.9.197, i32 0, i32 0
  %47 = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %8, i64 20, i8* %46, i32 %4) #9
  %48 = sext i32 %11 to i64
  %49 = call i64 @strlen(i8* %13) #10
  %50 = sub i64 %48, %49
  %51 = call i8* @strncat(i8* %13, i8* %8, i64 %50) #9
  call void @llvm.memset.p0i8.i64(i8* align 1 %8, i8 0, i64 20, i1 false)
  br label %52

; <label>:52:                                     ; preds = %45, %43
  call void @free(i8* %8) #9
  %53 = call i64 @strlen(i8* %13) #10
  %54 = add i64 %53, 1
  %55 = call i8* @realloc(i8* %13, i64 %54) #9, !track !255
  ret i8* %55
}

; Function Attrs: nounwind
declare dso_local i8* @strncat(i8*, i8*, i64) #2

; Function Attrs: noinline nounwind uwtable
define dso_local i32 @get_nb_cpus() #0 {
  %1 = getelementptr [14 x i8], [14 x i8]* @.str.10.200, i32 0, i32 0
  %2 = getelementptr [2 x i8], [2 x i8]* @.str.1.187, i32 0, i32 0
  %3 = call %struct._IO_FILE* @fopen64(i8* %1, i8* %2)
  %4 = icmp ne %struct._IO_FILE* %3, null
  br i1 %4, label %5, label %24

; <label>:5:                                      ; preds = %0
  %6 = call noalias i8* @calloc(i64 1, i64 81) #9
  %7 = icmp ne i8* %6, null
  br i1 %7, label %8, label %22

; <label>:8:                                      ; preds = %5
  %9 = call i8* @fgets(i8* %6, i32 80, %struct._IO_FILE* %3)
  %10 = icmp ne i8* %9, null
  br i1 %10, label %.lr.ph.preheader, label %._crit_edge

.lr.ph.preheader:                                 ; preds = %8
  br label %.lr.ph

.lr.ph:                                           ; preds = %.lr.ph.preheader, %18
  %.01 = phi i32 [ %.1, %18 ], [ -2, %.lr.ph.preheader ]
  %11 = getelementptr [10 x i8], [10 x i8]* @.str.11.201, i32 0, i32 0
  %12 = call i8* @strstr(i8* %6, i8* %11) #10
  %13 = icmp eq i8* %12, %6
  br i1 %13, label %14, label %18

; <label>:14:                                     ; preds = %.lr.ph
  %15 = call i8* @strchr(i8* %6, i32 58) #10
  %16 = getelementptr inbounds i8, i8* %15, i64 1
  %17 = call i32 @atoi(i8* %16) #10
  br label %18

; <label>:18:                                     ; preds = %14, %.lr.ph
  %.1 = phi i32 [ %17, %14 ], [ %.01, %.lr.ph ]
  %19 = call i8* @fgets(i8* %6, i32 80, %struct._IO_FILE* %3)
  %20 = icmp ne i8* %19, null
  br i1 %20, label %.lr.ph, label %._crit_edge.loopexit

._crit_edge.loopexit:                             ; preds = %18
  %.0.lcssa.ph = phi i32 [ %.1, %18 ]
  br label %._crit_edge

._crit_edge:                                      ; preds = %._crit_edge.loopexit, %8
  %.0.lcssa = phi i32 [ -2, %8 ], [ %.0.lcssa.ph, %._crit_edge.loopexit ]
  %21 = add nsw i32 %.0.lcssa, 1
  call void @free(i8* %6) #9
  br label %22

; <label>:22:                                     ; preds = %._crit_edge, %5
  %.2 = phi i32 [ %21, %._crit_edge ], [ -1, %5 ]
  %23 = call i32 @fclose(%struct._IO_FILE* %3)
  br label %24

; <label>:24:                                     ; preds = %22, %0
  %.3 = phi i32 [ %.2, %22 ], [ -1, %0 ]
  %25 = icmp eq i32 %.3, -1
  br i1 %25, label %26, label %30

; <label>:26:                                     ; preds = %24
  %27 = call i64 @sysconf(i32 84) #9
  %28 = trunc i64 %27 to i32
  %29 = icmp slt i32 %28, 1
  %spec.select = select i1 %29, i32 -1, i32 %28
  br label %30

; <label>:30:                                     ; preds = %26, %24
  %.5 = phi i32 [ %spec.select, %26 ], [ %.3, %24 ]
  ret i32 %.5
}

; Function Attrs: nounwind readonly
declare dso_local i8* @strstr(i8*, i8*) #3

; Function Attrs: nounwind readonly
declare dso_local i8* @strchr(i8*, i32) #3

; Function Attrs: nounwind
declare dso_local i64 @sysconf(i32) #2

; Function Attrs: noinline nounwind uwtable
define dso_local i32 @maccmp(i8*, i8*) #0 {
  %3 = icmp eq i8* %0, null
  %4 = icmp eq i8* %1, null
  %or.cond = or i1 %3, %4
  br i1 %or.cond, label %17, label %.preheader

.preheader:                                       ; preds = %2
  br label %5

; <label>:5:                                      ; preds = %.preheader, %15
  %indvars.iv = phi i64 [ %indvars.iv.next, %15 ], [ 0, %.preheader ]
  %6 = getelementptr inbounds i8, i8* %0, i64 %indvars.iv
  %7 = load i8, i8* %6, align 1
  %8 = zext i8 %7 to i32
  %9 = call i32 @toupper(i32 %8) #10
  %10 = getelementptr inbounds i8, i8* %1, i64 %indvars.iv
  %11 = load i8, i8* %10, align 1
  %12 = zext i8 %11 to i32
  %13 = call i32 @toupper(i32 %12) #10
  %14 = icmp ne i32 %9, %13
  br i1 %14, label %.loopexit, label %15

; <label>:15:                                     ; preds = %5
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %16 = icmp ult i64 %indvars.iv.next, 6
  br i1 %16, label %5, label %.loopexit

.loopexit:                                        ; preds = %5, %15
  %.0.ph = phi i32 [ 0, %15 ], [ -1, %5 ]
  br label %17

; <label>:17:                                     ; preds = %.loopexit, %2
  %.0 = phi i32 [ -1, %2 ], [ %.0.ph, %.loopexit ]
  ret i32 %.0
}

; Function Attrs: noinline nounwind uwtable
define dso_local i8* @mac2string(i8*) #0 {
  %2 = call noalias i8* @malloc(i64 18) #9
  %3 = load i8, i8* %0, align 1
  %4 = zext i8 %3 to i32
  %5 = getelementptr inbounds i8, i8* %0, i64 1
  %6 = load i8, i8* %5, align 1
  %7 = zext i8 %6 to i32
  %8 = getelementptr inbounds i8, i8* %0, i64 2
  %9 = load i8, i8* %8, align 1
  %10 = zext i8 %9 to i32
  %11 = getelementptr inbounds i8, i8* %0, i64 3
  %12 = load i8, i8* %11, align 1
  %13 = zext i8 %12 to i32
  %14 = getelementptr inbounds i8, i8* %0, i64 4
  %15 = load i8, i8* %14, align 1
  %16 = zext i8 %15 to i32
  %17 = getelementptr inbounds i8, i8* %0, i64 5
  %18 = load i8, i8* %17, align 1
  %19 = zext i8 %18 to i32
  %20 = getelementptr [30 x i8], [30 x i8]* @.str.12.202, i32 0, i32 0
  %21 = call i32 (i8*, i64, i8*, ...) @snprintf(i8* %2, i64 18, i8* %20, i32 %4, i32 %7, i32 %10, i32 %13, i32 %16, i32 %19) #9
  ret i8* %2
}

; Function Attrs: noinline nounwind uwtable
define dso_local i32 @hexCharToInt(i8 zeroext) #0 {
  %2 = load i32, i32* @hexCharToInt.table_created, align 4
  %3 = icmp eq i32 %2, 0
  br i1 %3, label %.preheader, label %44

.preheader:                                       ; preds = %1
  br label %4

; <label>:4:                                      ; preds = %.preheader, %41
  %indvars.iv = phi i64 [ %indvars.iv.next, %41 ], [ 0, %.preheader ]
  %.01 = phi i32 [ %42, %41 ], [ 0, %.preheader ]
  %5 = trunc i32 %.01 to i8
  %6 = zext i8 %5 to i32
  switch i32 %6, label %39 [
    i32 48, label %7
    i32 49, label %9
    i32 50, label %11
    i32 51, label %13
    i32 52, label %15
    i32 53, label %17
    i32 54, label %19
    i32 55, label %21
    i32 56, label %23
    i32 57, label %25
    i32 65, label %27
    i32 97, label %27
    i32 66, label %29
    i32 98, label %29
    i32 67, label %31
    i32 99, label %31
    i32 68, label %33
    i32 100, label %33
    i32 69, label %35
    i32 101, label %35
    i32 70, label %37
    i32 102, label %37
  ]

; <label>:7:                                      ; preds = %4
  %8 = getelementptr inbounds [256 x i32], [256 x i32]* @hexCharToInt.table, i64 0, i64 %indvars.iv
  store i32 0, i32* %8, align 4
  br label %41

; <label>:9:                                      ; preds = %4
  %10 = getelementptr inbounds [256 x i32], [256 x i32]* @hexCharToInt.table, i64 0, i64 %indvars.iv
  store i32 1, i32* %10, align 4
  br label %41

; <label>:11:                                     ; preds = %4
  %12 = getelementptr inbounds [256 x i32], [256 x i32]* @hexCharToInt.table, i64 0, i64 %indvars.iv
  store i32 2, i32* %12, align 4
  br label %41

; <label>:13:                                     ; preds = %4
  %14 = getelementptr inbounds [256 x i32], [256 x i32]* @hexCharToInt.table, i64 0, i64 %indvars.iv
  store i32 3, i32* %14, align 4
  br label %41

; <label>:15:                                     ; preds = %4
  %16 = getelementptr inbounds [256 x i32], [256 x i32]* @hexCharToInt.table, i64 0, i64 %indvars.iv
  store i32 4, i32* %16, align 4
  br label %41

; <label>:17:                                     ; preds = %4
  %18 = getelementptr inbounds [256 x i32], [256 x i32]* @hexCharToInt.table, i64 0, i64 %indvars.iv
  store i32 5, i32* %18, align 4
  br label %41

; <label>:19:                                     ; preds = %4
  %20 = getelementptr inbounds [256 x i32], [256 x i32]* @hexCharToInt.table, i64 0, i64 %indvars.iv
  store i32 6, i32* %20, align 4
  br label %41

; <label>:21:                                     ; preds = %4
  %22 = getelementptr inbounds [256 x i32], [256 x i32]* @hexCharToInt.table, i64 0, i64 %indvars.iv
  store i32 7, i32* %22, align 4
  br label %41

; <label>:23:                                     ; preds = %4
  %24 = getelementptr inbounds [256 x i32], [256 x i32]* @hexCharToInt.table, i64 0, i64 %indvars.iv
  store i32 8, i32* %24, align 4
  br label %41

; <label>:25:                                     ; preds = %4
  %26 = getelementptr inbounds [256 x i32], [256 x i32]* @hexCharToInt.table, i64 0, i64 %indvars.iv
  store i32 9, i32* %26, align 4
  br label %41

; <label>:27:                                     ; preds = %4, %4
  %28 = getelementptr inbounds [256 x i32], [256 x i32]* @hexCharToInt.table, i64 0, i64 %indvars.iv
  store i32 10, i32* %28, align 4
  br label %41

; <label>:29:                                     ; preds = %4, %4
  %30 = getelementptr inbounds [256 x i32], [256 x i32]* @hexCharToInt.table, i64 0, i64 %indvars.iv
  store i32 11, i32* %30, align 4
  br label %41

; <label>:31:                                     ; preds = %4, %4
  %32 = getelementptr inbounds [256 x i32], [256 x i32]* @hexCharToInt.table, i64 0, i64 %indvars.iv
  store i32 12, i32* %32, align 4
  br label %41

; <label>:33:                                     ; preds = %4, %4
  %34 = getelementptr inbounds [256 x i32], [256 x i32]* @hexCharToInt.table, i64 0, i64 %indvars.iv
  store i32 13, i32* %34, align 4
  br label %41

; <label>:35:                                     ; preds = %4, %4
  %36 = getelementptr inbounds [256 x i32], [256 x i32]* @hexCharToInt.table, i64 0, i64 %indvars.iv
  store i32 14, i32* %36, align 4
  br label %41

; <label>:37:                                     ; preds = %4, %4
  %38 = getelementptr inbounds [256 x i32], [256 x i32]* @hexCharToInt.table, i64 0, i64 %indvars.iv
  store i32 15, i32* %38, align 4
  br label %41

; <label>:39:                                     ; preds = %4
  %40 = getelementptr inbounds [256 x i32], [256 x i32]* @hexCharToInt.table, i64 0, i64 %indvars.iv
  store i32 -1, i32* %40, align 4
  br label %41

; <label>:41:                                     ; preds = %7, %9, %11, %13, %15, %17, %19, %21, %23, %25, %27, %29, %31, %33, %35, %37, %39
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %42 = add nuw nsw i32 %.01, 1
  %exitcond = icmp ne i64 %indvars.iv.next, 256
  br i1 %exitcond, label %4, label %43

; <label>:43:                                     ; preds = %41
  store i32 1, i32* @hexCharToInt.table_created, align 4
  br label %44

; <label>:44:                                     ; preds = %43, %1
  %45 = zext i8 %0 to i64
  %46 = getelementptr inbounds [256 x i32], [256 x i32]* @hexCharToInt.table, i64 0, i64 %45
  %47 = load i32, i32* %46, align 4
  ret i32 %47
}

; Function Attrs: noinline nounwind uwtable
define dso_local i32 @hexStringToHex(i8*, i32, i8*) #0 {
  %4 = icmp slt i32 %1, 1
  br i1 %4, label %52, label %5

; <label>:5:                                      ; preds = %3
  %6 = icmp slt i32 0, %1
  br i1 %6, label %.lr.ph.preheader, label %50

.lr.ph.preheader:                                 ; preds = %5
  br label %.lr.ph

.lr.ph:                                           ; preds = %.lr.ph.preheader, %39
  %indvars.iv = phi i64 [ %indvars.iv.next, %39 ], [ 0, %.lr.ph.preheader ]
  %.018 = phi i8* [ %.1, %39 ], [ %0, %.lr.ph.preheader ]
  %.027 = phi i32 [ %.13, %39 ], [ %1, %.lr.ph.preheader ]
  %7 = getelementptr inbounds i8, i8* %.018, i64 %indvars.iv
  %8 = load i8, i8* %7, align 1
  %9 = sext i8 %8 to i32
  %10 = icmp eq i32 %9, 45
  br i1 %10, label %26, label %11

; <label>:11:                                     ; preds = %.lr.ph
  %12 = getelementptr inbounds i8, i8* %.018, i64 %indvars.iv
  %13 = load i8, i8* %12, align 1
  %14 = sext i8 %13 to i32
  %15 = icmp eq i32 %14, 58
  br i1 %15, label %26, label %16

; <label>:16:                                     ; preds = %11
  %17 = getelementptr inbounds i8, i8* %.018, i64 %indvars.iv
  %18 = load i8, i8* %17, align 1
  %19 = sext i8 %18 to i32
  %20 = icmp eq i32 %19, 95
  br i1 %20, label %26, label %21

; <label>:21:                                     ; preds = %16
  %22 = getelementptr inbounds i8, i8* %.018, i64 %indvars.iv
  %23 = load i8, i8* %22, align 1
  %24 = sext i8 %23 to i32
  %25 = icmp eq i32 %24, 32
  br i1 %25, label %26, label %29

; <label>:26:                                     ; preds = %21, %16, %11, %.lr.ph
  %27 = getelementptr inbounds i8, i8* %.018, i32 1
  %28 = add nsw i32 %.027, -1
  br label %29

; <label>:29:                                     ; preds = %26, %21
  %.13 = phi i32 [ %28, %26 ], [ %.027, %21 ]
  %.1 = phi i8* [ %27, %26 ], [ %.018, %21 ]
  %30 = getelementptr inbounds i8, i8* %.1, i64 %indvars.iv
  %31 = load i8, i8* %30, align 1
  %32 = call i32 @hexCharToInt(i8 zeroext %31)
  %33 = add nuw nsw i64 %indvars.iv, 1
  %34 = getelementptr inbounds i8, i8* %.1, i64 %33
  %35 = load i8, i8* %34, align 1
  %36 = call i32 @hexCharToInt(i8 zeroext %35)
  %37 = icmp slt i32 %32, 0
  %38 = icmp sgt i32 %32, 15
  %or.cond = or i1 %37, %38
  br i1 %or.cond, label %.loopexit, label %39

; <label>:39:                                     ; preds = %29
  %40 = shl i32 %32, 4
  %41 = add nsw i32 %40, %36
  %42 = and i32 %41, 255
  %43 = trunc i32 %42 to i8
  %44 = trunc i64 %indvars.iv to i32
  %.udiv = udiv i32 %44, 2
  %45 = sext i32 %.udiv to i64
  %46 = getelementptr inbounds i8, i8* %2, i64 %45
  store i8 %43, i8* %46, align 1
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 2
  %47 = sext i32 %.13 to i64
  %48 = icmp slt i64 %indvars.iv.next, %47
  br i1 %48, label %.lr.ph, label %._crit_edge

._crit_edge:                                      ; preds = %39
  %split.wide = phi i64 [ %indvars.iv.next, %39 ]
  %49 = trunc i64 %split.wide to i32
  br label %50

; <label>:50:                                     ; preds = %._crit_edge, %5
  %.04.lcssa = phi i32 [ %49, %._crit_edge ], [ 0, %5 ]
  %51 = sdiv i32 %.04.lcssa, 2
  br label %52

.loopexit:                                        ; preds = %29
  %.0.ph = phi i32 [ -1, %29 ]
  br label %52

; <label>:52:                                     ; preds = %.loopexit, %3, %50
  %.0 = phi i32 [ %51, %50 ], [ 1, %3 ], [ %.0.ph, %.loopexit ]
  ret i32 %.0
}

; Function Attrs: noinline nounwind uwtable
define dso_local i32 @getmac(i8*, i32, i8*) #0 {
  %4 = alloca [3 x i8], align 1, !track !256
  %5 = alloca i32, align 4, !track !257
  %6 = icmp eq i8* %0, null
  br i1 %6, label %75, label %7

; <label>:7:                                      ; preds = %3
  %8 = call i64 @strlen(i8* %0) #10
  %9 = trunc i64 %8 to i32
  %10 = icmp slt i32 %9, 12
  br i1 %10, label %75, label %11

; <label>:11:                                     ; preds = %7
  call void @llvm.memset.p0i8.i64(i8* align 1 %2, i8 0, i64 6, i1 false)
  %12 = getelementptr inbounds [3 x i8], [3 x i8]* %4, i64 0, i64 2
  store i8 0, i8* %12, align 1
  %13 = load i8, i8* %0, align 1
  %14 = sext i8 %13 to i32
  %15 = icmp ne i32 %14, 0
  br i1 %15, label %.lr.ph.preheader, label %69

.lr.ph.preheader:                                 ; preds = %11
  br label %.lr.ph

.lr.ph:                                           ; preds = %.lr.ph.preheader, %62
  %indvars.iv = phi i64 [ %indvars.iv.next, %62 ], [ 0, %.lr.ph.preheader ]
  %.025 = phi i32 [ %.1, %62 ], [ 0, %.lr.ph.preheader ]
  call void @unroll_loop(i32 154)
  %16 = sext i32 %.025 to i64
  %17 = getelementptr inbounds i8, i8* %0, i64 %16
  %18 = load i8, i8* %17, align 1
  %19 = getelementptr inbounds [3 x i8], [3 x i8]* %4, i64 0, i64 0
  store i8 %18, i8* %19, align 1
  %20 = add nsw i32 %.025, 1
  %21 = sext i32 %20 to i64
  %22 = getelementptr inbounds i8, i8* %0, i64 %21
  %23 = load i8, i8* %22, align 1
  %24 = getelementptr inbounds [3 x i8], [3 x i8]* %4, i64 0, i64 1
  store i8 %23, i8* %24, align 1
  %25 = getelementptr inbounds [3 x i8], [3 x i8]* %4, i32 0, i32 0
  %26 = getelementptr [3 x i8], [3 x i8]* @.str.13.207, i32 0, i32 0
  %27 = call i32 (i8*, i8*, ...) @__isoc99_sscanf(i8* %25, i8* %26, i32* %5) #9
  %28 = icmp ne i32 %27, 1
  br i1 %28, label %29, label %33

; <label>:29:                                     ; preds = %.lr.ph
  %30 = getelementptr inbounds [3 x i8], [3 x i8]* %4, i32 0, i32 0
  %31 = call i64 @strlen(i8* %30) #10
  %32 = icmp eq i64 %31, 2
  br i1 %32, label %.loopexit, label %33

; <label>:33:                                     ; preds = %29, %.lr.ph
  %34 = getelementptr inbounds [3 x i8], [3 x i8]* %4, i64 0, i64 1
  %35 = load i8, i8* %34, align 1
  %36 = call i32 @hexCharToInt(i8 zeroext %35)
  %37 = icmp slt i32 %36, 0
  br i1 %37, label %.loopexit, label %38

; <label>:38:                                     ; preds = %33
  %39 = load i32, i32* %5, align 4
  %40 = trunc i32 %39 to i8
  %41 = getelementptr inbounds i8, i8* %2, i64 %indvars.iv
  store i8 %40, i8* %41, align 1
  %42 = add nsw i32 %.025, 2
  %indvars.iv.next = add nuw i64 %indvars.iv, 1
  %43 = sext i32 %42 to i64
  %44 = getelementptr inbounds i8, i8* %0, i64 %43
  %45 = load i8, i8* %44, align 1
  %46 = sext i8 %45 to i32
  %47 = icmp eq i32 %46, 58
  br i1 %47, label %60, label %48

; <label>:48:                                     ; preds = %38
  %49 = sext i32 %42 to i64
  %50 = getelementptr inbounds i8, i8* %0, i64 %49
  %51 = load i8, i8* %50, align 1
  %52 = sext i8 %51 to i32
  %53 = icmp eq i32 %52, 45
  br i1 %53, label %60, label %54

; <label>:54:                                     ; preds = %48
  %55 = sext i32 %42 to i64
  %56 = getelementptr inbounds i8, i8* %0, i64 %55
  %57 = load i8, i8* %56, align 1
  %58 = sext i8 %57 to i32
  %59 = icmp eq i32 %58, 95
  br i1 %59, label %60, label %62

; <label>:60:                                     ; preds = %54, %48, %38
  %61 = add nsw i32 %42, 1
  br label %62

; <label>:62:                                     ; preds = %60, %54
  %.1 = phi i32 [ %61, %60 ], [ %42, %54 ]
  %63 = sext i32 %.1 to i64
  %64 = getelementptr inbounds i8, i8* %0, i64 %63
  %65 = load i8, i8* %64, align 1
  %66 = sext i8 %65 to i32
  %67 = icmp ne i32 %66, 0
  br i1 %67, label %.lr.ph, label %._crit_edge

._crit_edge:                                      ; preds = %62
  %split.wide = phi i64 [ %indvars.iv.next, %62 ]
  %68 = trunc i64 %split.wide to i32
  br label %69

; <label>:69:                                     ; preds = %._crit_edge, %11
  %.01.lcssa = phi i32 [ %68, %._crit_edge ], [ 0, %11 ]
  %70 = icmp ne i32 %1, 0
  %71 = icmp ne i32 %.01.lcssa, 6
  %or.cond = and i1 %70, %71
  br i1 %or.cond, label %75, label %72

; <label>:72:                                     ; preds = %69
  %73 = icmp eq i32 %1, 0
  %74 = icmp sgt i32 %.01.lcssa, 6
  %or.cond1 = and i1 %73, %74
  %spec.select = select i1 %or.cond1, i32 1, i32 0
  ret i32 %spec.select

.loopexit:                                        ; preds = %29, %33
  br label %75

; <label>:75:                                     ; preds = %.loopexit, %69, %7, %3
  ret i32 1
}

; Function Attrs: nounwind
declare dso_local i32 @__isoc99_sscanf(i8*, i8*, ...) #2

; Function Attrs: noinline nounwind uwtable
define dso_local i32 @readLine(i8*, i32) #0 {
  %3 = sext i32 %1 to i64
  br label %4

; <label>:4:                                      ; preds = %29, %2
  %indvars.iv = phi i64 [ %indvars.iv.next, %29 ], [ -1, %2 ]
  %5 = call i32 @getchar()
  %6 = icmp eq i32 %5, -1
  %spec.select = select i1 %6, i32 0, i32 %5
  %7 = trunc i32 %spec.select to i8
  %indvars.iv.next = add nsw i64 %indvars.iv, 1
  %8 = getelementptr inbounds i8, i8* %0, i64 %indvars.iv.next
  store i8 %7, i8* %8, align 1
  %9 = getelementptr inbounds i8, i8* %0, i64 %indvars.iv.next
  %10 = load i8, i8* %9, align 1
  %11 = sext i8 %10 to i32
  %12 = icmp eq i32 %11, 10
  br i1 %12, label %13, label %15

; <label>:13:                                     ; preds = %4
  %.lcssa.wide = phi i64 [ %indvars.iv.next, %4 ]
  %14 = trunc i64 %.lcssa.wide to i32
  br label %33

; <label>:15:                                     ; preds = %4
  %16 = getelementptr inbounds i8, i8* %0, i64 %indvars.iv.next
  %17 = load i8, i8* %16, align 1
  %18 = sext i8 %17 to i32
  %19 = icmp eq i32 %18, 13
  br i1 %19, label %20, label %22

; <label>:20:                                     ; preds = %15
  %.lcssa2.wide = phi i64 [ %indvars.iv.next, %15 ]
  %21 = trunc i64 %.lcssa2.wide to i32
  br label %33

; <label>:22:                                     ; preds = %15
  %23 = getelementptr inbounds i8, i8* %0, i64 %indvars.iv.next
  %24 = load i8, i8* %23, align 1
  %25 = sext i8 %24 to i32
  %26 = icmp eq i32 %25, 0
  br i1 %26, label %27, label %29

; <label>:27:                                     ; preds = %22
  %.lcssa3.wide = phi i64 [ %indvars.iv.next, %22 ]
  %28 = trunc i64 %.lcssa3.wide to i32
  br label %33

; <label>:29:                                     ; preds = %22
  %30 = add nuw nsw i64 %indvars.iv.next, 1
  %31 = icmp slt i64 %30, %3
  br i1 %31, label %4, label %.loopexit

.loopexit:                                        ; preds = %29
  %.lcssa4.ph.wide = phi i64 [ %indvars.iv.next, %29 ]
  %32 = trunc i64 %.lcssa4.ph.wide to i32
  br label %33

; <label>:33:                                     ; preds = %.loopexit, %27, %20, %13
  %.lcssa4 = phi i32 [ %28, %27 ], [ %21, %20 ], [ %14, %13 ], [ %32, %.loopexit ]
  ret i32 %.lcssa4
}

declare dso_local i32 @getchar() #1

; Function Attrs: noinline nounwind uwtable
define dso_local i32 @hexToInt(i8*, i32) #0 {
  %3 = icmp slt i32 0, %1
  br i1 %3, label %.lr.ph9, label %.loopexit

.lr.ph9:                                          ; preds = %2
  %4 = sext i32 %1 to i64
  br label %5

; <label>:5:                                      ; preds = %.lr.ph9, %19
  %indvars.iv11 = phi i64 [ 0, %.lr.ph9 ], [ %indvars.iv.next12, %19 ]
  %6 = getelementptr inbounds i8, i8* %0, i64 %indvars.iv11
  %7 = load i8, i8* %6, align 1
  %8 = sext i8 %7 to i32
  %9 = icmp ne i32 %8, 48
  %10 = trunc i64 %indvars.iv11 to i32
  br i1 %9, label %.loopexit.loopexit, label %11

; <label>:11:                                     ; preds = %5
  %12 = icmp eq i64 %indvars.iv11, 1
  br i1 %12, label %13, label %19

; <label>:13:                                     ; preds = %11
  %14 = getelementptr inbounds i8, i8* %0, i64 %indvars.iv11
  %15 = load i8, i8* %14, align 1
  %16 = sext i8 %15 to i32
  %17 = call i32 @toupper(i32 %16) #10
  %18 = icmp ne i32 %17, 88
  br i1 %18, label %.loopexit.loopexit, label %19

; <label>:19:                                     ; preds = %13, %11
  %indvars.iv.next12 = add nuw nsw i64 %indvars.iv11, 1
  %20 = icmp slt i64 %indvars.iv.next12, %4
  br i1 %20, label %5, label %..loopexit_crit_edge

..loopexit_crit_edge:                             ; preds = %19
  %split10.wide = phi i64 [ %indvars.iv.next12, %19 ]
  %21 = trunc i64 %split10.wide to i32
  br label %.loopexit

.loopexit.loopexit:                               ; preds = %13, %5
  %.02.lcssa.ph = phi i32 [ %10, %5 ], [ %10, %13 ]
  br label %.loopexit

.loopexit:                                        ; preds = %.loopexit.loopexit, %2, %..loopexit_crit_edge
  %.02.lcssa = phi i32 [ %21, %..loopexit_crit_edge ], [ 0, %2 ], [ %.02.lcssa.ph, %.loopexit.loopexit ]
  %22 = icmp slt i32 %.02.lcssa, %1
  br i1 %22, label %.lr.ph, label %._crit_edge

.lr.ph:                                           ; preds = %.loopexit
  %23 = zext i32 %.02.lcssa to i64
  %24 = sext i32 %1 to i64
  br label %25

; <label>:25:                                     ; preds = %.lr.ph, %30
  %indvars.iv = phi i64 [ %23, %.lr.ph ], [ %indvars.iv.next, %30 ]
  %.016 = phi i32 [ 0, %.lr.ph ], [ %32, %30 ]
  %26 = getelementptr inbounds i8, i8* %0, i64 %indvars.iv
  %27 = load i8, i8* %26, align 1
  %28 = call i32 @hexCharToInt(i8 zeroext %27)
  %29 = icmp eq i32 %28, -1
  br i1 %29, label %._crit_edge.loopexit, label %30

; <label>:30:                                     ; preds = %25
  %31 = mul nsw i32 %.016, 16
  %32 = add nsw i32 %31, %28
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %33 = icmp slt i64 %indvars.iv.next, %24
  br i1 %33, label %25, label %._crit_edge.loopexit

._crit_edge.loopexit:                             ; preds = %25, %30
  %.0.ph = phi i32 [ %32, %30 ], [ -1, %25 ]
  br label %._crit_edge

._crit_edge:                                      ; preds = %._crit_edge.loopexit, %.loopexit
  %.0 = phi i32 [ 0, %.loopexit ], [ %.0.ph, %._crit_edge.loopexit ]
  ret i32 %.0
}

; Function Attrs: noinline nounwind uwtable
define dso_local i8** @uniqueiv_init() #8 {
  %1 = call noalias i8* @malloc(i64 2048) #9, !track !258
  %2 = bitcast i8* %1 to i8**
  %3 = icmp eq i8** %2, null
  br i1 %3, label %6, label %.preheader

.preheader:                                       ; preds = %0
  br label %4

; <label>:4:                                      ; preds = %.preheader, %4
  %indvars.iv = phi i64 [ %indvars.iv.next, %4 ], [ 0, %.preheader ]
  call void @unroll_loop(i32 155)
  %5 = getelementptr inbounds i8*, i8** %2, i64 %indvars.iv
  store i8* null, i8** %5, align 8
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond = icmp ne i64 %indvars.iv.next, 256
  br i1 %exitcond, label %4, label %.loopexit

.loopexit:                                        ; preds = %4
  %.0.ph = phi i8** [ %2, %4 ]
  br label %6

; <label>:6:                                      ; preds = %.loopexit, %0
  %.0 = phi i8** [ null, %0 ], [ %.0.ph, %.loopexit ]
  ret i8** %.0
}

; Function Attrs: noinline nounwind uwtable
define dso_local i32 @uniqueiv_mark(i8**, i8*) #0 {
  %3 = icmp eq i8** %0, null
  br i1 %3, label %61, label %4

; <label>:4:                                      ; preds = %2
  %5 = getelementptr inbounds i8, i8* %1, i64 2
  %6 = load i8, i8* %5, align 1
  %7 = zext i8 %6 to i64
  %8 = getelementptr inbounds i8*, i8** %0, i64 %7
  %9 = load i8*, i8** %8, align 8
  %10 = bitcast i8* %9 to i8**
  %11 = icmp eq i8** %10, null
  br i1 %11, label %12, label %28

; <label>:12:                                     ; preds = %4
  %13 = call noalias i8* @malloc(i64 2048) #9, !track !259
  %14 = bitcast i8* %13 to i8**
  %15 = icmp eq i8** %14, null
  br i1 %15, label %61, label %.preheader1

.preheader1:                                      ; preds = %12
  br label %16

; <label>:16:                                     ; preds = %.preheader1, %16
  %.015 = phi i16 [ %19, %16 ], [ 0, %.preheader1 ]
  call void @unroll_loop(i32 156)
  %17 = sext i16 %.015 to i64
  %18 = getelementptr inbounds i8*, i8** %14, i64 %17
  store i8* null, i8** %18, align 8
  %19 = add i16 %.015, 1
  %20 = sext i16 %19 to i32
  %21 = icmp slt i32 %20, 256
  br i1 %21, label %16, label %22

; <label>:22:                                     ; preds = %16
  %23 = bitcast i8** %14 to i8*
  %24 = getelementptr inbounds i8, i8* %1, i64 2
  %25 = load i8, i8* %24, align 1
  %26 = zext i8 %25 to i64
  %27 = getelementptr inbounds i8*, i8** %0, i64 %26
  store i8* %23, i8** %27, align 8
  br label %28

; <label>:28:                                     ; preds = %22, %4
  %.03 = phi i8** [ %14, %22 ], [ %10, %4 ]
  %29 = getelementptr inbounds i8, i8* %1, i64 1
  %30 = load i8, i8* %29, align 1
  %31 = zext i8 %30 to i64
  %32 = getelementptr inbounds i8*, i8** %.03, i64 %31
  %33 = load i8*, i8** %32, align 8
  %34 = icmp eq i8* %33, null
  br i1 %34, label %35, label %45

; <label>:35:                                     ; preds = %28
  %36 = call noalias i8* @malloc(i64 32) #9, !track !260
  %37 = icmp eq i8** %.03, null
  br i1 %37, label %61, label %.preheader

.preheader:                                       ; preds = %35
  br label %38

; <label>:38:                                     ; preds = %.preheader, %38
  %indvars.iv = phi i64 [ %indvars.iv.next, %38 ], [ 0, %.preheader ]
  call void @unroll_loop(i32 157)
  %39 = getelementptr inbounds i8, i8* %36, i64 %indvars.iv
  store i8 0, i8* %39, align 1
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond = icmp ne i64 %indvars.iv.next, 32
  br i1 %exitcond, label %38, label %40

; <label>:40:                                     ; preds = %38
  %41 = getelementptr inbounds i8, i8* %1, i64 1
  %42 = load i8, i8* %41, align 1
  %43 = zext i8 %42 to i64
  %44 = getelementptr inbounds i8*, i8** %.03, i64 %43
  store i8* %36, i8** %44, align 8
  br label %45

; <label>:45:                                     ; preds = %40, %28
  %.02 = phi i8* [ %36, %40 ], [ %33, %28 ]
  %46 = getelementptr inbounds i8, i8* %1, i64 0
  %47 = load i8, i8* %46, align 1
  %48 = zext i8 %47 to i32
  %49 = and i32 %48, 7
  %50 = shl i32 1, %49
  %51 = getelementptr inbounds i8, i8* %1, i64 0
  %52 = load i8, i8* %51, align 1
  %53 = zext i8 %52 to i32
  %54 = ashr i32 %53, 3
  %55 = sext i32 %54 to i64
  %56 = getelementptr inbounds i8, i8* %.02, i64 %55
  %57 = load i8, i8* %56, align 1
  %58 = zext i8 %57 to i32
  %59 = or i32 %58, %50
  %60 = trunc i32 %59 to i8
  store i8 %60, i8* %56, align 1
  br label %61

; <label>:61:                                     ; preds = %35, %12, %2, %45
  %.0 = phi i32 [ 0, %45 ], [ 0, %2 ], [ 1, %12 ], [ 1, %35 ]
  ret i32 %.0
}

; Function Attrs: noinline nounwind uwtable
define dso_local i32 @uniqueiv_check(i8**, i8*) #0 {
  %3 = icmp eq i8** %0, null
  br i1 %3, label %35, label %4

; <label>:4:                                      ; preds = %2
  %5 = getelementptr inbounds i8, i8* %1, i64 2
  %6 = load i8, i8* %5, align 1
  %7 = zext i8 %6 to i64
  %8 = getelementptr inbounds i8*, i8** %0, i64 %7
  %9 = load i8*, i8** %8, align 8
  %10 = bitcast i8* %9 to i8**
  %11 = icmp eq i8** %10, null
  br i1 %11, label %35, label %12

; <label>:12:                                     ; preds = %4
  %13 = getelementptr inbounds i8, i8* %1, i64 1
  %14 = load i8, i8* %13, align 1
  %15 = zext i8 %14 to i64
  %16 = getelementptr inbounds i8*, i8** %10, i64 %15
  %17 = load i8*, i8** %16, align 8
  %18 = icmp eq i8* %17, null
  br i1 %18, label %35, label %19

; <label>:19:                                     ; preds = %12
  %20 = getelementptr inbounds i8, i8* %1, i64 0
  %21 = load i8, i8* %20, align 1
  %22 = zext i8 %21 to i32
  %23 = ashr i32 %22, 3
  %24 = sext i32 %23 to i64
  %25 = getelementptr inbounds i8, i8* %17, i64 %24
  %26 = load i8, i8* %25, align 1
  %27 = zext i8 %26 to i32
  %28 = getelementptr inbounds i8, i8* %1, i64 0
  %29 = load i8, i8* %28, align 1
  %30 = zext i8 %29 to i32
  %31 = and i32 %30, 7
  %32 = shl i32 1, %31
  %33 = and i32 %27, %32
  %34 = icmp eq i32 %33, 0
  %. = select i1 %34, i32 0, i32 1
  br label %35

; <label>:35:                                     ; preds = %19, %12, %4, %2
  %.0 = phi i32 [ 0, %2 ], [ 0, %4 ], [ 0, %12 ], [ %., %19 ]
  ret i32 %.0
}

; Function Attrs: noinline nounwind uwtable
define dso_local void @uniqueiv_wipe(i8**) #0 {
  %2 = icmp eq i8** %0, null
  br i1 %2, label %19, label %.preheader1

.preheader1:                                      ; preds = %1
  br label %3

; <label>:3:                                      ; preds = %.preheader1, %16
  %indvars.iv4 = phi i64 [ %indvars.iv.next5, %16 ], [ 0, %.preheader1 ]
  call void @unroll_loop(i32 158)
  %4 = getelementptr inbounds i8*, i8** %0, i64 %indvars.iv4
  %5 = load i8*, i8** %4, align 8
  %6 = bitcast i8* %5 to i8**
  %7 = icmp ne i8** %6, null
  br i1 %7, label %.preheader, label %16

.preheader:                                       ; preds = %3
  br label %8

; <label>:8:                                      ; preds = %.preheader, %13
  %indvars.iv = phi i64 [ %indvars.iv.next, %13 ], [ 0, %.preheader ]
  call void @unroll_loop(i32 159)
  %9 = getelementptr inbounds i8*, i8** %6, i64 %indvars.iv
  %10 = load i8*, i8** %9, align 8
  %11 = icmp ne i8* %10, null
  br i1 %11, label %12, label %13

; <label>:12:                                     ; preds = %8
  call void @free(i8* %10) #9
  br label %13

; <label>:13:                                     ; preds = %8, %12
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond = icmp ne i64 %indvars.iv.next, 256
  br i1 %exitcond, label %8, label %14

; <label>:14:                                     ; preds = %13
  %15 = bitcast i8** %6 to i8*
  call void @free(i8* %15) #9
  br label %16

; <label>:16:                                     ; preds = %3, %14
  %indvars.iv.next5 = add nuw nsw i64 %indvars.iv4, 1
  %exitcond6 = icmp ne i64 %indvars.iv.next5, 256
  br i1 %exitcond6, label %3, label %17

; <label>:17:                                     ; preds = %16
  %18 = bitcast i8** %0 to i8*
  call void @free(i8* %18) #9
  br label %19

; <label>:19:                                     ; preds = %1, %17
  ret void
}

; Function Attrs: noinline nounwind uwtable
define dso_local i8* @data_init() #0 {
  %1 = call noalias i8* @calloc(i64 50331648, i64 1) #9
  ret i8* %1
}

; Function Attrs: noinline nounwind uwtable
define dso_local i32 @data_check(i8*, i8*, i8*) #0 {
  %4 = icmp ne i8* %0, null
  br i1 %4, label %5, label %57

; <label>:5:                                      ; preds = %3
  %6 = getelementptr inbounds i8, i8* %1, i64 0
  %7 = load i8, i8* %6, align 1
  %8 = zext i8 %7 to i32
  %9 = mul nsw i32 %8, 256
  %10 = getelementptr inbounds i8, i8* %1, i64 1
  %11 = load i8, i8* %10, align 1
  %12 = zext i8 %11 to i32
  %13 = add nsw i32 %9, %12
  %14 = mul nsw i32 %13, 256
  %15 = getelementptr inbounds i8, i8* %1, i64 2
  %16 = load i8, i8* %15, align 1
  %17 = zext i8 %16 to i32
  %18 = add nsw i32 %14, %17
  %19 = mul nsw i32 %18, 3
  %20 = sext i32 %19 to i64
  %21 = getelementptr inbounds i8, i8* %0, i64 %20
  %22 = load i8, i8* %21, align 1
  %23 = zext i8 %22 to i32
  %24 = icmp eq i32 %23, 0
  %25 = sext i32 %19 to i64
  %26 = getelementptr inbounds i8, i8* %0, i64 %25
  br i1 %24, label %27, label %38

; <label>:27:                                     ; preds = %5
  store i8 1, i8* %26, align 1
  %28 = getelementptr inbounds i8, i8* %2, i64 0
  %29 = load i8, i8* %28, align 1
  %30 = sext i32 %19 to i64
  %31 = getelementptr inbounds i8, i8* %0, i64 %30
  %32 = getelementptr inbounds i8, i8* %31, i64 1
  store i8 %29, i8* %32, align 1
  %33 = getelementptr inbounds i8, i8* %2, i64 1
  %34 = load i8, i8* %33, align 1
  %35 = sext i32 %19 to i64
  %36 = getelementptr inbounds i8, i8* %0, i64 %35
  %37 = getelementptr inbounds i8, i8* %36, i64 2
  store i8 %34, i8* %37, align 1
  br label %57

; <label>:38:                                     ; preds = %5
  %39 = getelementptr inbounds i8, i8* %26, i64 1
  %40 = load i8, i8* %39, align 1
  %41 = zext i8 %40 to i32
  %42 = getelementptr inbounds i8, i8* %2, i64 0
  %43 = load i8, i8* %42, align 1
  %44 = zext i8 %43 to i32
  %45 = icmp ne i32 %41, %44
  br i1 %45, label %56, label %46

; <label>:46:                                     ; preds = %38
  %47 = sext i32 %19 to i64
  %48 = getelementptr inbounds i8, i8* %0, i64 %47
  %49 = getelementptr inbounds i8, i8* %48, i64 2
  %50 = load i8, i8* %49, align 1
  %51 = zext i8 %50 to i32
  %52 = getelementptr inbounds i8, i8* %2, i64 1
  %53 = load i8, i8* %52, align 1
  %54 = zext i8 %53 to i32
  %55 = icmp ne i32 %51, %54
  br i1 %55, label %56, label %57

; <label>:56:                                     ; preds = %46, %38
  br label %57

; <label>:57:                                     ; preds = %27, %56, %46, %3
  %.2 = phi i32 [ 0, %3 ], [ 0, %27 ], [ 1, %56 ], [ 0, %46 ]
  ret i32 %.2
}

; Function Attrs: noinline nounwind uwtable
define dso_local void @data_wipe(i8*) #0 {
  %2 = icmp ne i8* %0, null
  br i1 %2, label %3, label %4

; <label>:3:                                      ; preds = %1
  call void @free(i8* %0) #9
  br label %4

; <label>:4:                                      ; preds = %3, %1
  ret void
}

; Function Attrs: noinline nounwind uwtable
define dso_local i32 @PTW_computeKey(%struct.PTW_attackstate*, i8*, i32, i32, i32*, [256 x i32]*, i32) #0 {
  %8 = alloca [29 x i32], align 16, !track !261
  %9 = alloca [29 x double], align 16, !track !262
  %10 = alloca [29 x double], align 16, !track !263
  %11 = alloca [29 x %struct.doublesorthelper], align 16, !track !264
  %12 = alloca [32 x i8], align 16, !track !265
  %13 = alloca [32 x i8], align 16, !track !266
  %14 = sext i32 %2 to i64
  %15 = mul i64 2048, %14
  %16 = alloca i8, i64 %15, align 16, !track !267
  %17 = bitcast i8* %16 to [256 x %struct.PTW_tableentry]*
  store i32 0, i32* @tried, align 4
  %18 = icmp eq [256 x %struct.PTW_tableentry]* %17, null
  br i1 %18, label %19, label %22

; <label>:19:                                     ; preds = %7
  %20 = getelementptr [27 x i8], [27 x i8]* @.str.222, i32 0, i32 0
  %21 = call i32 (i8*, ...) @printf(i8* %20)
  call void @exit(i32 -1) #11
  unreachable

; <label>:22:                                     ; preds = %7
  %23 = and i32 %6, 1
  %24 = icmp ne i32 %23, 0
  br i1 %24, label %103, label %25

; <label>:25:                                     ; preds = %22
  %26 = icmp slt i32 0, %2
  br i1 %26, label %.lr.ph45, label %._crit_edge46

.lr.ph45:                                         ; preds = %25
  %27 = zext i32 %2 to i64
  br label %28

; <label>:28:                                     ; preds = %.lr.ph45, %87
  %indvars.iv47 = phi i64 [ 0, %.lr.ph45 ], [ %indvars.iv.next48, %87 ]
  call void @unroll_loop(i32 160)
  %29 = getelementptr inbounds [256 x %struct.PTW_tableentry], [256 x %struct.PTW_tableentry]* %17, i64 %indvars.iv47
  %30 = getelementptr inbounds [256 x %struct.PTW_tableentry], [256 x %struct.PTW_tableentry]* %29, i64 0, i64 0
  %31 = bitcast %struct.PTW_tableentry* %30 to i8*
  call void @llvm.memset.p0i8.i64(i8* align 4 %31, i8 0, i64 2048, i1 false)
  br label %32

; <label>:32:                                     ; preds = %28, %32
  %indvars.iv32 = phi i64 [ 0, %28 ], [ %indvars.iv.next33, %32 ]
  %.0131 = phi i32 [ 0, %28 ], [ %37, %32 ]
  call void @unroll_loop(i32 161)
  %33 = trunc i32 %.0131 to i8
  %34 = getelementptr inbounds [256 x %struct.PTW_tableentry], [256 x %struct.PTW_tableentry]* %17, i64 %indvars.iv47
  %35 = getelementptr inbounds [256 x %struct.PTW_tableentry], [256 x %struct.PTW_tableentry]* %34, i64 0, i64 %indvars.iv32
  %36 = getelementptr inbounds %struct.PTW_tableentry, %struct.PTW_tableentry* %35, i32 0, i32 1
  store i8 %33, i8* %36, align 4
  %indvars.iv.next33 = add nuw nsw i64 %indvars.iv32, 1
  %37 = add nuw nsw i32 %.0131, 1
  %exitcond34 = icmp ne i64 %indvars.iv.next33, 256
  br i1 %exitcond34, label %32, label %38

; <label>:38:                                     ; preds = %32
  %39 = getelementptr inbounds %struct.PTW_attackstate, %struct.PTW_attackstate* %0, i32 0, i32 0
  %40 = load i32, i32* %39, align 8
  %41 = icmp slt i32 0, %40
  br i1 %41, label %.lr.ph37.preheader, label %._crit_edge38

.lr.ph37.preheader:                               ; preds = %38
  br label %.lr.ph37

.lr.ph37:                                         ; preds = %.lr.ph37.preheader, %.lr.ph37
  %indvars.iv39 = phi i64 [ %indvars.iv.next40, %.lr.ph37 ], [ 0, %.lr.ph37.preheader ]
  call void @unroll_loop(i32 162)
  %42 = getelementptr inbounds [32 x i8], [32 x i8]* %12, i32 0, i32 0
  %43 = getelementptr inbounds %struct.PTW_attackstate, %struct.PTW_attackstate* %0, i32 0, i32 5
  %44 = load %struct.PTW_session*, %struct.PTW_session** %43, align 8
  %45 = getelementptr inbounds %struct.PTW_session, %struct.PTW_session* %44, i64 %indvars.iv39
  %46 = getelementptr inbounds %struct.PTW_session, %struct.PTW_session* %45, i32 0, i32 0
  %47 = getelementptr inbounds [3 x i8], [3 x i8]* %46, i32 0, i32 0
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 16 %42, i8* align 4 %47, i64 3, i1 false), !track !268
  %48 = add nuw nsw i64 %indvars.iv47, 3
  %49 = getelementptr inbounds [32 x i8], [32 x i8]* %12, i32 0, i32 0
  %50 = getelementptr inbounds %struct.PTW_attackstate, %struct.PTW_attackstate* %0, i32 0, i32 5
  %51 = load %struct.PTW_session*, %struct.PTW_session** %50, align 8
  %52 = getelementptr inbounds %struct.PTW_session, %struct.PTW_session* %51, i64 %indvars.iv39
  %53 = getelementptr inbounds %struct.PTW_session, %struct.PTW_session* %52, i32 0, i32 1
  %54 = getelementptr inbounds [32 x i8], [32 x i8]* %53, i32 0, i32 0
  %55 = getelementptr inbounds [32 x i8], [32 x i8]* %13, i32 0, i32 0
  %56 = trunc i64 %48 to i32
  call void @guesskeybytes(i32 %56, i8* %49, i8* %54, i8* %55, i32 1)
  %57 = getelementptr inbounds %struct.PTW_attackstate, %struct.PTW_attackstate* %0, i32 0, i32 5
  %58 = load %struct.PTW_session*, %struct.PTW_session** %57, align 8
  %59 = getelementptr inbounds %struct.PTW_session, %struct.PTW_session* %58, i64 %indvars.iv39
  %60 = getelementptr inbounds %struct.PTW_session, %struct.PTW_session* %59, i32 0, i32 2
  %61 = load i32, i32* %60, align 4
  %62 = getelementptr inbounds [256 x %struct.PTW_tableentry], [256 x %struct.PTW_tableentry]* %17, i64 %indvars.iv47
  %63 = getelementptr inbounds [32 x i8], [32 x i8]* %13, i64 0, i64 0
  %64 = load i8, i8* %63, align 16
  %65 = zext i8 %64 to i64
  %66 = getelementptr inbounds [256 x %struct.PTW_tableentry], [256 x %struct.PTW_tableentry]* %62, i64 0, i64 %65
  %67 = getelementptr inbounds %struct.PTW_tableentry, %struct.PTW_tableentry* %66, i32 0, i32 0
  %68 = load i32, i32* %67, align 4
  %69 = add nsw i32 %68, %61
  store i32 %69, i32* %67, align 4
  %indvars.iv.next40 = add nuw nsw i64 %indvars.iv39, 1
  %70 = load i32, i32* %39, align 8
  %71 = sext i32 %70 to i64
  %72 = icmp slt i64 %indvars.iv.next40, %71
  br i1 %72, label %.lr.ph37, label %._crit_edge38.loopexit

._crit_edge38.loopexit:                           ; preds = %.lr.ph37
  br label %._crit_edge38

._crit_edge38:                                    ; preds = %._crit_edge38.loopexit, %38
  %73 = getelementptr inbounds [256 x %struct.PTW_tableentry], [256 x %struct.PTW_tableentry]* %17, i64 %indvars.iv47
  %74 = getelementptr inbounds [256 x %struct.PTW_tableentry], [256 x %struct.PTW_tableentry]* %73, i64 0, i64 0
  %75 = bitcast %struct.PTW_tableentry* %74 to i8*
  call void @qsort(i8* %75, i64 256, i64 8, i32 (i8*, i8*)* @compare)
  br label %76

; <label>:76:                                     ; preds = %76, %._crit_edge38
  %indvars.iv41 = phi i64 [ %indvars.iv.next42, %76 ], [ 0, %._crit_edge38 ]
  call void @unroll_loop(i32 163)
  %77 = getelementptr inbounds [256 x i32], [256 x i32]* %5, i64 %indvars.iv47
  %78 = getelementptr inbounds [256 x %struct.PTW_tableentry], [256 x %struct.PTW_tableentry]* %17, i64 %indvars.iv47
  %79 = getelementptr inbounds [256 x %struct.PTW_tableentry], [256 x %struct.PTW_tableentry]* %78, i64 0, i64 %indvars.iv41
  %80 = getelementptr inbounds %struct.PTW_tableentry, %struct.PTW_tableentry* %79, i32 0, i32 1
  %81 = load i8, i8* %80, align 4
  %82 = zext i8 %81 to i64
  %83 = getelementptr inbounds [256 x i32], [256 x i32]* %77, i64 0, i64 %82
  %84 = load i32, i32* %83, align 4
  %85 = icmp ne i32 %84, 0
  %86 = xor i1 %85, true
  %indvars.iv.next42 = add nuw i64 %indvars.iv41, 1
  br i1 %86, label %76, label %87

; <label>:87:                                     ; preds = %76
  %.2.lcssa.wide = phi i64 [ %indvars.iv41, %76 ]
  %88 = trunc i64 %.2.lcssa.wide to i32
  %89 = getelementptr inbounds [256 x %struct.PTW_tableentry], [256 x %struct.PTW_tableentry]* %17, i64 %indvars.iv47
  %90 = sext i32 %88 to i64
  %91 = getelementptr inbounds [256 x %struct.PTW_tableentry], [256 x %struct.PTW_tableentry]* %89, i64 0, i64 %90
  %92 = getelementptr inbounds %struct.PTW_tableentry, %struct.PTW_tableentry* %91, i32 0, i32 1
  %93 = load i8, i8* %92, align 4
  %94 = add nuw nsw i64 %indvars.iv47, 3
  %95 = getelementptr inbounds [32 x i8], [32 x i8]* %12, i64 0, i64 %94
  store i8 %93, i8* %95, align 1
  %indvars.iv.next48 = add nuw nsw i64 %indvars.iv47, 1
  %exitcond3 = icmp ne i64 %indvars.iv.next48, %27
  br i1 %exitcond3, label %28, label %._crit_edge46.loopexit

._crit_edge46.loopexit:                           ; preds = %87
  br label %._crit_edge46

._crit_edge46:                                    ; preds = %._crit_edge46.loopexit, %25
  %96 = getelementptr inbounds [32 x i8], [32 x i8]* %12, i64 0, i64 3
  %97 = call i32 @correct(%struct.PTW_attackstate* %0, i8* %96, i32 %2)
  %98 = icmp ne i32 %97, 0
  br i1 %98, label %99, label %103

; <label>:99:                                     ; preds = %._crit_edge46
  %100 = getelementptr inbounds [32 x i8], [32 x i8]* %12, i64 0, i64 3
  %101 = sext i32 %2 to i64
  %102 = mul i64 %101, 1
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %1, i8* align 1 %100, i64 %102, i1 false), !track !269
  br label %240

; <label>:103:                                    ; preds = %._crit_edge46, %22
  %104 = and i32 %6, 2
  %105 = icmp ne i32 %104, 0
  br i1 %105, label %239, label %106

; <label>:106:                                    ; preds = %103
  %107 = bitcast [256 x %struct.PTW_tableentry]* %17 to i8*
  %108 = getelementptr inbounds %struct.PTW_attackstate, %struct.PTW_attackstate* %0, i32 0, i32 4
  %109 = getelementptr inbounds [29 x [256 x %struct.PTW_tableentry]], [29 x [256 x %struct.PTW_tableentry]]* %108, i32 0, i32 0
  %110 = bitcast [256 x %struct.PTW_tableentry]* %109 to i8*
  %111 = sext i32 %2 to i64
  %112 = mul i64 2048, %111
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %107, i8* align 8 %110, i64 %112, i1 false), !track !270
  %113 = sdiv i32 %3, 10
  %114 = mul nsw i32 %113, 2
  %115 = sdiv i32 %3, 10
  %116 = mul nsw i32 %115, 1
  %117 = sub nsw i32 %3, %114
  %118 = sub nsw i32 %117, %116
  %119 = icmp slt i32 0, %2
  br i1 %119, label %.lr.ph25, label %._crit_edge26

.lr.ph25:                                         ; preds = %106
  %120 = zext i32 %2 to i64
  br label %121

; <label>:121:                                    ; preds = %.lr.ph25, %121
  %indvars.iv27 = phi i64 [ 0, %.lr.ph25 ], [ %indvars.iv.next28, %121 ]
  call void @unroll_loop(i32 164)
  %122 = getelementptr inbounds [256 x %struct.PTW_tableentry], [256 x %struct.PTW_tableentry]* %17, i64 %indvars.iv27
  %123 = getelementptr inbounds [256 x %struct.PTW_tableentry], [256 x %struct.PTW_tableentry]* %122, i64 0, i64 0
  %124 = bitcast %struct.PTW_tableentry* %123 to i8*
  call void @qsort(i8* %124, i64 256, i64 8, i32 (i8*, i8*)* @compare)
  %125 = getelementptr inbounds [29 x i32], [29 x i32]* %8, i64 0, i64 %indvars.iv27
  store i32 0, i32* %125, align 4
  %indvars.iv.next28 = add nuw nsw i64 %indvars.iv27, 1
  %exitcond2 = icmp ne i64 %indvars.iv.next28, %120
  br i1 %exitcond2, label %121, label %._crit_edge26.loopexit

._crit_edge26.loopexit:                           ; preds = %121
  br label %._crit_edge26

._crit_edge26:                                    ; preds = %._crit_edge26.loopexit, %106
  %126 = sext i32 %2 to i64
  %127 = mul i64 3060, %126
  %128 = alloca i8, i64 %127, align 16, !track !271
  %129 = bitcast i8* %128 to [255 x %struct.sorthelper]*
  %130 = icmp eq [255 x %struct.sorthelper]* %129, null
  br i1 %130, label %131, label %134

; <label>:131:                                    ; preds = %._crit_edge26
  %132 = getelementptr [27 x i8], [27 x i8]* @.str.222, i32 0, i32 0
  %133 = call i32 (i8*, ...) @printf(i8* %132)
  call void @exit(i32 -1) #11
  unreachable

; <label>:134:                                    ; preds = %._crit_edge26
  %135 = icmp slt i32 0, %2
  br i1 %135, label %.lr.ph17, label %._crit_edge18

.lr.ph17:                                         ; preds = %134
  %136 = zext i32 %2 to i64
  br label %137

; <label>:137:                                    ; preds = %.lr.ph17, %165
  %indvars.iv19 = phi i64 [ 0, %.lr.ph17 ], [ %indvars.iv.next20, %165 ]
  br label %138

; <label>:138:                                    ; preds = %137, %138
  %indvars.iv12 = phi i64 [ 1, %137 ], [ %indvars.iv.next13, %138 ]
  call void @unroll_loop(i32 165)
  %139 = getelementptr inbounds [256 x %struct.PTW_tableentry], [256 x %struct.PTW_tableentry]* %17, i64 %indvars.iv19
  %140 = getelementptr inbounds [256 x %struct.PTW_tableentry], [256 x %struct.PTW_tableentry]* %139, i64 0, i64 0
  %141 = getelementptr inbounds %struct.PTW_tableentry, %struct.PTW_tableentry* %140, i32 0, i32 0
  %142 = load i32, i32* %141, align 4
  %143 = getelementptr inbounds [256 x %struct.PTW_tableentry], [256 x %struct.PTW_tableentry]* %17, i64 %indvars.iv19
  %144 = getelementptr inbounds [256 x %struct.PTW_tableentry], [256 x %struct.PTW_tableentry]* %143, i64 0, i64 %indvars.iv12
  %145 = getelementptr inbounds %struct.PTW_tableentry, %struct.PTW_tableentry* %144, i32 0, i32 0
  %146 = load i32, i32* %145, align 4
  %147 = sub nsw i32 %142, %146
  %148 = getelementptr inbounds [255 x %struct.sorthelper], [255 x %struct.sorthelper]* %129, i64 %indvars.iv19
  %149 = sub nuw nsw i64 %indvars.iv12, 1
  %150 = getelementptr inbounds [255 x %struct.sorthelper], [255 x %struct.sorthelper]* %148, i64 0, i64 %149
  %151 = getelementptr inbounds %struct.sorthelper, %struct.sorthelper* %150, i32 0, i32 2
  store i32 %147, i32* %151, align 4
  %152 = getelementptr inbounds [256 x %struct.PTW_tableentry], [256 x %struct.PTW_tableentry]* %17, i64 %indvars.iv19
  %153 = getelementptr inbounds [256 x %struct.PTW_tableentry], [256 x %struct.PTW_tableentry]* %152, i64 0, i64 %indvars.iv12
  %154 = getelementptr inbounds %struct.PTW_tableentry, %struct.PTW_tableentry* %153, i32 0, i32 1
  %155 = load i8, i8* %154, align 4
  %156 = getelementptr inbounds [255 x %struct.sorthelper], [255 x %struct.sorthelper]* %129, i64 %indvars.iv19
  %157 = sub nuw nsw i64 %indvars.iv12, 1
  %158 = getelementptr inbounds [255 x %struct.sorthelper], [255 x %struct.sorthelper]* %156, i64 0, i64 %157
  %159 = getelementptr inbounds %struct.sorthelper, %struct.sorthelper* %158, i32 0, i32 1
  store i8 %155, i8* %159, align 4
  %160 = getelementptr inbounds [255 x %struct.sorthelper], [255 x %struct.sorthelper]* %129, i64 %indvars.iv19
  %161 = sub nuw nsw i64 %indvars.iv12, 1
  %162 = getelementptr inbounds [255 x %struct.sorthelper], [255 x %struct.sorthelper]* %160, i64 0, i64 %161
  %163 = getelementptr inbounds %struct.sorthelper, %struct.sorthelper* %162, i32 0, i32 0
  %164 = trunc i64 %indvars.iv19 to i32
  store i32 %164, i32* %163, align 4
  %indvars.iv.next13 = add nuw nsw i64 %indvars.iv12, 1
  %exitcond14 = icmp ne i64 %indvars.iv.next13, 256
  br i1 %exitcond14, label %138, label %165

; <label>:165:                                    ; preds = %138
  %indvars.iv.next20 = add nuw nsw i64 %indvars.iv19, 1
  %exitcond1 = icmp ne i64 %indvars.iv.next20, %136
  br i1 %exitcond1, label %137, label %._crit_edge18.loopexit

._crit_edge18.loopexit:                           ; preds = %165
  br label %._crit_edge18

._crit_edge18:                                    ; preds = %._crit_edge18.loopexit, %134
  %166 = bitcast [255 x %struct.sorthelper]* %129 to i8*
  %167 = mul nsw i32 255, %2
  %168 = sext i32 %167 to i64
  call void @qsort(i8* %166, i64 %168, i64 12, i32 (i8*, i8*)* @comparesorthelper)
  %169 = bitcast [255 x %struct.sorthelper]* %129 to %struct.sorthelper*
  %170 = getelementptr inbounds [29 x i32], [29 x i32]* %8, i32 0, i32 0
  %171 = call i32 @doComputation(%struct.PTW_attackstate* %0, i8* %1, i32 %2, [256 x %struct.PTW_tableentry]* %17, %struct.sorthelper* %169, i32* %170, i32 %118, i32* %4, [256 x i32]* %5)
  %172 = icmp ne i32 %171, 0
  br i1 %172, label %240, label %173

; <label>:173:                                    ; preds = %._crit_edge18
  %174 = getelementptr inbounds %struct.PTW_attackstate, %struct.PTW_attackstate* %0, i32 0, i32 4
  %175 = getelementptr inbounds [29 x [256 x %struct.PTW_tableentry]], [29 x [256 x %struct.PTW_tableentry]]* %174, i32 0, i32 0
  %176 = getelementptr inbounds [29 x double], [29 x double]* %9, i32 0, i32 0
  %177 = getelementptr inbounds [29 x double], [29 x double]* %10, i32 0, i32 0
  call void @getdrv([256 x %struct.PTW_tableentry]* %175, i32 %2, double* %176, double* %177)
  %178 = sub nsw i32 %2, 1
  %179 = icmp slt i32 0, %178
  br i1 %179, label %.lr.ph, label %._crit_edge

.lr.ph:                                           ; preds = %173
  %180 = add i32 %2, -1
  %wide.trip.count = zext i32 %180 to i64
  br label %181

; <label>:181:                                    ; preds = %.lr.ph, %181
  %indvars.iv9 = phi i64 [ 0, %.lr.ph ], [ %indvars.iv.next10, %181 ]
  call void @unroll_loop(i32 166)
  %indvars.iv.next10 = add nuw nsw i64 %indvars.iv9, 1
  %182 = getelementptr inbounds [29 x %struct.doublesorthelper], [29 x %struct.doublesorthelper]* %11, i64 0, i64 %indvars.iv9
  %183 = getelementptr inbounds %struct.doublesorthelper, %struct.doublesorthelper* %182, i32 0, i32 0
  %184 = trunc i64 %indvars.iv.next10 to i32
  store i32 %184, i32* %183, align 16
  %185 = getelementptr inbounds [29 x double], [29 x double]* %9, i64 0, i64 %indvars.iv.next10
  %186 = load double, double* %185, align 8
  %187 = getelementptr inbounds [29 x double], [29 x double]* %10, i64 0, i64 %indvars.iv.next10
  %188 = load double, double* %187, align 8
  %189 = fsub double %186, %188
  %190 = getelementptr inbounds [29 x %struct.doublesorthelper], [29 x %struct.doublesorthelper]* %11, i64 0, i64 %indvars.iv9
  %191 = getelementptr inbounds %struct.doublesorthelper, %struct.doublesorthelper* %190, i32 0, i32 1
  store double %189, double* %191, align 8
  %exitcond = icmp ne i64 %indvars.iv.next10, %wide.trip.count
  br i1 %exitcond, label %181, label %._crit_edge.loopexit

._crit_edge.loopexit:                             ; preds = %181
  br label %._crit_edge

._crit_edge:                                      ; preds = %._crit_edge.loopexit, %173
  %192 = getelementptr inbounds [29 x %struct.doublesorthelper], [29 x %struct.doublesorthelper]* %11, i32 0, i32 0
  %193 = bitcast %struct.doublesorthelper* %192 to i8*
  %194 = sub nsw i32 %2, 1
  %195 = sext i32 %194 to i64
  call void @qsort(i8* %193, i64 %195, i64 16, i32 (i8*, i8*)* @comparedoublesorthelper)
  br label %196

; <label>:196:                                    ; preds = %196, %._crit_edge
  %indvars.iv6 = phi i64 [ %indvars.iv.next7, %196 ], [ 0, %._crit_edge ]
  call void @unroll_loop(i32 167)
  %197 = getelementptr inbounds [29 x %struct.doublesorthelper], [29 x %struct.doublesorthelper]* %11, i64 0, i64 %indvars.iv6
  %198 = getelementptr inbounds %struct.doublesorthelper, %struct.doublesorthelper* %197, i32 0, i32 0
  %199 = load i32, i32* %198, align 16
  %200 = sext i32 %199 to i64
  %201 = getelementptr inbounds i32, i32* %4, i64 %200
  %202 = load i32, i32* %201, align 4
  %203 = icmp eq i32 %202, 1
  %indvars.iv.next7 = add nuw i64 %indvars.iv6, 1
  br i1 %203, label %196, label %204

; <label>:204:                                    ; preds = %196
  %.4.lcssa.wide = phi i64 [ %indvars.iv6, %196 ]
  %205 = trunc i64 %.4.lcssa.wide to i32
  %206 = sext i32 %205 to i64
  %207 = getelementptr inbounds [29 x %struct.doublesorthelper], [29 x %struct.doublesorthelper]* %11, i64 0, i64 %206
  %208 = getelementptr inbounds %struct.doublesorthelper, %struct.doublesorthelper* %207, i32 0, i32 0
  %209 = load i32, i32* %208, align 16
  %210 = sext i32 %209 to i64
  %211 = getelementptr inbounds [29 x i32], [29 x i32]* %8, i64 0, i64 %210
  store i32 1, i32* %211, align 4
  %212 = bitcast [255 x %struct.sorthelper]* %129 to %struct.sorthelper*
  %213 = getelementptr inbounds [29 x i32], [29 x i32]* %8, i32 0, i32 0
  %214 = call i32 @doComputation(%struct.PTW_attackstate* %0, i8* %1, i32 %2, [256 x %struct.PTW_tableentry]* %17, %struct.sorthelper* %212, i32* %213, i32 %114, i32* %4, [256 x i32]* %5)
  %215 = icmp ne i32 %214, 0
  br i1 %215, label %240, label %216

; <label>:216:                                    ; preds = %204
  %217 = add i32 %205, 1
  %218 = sext i32 %217 to i64
  br label %219

; <label>:219:                                    ; preds = %219, %216
  %indvars.iv = phi i64 [ %indvars.iv.next, %219 ], [ %218, %216 ]
  call void @unroll_loop(i32 168)
  %220 = getelementptr inbounds [29 x %struct.doublesorthelper], [29 x %struct.doublesorthelper]* %11, i64 0, i64 %indvars.iv
  %221 = getelementptr inbounds %struct.doublesorthelper, %struct.doublesorthelper* %220, i32 0, i32 0
  %222 = load i32, i32* %221, align 16
  %223 = sext i32 %222 to i64
  %224 = getelementptr inbounds i32, i32* %4, i64 %223
  %225 = load i32, i32* %224, align 4
  %226 = icmp eq i32 %225, 1
  %indvars.iv.next = add i64 %indvars.iv, 1
  br i1 %226, label %219, label %227

; <label>:227:                                    ; preds = %219
  %.5.lcssa.wide = phi i64 [ %indvars.iv, %219 ]
  %228 = trunc i64 %.5.lcssa.wide to i32
  %229 = sext i32 %228 to i64
  %230 = getelementptr inbounds [29 x %struct.doublesorthelper], [29 x %struct.doublesorthelper]* %11, i64 0, i64 %229
  %231 = getelementptr inbounds %struct.doublesorthelper, %struct.doublesorthelper* %230, i32 0, i32 0
  %232 = load i32, i32* %231, align 16
  %233 = sext i32 %232 to i64
  %234 = getelementptr inbounds [29 x i32], [29 x i32]* %8, i64 0, i64 %233
  store i32 1, i32* %234, align 4
  %235 = bitcast [255 x %struct.sorthelper]* %129 to %struct.sorthelper*
  %236 = getelementptr inbounds [29 x i32], [29 x i32]* %8, i32 0, i32 0
  %237 = call i32 @doComputation(%struct.PTW_attackstate* %0, i8* %1, i32 %2, [256 x %struct.PTW_tableentry]* %17, %struct.sorthelper* %235, i32* %236, i32 %116, i32* %4, [256 x i32]* %5)
  %238 = icmp ne i32 %237, 0
  br i1 %238, label %240, label %239

; <label>:239:                                    ; preds = %227, %103
  br label %240

; <label>:240:                                    ; preds = %227, %204, %._crit_edge18, %239, %99
  %.0 = phi i32 [ 0, %239 ], [ 1, %99 ], [ 1, %._crit_edge18 ], [ 1, %204 ], [ 1, %227 ]
  ret i32 %.0
}

; Function Attrs: noinline nounwind uwtable
define internal void @guesskeybytes(i32, i8*, i8*, i8*, i32) #0 {
  %6 = alloca [256 x i8], align 16, !track !272
  %7 = getelementptr inbounds [256 x i8], [256 x i8]* %6, i32 0, i32 0
  %8 = getelementptr [256 x i8], [256 x i8]* @rc4initial, i32 0, i32 0
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 16 %7, i8* align 16 %8, i64 256, i1 false), !track !273
  %9 = icmp slt i32 0, %0
  br i1 %9, label %.lr.ph13, label %._crit_edge14

.lr.ph13:                                         ; preds = %5
  %10 = zext i32 %0 to i64
  br label %11

; <label>:11:                                     ; preds = %.lr.ph13, %11
  %indvars.iv15 = phi i64 [ 0, %.lr.ph13 ], [ %indvars.iv.next16, %11 ]
  %.0410 = phi i8 [ 0, %.lr.ph13 ], [ %21, %11 ]
  call void @unroll_loop(i32 169)
  %12 = getelementptr inbounds [256 x i8], [256 x i8]* %6, i64 0, i64 %indvars.iv15
  %13 = load i8, i8* %12, align 1
  %14 = zext i8 %13 to i32
  %15 = getelementptr inbounds i8, i8* %1, i64 %indvars.iv15
  %16 = load i8, i8* %15, align 1
  %17 = zext i8 %16 to i32
  %18 = add nsw i32 %14, %17
  %19 = zext i8 %.0410 to i32
  %20 = add nsw i32 %19, %18
  %21 = trunc i32 %20 to i8
  %22 = getelementptr inbounds [256 x i8], [256 x i8]* %6, i64 0, i64 %indvars.iv15
  %23 = load i8, i8* %22, align 1
  %24 = zext i8 %21 to i64
  %25 = getelementptr inbounds [256 x i8], [256 x i8]* %6, i64 0, i64 %24
  %26 = load i8, i8* %25, align 1
  %27 = getelementptr inbounds [256 x i8], [256 x i8]* %6, i64 0, i64 %indvars.iv15
  store i8 %26, i8* %27, align 1
  %28 = zext i8 %21 to i64
  %29 = getelementptr inbounds [256 x i8], [256 x i8]* %6, i64 0, i64 %28
  store i8 %23, i8* %29, align 1
  %indvars.iv.next16 = add nuw nsw i64 %indvars.iv15, 1
  %exitcond = icmp ne i64 %indvars.iv.next16, %10
  br i1 %exitcond, label %11, label %._crit_edge14.loopexit

._crit_edge14.loopexit:                           ; preds = %11
  %.04.lcssa.ph = phi i8 [ %21, %11 ]
  br label %._crit_edge14

._crit_edge14:                                    ; preds = %._crit_edge14.loopexit, %5
  %.04.lcssa = phi i8 [ 0, %5 ], [ %.04.lcssa.ph, %._crit_edge14.loopexit ]
  %30 = icmp slt i32 0, %4
  br i1 %30, label %.lr.ph, label %._crit_edge

.lr.ph:                                           ; preds = %._crit_edge14
  %31 = sext i32 %0 to i64
  %32 = zext i32 %4 to i64
  br label %33

; <label>:33:                                     ; preds = %.lr.ph, %49
  %indvars.iv8 = phi i64 [ 0, %.lr.ph ], [ %indvars.iv.next9, %49 ]
  %indvars.iv = phi i64 [ %31, %.lr.ph ], [ %indvars.iv.next, %49 ]
  %.07 = phi i8 [ 0, %.lr.ph ], [ %55, %49 ]
  call void @unroll_loop(i32 170)
  %34 = sub nsw i64 %indvars.iv, 1
  %35 = getelementptr inbounds i8, i8* %2, i64 %34
  %36 = load i8, i8* %35, align 1
  %37 = zext i8 %36 to i32
  %38 = trunc i64 %indvars.iv to i32
  %39 = sub nsw i32 %38, %37
  %40 = trunc i32 %39 to i8
  br label %41

; <label>:41:                                     ; preds = %41, %33
  %.01 = phi i8 [ 0, %33 ], [ %48, %41 ]
  call void @unroll_loop(i32 171)
  %42 = zext i8 %40 to i32
  %43 = zext i8 %.01 to i64
  %44 = getelementptr inbounds [256 x i8], [256 x i8]* %6, i64 0, i64 %43
  %45 = load i8, i8* %44, align 1
  %46 = zext i8 %45 to i32
  %47 = icmp ne i32 %42, %46
  %48 = add i8 %.01, 1
  br i1 %47, label %41, label %49

; <label>:49:                                     ; preds = %41
  %.01.lcssa = phi i8 [ %.01, %41 ]
  %50 = getelementptr inbounds [256 x i8], [256 x i8]* %6, i64 0, i64 %indvars.iv
  %51 = load i8, i8* %50, align 1
  %52 = zext i8 %51 to i32
  %53 = zext i8 %.07 to i32
  %54 = add nsw i32 %53, %52
  %55 = trunc i32 %54 to i8
  %56 = zext i8 %.04.lcssa to i32
  %57 = zext i8 %55 to i32
  %58 = add nsw i32 %56, %57
  %59 = zext i8 %.01.lcssa to i32
  %60 = sub nsw i32 %59, %58
  %61 = trunc i32 %60 to i8
  %62 = getelementptr inbounds i8, i8* %3, i64 %indvars.iv8
  store i8 %61, i8* %62, align 1
  %indvars.iv.next = add nsw i64 %indvars.iv, 1
  %indvars.iv.next9 = add nuw nsw i64 %indvars.iv8, 1
  %exitcond1 = icmp ne i64 %indvars.iv.next9, %32
  br i1 %exitcond1, label %33, label %._crit_edge.loopexit

._crit_edge.loopexit:                             ; preds = %49
  br label %._crit_edge

._crit_edge:                                      ; preds = %._crit_edge.loopexit, %._crit_edge14
  ret void
}

; Function Attrs: noinline nounwind uwtable
define internal i32 @compare(i8*, i8*) #0 {
  %3 = bitcast i8* %0 to %struct.PTW_tableentry*
  %4 = bitcast i8* %1 to %struct.PTW_tableentry*
  %5 = getelementptr inbounds %struct.PTW_tableentry, %struct.PTW_tableentry* %3, i32 0, i32 0
  %6 = load i32, i32* %5, align 4
  %7 = getelementptr inbounds %struct.PTW_tableentry, %struct.PTW_tableentry* %4, i32 0, i32 0
  %8 = load i32, i32* %7, align 4
  %9 = icmp sgt i32 %6, %8
  br i1 %9, label %16, label %10

; <label>:10:                                     ; preds = %2
  %11 = getelementptr inbounds %struct.PTW_tableentry, %struct.PTW_tableentry* %3, i32 0, i32 0
  %12 = load i32, i32* %11, align 4
  %13 = getelementptr inbounds %struct.PTW_tableentry, %struct.PTW_tableentry* %4, i32 0, i32 0
  %14 = load i32, i32* %13, align 4
  %15 = icmp eq i32 %12, %14
  %. = select i1 %15, i32 0, i32 1
  br label %16

; <label>:16:                                     ; preds = %10, %2
  %.0 = phi i32 [ -1, %2 ], [ %., %10 ]
  ret i32 %.0
}

; Function Attrs: noinline nounwind uwtable
define internal i32 @correct(%struct.PTW_attackstate*, i8*, i32) #0 {
  %4 = alloca [32 x i8], align 16, !track !274
  %5 = alloca %struct.rc4state, align 1, !track !275
  %6 = getelementptr inbounds %struct.PTW_attackstate, %struct.PTW_attackstate* %0, i32 0, i32 2
  %7 = load i32, i32* %6, align 4
  %8 = icmp slt i32 %7, 3
  br i1 %8, label %45, label %9

; <label>:9:                                      ; preds = %3
  %10 = load i32, i32* @tried, align 4
  %11 = add nsw i32 %10, 1
  store i32 %11, i32* @tried, align 4
  %12 = call i32 @rand() #9
  %13 = getelementptr inbounds %struct.PTW_attackstate, %struct.PTW_attackstate* %0, i32 0, i32 2
  %14 = load i32, i32* %13, align 4
  %15 = sub nsw i32 %14, 10
  %16 = srem i32 %12, %15
  %17 = add nsw i32 %16, 10
  %18 = sext i32 %16 to i64
  %19 = sext i32 %17 to i64
  br label %20

; <label>:20:                                     ; preds = %9, %43
  %indvars.iv5 = phi i64 [ %18, %9 ], [ %indvars.iv.next6, %43 ]
  call void @unroll_loop(i32 172)
  %21 = getelementptr inbounds [32 x i8], [32 x i8]* %4, i64 0, i64 3
  %22 = sext i32 %2 to i64
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %21, i8* align 1 %1, i64 %22, i1 false), !track !276
  %23 = getelementptr inbounds [32 x i8], [32 x i8]* %4, i32 0, i32 0
  %24 = getelementptr inbounds %struct.PTW_attackstate, %struct.PTW_attackstate* %0, i32 0, i32 3
  %25 = getelementptr inbounds [10000 x %struct.PTW_session], [10000 x %struct.PTW_session]* %24, i64 0, i64 %indvars.iv5
  %26 = getelementptr inbounds %struct.PTW_session, %struct.PTW_session* %25, i32 0, i32 0
  %27 = getelementptr inbounds [3 x i8], [3 x i8]* %26, i32 0, i32 0
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 16 %23, i8* align 8 %27, i64 3, i1 false), !track !277
  %28 = getelementptr inbounds [32 x i8], [32 x i8]* %4, i32 0, i32 0
  %29 = add nsw i32 %2, 3
  call void @rc4init(i8* %28, i32 %29, %struct.rc4state* %5)
  br label %30

; <label>:30:                                     ; preds = %20, %41
  %indvars.iv = phi i64 [ 0, %20 ], [ %indvars.iv.next, %41 ]
  call void @unroll_loop(i32 173)
  %31 = call zeroext i8 @rc4update(%struct.rc4state* %5)
  %32 = zext i8 %31 to i32
  %33 = getelementptr inbounds %struct.PTW_attackstate, %struct.PTW_attackstate* %0, i32 0, i32 3
  %34 = getelementptr inbounds [10000 x %struct.PTW_session], [10000 x %struct.PTW_session]* %33, i64 0, i64 %indvars.iv5
  %35 = getelementptr inbounds %struct.PTW_session, %struct.PTW_session* %34, i32 0, i32 1
  %36 = getelementptr inbounds [32 x i8], [32 x i8]* %35, i64 0, i64 %indvars.iv
  %37 = load i8, i8* %36, align 1
  %38 = zext i8 %37 to i32
  %39 = xor i32 %32, %38
  %40 = icmp ne i32 %39, 0
  br i1 %40, label %.loopexit, label %41

; <label>:41:                                     ; preds = %30
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %42 = icmp ult i64 %indvars.iv.next, 6
  br i1 %42, label %30, label %43

; <label>:43:                                     ; preds = %41
  %indvars.iv.next6 = add nsw i64 %indvars.iv5, 1
  %44 = icmp slt i64 %indvars.iv.next6, %19
  br i1 %44, label %20, label %.loopexit1

.loopexit:                                        ; preds = %30
  %.0.ph = phi i32 [ 0, %30 ]
  br label %45

.loopexit1:                                       ; preds = %43
  %.0.ph2 = phi i32 [ 1, %43 ]
  br label %45

; <label>:45:                                     ; preds = %.loopexit1, %.loopexit, %3
  %.0 = phi i32 [ 0, %3 ], [ %.0.ph, %.loopexit ], [ %.0.ph2, %.loopexit1 ]
  ret i32 %.0
}

; Function Attrs: noinline nounwind uwtable
define internal i32 @comparesorthelper(i8*, i8*) #0 {
  %3 = bitcast i8* %0 to %struct.sorthelper*
  %4 = bitcast i8* %1 to %struct.sorthelper*
  %5 = getelementptr inbounds %struct.sorthelper, %struct.sorthelper* %3, i32 0, i32 2
  %6 = load i32, i32* %5, align 4
  %7 = getelementptr inbounds %struct.sorthelper, %struct.sorthelper* %4, i32 0, i32 2
  %8 = load i32, i32* %7, align 4
  %9 = icmp sgt i32 %6, %8
  br i1 %9, label %16, label %10

; <label>:10:                                     ; preds = %2
  %11 = getelementptr inbounds %struct.sorthelper, %struct.sorthelper* %3, i32 0, i32 2
  %12 = load i32, i32* %11, align 4
  %13 = getelementptr inbounds %struct.sorthelper, %struct.sorthelper* %4, i32 0, i32 2
  %14 = load i32, i32* %13, align 4
  %15 = icmp eq i32 %12, %14
  %. = select i1 %15, i32 0, i32 -1
  br label %16

; <label>:16:                                     ; preds = %10, %2
  %.0 = phi i32 [ 1, %2 ], [ %., %10 ]
  ret i32 %.0
}

; Function Attrs: noinline nounwind uwtable
define internal i32 @doComputation(%struct.PTW_attackstate*, i8*, i32, [256 x %struct.PTW_tableentry]*, %struct.sorthelper*, i32*, i32, i32*, [256 x i32]*) #0 {
  %10 = alloca [29 x i32], align 16, !track !278
  %11 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 6
  %12 = load i32, i32* %11, align 8
  %13 = icmp ne i32 %12, 0
  br i1 %13, label %18, label %14

; <label>:14:                                     ; preds = %9
  %15 = bitcast [256 x %struct.PTW_tableentry]* %3 to i8*
  %16 = sext i32 %2 to i64
  %17 = mul i64 2048, %16
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 16 bitcast ([29 x [256 x %struct.PTW_tableentry]]* @keytable to i8*), i8* align 4 %15, i64 %17, i1 false), !track !279
  br label %18

; <label>:18:                                     ; preds = %14, %9
  %19 = icmp slt i32 0, %2
  br i1 %19, label %.lr.ph19, label %._crit_edge20

.lr.ph19:                                         ; preds = %18
  %20 = zext i32 %2 to i64
  br label %21

; <label>:21:                                     ; preds = %.lr.ph19, %29
  %indvars.iv21 = phi i64 [ 0, %.lr.ph19 ], [ %indvars.iv.next22, %29 ]
  call void @unroll_loop(i32 174)
  %22 = getelementptr inbounds i32, i32* %5, i64 %indvars.iv21
  %23 = load i32, i32* %22, align 4
  %24 = icmp eq i32 %23, 1
  %25 = getelementptr inbounds [29 x i32], [29 x i32]* %10, i64 0, i64 %indvars.iv21
  br i1 %24, label %26, label %28

; <label>:26:                                     ; preds = %21
  %27 = trunc i64 %indvars.iv21 to i32
  store i32 %27, i32* %25, align 4
  br label %29

; <label>:28:                                     ; preds = %21
  store i32 1, i32* %25, align 4
  br label %29

; <label>:29:                                     ; preds = %26, %28
  %indvars.iv.next22 = add nuw nsw i64 %indvars.iv21, 1
  %exitcond = icmp ne i64 %indvars.iv.next22, %20
  br i1 %exitcond, label %21, label %._crit_edge20.loopexit

._crit_edge20.loopexit:                           ; preds = %29
  br label %._crit_edge20

._crit_edge20:                                    ; preds = %._crit_edge20.loopexit, %18
  store i32 %6, i32* @max_tries, align 4
  %30 = icmp slt i32 0, %6
  br i1 %30, label %.lr.ph16, label %.loopexit

.lr.ph16:                                         ; preds = %._crit_edge20
  %31 = zext i32 %2 to i64
  br label %32

; <label>:32:                                     ; preds = %.lr.ph16, %111
  %.0114 = phi i32 [ 0, %.lr.ph16 ], [ %92, %111 ]
  %.0213 = phi i32 [ -1, %.lr.ph16 ], [ %87, %111 ]
  %.1612 = phi i32 [ 0, %.lr.ph16 ], [ %101, %111 ]
  call void @unroll_loop(i32 175)
  %33 = trunc i32 %.0114 to i8
  %34 = getelementptr inbounds [29 x i32], [29 x i32]* %10, i32 0, i32 0
  %35 = call i32 @doRound([256 x %struct.PTW_tableentry]* %3, i32 0, i32 %.0213, i8 zeroext %33, i32* %34, i8* %1, i32 %2, %struct.PTW_attackstate* %0, i8 zeroext 0, i32* %5, i32* %7, [256 x i32]* %8)
  %36 = icmp eq i32 %35, 1
  br i1 %36, label %37, label %47

; <label>:37:                                     ; preds = %32
  %38 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 6
  %39 = load i32, i32* %38, align 8
  %40 = icmp ne i32 %39, 0
  br i1 %40, label %122, label %41

; <label>:41:                                     ; preds = %37
  %42 = sub nsw i32 %2, 1
  %43 = getelementptr inbounds [29 x i32], [29 x i32]* %10, i32 0, i32 0
  %44 = load i32, i32* @tried, align 4
  %45 = getelementptr [29 x [256 x %struct.PTW_tableentry]], [29 x [256 x %struct.PTW_tableentry]]* @keytable, i32 0, i32 0
  %46 = getelementptr [29 x i32], [29 x i32]* @depth, i32 0, i32 0
  call void @show_wep_stats(i32 %42, i32 1, [256 x %struct.PTW_tableentry]* %45, i32* %43, i32* %46, i32 %44)
  br label %122

; <label>:47:                                     ; preds = %32
  %48 = sext i32 %.1612 to i64
  br label %49

; <label>:49:                                     ; preds = %69, %47
  %indvars.iv = phi i64 [ %indvars.iv.next, %69 ], [ %48, %47 ]
  call void @unroll_loop(i32 176)
  %50 = mul nsw i32 %2, 255
  %51 = sext i32 %50 to i64
  %52 = icmp slt i64 %indvars.iv, %51
  br i1 %52, label %53, label %69

; <label>:53:                                     ; preds = %49
  %54 = getelementptr inbounds %struct.sorthelper, %struct.sorthelper* %4, i64 %indvars.iv
  %55 = getelementptr inbounds %struct.sorthelper, %struct.sorthelper* %54, i32 0, i32 0
  %56 = load i32, i32* %55, align 4
  %57 = sext i32 %56 to i64
  %58 = getelementptr inbounds i32, i32* %5, i64 %57
  %59 = load i32, i32* %58, align 4
  %60 = icmp eq i32 %59, 1
  br i1 %60, label %69, label %61

; <label>:61:                                     ; preds = %53
  %62 = getelementptr inbounds %struct.sorthelper, %struct.sorthelper* %4, i64 %indvars.iv
  %63 = getelementptr inbounds %struct.sorthelper, %struct.sorthelper* %62, i32 0, i32 0
  %64 = load i32, i32* %63, align 4
  %65 = sext i32 %64 to i64
  %66 = getelementptr inbounds i32, i32* %7, i64 %65
  %67 = load i32, i32* %66, align 4
  %68 = icmp eq i32 %67, 1
  br label %69

; <label>:69:                                     ; preds = %53, %61, %49
  %70 = phi i1 [ false, %49 ], [ true, %53 ], [ %68, %61 ]
  %indvars.iv.next = add i64 %indvars.iv, 1
  br i1 %70, label %49, label %71

; <label>:71:                                     ; preds = %69
  %.27.lcssa.wide = phi i64 [ %indvars.iv, %69 ]
  %72 = trunc i64 %.27.lcssa.wide to i32
  %73 = mul nsw i32 %2, 255
  %74 = icmp sge i32 %72, %73
  br i1 %74, label %.loopexit.loopexit, label %75

; <label>:75:                                     ; preds = %71
  %76 = sext i32 %72 to i64
  %77 = getelementptr inbounds %struct.sorthelper, %struct.sorthelper* %4, i64 %76
  %78 = getelementptr inbounds %struct.sorthelper, %struct.sorthelper* %77, i32 0, i32 0
  %79 = load i32, i32* %78, align 4
  %80 = sext i32 %79 to i64
  %81 = getelementptr inbounds [29 x i32], [29 x i32]* %10, i64 0, i64 %80
  %82 = load i32, i32* %81, align 4
  %83 = add nsw i32 %82, 1
  store i32 %83, i32* %81, align 4
  %84 = sext i32 %72 to i64
  %85 = getelementptr inbounds %struct.sorthelper, %struct.sorthelper* %4, i64 %84
  %86 = getelementptr inbounds %struct.sorthelper, %struct.sorthelper* %85, i32 0, i32 0
  %87 = load i32, i32* %86, align 4
  %88 = sext i32 %72 to i64
  %89 = getelementptr inbounds %struct.sorthelper, %struct.sorthelper* %4, i64 %88
  %90 = getelementptr inbounds %struct.sorthelper, %struct.sorthelper* %89, i32 0, i32 1
  %91 = load i8, i8* %90, align 4
  %92 = zext i8 %91 to i32
  %93 = icmp slt i32 0, %2
  br i1 %93, label %.lr.ph.preheader, label %._crit_edge

.lr.ph.preheader:                                 ; preds = %75
  br label %.lr.ph

.lr.ph:                                           ; preds = %.lr.ph.preheader, %.lr.ph
  %indvars.iv10 = phi i64 [ %indvars.iv.next11, %.lr.ph ], [ 0, %.lr.ph.preheader ]
  %.19 = phi i32 [ %spec.select, %.lr.ph ], [ 1, %.lr.ph.preheader ]
  call void @unroll_loop(i32 177)
  %94 = getelementptr inbounds [29 x i32], [29 x i32]* %10, i64 0, i64 %indvars.iv10
  %95 = load i32, i32* %94, align 4
  %96 = mul nsw i32 %.19, %95
  %97 = getelementptr inbounds i32, i32* %7, i64 %indvars.iv10
  %98 = load i32, i32* %97, align 4
  %99 = icmp eq i32 %98, 1
  %100 = mul nsw i32 %96, 256
  %spec.select = select i1 %99, i32 %100, i32 %96
  %indvars.iv.next11 = add nuw nsw i64 %indvars.iv10, 1
  %exitcond1 = icmp ne i64 %indvars.iv.next11, %31
  br i1 %exitcond1, label %.lr.ph, label %._crit_edge.loopexit

._crit_edge.loopexit:                             ; preds = %.lr.ph
  %.1.lcssa.ph = phi i32 [ %spec.select, %.lr.ph ]
  br label %._crit_edge

._crit_edge:                                      ; preds = %._crit_edge.loopexit, %75
  %.1.lcssa = phi i32 [ 1, %75 ], [ %.1.lcssa.ph, %._crit_edge.loopexit ]
  %101 = add nsw i32 %72, 1
  %102 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 6
  %103 = load i32, i32* %102, align 8
  %104 = icmp ne i32 %103, 0
  br i1 %104, label %111, label %105

; <label>:105:                                    ; preds = %._crit_edge
  %106 = sub nsw i32 %2, 1
  %107 = getelementptr inbounds [29 x i32], [29 x i32]* %10, i32 0, i32 0
  %108 = load i32, i32* @tried, align 4
  %109 = getelementptr [29 x [256 x %struct.PTW_tableentry]], [29 x [256 x %struct.PTW_tableentry]]* @keytable, i32 0, i32 0
  %110 = getelementptr [29 x i32], [29 x i32]* @depth, i32 0, i32 0
  call void @show_wep_stats(i32 %106, i32 0, [256 x %struct.PTW_tableentry]* %109, i32* %107, i32* %110, i32 %108)
  br label %111

; <label>:111:                                    ; preds = %105, %._crit_edge
  %112 = icmp slt i32 %.1.lcssa, %6
  br i1 %112, label %32, label %.loopexit.loopexit

.loopexit.loopexit:                               ; preds = %71, %111
  br label %.loopexit

.loopexit:                                        ; preds = %.loopexit.loopexit, %._crit_edge20
  %113 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 6
  %114 = load i32, i32* %113, align 8
  %115 = icmp ne i32 %114, 0
  br i1 %115, label %122, label %116

; <label>:116:                                    ; preds = %.loopexit
  %117 = sub nsw i32 %2, 1
  %118 = getelementptr inbounds [29 x i32], [29 x i32]* %10, i32 0, i32 0
  %119 = load i32, i32* @tried, align 4
  %120 = getelementptr [29 x [256 x %struct.PTW_tableentry]], [29 x [256 x %struct.PTW_tableentry]]* @keytable, i32 0, i32 0
  %121 = getelementptr [29 x i32], [29 x i32]* @depth, i32 0, i32 0
  call void @show_wep_stats(i32 %117, i32 1, [256 x %struct.PTW_tableentry]* %120, i32* %118, i32* %121, i32 %119)
  br label %122

; <label>:122:                                    ; preds = %.loopexit, %116, %37, %41
  %.0 = phi i32 [ 1, %41 ], [ 1, %37 ], [ 0, %116 ], [ 0, %.loopexit ]
  ret i32 %.0
}

; Function Attrs: noinline nounwind uwtable
define internal void @getdrv([256 x %struct.PTW_tableentry]*, i32, double*, double*) #0 {
  br label %5

; <label>:5:                                      ; preds = %4, %5
  %indvars.iv22 = phi i64 [ 0, %4 ], [ %indvars.iv.next23, %5 ]
  %.0421 = phi i32 [ 0, %4 ], [ %10, %5 ]
  call void @unroll_loop(i32 178)
  %6 = getelementptr inbounds [256 x %struct.PTW_tableentry], [256 x %struct.PTW_tableentry]* %0, i64 0
  %7 = getelementptr inbounds [256 x %struct.PTW_tableentry], [256 x %struct.PTW_tableentry]* %6, i64 0, i64 %indvars.iv22
  %8 = getelementptr inbounds %struct.PTW_tableentry, %struct.PTW_tableentry* %7, i32 0, i32 0
  %9 = load i32, i32* %8, align 4
  %10 = add nsw i32 %.0421, %9
  %indvars.iv.next23 = add nuw nsw i64 %indvars.iv22, 1
  %exitcond24 = icmp ne i64 %indvars.iv.next23, 256
  br i1 %exitcond24, label %5, label %11

; <label>:11:                                     ; preds = %5
  %.04.lcssa = phi i32 [ %10, %5 ]
  %12 = sdiv i32 %.04.lcssa, 256
  %13 = sitofp i32 %12 to double
  %14 = icmp slt i32 0, %1
  br i1 %14, label %.lr.ph, label %._crit_edge

.lr.ph:                                           ; preds = %11
  %15 = zext i32 %1 to i64
  br label %16

; <label>:16:                                     ; preds = %.lr.ph, %77
  %indvars.iv17 = phi i64 [ 0, %.lr.ph ], [ %indvars.iv.next18, %77 ]
  call void @unroll_loop(i32 179)
  %17 = getelementptr inbounds [13 x double], [13 x double]* @eval, i64 0, i64 %indvars.iv17
  %18 = load double, double* %17, align 8
  %19 = getelementptr inbounds [13 x double], [13 x double]* @eval, i64 0, i64 %indvars.iv17
  %20 = load double, double* %19, align 8
  %21 = getelementptr inbounds double, double* %2, i64 %indvars.iv17
  store double 0.000000e+00, double* %21, align 8
  %22 = getelementptr inbounds double, double* %3, i64 %indvars.iv17
  store double 0.000000e+00, double* %22, align 8
  br label %23

; <label>:23:                                     ; preds = %16, %38
  %indvars.iv = phi i64 [ 0, %16 ], [ %indvars.iv.next, %38 ]
  %.011 = phi double [ 0.000000e+00, %16 ], [ %.1, %38 ]
  %.0110 = phi double [ 0.000000e+00, %16 ], [ %.12, %38 ]
  call void @unroll_loop(i32 180)
  %24 = getelementptr inbounds [256 x %struct.PTW_tableentry], [256 x %struct.PTW_tableentry]* %0, i64 %indvars.iv17
  %25 = getelementptr inbounds [256 x %struct.PTW_tableentry], [256 x %struct.PTW_tableentry]* %24, i64 0, i64 %indvars.iv
  %26 = getelementptr inbounds %struct.PTW_tableentry, %struct.PTW_tableentry* %25, i32 0, i32 0
  %27 = load i32, i32* %26, align 4
  %28 = sitofp i32 %27 to double
  %29 = fcmp ogt double %28, %.0110
  br i1 %29, label %30, label %38

; <label>:30:                                     ; preds = %23
  %31 = getelementptr inbounds [256 x %struct.PTW_tableentry], [256 x %struct.PTW_tableentry]* %0, i64 %indvars.iv17
  %32 = getelementptr inbounds [256 x %struct.PTW_tableentry], [256 x %struct.PTW_tableentry]* %31, i64 0, i64 %indvars.iv
  %33 = getelementptr inbounds %struct.PTW_tableentry, %struct.PTW_tableentry* %32, i32 0, i32 0
  %34 = load i32, i32* %33, align 4
  %35 = sitofp i32 %34 to double
  %36 = trunc i64 %indvars.iv to i32
  %37 = sitofp i32 %36 to double
  br label %38

; <label>:38:                                     ; preds = %23, %30
  %.12 = phi double [ %35, %30 ], [ %.0110, %23 ]
  %.1 = phi double [ %37, %30 ], [ %.011, %23 ]
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond = icmp ne i64 %indvars.iv.next, 256
  br i1 %exitcond, label %23, label %39

; <label>:39:                                     ; preds = %38
  %.0.lcssa = phi double [ %.1, %38 ]
  %40 = fsub double 1.000000e+00, %20
  %41 = sitofp i32 %.04.lcssa to double
  %42 = sitofp i32 %.04.lcssa to double
  %43 = fmul double %18, %41
  %44 = fdiv double %40, 2.550000e+02
  %45 = fmul double %44, %42
  br label %46

; <label>:46:                                     ; preds = %39, %61
  %indvars.iv13 = phi i64 [ 0, %39 ], [ %indvars.iv.next14, %61 ]
  call void @unroll_loop(i32 181)
  %47 = trunc i64 %indvars.iv13 to i32
  %48 = sitofp i32 %47 to double
  %49 = fcmp oeq double %48, %.0.lcssa
  %50 = getelementptr inbounds [256 x %struct.PTW_tableentry], [256 x %struct.PTW_tableentry]* %0, i64 %indvars.iv17
  %51 = getelementptr inbounds [256 x %struct.PTW_tableentry], [256 x %struct.PTW_tableentry]* %50, i64 0, i64 %indvars.iv13
  %52 = getelementptr inbounds %struct.PTW_tableentry, %struct.PTW_tableentry* %51, i32 0, i32 0
  %53 = load i32, i32* %52, align 4
  %54 = sitofp i32 %53 to double
  br i1 %49, label %55, label %58

; <label>:55:                                     ; preds = %46
  %56 = fdiv double %54, %43
  %57 = fsub double 1.000000e+00, %56
  br label %61

; <label>:58:                                     ; preds = %46
  %59 = fdiv double %54, %45
  %60 = fsub double 1.000000e+00, %59
  br label %61

; <label>:61:                                     ; preds = %58, %55
  %.03 = phi double [ %57, %55 ], [ %60, %58 ]
  %62 = fmul double %.03, %.03
  %63 = getelementptr inbounds double, double* %3, i64 %indvars.iv17
  %64 = load double, double* %63, align 8
  %65 = fadd double %64, %62
  store double %65, double* %63, align 8
  %66 = getelementptr inbounds [256 x %struct.PTW_tableentry], [256 x %struct.PTW_tableentry]* %0, i64 %indvars.iv17
  %67 = getelementptr inbounds [256 x %struct.PTW_tableentry], [256 x %struct.PTW_tableentry]* %66, i64 0, i64 %indvars.iv13
  %68 = getelementptr inbounds %struct.PTW_tableentry, %struct.PTW_tableentry* %67, i32 0, i32 0
  %69 = load i32, i32* %68, align 4
  %70 = sitofp i32 %69 to double
  %71 = fdiv double %70, %13
  %72 = fsub double 1.000000e+00, %71
  %73 = fmul double %72, %72
  %74 = getelementptr inbounds double, double* %2, i64 %indvars.iv17
  %75 = load double, double* %74, align 8
  %76 = fadd double %75, %73
  store double %76, double* %74, align 8
  %indvars.iv.next14 = add nuw nsw i64 %indvars.iv13, 1
  %exitcond15 = icmp ne i64 %indvars.iv.next14, 256
  br i1 %exitcond15, label %46, label %77

; <label>:77:                                     ; preds = %61
  %indvars.iv.next18 = add nuw nsw i64 %indvars.iv17, 1
  %exitcond1 = icmp ne i64 %indvars.iv.next18, %15
  br i1 %exitcond1, label %16, label %._crit_edge.loopexit

._crit_edge.loopexit:                             ; preds = %77
  br label %._crit_edge

._crit_edge:                                      ; preds = %._crit_edge.loopexit, %11
  ret void
}

; Function Attrs: noinline nounwind uwtable
define internal i32 @comparedoublesorthelper(i8*, i8*) #0 {
  %3 = bitcast i8* %0 to %struct.doublesorthelper*
  %4 = bitcast i8* %1 to %struct.doublesorthelper*
  %5 = getelementptr inbounds %struct.doublesorthelper, %struct.doublesorthelper* %3, i32 0, i32 1
  %6 = load double, double* %5, align 8
  %7 = getelementptr inbounds %struct.doublesorthelper, %struct.doublesorthelper* %4, i32 0, i32 1
  %8 = load double, double* %7, align 8
  %9 = fcmp ogt double %6, %8
  br i1 %9, label %16, label %10

; <label>:10:                                     ; preds = %2
  %11 = getelementptr inbounds %struct.doublesorthelper, %struct.doublesorthelper* %3, i32 0, i32 1
  %12 = load double, double* %11, align 8
  %13 = getelementptr inbounds %struct.doublesorthelper, %struct.doublesorthelper* %4, i32 0, i32 1
  %14 = load double, double* %13, align 8
  %15 = fcmp oeq double %12, %14
  %. = select i1 %15, i32 0, i32 -1
  br label %16

; <label>:16:                                     ; preds = %10, %2
  %.0 = phi i32 [ 1, %2 ], [ %., %10 ]
  ret i32 %.0
}

; Function Attrs: noinline nounwind uwtable
define internal i32 @doRound([256 x %struct.PTW_tableentry]*, i32, i32, i8 zeroext, i32*, i8*, i32, %struct.PTW_attackstate*, i8 zeroext, i32*, i32*, [256 x i32]*) #0 {
  %13 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 6
  %14 = load i32, i32* %13, align 8
  %15 = icmp eq i32 %14, 0
  %16 = icmp slt i32 %1, 4
  %or.cond = and i1 %15, %16
  br i1 %or.cond, label %17, label %22

; <label>:17:                                     ; preds = %12
  %18 = sub nsw i32 %6, 1
  %19 = load i32, i32* @tried, align 4
  %20 = getelementptr [29 x [256 x %struct.PTW_tableentry]], [29 x [256 x %struct.PTW_tableentry]]* @keytable, i32 0, i32 0
  %21 = getelementptr [29 x i32], [29 x i32]* @depth, i32 0, i32 0
  call void @show_wep_stats(i32 %18, i32 0, [256 x %struct.PTW_tableentry]* %20, i32* %4, i32* %21, i32 %19)
  br label %22

; <label>:22:                                     ; preds = %12, %17
  %23 = icmp sgt i32 %1, 0
  br i1 %23, label %24, label %36

; <label>:24:                                     ; preds = %22
  %25 = sub nsw i32 %1, 1
  %26 = sext i32 %25 to i64
  %27 = getelementptr inbounds [256 x i32], [256 x i32]* %11, i64 %26
  %28 = sub nsw i32 %1, 1
  %29 = sext i32 %28 to i64
  %30 = getelementptr inbounds i8, i8* %5, i64 %29
  %31 = load i8, i8* %30, align 1
  %32 = zext i8 %31 to i64
  %33 = getelementptr inbounds [256 x i32], [256 x i32]* %27, i64 0, i64 %32
  %34 = load i32, i32* %33, align 4
  %35 = icmp ne i32 %34, 0
  br i1 %35, label %36, label %._crit_edge

; <label>:36:                                     ; preds = %24, %22
  %37 = icmp eq i32 %1, %6
  br i1 %37, label %38, label %40

; <label>:38:                                     ; preds = %36
  %39 = call i32 @correct(%struct.PTW_attackstate* %7, i8* %5, i32 %6)
  br label %._crit_edge

; <label>:40:                                     ; preds = %36
  %41 = sext i32 %1 to i64
  %42 = getelementptr inbounds i32, i32* %10, i64 %41
  %43 = load i32, i32* %42, align 4
  %44 = icmp eq i32 %43, 1
  br i1 %44, label %.preheader, label %58

.preheader:                                       ; preds = %40
  br label %45

; <label>:45:                                     ; preds = %.preheader, %55
  %.023 = phi i32 [ %56, %55 ], [ 0, %.preheader ]
  call void @unroll_loop(i32 182)
  %46 = trunc i32 %.023 to i8
  %47 = sext i32 %1 to i64
  %48 = getelementptr inbounds i8, i8* %5, i64 %47
  store i8 %46, i8* %48, align 1
  %49 = add nsw i32 %1, 1
  %50 = zext i8 %8 to i32
  %51 = add nuw nsw i32 %50, %.023
  %52 = trunc i32 %51 to i8
  %53 = call i32 @doRound([256 x %struct.PTW_tableentry]* %0, i32 %49, i32 %2, i8 zeroext %3, i32* %4, i8* %5, i32 %6, %struct.PTW_attackstate* %7, i8 zeroext %52, i32* %9, i32* %10, [256 x i32]* %11)
  %54 = icmp ne i32 %53, 0
  br i1 %54, label %._crit_edge.loopexit, label %55

; <label>:55:                                     ; preds = %45
  %56 = add nuw nsw i32 %.023, 1
  %57 = icmp ult i32 %56, 256
  br i1 %57, label %45, label %._crit_edge.loopexit

; <label>:58:                                     ; preds = %40
  %59 = icmp eq i32 %1, %2
  br i1 %59, label %60, label %69

; <label>:60:                                     ; preds = %58
  %61 = zext i8 %3 to i32
  %62 = zext i8 %8 to i32
  %63 = sub nsw i32 %61, %62
  %64 = trunc i32 %63 to i8
  %65 = sext i32 %1 to i64
  %66 = getelementptr inbounds i8, i8* %5, i64 %65
  store i8 %64, i8* %66, align 1
  %67 = add nsw i32 %1, 1
  %68 = call i32 @doRound([256 x %struct.PTW_tableentry]* %0, i32 %67, i32 %2, i8 zeroext %3, i32* %4, i8* %5, i32 %6, %struct.PTW_attackstate* %7, i8 zeroext %3, i32* %9, i32* %10, [256 x i32]* %11)
  br label %._crit_edge

; <label>:69:                                     ; preds = %58
  %70 = sext i32 %1 to i64
  %71 = getelementptr inbounds i32, i32* %9, i64 %70
  %72 = load i32, i32* %71, align 4
  %73 = icmp eq i32 %72, 1
  br i1 %73, label %74, label %110

; <label>:74:                                     ; preds = %69
  %75 = add nsw i32 3, %1
  %76 = trunc i32 %75 to i8
  %77 = sub nsw i32 %1, 1
  %78 = icmp sge i32 %77, 1
  br i1 %78, label %.lr.ph, label %._crit_edge

.lr.ph:                                           ; preds = %74
  %79 = add i32 %1, -1
  %80 = sext i32 %79 to i64
  br label %81

; <label>:81:                                     ; preds = %.lr.ph, %108
  %indvars.iv = phi i64 [ %80, %.lr.ph ], [ %indvars.iv.next, %108 ]
  %.015 = phi i8 [ %76, %.lr.ph ], [ %90, %108 ]
  call void @unroll_loop(i32 183)
  %82 = getelementptr inbounds i8, i8* %5, i64 %indvars.iv
  %83 = load i8, i8* %82, align 1
  %84 = zext i8 %83 to i32
  %85 = add nsw i32 3, %84
  %86 = trunc i64 %indvars.iv to i32
  %87 = add nsw i32 %85, %86
  %88 = zext i8 %.015 to i32
  %89 = add nsw i32 %88, %87
  %90 = trunc i32 %89 to i8
  %91 = zext i8 %90 to i32
  %92 = sub nsw i32 256, %91
  %93 = trunc i32 %92 to i8
  %94 = sext i32 %1 to i64
  %95 = getelementptr inbounds i8, i8* %5, i64 %94
  store i8 %93, i8* %95, align 1
  %96 = add nsw i32 %1, 1
  %97 = zext i8 %90 to i32
  %98 = sub nsw i32 256, %97
  %99 = zext i8 %8 to i32
  %100 = add nsw i32 %98, %99
  %101 = srem i32 %100, 256
  %102 = trunc i32 %101 to i8
  %103 = call i32 @doRound([256 x %struct.PTW_tableentry]* %0, i32 %96, i32 %2, i8 zeroext %3, i32* %4, i8* %5, i32 %6, %struct.PTW_attackstate* %7, i8 zeroext %102, i32* %9, i32* %10, [256 x i32]* %11)
  %104 = icmp eq i32 %103, 1
  br i1 %104, label %105, label %108

; <label>:105:                                    ; preds = %81
  %106 = getelementptr [36 x i8], [36 x i8]* @.str.1.223, i32 0, i32 0
  %107 = call i32 (i8*, ...) @printf(i8* %106, i32 %1)
  br label %._crit_edge

; <label>:108:                                    ; preds = %81
  %indvars.iv.next = add nsw i64 %indvars.iv, -1
  %109 = icmp sge i64 %indvars.iv.next, 1
  br i1 %109, label %81, label %._crit_edge.loopexit1

; <label>:110:                                    ; preds = %69
  %111 = sext i32 %1 to i64
  %112 = getelementptr inbounds i32, i32* %4, i64 %111
  %113 = load i32, i32* %112, align 4
  %114 = icmp slt i32 0, %113
  br i1 %114, label %.lr.ph8.preheader, label %._crit_edge

.lr.ph8.preheader:                                ; preds = %110
  br label %.lr.ph8

.lr.ph8:                                          ; preds = %.lr.ph8.preheader, %149
  %indvars.iv10 = phi i64 [ %indvars.iv.next11, %149 ], [ 0, %.lr.ph8.preheader ]
  call void @unroll_loop(i32 184)
  %115 = sext i32 %1 to i64
  %116 = getelementptr inbounds [256 x %struct.PTW_tableentry], [256 x %struct.PTW_tableentry]* %0, i64 %115
  %117 = getelementptr inbounds [256 x %struct.PTW_tableentry], [256 x %struct.PTW_tableentry]* %116, i64 0, i64 %indvars.iv10
  %118 = getelementptr inbounds %struct.PTW_tableentry, %struct.PTW_tableentry* %117, i32 0, i32 1
  %119 = load i8, i8* %118, align 4
  %120 = zext i8 %119 to i32
  %121 = zext i8 %8 to i32
  %122 = sub nsw i32 %120, %121
  %123 = trunc i32 %122 to i8
  %124 = sext i32 %1 to i64
  %125 = getelementptr inbounds i8, i8* %5, i64 %124
  store i8 %123, i8* %125, align 1
  %126 = getelementptr %struct.options, %struct.options* @opt, i32 0, i32 6
  %127 = load i32, i32* %126, align 8
  %128 = icmp ne i32 %127, 0
  br i1 %128, label %140, label %129

; <label>:129:                                    ; preds = %.lr.ph8
  %130 = sext i32 %1 to i64
  %131 = getelementptr inbounds [29 x i32], [29 x i32]* @depth, i64 0, i64 %130
  %132 = trunc i64 %indvars.iv10 to i32
  store i32 %132, i32* %131, align 4
  %133 = sext i32 %1 to i64
  %134 = getelementptr inbounds i8, i8* %5, i64 %133
  %135 = load i8, i8* %134, align 1
  %136 = sext i32 %1 to i64
  %137 = getelementptr inbounds [29 x [256 x %struct.PTW_tableentry]], [29 x [256 x %struct.PTW_tableentry]]* @keytable, i64 0, i64 %136
  %138 = getelementptr inbounds [256 x %struct.PTW_tableentry], [256 x %struct.PTW_tableentry]* %137, i64 0, i64 %indvars.iv10
  %139 = getelementptr inbounds %struct.PTW_tableentry, %struct.PTW_tableentry* %138, i32 0, i32 1
  store i8 %135, i8* %139, align 4
  br label %140

; <label>:140:                                    ; preds = %129, %.lr.ph8
  %141 = add nsw i32 %1, 1
  %142 = sext i32 %1 to i64
  %143 = getelementptr inbounds [256 x %struct.PTW_tableentry], [256 x %struct.PTW_tableentry]* %0, i64 %142
  %144 = getelementptr inbounds [256 x %struct.PTW_tableentry], [256 x %struct.PTW_tableentry]* %143, i64 0, i64 %indvars.iv10
  %145 = getelementptr inbounds %struct.PTW_tableentry, %struct.PTW_tableentry* %144, i32 0, i32 1
  %146 = load i8, i8* %145, align 4
  %147 = call i32 @doRound([256 x %struct.PTW_tableentry]* %0, i32 %141, i32 %2, i8 zeroext %3, i32* %4, i8* %5, i32 %6, %struct.PTW_attackstate* %7, i8 zeroext %146, i32* %9, i32* %10, [256 x i32]* %11)
  %148 = icmp ne i32 %147, 0
  br i1 %148, label %._crit_edge.loopexit3, label %149

; <label>:149:                                    ; preds = %140
  %indvars.iv.next11 = add nuw nsw i64 %indvars.iv10, 1
  %150 = load i32, i32* %112, align 4
  %151 = sext i32 %150 to i64
  %152 = icmp slt i64 %indvars.iv.next11, %151
  br i1 %152, label %.lr.ph8, label %._crit_edge.loopexit3

._crit_edge.loopexit:                             ; preds = %45, %55
  %.0.ph = phi i32 [ 0, %55 ], [ 1, %45 ]
  br label %._crit_edge

._crit_edge.loopexit1:                            ; preds = %108
  %.0.ph2 = phi i32 [ 0, %108 ]
  br label %._crit_edge

._crit_edge.loopexit3:                            ; preds = %140, %149
  %.0.ph4 = phi i32 [ 0, %149 ], [ 1, %140 ]
  br label %._crit_edge

._crit_edge:                                      ; preds = %._crit_edge.loopexit3, %._crit_edge.loopexit1, %._crit_edge.loopexit, %110, %74, %24, %105, %60, %38
  %.0 = phi i32 [ %39, %38 ], [ %68, %60 ], [ 1, %105 ], [ 0, %24 ], [ 0, %74 ], [ 0, %110 ], [ %.0.ph, %._crit_edge.loopexit ], [ %.0.ph2, %._crit_edge.loopexit1 ], [ %.0.ph4, %._crit_edge.loopexit3 ]
  ret i32 %.0
}

; Function Attrs: nounwind
declare dso_local i32 @rand() #2

; Function Attrs: noinline nounwind uwtable
define internal void @rc4init(i8*, i32, %struct.rc4state*) #0 {
  %4 = getelementptr inbounds %struct.rc4state, %struct.rc4state* %2, i32 0, i32 2
  %5 = getelementptr inbounds [256 x i8], [256 x i8]* %4, i32 0, i32 0
  %6 = getelementptr [256 x i8], [256 x i8]* @rc4initial, i32 0, i32 0
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %5, i8* align 16 %6, i64 256, i1 false), !track !280
  br label %7

; <label>:7:                                      ; preds = %3, %7
  %indvars.iv = phi i64 [ 0, %3 ], [ %indvars.iv.next, %7 ]
  %.03 = phi i8 [ 0, %3 ], [ %21, %7 ]
  call void @unroll_loop(i32 185)
  %8 = zext i8 %.03 to i32
  %9 = getelementptr inbounds %struct.rc4state, %struct.rc4state* %2, i32 0, i32 2
  %10 = getelementptr inbounds [256 x i8], [256 x i8]* %9, i64 0, i64 %indvars.iv
  %11 = load i8, i8* %10, align 1
  %12 = zext i8 %11 to i32
  %13 = add nsw i32 %8, %12
  %14 = trunc i64 %indvars.iv to i32
  %15 = srem i32 %14, %1
  %16 = sext i32 %15 to i64
  %17 = getelementptr inbounds i8, i8* %0, i64 %16
  %18 = load i8, i8* %17, align 1
  %19 = zext i8 %18 to i32
  %20 = add nsw i32 %13, %19
  %21 = trunc i32 %20 to i8
  %22 = getelementptr inbounds %struct.rc4state, %struct.rc4state* %2, i32 0, i32 2
  %23 = getelementptr inbounds [256 x i8], [256 x i8]* %22, i64 0, i64 %indvars.iv
  %24 = load i8, i8* %23, align 1
  %25 = getelementptr inbounds %struct.rc4state, %struct.rc4state* %2, i32 0, i32 2
  %26 = zext i8 %21 to i64
  %27 = getelementptr inbounds [256 x i8], [256 x i8]* %25, i64 0, i64 %26
  %28 = load i8, i8* %27, align 1
  %29 = getelementptr inbounds %struct.rc4state, %struct.rc4state* %2, i32 0, i32 2
  %30 = getelementptr inbounds [256 x i8], [256 x i8]* %29, i64 0, i64 %indvars.iv
  store i8 %28, i8* %30, align 1
  %31 = getelementptr inbounds %struct.rc4state, %struct.rc4state* %2, i32 0, i32 2
  %32 = zext i8 %21 to i64
  %33 = getelementptr inbounds [256 x i8], [256 x i8]* %31, i64 0, i64 %32
  store i8 %24, i8* %33, align 1
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond = icmp ne i64 %indvars.iv.next, 256
  br i1 %exitcond, label %7, label %34

; <label>:34:                                     ; preds = %7
  %35 = getelementptr inbounds %struct.rc4state, %struct.rc4state* %2, i32 0, i32 0
  store i8 0, i8* %35, align 1
  %36 = getelementptr inbounds %struct.rc4state, %struct.rc4state* %2, i32 0, i32 1
  store i8 0, i8* %36, align 1
  ret void
}

; Function Attrs: noinline nounwind uwtable
define internal zeroext i8 @rc4update(%struct.rc4state*) #0 {
  %2 = getelementptr inbounds %struct.rc4state, %struct.rc4state* %0, i32 0, i32 0
  %3 = load i8, i8* %2, align 1
  %4 = add i8 %3, 1
  store i8 %4, i8* %2, align 1
  %5 = getelementptr inbounds %struct.rc4state, %struct.rc4state* %0, i32 0, i32 2
  %6 = getelementptr inbounds %struct.rc4state, %struct.rc4state* %0, i32 0, i32 0
  %7 = load i8, i8* %6, align 1
  %8 = zext i8 %7 to i64
  %9 = getelementptr inbounds [256 x i8], [256 x i8]* %5, i64 0, i64 %8
  %10 = load i8, i8* %9, align 1
  %11 = zext i8 %10 to i32
  %12 = getelementptr inbounds %struct.rc4state, %struct.rc4state* %0, i32 0, i32 1
  %13 = load i8, i8* %12, align 1
  %14 = zext i8 %13 to i32
  %15 = add nsw i32 %14, %11
  %16 = trunc i32 %15 to i8
  store i8 %16, i8* %12, align 1
  %17 = getelementptr inbounds %struct.rc4state, %struct.rc4state* %0, i32 0, i32 2
  %18 = getelementptr inbounds %struct.rc4state, %struct.rc4state* %0, i32 0, i32 0
  %19 = load i8, i8* %18, align 1
  %20 = zext i8 %19 to i64
  %21 = getelementptr inbounds [256 x i8], [256 x i8]* %17, i64 0, i64 %20
  %22 = load i8, i8* %21, align 1
  %23 = getelementptr inbounds %struct.rc4state, %struct.rc4state* %0, i32 0, i32 2
  %24 = getelementptr inbounds %struct.rc4state, %struct.rc4state* %0, i32 0, i32 1
  %25 = load i8, i8* %24, align 1
  %26 = zext i8 %25 to i64
  %27 = getelementptr inbounds [256 x i8], [256 x i8]* %23, i64 0, i64 %26
  %28 = load i8, i8* %27, align 1
  %29 = getelementptr inbounds %struct.rc4state, %struct.rc4state* %0, i32 0, i32 2
  %30 = getelementptr inbounds %struct.rc4state, %struct.rc4state* %0, i32 0, i32 0
  %31 = load i8, i8* %30, align 1
  %32 = zext i8 %31 to i64
  %33 = getelementptr inbounds [256 x i8], [256 x i8]* %29, i64 0, i64 %32
  store i8 %28, i8* %33, align 1
  %34 = getelementptr inbounds %struct.rc4state, %struct.rc4state* %0, i32 0, i32 2
  %35 = getelementptr inbounds %struct.rc4state, %struct.rc4state* %0, i32 0, i32 1
  %36 = load i8, i8* %35, align 1
  %37 = zext i8 %36 to i64
  %38 = getelementptr inbounds [256 x i8], [256 x i8]* %34, i64 0, i64 %37
  store i8 %22, i8* %38, align 1
  %39 = getelementptr inbounds %struct.rc4state, %struct.rc4state* %0, i32 0, i32 2
  %40 = getelementptr inbounds %struct.rc4state, %struct.rc4state* %0, i32 0, i32 0
  %41 = load i8, i8* %40, align 1
  %42 = zext i8 %41 to i64
  %43 = getelementptr inbounds [256 x i8], [256 x i8]* %39, i64 0, i64 %42
  %44 = load i8, i8* %43, align 1
  %45 = zext i8 %44 to i32
  %46 = getelementptr inbounds %struct.rc4state, %struct.rc4state* %0, i32 0, i32 2
  %47 = getelementptr inbounds %struct.rc4state, %struct.rc4state* %0, i32 0, i32 1
  %48 = load i8, i8* %47, align 1
  %49 = zext i8 %48 to i64
  %50 = getelementptr inbounds [256 x i8], [256 x i8]* %46, i64 0, i64 %49
  %51 = load i8, i8* %50, align 1
  %52 = zext i8 %51 to i32
  %53 = add nsw i32 %45, %52
  %54 = trunc i32 %53 to i8
  %55 = getelementptr inbounds %struct.rc4state, %struct.rc4state* %0, i32 0, i32 2
  %56 = zext i8 %54 to i64
  %57 = getelementptr inbounds [256 x i8], [256 x i8]* %55, i64 0, i64 %56
  %58 = load i8, i8* %57, align 1
  ret i8 %58
}

; Function Attrs: noinline nounwind uwtable
define dso_local i32 @PTW_addsession(%struct.PTW_attackstate*, i8*, i8*, i32*, i32) #0 {
  %6 = alloca [29 x i8], align 16, !track !281
  %7 = getelementptr inbounds i8, i8* %1, i64 0
  %8 = load i8, i8* %7, align 1
  %9 = zext i8 %8 to i32
  %10 = shl i32 %9, 16
  %11 = getelementptr inbounds i8, i8* %1, i64 1
  %12 = load i8, i8* %11, align 1
  %13 = zext i8 %12 to i32
  %14 = shl i32 %13, 8
  %15 = or i32 %10, %14
  %16 = getelementptr inbounds i8, i8* %1, i64 2
  %17 = load i8, i8* %16, align 1
  %18 = zext i8 %17 to i32
  %19 = or i32 %15, %18
  %20 = sdiv i32 %19, 8
  %21 = srem i32 %19, 8
  %22 = shl i32 1, %21
  %23 = getelementptr inbounds %struct.PTW_attackstate, %struct.PTW_attackstate* %0, i32 0, i32 1
  %24 = sext i32 %20 to i64
  %25 = getelementptr inbounds [2097152 x i8], [2097152 x i8]* %23, i64 0, i64 %24
  %26 = load i8, i8* %25, align 1
  %27 = zext i8 %26 to i32
  %28 = and i32 %27, %22
  %29 = icmp eq i32 %28, 0
  br i1 %29, label %30, label %139

; <label>:30:                                     ; preds = %5
  %31 = getelementptr inbounds %struct.PTW_attackstate, %struct.PTW_attackstate* %0, i32 0, i32 1
  %32 = sext i32 %20 to i64
  %33 = getelementptr inbounds [2097152 x i8], [2097152 x i8]* %31, i64 0, i64 %32
  %34 = load i8, i8* %33, align 1
  %35 = zext i8 %34 to i32
  %36 = or i32 %35, %22
  %37 = trunc i32 %36 to i8
  store i8 %37, i8* %33, align 1
  %38 = icmp slt i32 0, %4
  br i1 %38, label %.lr.ph, label %._crit_edge

.lr.ph:                                           ; preds = %30
  %39 = sext i32 %4 to i64
  br label %40

; <label>:40:                                     ; preds = %.lr.ph, %86
  %indvars.iv5 = phi i64 [ 0, %.lr.ph ], [ %indvars.iv.next6, %86 ]
  call void @unroll_loop(i32 186)
  %41 = getelementptr inbounds %struct.PTW_attackstate, %struct.PTW_attackstate* %0, i32 0, i32 0
  %42 = load i32, i32* %41, align 8
  %43 = add nsw i32 %42, 1
  store i32 %43, i32* %41, align 8
  %44 = mul nuw nsw i64 32, %indvars.iv5
  %45 = getelementptr inbounds i8, i8* %2, i64 %44
  %46 = getelementptr inbounds [29 x i8], [29 x i8]* %6, i32 0, i32 0
  call void @guesskeybytes(i32 3, i8* %1, i8* %45, i8* %46, i32 29)
  br label %47

; <label>:47:                                     ; preds = %40, %47
  %indvars.iv = phi i64 [ 0, %40 ], [ %indvars.iv.next, %47 ]
  call void @unroll_loop(i32 187)
  %48 = getelementptr inbounds i32, i32* %3, i64 %indvars.iv5
  %49 = load i32, i32* %48, align 4
  %50 = getelementptr inbounds %struct.PTW_attackstate, %struct.PTW_attackstate* %0, i32 0, i32 4
  %51 = getelementptr inbounds [29 x [256 x %struct.PTW_tableentry]], [29 x [256 x %struct.PTW_tableentry]]* %50, i64 0, i64 %indvars.iv
  %52 = getelementptr inbounds [29 x i8], [29 x i8]* %6, i64 0, i64 %indvars.iv
  %53 = load i8, i8* %52, align 1
  %54 = zext i8 %53 to i64
  %55 = getelementptr inbounds [256 x %struct.PTW_tableentry], [256 x %struct.PTW_tableentry]* %51, i64 0, i64 %54
  %56 = getelementptr inbounds %struct.PTW_tableentry, %struct.PTW_tableentry* %55, i32 0, i32 0
  %57 = load i32, i32* %56, align 8
  %58 = add nsw i32 %57, %49
  store i32 %58, i32* %56, align 8
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond = icmp ne i64 %indvars.iv.next, 29
  br i1 %exitcond, label %47, label %59

; <label>:59:                                     ; preds = %47
  %60 = getelementptr inbounds %struct.PTW_attackstate, %struct.PTW_attackstate* %0, i32 0, i32 6
  %61 = load i32, i32* %60, align 8
  %62 = getelementptr inbounds %struct.PTW_attackstate, %struct.PTW_attackstate* %0, i32 0, i32 0
  %63 = load i32, i32* %62, align 8
  %64 = icmp slt i32 %61, %63
  br i1 %64, label %65, label %86

; <label>:65:                                     ; preds = %59
  %66 = getelementptr inbounds %struct.PTW_attackstate, %struct.PTW_attackstate* %0, i32 0, i32 6
  %67 = load i32, i32* %66, align 8
  %68 = shl i32 %67, 1
  %69 = getelementptr inbounds %struct.PTW_attackstate, %struct.PTW_attackstate* %0, i32 0, i32 6
  store i32 %68, i32* %69, align 8
  %70 = getelementptr inbounds %struct.PTW_attackstate, %struct.PTW_attackstate* %0, i32 0, i32 5
  %71 = load %struct.PTW_session*, %struct.PTW_session** %70, align 8
  %72 = bitcast %struct.PTW_session* %71 to i8*
  %73 = getelementptr inbounds %struct.PTW_attackstate, %struct.PTW_attackstate* %0, i32 0, i32 6
  %74 = load i32, i32* %73, align 8
  %75 = sext i32 %74 to i64
  %76 = mul i64 %75, 40
  %77 = call i8* @realloc(i8* %72, i64 %76) #9, !track !282
  %78 = bitcast i8* %77 to %struct.PTW_session*
  %79 = getelementptr inbounds %struct.PTW_attackstate, %struct.PTW_attackstate* %0, i32 0, i32 5
  store %struct.PTW_session* %78, %struct.PTW_session** %79, align 8
  %80 = getelementptr inbounds %struct.PTW_attackstate, %struct.PTW_attackstate* %0, i32 0, i32 5
  %81 = load %struct.PTW_session*, %struct.PTW_session** %80, align 8
  %82 = icmp eq %struct.PTW_session* %81, null
  br i1 %82, label %83, label %86

; <label>:83:                                     ; preds = %65
  %84 = getelementptr [27 x i8], [27 x i8]* @.str.222, i32 0, i32 0
  %85 = call i32 (i8*, ...) @printf(i8* %84)
  call void @exit(i32 -1) #11
  unreachable

; <label>:86:                                     ; preds = %65, %59
  %87 = getelementptr inbounds %struct.PTW_attackstate, %struct.PTW_attackstate* %0, i32 0, i32 5
  %88 = load %struct.PTW_session*, %struct.PTW_session** %87, align 8
  %89 = getelementptr inbounds %struct.PTW_attackstate, %struct.PTW_attackstate* %0, i32 0, i32 0
  %90 = load i32, i32* %89, align 8
  %91 = sub nsw i32 %90, 1
  %92 = sext i32 %91 to i64
  %93 = getelementptr inbounds %struct.PTW_session, %struct.PTW_session* %88, i64 %92
  %94 = getelementptr inbounds %struct.PTW_session, %struct.PTW_session* %93, i32 0, i32 0
  %95 = getelementptr inbounds [3 x i8], [3 x i8]* %94, i32 0, i32 0
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %95, i8* align 1 %1, i64 3, i1 false), !track !283
  %96 = getelementptr inbounds %struct.PTW_attackstate, %struct.PTW_attackstate* %0, i32 0, i32 5
  %97 = load %struct.PTW_session*, %struct.PTW_session** %96, align 8
  %98 = getelementptr inbounds %struct.PTW_attackstate, %struct.PTW_attackstate* %0, i32 0, i32 0
  %99 = load i32, i32* %98, align 8
  %100 = sub nsw i32 %99, 1
  %101 = sext i32 %100 to i64
  %102 = getelementptr inbounds %struct.PTW_session, %struct.PTW_session* %97, i64 %101
  %103 = getelementptr inbounds %struct.PTW_session, %struct.PTW_session* %102, i32 0, i32 1
  %104 = getelementptr inbounds [32 x i8], [32 x i8]* %103, i32 0, i32 0
  %105 = mul nuw nsw i64 32, %indvars.iv5
  %106 = getelementptr inbounds i8, i8* %2, i64 %105
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %104, i8* align 1 %106, i64 32, i1 false), !track !284
  %107 = getelementptr inbounds i32, i32* %3, i64 %indvars.iv5
  %108 = load i32, i32* %107, align 4
  %109 = getelementptr inbounds %struct.PTW_attackstate, %struct.PTW_attackstate* %0, i32 0, i32 5
  %110 = load %struct.PTW_session*, %struct.PTW_session** %109, align 8
  %111 = getelementptr inbounds %struct.PTW_attackstate, %struct.PTW_attackstate* %0, i32 0, i32 0
  %112 = load i32, i32* %111, align 8
  %113 = sub nsw i32 %112, 1
  %114 = sext i32 %113 to i64
  %115 = getelementptr inbounds %struct.PTW_session, %struct.PTW_session* %110, i64 %114
  %116 = getelementptr inbounds %struct.PTW_session, %struct.PTW_session* %115, i32 0, i32 2
  store i32 %108, i32* %116, align 4
  %indvars.iv.next6 = add nuw nsw i64 %indvars.iv5, 1
  %117 = icmp slt i64 %indvars.iv.next6, %39
  br i1 %117, label %40, label %._crit_edge.loopexit

._crit_edge.loopexit:                             ; preds = %86
  br label %._crit_edge

._crit_edge:                                      ; preds = %._crit_edge.loopexit, %30
  %118 = getelementptr inbounds %struct.PTW_attackstate, %struct.PTW_attackstate* %0, i32 0, i32 2
  %119 = load i32, i32* %118, align 4
  %120 = icmp slt i32 %119, 10000
  br i1 %120, label %121, label %139

; <label>:121:                                    ; preds = %._crit_edge
  %122 = getelementptr inbounds %struct.PTW_attackstate, %struct.PTW_attackstate* %0, i32 0, i32 3
  %123 = getelementptr inbounds %struct.PTW_attackstate, %struct.PTW_attackstate* %0, i32 0, i32 2
  %124 = load i32, i32* %123, align 4
  %125 = sext i32 %124 to i64
  %126 = getelementptr inbounds [10000 x %struct.PTW_session], [10000 x %struct.PTW_session]* %122, i64 0, i64 %125
  %127 = getelementptr inbounds %struct.PTW_session, %struct.PTW_session* %126, i32 0, i32 0
  %128 = getelementptr inbounds [3 x i8], [3 x i8]* %127, i32 0, i32 0
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %128, i8* align 1 %1, i64 3, i1 false), !track !285
  %129 = getelementptr inbounds %struct.PTW_attackstate, %struct.PTW_attackstate* %0, i32 0, i32 3
  %130 = getelementptr inbounds %struct.PTW_attackstate, %struct.PTW_attackstate* %0, i32 0, i32 2
  %131 = load i32, i32* %130, align 4
  %132 = sext i32 %131 to i64
  %133 = getelementptr inbounds [10000 x %struct.PTW_session], [10000 x %struct.PTW_session]* %129, i64 0, i64 %132
  %134 = getelementptr inbounds %struct.PTW_session, %struct.PTW_session* %133, i32 0, i32 1
  %135 = getelementptr inbounds [32 x i8], [32 x i8]* %134, i32 0, i32 0
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %135, i8* align 1 %2, i64 32, i1 false), !track !286
  %136 = getelementptr inbounds %struct.PTW_attackstate, %struct.PTW_attackstate* %0, i32 0, i32 2
  %137 = load i32, i32* %136, align 4
  %138 = add nsw i32 %137, 1
  store i32 %138, i32* %136, align 4
  br label %139

; <label>:139:                                    ; preds = %5, %._crit_edge, %121
  %.0 = phi i32 [ 1, %121 ], [ 1, %._crit_edge ], [ 0, %5 ]
  ret i32 %.0
}

; Function Attrs: noinline nounwind uwtable
define dso_local %struct.PTW_attackstate* @PTW_newattackstate() #8 {
  %1 = call noalias i8* @malloc(i64 2556568) #9, !track !287
  %2 = bitcast i8* %1 to %struct.PTW_attackstate*
  %3 = icmp eq %struct.PTW_attackstate* %2, null
  br i1 %3, label %26, label %4

; <label>:4:                                      ; preds = %0
  %5 = bitcast %struct.PTW_attackstate* %2 to i8*
  call void @llvm.memset.p0i8.i64(i8* align 8 %5, i8 0, i64 2556568, i1 false)
  br label %6

; <label>:6:                                      ; preds = %4, %14
  %indvars.iv5 = phi i64 [ 0, %4 ], [ %indvars.iv.next6, %14 ]
  br label %7

; <label>:7:                                      ; preds = %6, %7
  %indvars.iv = phi i64 [ 0, %6 ], [ %indvars.iv.next, %7 ]
  %.023 = phi i32 [ 0, %6 ], [ %13, %7 ]
  call void @unroll_loop(i32 188)
  %8 = trunc i32 %.023 to i8
  %9 = getelementptr inbounds %struct.PTW_attackstate, %struct.PTW_attackstate* %2, i32 0, i32 4
  %10 = getelementptr inbounds [29 x [256 x %struct.PTW_tableentry]], [29 x [256 x %struct.PTW_tableentry]]* %9, i64 0, i64 %indvars.iv5
  %11 = getelementptr inbounds [256 x %struct.PTW_tableentry], [256 x %struct.PTW_tableentry]* %10, i64 0, i64 %indvars.iv
  %12 = getelementptr inbounds %struct.PTW_tableentry, %struct.PTW_tableentry* %11, i32 0, i32 1
  store i8 %8, i8* %12, align 4
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %13 = add nuw nsw i32 %.023, 1
  %exitcond = icmp ne i64 %indvars.iv.next, 256
  br i1 %exitcond, label %7, label %14

; <label>:14:                                     ; preds = %7
  %indvars.iv.next6 = add nuw nsw i64 %indvars.iv5, 1
  %exitcond7 = icmp ne i64 %indvars.iv.next6, 29
  br i1 %exitcond7, label %6, label %15

; <label>:15:                                     ; preds = %14
  %16 = call noalias i8* @malloc(i64 163840) #9, !track !288
  %17 = bitcast i8* %16 to %struct.PTW_session*
  %18 = getelementptr inbounds %struct.PTW_attackstate, %struct.PTW_attackstate* %2, i32 0, i32 5
  store %struct.PTW_session* %17, %struct.PTW_session** %18, align 8
  %19 = getelementptr inbounds %struct.PTW_attackstate, %struct.PTW_attackstate* %2, i32 0, i32 6
  store i32 4096, i32* %19, align 8
  %20 = getelementptr inbounds %struct.PTW_attackstate, %struct.PTW_attackstate* %2, i32 0, i32 5
  %21 = load %struct.PTW_session*, %struct.PTW_session** %20, align 8
  %22 = icmp eq %struct.PTW_session* %21, null
  br i1 %22, label %23, label %26

; <label>:23:                                     ; preds = %15
  %24 = getelementptr [27 x i8], [27 x i8]* @.str.222, i32 0, i32 0
  %25 = call i32 (i8*, ...) @printf(i8* %24)
  call void @exit(i32 -1) #11
  unreachable

; <label>:26:                                     ; preds = %15, %0
  %.0 = phi %struct.PTW_attackstate* [ null, %0 ], [ %2, %15 ]
  ret %struct.PTW_attackstate* %.0
}

; Function Attrs: noinline nounwind uwtable
define dso_local void @PTW_freeattackstate(%struct.PTW_attackstate*) #0 {
  %2 = getelementptr inbounds %struct.PTW_attackstate, %struct.PTW_attackstate* %0, i32 0, i32 5
  %3 = load %struct.PTW_session*, %struct.PTW_session** %2, align 8
  %4 = bitcast %struct.PTW_session* %3 to i8*
  call void @free(i8* %4) #9
  %5 = bitcast %struct.PTW_attackstate* %0 to i8*
  call void @free(i8* %5) #9
  ret void
}

declare void @unroll_loop(i32)

attributes #0 = { noinline nounwind uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #2 = { nounwind "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #3 = { nounwind readonly "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #4 = { argmemonly nounwind }
attributes #5 = { noreturn nounwind "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #6 = { noreturn "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #7 = { nounwind readnone "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #8 = { noinline nounwind uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "track_func"="true" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #9 = { nounwind }
attributes #10 = { nounwind readonly }
attributes #11 = { noreturn nounwind }
attributes #12 = { noreturn }
attributes #13 = { nounwind readnone }

!llvm.ident = !{!13, !13, !13, !13, !13}
!llvm.module.flags = !{!14}

!0 = !{i64 54}
!1 = !{i64 129}
!2 = !{i64 1}
!3 = !{i64 41}
!4 = !{i64 2}
!5 = !{i64 11}
!6 = !{i64 40}
!7 = !{i64 46}
!8 = !{i64 128}
!9 = !{i64 12}
!10 = !{i64 127}
!11 = !{i64 35}
!12 = !{i64 0}
!13 = !{!"clang version 7.0.0 (tags/RELEASE_700/final)"}
!14 = !{i32 1, !"wchar_size", i32 4}
!15 = !{i64 125}
!16 = !{i64 124}
!17 = !{i64 123}
!18 = !{i64 122}
!19 = !{i64 121}
!20 = !{i64 4}
!21 = !{i64 33}
!22 = !{i64 120}
!23 = !{i64 31}
!24 = !{i64 119}
!25 = !{i64 8}
!26 = !{i64 118}
!27 = !{i64 117}
!28 = !{i64 116}
!29 = !{i64 130}
!30 = !{i64 114}
!31 = !{i64 113}
!32 = !{i64 112}
!33 = !{i64 111}
!34 = !{i64 110}
!35 = !{i64 109}
!36 = !{i64 108}
!37 = !{i64 107}
!38 = !{i64 106}
!39 = !{i64 105}
!40 = !{i64 104}
!41 = !{i64 149}
!42 = !{i64 148}
!43 = !{i64 145}
!44 = !{i64 159}
!45 = !{i64 103}
!46 = !{i64 102}
!47 = !{i64 144}
!48 = !{i64 158}
!49 = !{i64 139}
!50 = !{i64 138}
!51 = !{i64 67}
!52 = !{i64 137}
!53 = !{i64 136}
!54 = !{i64 63}
!55 = !{i64 135}
!56 = !{i64 134}
!57 = !{i64 48}
!58 = !{i64 133}
!59 = !{i64 132}
!60 = !{i64 131}
!61 = !{i64 74}
!62 = !{i64 72}
!63 = !{i64 71}
!64 = !{i64 70}
!65 = !{i64 73}
!66 = !{i64 32}
!67 = !{i64 28}
!68 = !{i64 61}
!69 = !{i64 69}
!70 = !{i64 53}
!71 = !{i64 19}
!72 = !{i64 44}
!73 = !{i64 9}
!74 = !{i64 15}
!75 = !{i64 59}
!76 = !{i64 3}
!77 = !{i64 157}
!78 = !{i64 156}
!79 = !{i64 155}
!80 = !{i64 154}
!81 = !{i64 153}
!82 = !{i64 152}
!83 = !{i64 151}
!84 = !{i64 150}
!85 = !{i64 43}
!86 = !{i64 97}
!87 = !{i64 96}
!88 = !{i64 87}
!89 = !{i64 95}
!90 = !{i64 94}
!91 = !{i64 93}
!92 = !{i64 92}
!93 = !{i64 91}
!94 = !{i64 90}
!95 = !{i64 89}
!96 = !{i64 88}
!97 = !{i64 101}
!98 = !{i64 86}
!99 = !{i64 147}
!100 = !{i64 146}
!101 = !{i64 85}
!102 = !{i64 84}
!103 = !{i64 83}
!104 = !{i64 82}
!105 = !{i64 81}
!106 = !{i64 80}
!107 = !{i64 79}
!108 = !{i64 78}
!109 = !{i64 77}
!110 = !{i64 76}
!111 = !{i64 75}
!112 = !{i64 143}
!113 = !{i64 252}
!114 = !{i64 251}
!115 = !{i64 250}
!116 = !{i64 7}
!117 = !{i64 100}
!118 = !{i64 68}
!119 = !{i64 99}
!120 = !{i64 21}
!121 = !{i64 45}
!122 = !{i64 10}
!123 = !{i64 14}
!124 = !{i64 98}
!125 = !{i64 5}
!126 = !{i64 249}
!127 = !{i64 248}
!128 = !{i64 247}
!129 = !{i64 246}
!130 = !{i64 245}
!131 = !{i64 244}
!132 = !{i64 243}
!133 = !{i64 242}
!134 = !{i64 241}
!135 = !{i64 240}
!136 = !{i64 239}
!137 = !{i64 238}
!138 = !{i64 174}
!139 = !{i64 253}
!140 = !{i64 236}
!141 = !{i64 235}
!142 = !{i64 234}
!143 = !{i64 233}
!144 = !{i64 232}
!145 = !{i64 231}
!146 = !{i64 230}
!147 = !{i64 229}
!148 = !{i64 228}
!149 = !{i64 227}
!150 = !{i64 226}
!151 = !{i64 225}
!152 = !{i64 224}
!153 = !{i64 223}
!154 = !{i64 269}
!155 = !{i64 284}
!156 = !{i64 283}
!157 = !{i64 282}
!158 = !{i64 281}
!159 = !{i64 280}
!160 = !{i64 22}
!161 = !{i64 6}
!162 = !{i64 29}
!163 = !{i64 52}
!164 = !{i64 279}
!165 = !{i64 278}
!166 = !{i64 277}
!167 = !{i64 276}
!168 = !{i64 275}
!169 = !{i64 66}
!170 = !{i64 17}
!171 = !{i64 115}
!172 = !{i64 142}
!173 = !{i64 141}
!174 = !{i64 126}
!175 = !{i64 140}
!176 = !{i64 274}
!177 = !{i64 273}
!178 = !{i64 272}
!179 = !{i64 271}
!180 = !{i64 270}
!181 = !{i64 285}
!182 = !{i64 268}
!183 = !{i64 267}
!184 = !{i64 266}
!185 = !{i64 39}
!186 = !{i64 265}
!187 = !{i64 62}
!188 = !{i64 55}
!189 = !{i64 264}
!190 = !{i64 263}
!191 = !{i64 262}
!192 = !{i64 261}
!193 = !{i64 260}
!194 = !{i64 259}
!195 = !{i64 258}
!196 = !{i64 257}
!197 = !{i64 256}
!198 = !{i64 255}
!199 = !{i64 254}
!200 = !{i64 237}
!201 = !{i64 189}
!202 = !{i64 188}
!203 = !{i64 37}
!204 = !{i64 187}
!205 = !{i64 20}
!206 = !{i64 58}
!207 = !{i64 18}
!208 = !{i64 186}
!209 = !{i64 185}
!210 = !{i64 184}
!211 = !{i64 183}
!212 = !{i64 182}
!213 = !{i64 181}
!214 = !{i64 16}
!215 = !{i64 180}
!216 = !{i64 27}
!217 = !{i64 24}
!218 = !{i64 38}
!219 = !{!"1"}
!220 = !{i64 179}
!221 = !{i64 178}
!222 = !{i64 177}
!223 = !{i64 176}
!224 = !{i64 175}
!225 = !{i64 190}
!226 = !{i64 173}
!227 = !{i64 36}
!228 = !{i64 172}
!229 = !{i64 171}
!230 = !{i64 170}
!231 = !{i64 169}
!232 = !{i64 168}
!233 = !{i64 167}
!234 = !{i64 166}
!235 = !{i64 165}
!236 = !{i64 164}
!237 = !{i64 163}
!238 = !{i64 162}
!239 = !{i64 161}
!240 = !{i64 160}
!241 = !{i64 206}
!242 = !{i64 221}
!243 = !{i64 220}
!244 = !{i64 219}
!245 = !{i64 218}
!246 = !{i64 217}
!247 = !{i64 216}
!248 = !{i64 215}
!249 = !{i64 214}
!250 = !{i64 213}
!251 = !{i64 212}
!252 = !{i64 211}
!253 = !{i64 210}
!254 = !{i64 209}
!255 = !{i64 208}
!256 = !{i64 65}
!257 = !{i64 64}
!258 = !{i64 207}
!259 = !{i64 222}
!260 = !{i64 205}
!261 = !{i64 42}
!262 = !{i64 51}
!263 = !{i64 50}
!264 = !{i64 26}
!265 = !{i64 60}
!266 = !{i64 49}
!267 = !{i64 23}
!268 = !{i64 204}
!269 = !{i64 203}
!270 = !{i64 202}
!271 = !{i64 25}
!272 = !{i64 30}
!273 = !{i64 201}
!274 = !{i64 47}
!275 = !{i64 13}
!276 = !{i64 200}
!277 = !{i64 199}
!278 = !{i64 34}
!279 = !{i64 198}
!280 = !{i64 197}
!281 = !{i64 57}
!282 = !{i64 196}
!283 = !{i64 195}
!284 = !{i64 194}
!285 = !{i64 193}
!286 = !{i64 192}
!287 = !{i64 56}
!288 = !{i64 191}
