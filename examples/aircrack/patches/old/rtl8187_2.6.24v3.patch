diff -Naur rtl8187_linux_26.1010.0622.2006/beta-8187/ieee80211_crypt.h rtl8187_linux_26.1010.0622.2006_rawtx/beta-8187/ieee80211_crypt.h
--- rtl8187_linux_26.1010.0622.2006/beta-8187/ieee80211_crypt.h	2006-06-06 04:58:02.000000000 +0200
+++ rtl8187_linux_26.1010.0622.2006_rawtx/beta-8187/ieee80211_crypt.h	2008-01-30 17:38:10.000000000 +0100
@@ -75,12 +75,12 @@
 	atomic_t refcnt;
 };
 
-int ieee80211_register_crypto_ops(struct ieee80211_crypto_ops *ops);
-int ieee80211_unregister_crypto_ops(struct ieee80211_crypto_ops *ops);
-struct ieee80211_crypto_ops * ieee80211_get_crypto_ops(const char *name);
-void ieee80211_crypt_deinit_entries(struct ieee80211_device *, int);
-void ieee80211_crypt_deinit_handler(unsigned long);
-void ieee80211_crypt_delayed_deinit(struct ieee80211_device *ieee,
+int ieee80211_register_crypto_ops_rtl7(struct ieee80211_crypto_ops *ops);
+int ieee80211_unregister_crypto_ops_rtl7(struct ieee80211_crypto_ops *ops);
+struct ieee80211_crypto_ops * ieee80211_get_crypto_ops_rtl7(const char *name);
+void ieee80211_crypt_deinit_entries_rtl7(struct ieee80211_device *, int);
+void ieee80211_crypt_deinit_handler_rtl7(unsigned long);
+void ieee80211_crypt_delayed_deinit_rtl7(struct ieee80211_device *ieee,
 				    struct ieee80211_crypt_data **crypt);
 
 #endif
diff -Naur rtl8187_linux_26.1010.0622.2006/beta-8187/ieee80211.h rtl8187_linux_26.1010.0622.2006_rawtx/beta-8187/ieee80211.h
--- rtl8187_linux_26.1010.0622.2006/beta-8187/ieee80211.h	2006-06-06 04:58:02.000000000 +0200
+++ rtl8187_linux_26.1010.0622.2006_rawtx/beta-8187/ieee80211.h	2008-01-30 17:38:10.000000000 +0100
@@ -120,7 +120,7 @@
 static inline unsigned long msleep_interruptible_rtl(unsigned int msecs)
 {
          unsigned long timeout = MSECS(msecs) + 1;
- 
+
          while (timeout) {
                  set_current_state(TASK_UNINTERRUPTIBLE);
                  timeout = schedule_timeout(timeout);
@@ -156,6 +156,22 @@
 	struct list_head list;
 };
 
+#define LWNG_CAP_DID_BASE   (4 | (1 << 6)) /* section 4, group 1 */
+/* ARPHRD_IEEE80211_PRISM uses a bloated version of Prism2 RX frame header
+ * (from linux-wlan-ng) */
+struct linux_wlan_ng_val {
+	u32 did;
+	u16 status, len;
+	u32 data;
+} __attribute__ ((packed));
+
+struct linux_wlan_ng_prism_hdr {
+	u32 msgcode, msglen;
+	char devname[16];
+	struct linux_wlan_ng_val hosttime, mactime, channel, rssi, sq, signal,
+		noise, rate, istx, frmlen;
+} __attribute__ ((packed));
+
 struct ieee80211_hdr {
 	u16 frame_ctl;
 	u16 duration_id;
@@ -798,7 +814,7 @@
 
 	/* the card is not linked at all */
 	IEEE80211_NOLINK = 0,
-	
+
 	/* IEEE80211_ASSOCIATING* are for BSS client mode
 	 * the driver shall not perform RX filtering unless
 	 * the state is LINKED.
@@ -806,31 +822,31 @@
 	 * defaults to NOLINK for ALL the other states (including
 	 * LINKED_SCANNING)
 	 */
-	
+
 	/* the association procedure will start (wq scheduling)*/
 	IEEE80211_ASSOCIATING,
 	IEEE80211_ASSOCIATING_RETRY,
-	
+
 	/* the association procedure is sending AUTH request*/
 	IEEE80211_ASSOCIATING_AUTHENTICATING,
-	
+
 	/* the association procedure has successfully authentcated
 	 * and is sending association request
 	 */
 	IEEE80211_ASSOCIATING_AUTHENTICATED,
-	
+
 	/* the link is ok. the card associated to a BSS or linked
 	 * to a ibss cell or acting as an AP and creating the bss
 	 */
 	IEEE80211_LINKED,
-	
+
 	/* same as LINKED, but the driver shall apply RX filter
 	 * rules as we are in NO_LINK mode. As the card is still
 	 * logically linked, but it is doing a syncro site survey
 	 * then it will be back to LINKED state.
 	 */
 	IEEE80211_LINKED_SCANNING,
-	
+
 };
 
 #define DEFAULT_MAX_SCAN_AGE (15 * HZ)
@@ -840,14 +856,14 @@
 
 
 #if (LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,11))
-extern inline int is_multicast_ether_addr(const u8 *addr)
+extern inline int is_multicast_ether_addr_rtl7(const u8 *addr)
 {
         return ((addr[0] != 0xff) && (0x01 & addr[0]));
 }
 #endif
 
 #if (LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,13))
-extern inline int is_broadcast_ether_addr(const u8 *addr)
+extern inline int is_broadcast_ether_addr_rtl7(const u8 *addr)
 {
 	return ((addr[0] == 0xff) && (addr[1] == 0xff) && (addr[2] == 0xff) &&   \
 		(addr[3] == 0xff) && (addr[4] == 0xff) && (addr[5] == 0xff));
@@ -870,7 +886,7 @@
 	struct net_device_stats stats;
 	struct ieee80211_stats ieee_stats;
 	struct ieee80211_softmac_stats softmac_stats;
-	
+
 	/* Probe / Beacon management */
 	struct list_head network_free_list;
 	struct list_head network_list;
@@ -881,7 +897,7 @@
 	int iw_mode; /* operating mode (IW_MODE_*) */
 
 	spinlock_t lock;
-	
+
 	int tx_headroom; /* Set to size of any additional room needed at front
 			  * of allocated Tx SKBs */
 	u32 config;
@@ -924,11 +940,11 @@
 	 * ad-hoc is a mixture ;-).
 	 * Note that in infrastructure mode, even when not associated,
 	 * fields bssid and essid may be valid (if wpa_set and essid_set
-	 * are true) as thy carry the value set by the user via iwconfig  
+	 * are true) as thy carry the value set by the user via iwconfig
 	 */
 	struct ieee80211_network current_network;
 
-	
+
 	enum ieee80211_state state;
 
 	int short_slot;
@@ -936,33 +952,33 @@
 	int modulation; /* CCK, OFDM */
 	int freq_band;  /* 2.4Ghz, 5.2Ghz, Mixed */
 	int abg_true;   /* ABG flag              */
-	
-	/* used for forcing the ibss workqueue to terminate 
+
+	/* used for forcing the ibss workqueue to terminate
 	 * without wait for the syncro scan to terminate
 	 */
-	short sync_scan_hurryup; 
-	
+	short sync_scan_hurryup;
+
 	/* map of allowed channels. 0 is dummy */
 	// FIXME: remeber to default to a basic channel plan depending of the PHY type
 	int channel_map[MAX_CHANNEL_NUMBER+1];
-	
+
 	int rate;       /* current rate */
 	int basic_rate;
 	//FIXME: pleace callback, see if redundant with softmac_features
 	short active_scan;
-	
+
 	/* this contains flags for selectively enable softmac support */
 	u16 softmac_features;
-	
+
 	/* if the sequence control field is not filled by HW */
 	u16 seq_ctrl;
-	
+
 	/* association procedure transaction sequence number */
 	u16 associate_seq;
-	
+
 	/* AID for RTXed association responses */
 	u16 assoc_id;
-	
+
 	/* power save mode related*/
 	short ps;
 	short sta_sleep;
@@ -970,147 +986,153 @@
 	struct tasklet_struct ps_task;
 	u32 ps_th;
 	u32 ps_tl;
-	
+
 	short raw_tx;
 	/* used if IEEE_SOFTMAC_TX_QUEUE is set */
 	short queue_stop;
 	short scanning;
 	short proto_started;
-	
+
 	struct semaphore wx_sem;
 	struct semaphore scan_sem;
-	
-	spinlock_t mgmt_tx_lock;	
+
+	spinlock_t mgmt_tx_lock;
 	spinlock_t beacon_lock;
 
 	short beacon_txing;
 
 	short wap_set;
 	short ssid_set;
-	
+
 	/* for discarding duplicated packets in IBSS */
 	struct list_head ibss_mac_hash[IEEE_IBSS_MAC_HASH_SIZE];
-	
+
 	/* for discarding duplicated packets in BSS */
 	u16 last_seq_num;
 	u16 last_frag_num;
 	unsigned long last_packet_time;
-	
+
 	/* for PS mode */
 	unsigned long last_rx_ps_time;
-	
+
 	/* used if IEEE_SOFTMAC_SINGLE_QUEUE is set */
 	struct sk_buff *mgmt_queue_ring[MGMT_QUEUE_NUM];
 	int mgmt_queue_head;
 	int mgmt_queue_tail;
-	
-	
+
+
 	/* used if IEEE_SOFTMAC_TX_QUEUE is set */
 	struct  tx_pending_t tx_pending;
-	
+
 	/* used if IEEE_SOFTMAC_ASSOCIATE is set */
 	struct timer_list associate_timer;
 
 	/* used if IEEE_SOFTMAC_BEACONS is set */
 	struct timer_list beacon_timer;
-	
+
 	struct work_struct associate_complete_wq;
+
+# if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20))
+	struct delayed_work associate_retry_wq;
+	struct delayed_work softmac_scan_wq;
+#else
 	struct work_struct associate_retry_wq;
+	struct work_struct softmac_scan_wq;
+#endif
 	struct work_struct start_ibss_wq;
 	struct work_struct associate_procedure_wq;
-	struct work_struct softmac_scan_wq;
 	struct work_struct wx_sync_scan_wq;
-	
+
 	struct workqueue_struct *wq;
 	/* Callback functions */
 	void (*set_security)(struct net_device *dev,
 			     struct ieee80211_security *sec);
-	
+
 	/* Used to TX data frame by using txb structs.
 	 * this is not used if in the softmac_features
 	 * is set the flag IEEE_SOFTMAC_TX_QUEUE
 	 */
 	int (*hard_start_xmit)(struct ieee80211_txb *txb,
 			       struct net_device *dev);
-	
+
 	int (*reset_port)(struct net_device *dev);
 
-	/* Softmac-generated frames (mamagement) are TXed via this 
-	 * callback if the flag IEEE_SOFTMAC_SINGLE_QUEUE is 
-	 * not set. As some cards may have different HW queues that 
+	/* Softmac-generated frames (mamagement) are TXed via this
+	 * callback if the flag IEEE_SOFTMAC_SINGLE_QUEUE is
+	 * not set. As some cards may have different HW queues that
 	 * one might want to use for data and management frames
 	 * the option to have two callbacks might be useful.
 	 * This fucntion can't sleep.
 	 */
 	int (*softmac_hard_start_xmit)(struct sk_buff *skb,
 			       struct net_device *dev);
-	
+
 	/* used instead of hard_start_xmit (not softmac_hard_start_xmit)
 	 * if the IEEE_SOFTMAC_TX_QUEUE feature is used to TX data
 	 * frames. I the option IEEE_SOFTMAC_SINGLE_QUEUE is also set
 	 * then also management frames are sent via this callback.
 	 * This function can't sleep.
-	 */    
+	 */
 	void (*softmac_data_hard_start_xmit)(struct sk_buff *skb,
 			       struct net_device *dev,int rate);
 
 	/* stops the HW queue for DATA frames. Useful to avoid
 	 * waste time to TX data frame when we are reassociating
 	 * This function can sleep.
-	 */	 
+	 */
 	void (*data_hard_stop)(struct net_device *dev);
-	
+
 	/* OK this is complementar to data_poll_hard_stop */
 	void (*data_hard_resume)(struct net_device *dev);
-	
+
 	/* ask to the driver to retune the radio .
 	 * This function can sleep. the driver should ensure
 	 * the radio has been swithced before return.
 	 */
 	void (*set_chan)(struct net_device *dev,short ch);
-	
+
 	/* These are not used if the ieee stack takes care of
-	 * scanning (IEEE_SOFTMAC_SCAN feature set). 
+	 * scanning (IEEE_SOFTMAC_SCAN feature set).
 	 * In this case only the set_chan is used.
 	 *
 	 * The syncro version is similar to the start_scan but
 	 * does not return until all channels has been scanned.
-	 * this is called in user context and should sleep, 
+	 * this is called in user context and should sleep,
 	 * it is called in a work_queue when swithcing to ad-hoc mode
-	 * or in behalf of iwlist scan when the card is associated 
-	 * and root user ask for a scan. 
+	 * or in behalf of iwlist scan when the card is associated
+	 * and root user ask for a scan.
 	 * the fucntion stop_scan should stop both the syncro and
 	 * background scanning and can sleep.
-	 * The fucntion start_scan should initiate the background 
+	 * The fucntion start_scan should initiate the background
 	 * scanning and can't sleep.
-	 */ 
+	 */
 	void (*scan_syncro)(struct net_device *dev);
 	void (*start_scan)(struct net_device *dev);
 	void (*stop_scan)(struct net_device *dev);
-	
+
 	/* indicate the driver that the link state is changed
 	 * for example it may indicate the card is associated now.
-	 * Driver might be interested in this to apply RX filter 
-	 * rules or simply light the LINK led 
+	 * Driver might be interested in this to apply RX filter
+	 * rules or simply light the LINK led
 	 */
 	void (*link_change)(struct net_device *dev);
-	
+
 	/* these two function indicates to the HW when to start
-	 * and stop to send beacons. This is used when the 
+	 * and stop to send beacons. This is used when the
 	 * IEEE_SOFTMAC_BEACONS is not set. For now the
 	 * stop_send_bacons is NOT guaranteed to be called only
 	 * after start_send_beacons.
 	 */
 	void (*start_send_beacons) (struct net_device *dev);
 	void (*stop_send_beacons) (struct net_device *dev);
-	
+
 	/* power save mode related */
 	void (*sta_wake_up) (struct net_device *dev);
 	void (*ps_request_tx_ack) (struct net_device *dev);
 	void (*enter_sleep_state) (struct net_device *dev, u32 th, u32 tl);
 	short (*ps_is_queue_empty) (struct net_device *dev);
-	
-	
+
+
 	/* This must be the last item so that it points to the data
 	 * allocated beyond this structure by alloc_ieee80211 */
 	u8 priv[0];
@@ -1148,18 +1170,18 @@
 #define IEEE_SOFTMAC_SINGLE_QUEUE (1<<8)
 
 /* Generate beacons.  The stack will enqueue beacons
- * to the card 
- */ 
+ * to the card
+ */
 #define IEEE_SOFTMAC_BEACONS (1<<6)
 
 
 
-extern inline void *ieee80211_priv(struct net_device *dev)
+extern inline void *ieee80211_priv_rtl7(struct net_device *dev)
 {
 	return ((struct ieee80211_device *)netdev_priv(dev))->priv;
 }
 
-extern inline int ieee80211_is_empty_essid(const char *essid, int essid_len)
+extern inline int ieee80211_is_empty_essid_rtl7(const char *essid, int essid_len)
 {
 	/* Single white space is for Linksys APs */
 	if (essid_len == 1 && essid[0] == ' ')
@@ -1175,7 +1197,7 @@
 	return 1;
 }
 
-extern inline int ieee80211_is_valid_mode(struct ieee80211_device *ieee, int mode)
+extern inline int ieee80211_is_valid_mode_rtl7(struct ieee80211_device *ieee, int mode)
 {
 	/*
 	 * It is possible for both access points and our device to support
@@ -1201,7 +1223,7 @@
 	return 0;
 }
 
-extern inline int ieee80211_get_hdrlen(u16 fc)
+extern inline int ieee80211_get_hdrlen_rtl7(u16 fc)
 {
 	int hdrlen = 24;
 
@@ -1229,140 +1251,144 @@
 
 
 /* ieee80211.c */
-extern void free_ieee80211(struct net_device *dev);
-extern struct net_device *alloc_ieee80211(int sizeof_priv);
+extern void free_ieee80211_rtl7(struct net_device *dev);
+extern struct net_device *alloc_ieee80211_rtl7(int sizeof_priv);
 
-extern int ieee80211_set_encryption(struct ieee80211_device *ieee);
+extern int ieee80211_set_encryption_rtl7(struct ieee80211_device *ieee);
 
 /* ieee80211_tx.c */
 
-extern int ieee80211_encrypt_fragment(
+extern int ieee80211_encrypt_fragment_rtl7(
 	struct ieee80211_device *ieee,
 	struct sk_buff *frag,
 	int hdr_len);
-	
-extern int ieee80211_xmit(struct sk_buff *skb,
+
+extern int ieee80211_xmit_rtl7(struct sk_buff *skb,
 			  struct net_device *dev);
-extern void ieee80211_txb_free(struct ieee80211_txb *);
+extern void ieee80211_txb_free_rtl7(struct ieee80211_txb *);
 
 
 /* ieee80211_rx.c */
-extern int ieee80211_rx(struct ieee80211_device *ieee, struct sk_buff *skb,
+extern int ieee80211_rx_rtl7(struct ieee80211_device *ieee, struct sk_buff *skb,
 			struct ieee80211_rx_stats *rx_stats);
-extern void ieee80211_rx_mgt(struct ieee80211_device *ieee,
+extern void ieee80211_rx_mgt_rtl7(struct ieee80211_device *ieee,
 			     struct ieee80211_hdr *header,
 			     struct ieee80211_rx_stats *stats);
 
 /* ieee80211_wx.c */
-extern int ieee80211_wx_get_scan(struct ieee80211_device *ieee,
+extern int ieee80211_wx_get_scan_rtl7(struct ieee80211_device *ieee,
 				 struct iw_request_info *info,
 				 union iwreq_data *wrqu, char *key);
-extern int ieee80211_wx_set_encode(struct ieee80211_device *ieee,
+extern int ieee80211_wx_set_encode_rtl7(struct ieee80211_device *ieee,
 				   struct iw_request_info *info,
 				   union iwreq_data *wrqu, char *key);
-extern int ieee80211_wx_get_encode(struct ieee80211_device *ieee,
+extern int ieee80211_wx_get_encode_rtl7(struct ieee80211_device *ieee,
 				   struct iw_request_info *info,
 				   union iwreq_data *wrqu, char *key);
 /* ieee80211_softmac.c */
-extern short ieee80211_is_54g(struct ieee80211_network net);
-extern short ieee80211_is_shortslot(struct ieee80211_network net);
-extern int ieee80211_rx_frame_softmac(struct ieee80211_device *ieee, struct sk_buff *skb,
+extern short ieee80211_is_54g_rtl7(struct ieee80211_network net);
+extern short ieee80211_is_shortslot_rtl7(struct ieee80211_network net);
+extern int ieee80211_rx_frame_softmac_rtl7(struct ieee80211_device *ieee, struct sk_buff *skb,
 			struct ieee80211_rx_stats *rx_stats, u16 type,
 			u16 stype);
-extern void ieee80211_softmac_new_net(struct ieee80211_device *ieee, struct ieee80211_network *net);
+extern void ieee80211_softmac_new_net_rtl7(struct ieee80211_device *ieee, struct ieee80211_network *net);
 
-extern void ieee80211_softmac_xmit(struct ieee80211_txb *txb, struct ieee80211_device *ieee);
-extern void ieee80211_softmac_check_all_nets(struct ieee80211_device *ieee);
-extern void ieee80211_start_bss(struct ieee80211_device *ieee);
-extern void ieee80211_start_master_bss(struct ieee80211_device *ieee);
-extern void ieee80211_start_ibss(struct ieee80211_device *ieee);
-extern void ieee80211_softmac_init(struct ieee80211_device *ieee);
-extern void ieee80211_softmac_free(struct ieee80211_device *ieee);
-extern void ieee80211_associate_abort(struct ieee80211_device *ieee);
-extern void ieee80211_disassociate(struct ieee80211_device *ieee);
-extern void ieee80211_stop_scan(struct ieee80211_device *ieee);
-extern void ieee80211_start_scan_syncro(struct ieee80211_device *ieee);
-extern void ieee80211_check_all_nets(struct ieee80211_device *ieee);
-extern void ieee80211_start_protocol(struct ieee80211_device *ieee);
-extern void ieee80211_stop_protocol(struct ieee80211_device *ieee);
-extern void ieee80211_softmac_start_protocol(struct ieee80211_device *ieee);
-extern void ieee80211_softmac_stop_protocol(struct ieee80211_device *ieee);
-extern void ieee80211_reset_queue(struct ieee80211_device *ieee);
-extern void ieee80211_wake_queue(struct ieee80211_device *ieee);
-extern void ieee80211_stop_queue(struct ieee80211_device *ieee);
-extern struct sk_buff *ieee80211_get_beacon(struct ieee80211_device *ieee);
-extern void ieee80211_start_send_beacons(struct ieee80211_device *ieee);
-extern void ieee80211_stop_send_beacons(struct ieee80211_device *ieee);
-extern int ieee80211_wpa_supplicant_ioctl(struct ieee80211_device *ieee, struct iw_point *p);
-extern void notify_wx_assoc_event(struct ieee80211_device *ieee);
-extern void ieee80211_ps_tx_ack(struct ieee80211_device *ieee, short success);
+extern void ieee80211_softmac_xmit_rtl7(struct ieee80211_txb *txb, struct ieee80211_device *ieee);
+extern void ieee80211_softmac_check_all_nets_rtl7(struct ieee80211_device *ieee);
+extern void ieee80211_start_bss_rtl7(struct ieee80211_device *ieee);
+extern void ieee80211_start_master_bss_rtl7(struct ieee80211_device *ieee);
+extern void ieee80211_start_ibss_rtl7(struct ieee80211_device *ieee);
+extern void ieee80211_softmac_init_rtl7(struct ieee80211_device *ieee);
+extern void ieee80211_softmac_free_rtl7(struct ieee80211_device *ieee);
+extern void ieee80211_associate_abort_rtl7(struct ieee80211_device *ieee);
+extern void ieee80211_disassociate_rtl7(struct ieee80211_device *ieee);
+extern void ieee80211_stop_scan_rtl7(struct ieee80211_device *ieee);
+extern void ieee80211_start_scan_syncro_rtl7(struct ieee80211_device *ieee);
+extern void ieee80211_check_all_nets_rtl7(struct ieee80211_device *ieee);
+extern void ieee80211_start_protocol_rtl7(struct ieee80211_device *ieee);
+extern void ieee80211_stop_protocol_rtl7(struct ieee80211_device *ieee);
+extern void ieee80211_softmac_start_protocol_rtl7(struct ieee80211_device *ieee);
+extern void ieee80211_softmac_stop_protocol_rtl7(struct ieee80211_device *ieee);
+extern void ieee80211_reset_queue_rtl7(struct ieee80211_device *ieee);
+extern void ieee80211_wake_queue_rtl7(struct ieee80211_device *ieee);
+extern void ieee80211_stop_queue_rtl7(struct ieee80211_device *ieee);
+extern struct sk_buff *ieee80211_get_beacon_rtl7(struct ieee80211_device *ieee);
+extern void ieee80211_start_send_beacons_rtl7(struct ieee80211_device *ieee);
+extern void ieee80211_stop_send_beacons_rtl7(struct ieee80211_device *ieee);
+extern int ieee80211_wpa_supplicant_ioctl_rtl7(struct ieee80211_device *ieee, struct iw_point *p);
+extern void notify_wx_assoc_event_rtl7(struct ieee80211_device *ieee);
+extern void ieee80211_ps_tx_ack_rtl7(struct ieee80211_device *ieee, short success);
 
 /* ieee80211_softmac_wx.c */
 
-extern int ieee80211_wx_get_wap(struct ieee80211_device *ieee, 
-			    struct iw_request_info *info, 
+extern int ieee80211_wx_get_wap_rtl7(struct ieee80211_device *ieee,
+			    struct iw_request_info *info,
 			    union iwreq_data *wrqu, char *ext);
-			    
-extern int ieee80211_wx_set_wap(struct ieee80211_device *ieee,
+
+extern int ieee80211_wx_set_wap_rtl7(struct ieee80211_device *ieee,
 			 struct iw_request_info *info,
 			 union iwreq_data *awrq,
 			 char *extra);
-			 
-extern int ieee80211_wx_get_essid(struct ieee80211_device *ieee, struct iw_request_info *a,union iwreq_data *wrqu,char *b);
 
-extern int ieee80211_wx_set_rate(struct ieee80211_device *ieee, 
+extern int ieee80211_wx_get_essid_rtl7(struct ieee80211_device *ieee, struct iw_request_info *a,union iwreq_data *wrqu,char *b);
+
+extern int ieee80211_wx_set_rate_rtl7(struct ieee80211_device *ieee,
 			     struct iw_request_info *info,
 			     union iwreq_data *wrqu, char *extra);
-			     
-extern int ieee80211_wx_get_rate(struct ieee80211_device *ieee, 
-			     struct iw_request_info *info, 
+
+extern int ieee80211_wx_get_rate_rtl7(struct ieee80211_device *ieee,
+			     struct iw_request_info *info,
 			     union iwreq_data *wrqu, char *extra);
-			     
-extern int ieee80211_wx_set_mode(struct ieee80211_device *ieee, struct iw_request_info *a,
+
+extern int ieee80211_wx_set_mode_rtl7(struct ieee80211_device *ieee, struct iw_request_info *a,
 			     union iwreq_data *wrqu, char *b);
-			     
-extern int ieee80211_wx_set_scan(struct ieee80211_device *ieee, struct iw_request_info *a,
+
+extern int ieee80211_wx_set_scan_rtl7(struct ieee80211_device *ieee, struct iw_request_info *a,
 			     union iwreq_data *wrqu, char *b);
-			     
-extern int ieee80211_wx_set_essid(struct ieee80211_device *ieee, 
+
+extern int ieee80211_wx_set_essid_rtl7(struct ieee80211_device *ieee,
 			      struct iw_request_info *a,
 			      union iwreq_data *wrqu, char *extra);
-			      
-extern int ieee80211_wx_get_mode(struct ieee80211_device *ieee, struct iw_request_info *a,
+
+extern int ieee80211_wx_get_mode_rtl7(struct ieee80211_device *ieee, struct iw_request_info *a,
 			     union iwreq_data *wrqu, char *b);
 
-extern int ieee80211_wx_set_freq(struct ieee80211_device *ieee, struct iw_request_info *a,
+extern int ieee80211_wx_set_freq_rtl7(struct ieee80211_device *ieee, struct iw_request_info *a,
 			     union iwreq_data *wrqu, char *b);
 
-extern int ieee80211_wx_get_freq(struct ieee80211_device *ieee, struct iw_request_info *a,
+extern int ieee80211_wx_get_freq_rtl7(struct ieee80211_device *ieee, struct iw_request_info *a,
 			     union iwreq_data *wrqu, char *b);
 
-extern void ieee80211_wx_sync_scan_wq(struct ieee80211_device *ieee);
+# if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20))
+extern void ieee80211_wx_sync_scan_wq_rtl7(struct work_struct *work);
+#else
+extern void ieee80211_wx_sync_scan_wq_rtl7(struct ieee80211_device *ieee);
+#endif
 
-extern int ieee80211_wx_set_rawtx(struct ieee80211_device *ieee, 
-			       struct iw_request_info *info, 
+extern int ieee80211_wx_set_rawtx_rtl7(struct ieee80211_device *ieee,
+			       struct iw_request_info *info,
 			       union iwreq_data *wrqu, char *extra);
-			       
-extern int ieee80211_wx_get_name(struct ieee80211_device *ieee, 
-			     struct iw_request_info *info, 
+
+extern int ieee80211_wx_get_name_rtl7(struct ieee80211_device *ieee,
+			     struct iw_request_info *info,
 			     union iwreq_data *wrqu, char *extra);
 
-extern int ieee80211_wx_set_power(struct ieee80211_device *ieee,
+extern int ieee80211_wx_set_power_rtl7(struct ieee80211_device *ieee,
 				 struct iw_request_info *info,
 				 union iwreq_data *wrqu, char *extra);
 
-extern int ieee80211_wx_get_power(struct ieee80211_device *ieee,
+extern int ieee80211_wx_get_power_rtl7(struct ieee80211_device *ieee,
 				 struct iw_request_info *info,
 				 union iwreq_data *wrqu, char *extra);
-				 			     
-extern const long ieee80211_wlan_frequencies[];
 
-extern inline void ieee80211_increment_scans(struct ieee80211_device *ieee)
+extern const long ieee80211_wlan_frequencies_rtl7[];
+
+extern inline void ieee80211_increment_scans_rtl7(struct ieee80211_device *ieee)
 {
 	ieee->scans++;
 }
 
-extern inline int ieee80211_get_scans(struct ieee80211_device *ieee)
+extern inline int ieee80211_get_scans_rtl7(struct ieee80211_device *ieee)
 {
 	return ieee->scans;
 }
@@ -1372,7 +1398,7 @@
 	const char *s = essid;
 	char *d = escaped;
 
-	if (ieee80211_is_empty_essid(essid, essid_len)) {
+	if (ieee80211_is_empty_essid_rtl7(essid, essid_len)) {
 		memcpy(escaped, "<hidden>", sizeof("<hidden>"));
 		return escaped;
 	}
@@ -1390,4 +1416,5 @@
 	*d = '\0';
 	return escaped;
 }
+
 #endif /* IEEE80211_H */
diff -Naur rtl8187_linux_26.1010.0622.2006/beta-8187/Makefile rtl8187_linux_26.1010.0622.2006_rawtx/beta-8187/Makefile
--- rtl8187_linux_26.1010.0622.2006/beta-8187/Makefile	2006-06-06 04:58:00.000000000 +0200
+++ rtl8187_linux_26.1010.0622.2006_rawtx/beta-8187/Makefile	2008-01-30 17:38:10.000000000 +0100
@@ -18,6 +18,8 @@
 KVER  := $(shell uname -r)
 KSRC := /lib/modules/$(KVER)/build
 INSTALL_PREFIX :=
+PWD = $(shell pwd)
+
 all: modules
 
 clean:
diff -Naur rtl8187_linux_26.1010.0622.2006/beta-8187/r8180_93cx6.c rtl8187_linux_26.1010.0622.2006_rawtx/beta-8187/r8180_93cx6.c
--- rtl8187_linux_26.1010.0622.2006/beta-8187/r8180_93cx6.c	2006-06-06 04:58:00.000000000 +0200
+++ rtl8187_linux_26.1010.0622.2006_rawtx/beta-8187/r8180_93cx6.c	2008-01-30 17:38:10.000000000 +0100
@@ -87,7 +87,7 @@
 
 u32 eprom_read(struct net_device *dev, u32 addr)
 {
-	struct r8180_priv *priv = ieee80211_priv(dev);
+	struct r8180_priv *priv = ieee80211_priv_rtl7(dev);
 	short read_cmd[]={1,1,0};
 	short addr_str[8];
 	int i;
diff -Naur rtl8187_linux_26.1010.0622.2006/beta-8187/r8180_hw.h rtl8187_linux_26.1010.0622.2006_rawtx/beta-8187/r8180_hw.h
--- rtl8187_linux_26.1010.0622.2006/beta-8187/r8180_hw.h	2006-06-06 04:58:00.000000000 +0200
+++ rtl8187_linux_26.1010.0622.2006_rawtx/beta-8187/r8180_hw.h	2008-01-30 17:38:11.000000000 +0100
@@ -646,6 +646,7 @@
 #define FFER_INTR    ((1<<15))
 #define FFER_GWAKE   ((1<< 4))
 
-
+#define MAX_TX_POWER	27
+#define MIN_TX_POWER	20
 
 #endif
diff -Naur rtl8187_linux_26.1010.0622.2006/beta-8187/r8180_rtl8225.c rtl8187_linux_26.1010.0622.2006_rawtx/beta-8187/r8180_rtl8225.c
--- rtl8187_linux_26.1010.0622.2006/beta-8187/r8180_rtl8225.c	2006-06-06 04:58:02.000000000 +0200
+++ rtl8187_linux_26.1010.0622.2006_rawtx/beta-8187/r8180_rtl8225.c	2008-01-30 17:38:11.000000000 +0100
@@ -173,7 +173,7 @@
 
 void rtl8225_set_gain(struct net_device *dev, short gain)
 {
-	struct r8180_priv *priv = ieee80211_priv(dev);
+	struct r8180_priv *priv = ieee80211_priv_rtl7(dev);
 	
 	rtl8180_set_anaparam(dev, RTL8225_ANAPARAM_ON);
 	
@@ -208,7 +208,7 @@
 {
 #ifdef USE_8051_3WIRE
 
-        struct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);
+        struct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv_rtl7(dev);
         struct usb_device *udev = priv->udev;
         //u8 bit;
         u16                             wReg80, wReg82, wReg84;
@@ -255,7 +255,7 @@
 	u16 out,select;
 	u8 bit;
 	u32 bangdata = (data << 4) | (adr & 0xf);
-	struct r8180_priv *priv = ieee80211_priv(dev);
+	struct r8180_priv *priv = ieee80211_priv_rtl7(dev);
 	
 	out = read_nic_word(dev, RFPinsOutput) & 0xfff3;
 		
@@ -349,7 +349,7 @@
 
 void rtl8225_SetTXPowerLevel(struct net_device *dev, short ch)
 {
-	struct r8180_priv *priv = ieee80211_priv(dev);
+	struct r8180_priv *priv = ieee80211_priv_rtl7(dev);
 	
 	int GainIdx;
 	int GainSetting;
@@ -454,9 +454,9 @@
 
 void rtl8225_rf_set_chan(struct net_device *dev, short ch)
 {
-	struct r8180_priv *priv = ieee80211_priv(dev);
+	struct r8180_priv *priv = ieee80211_priv_rtl7(dev);
 	short gset = (priv->ieee80211->state == IEEE80211_LINKED &&
-		ieee80211_is_54g(priv->ieee80211->current_network)) ||
+		ieee80211_is_54g_rtl7(priv->ieee80211->current_network)) ||
 		priv->ieee80211->iw_mode == IW_MODE_MONITOR;
 	
 	rtl8225_SetTXPowerLevel(dev, ch);
@@ -474,7 +474,7 @@
 		write_nic_byte(dev,DIFS,0x24); //DIFS: 36 
 	
 	if(priv->ieee80211->state == IEEE80211_LINKED &&
-		ieee80211_is_shortslot(priv->ieee80211->current_network))
+		ieee80211_is_shortslot_rtl7(priv->ieee80211->current_network))
 		write_nic_byte(dev,SLOT,0x9); //SLOT: 9
 		
 	else
@@ -546,7 +546,7 @@
 
 void rtl8225_rf_init(struct net_device *dev) 
 {
-	struct r8180_priv *priv = ieee80211_priv(dev);
+	struct r8180_priv *priv = ieee80211_priv_rtl7(dev);
 	int i;
 	short channel = 1;
 	u16 brsr;
diff -Naur rtl8187_linux_26.1010.0622.2006/beta-8187/r8180_rtl8225.h rtl8187_linux_26.1010.0622.2006_rawtx/beta-8187/r8180_rtl8225.h
--- rtl8187_linux_26.1010.0622.2006/beta-8187/r8180_rtl8225.h	2006-06-06 04:58:00.000000000 +0200
+++ rtl8187_linux_26.1010.0622.2006_rawtx/beta-8187/r8180_rtl8225.h	2008-01-30 17:38:11.000000000 +0100
@@ -44,3 +44,5 @@
 extern u32 rtl8225_chan[];
 
 #endif
+
+void rtl8225z2_SetTXPowerLevel(struct net_device *dev, short ch);
diff -Naur rtl8187_linux_26.1010.0622.2006/beta-8187/r8180_rtl8225z2.c rtl8187_linux_26.1010.0622.2006_rawtx/beta-8187/r8180_rtl8225z2.c
--- rtl8187_linux_26.1010.0622.2006/beta-8187/r8180_rtl8225z2.c	2006-06-06 04:58:02.000000000 +0200
+++ rtl8187_linux_26.1010.0622.2006_rawtx/beta-8187/r8180_rtl8225z2.c	2008-02-15 00:49:20.000000000 +0100
@@ -2,12 +2,12 @@
   This is part of the rtl8180-sa2400 driver
   released under the GPL (See file COPYING for details).
   Copyright (c) 2005 Andrea Merello <andreamrl@tiscali.it>
-  
-  This files contains programming code for the rtl8225 
+
+  This files contains programming code for the rtl8225
   radio frontend.
-  
+
   *Many* thanks to Realtek Corp. for their great support!
-  
+
 */
 
 
@@ -32,51 +32,68 @@
 };
 
 u8 rtl8225z2_gain_a[]={
-	0x13,0x27,0x5a,//,0x37,// -82dbm 
-	0x23,0x23,0x58,//,0x37,// -82dbm 
-	0x33,0x1f,0x56,//,0x37,// -82dbm 
-	0x43,0x1b,0x54,//,0x37,// -78dbm 
-	0x53,0x17,0x51,//,0x37,// -74dbm 
-	0x63,0x24,0x4f,//,0x37,// -70dbm 
-	0x73,0x0f,0x4c,//,0x37,// -66dbm 
+	0x13,0x27,0x5a,//,0x37,// -82dbm
+	0x23,0x23,0x58,//,0x37,// -82dbm
+	0x33,0x1f,0x56,//,0x37,// -82dbm
+	0x43,0x1b,0x54,//,0x37,// -78dbm
+	0x53,0x17,0x51,//,0x37,// -74dbm
+	0x63,0x24,0x4f,//,0x37,// -70dbm
+	0x73,0x0f,0x4c,//,0x37,// -66dbm
 };
 #if 0
 u32 rtl8225_chan[] = {
 	0,	//dummy channel 0
-	0x085c, //1	 
-	0x08dc, //2  
-	0x095c, //3  
-	0x09dc, //4  
-	0x0a5c, //5  
-	0x0adc, //6  
-	0x0b5c, //7  
-	0x0bdc, //8  
-	0x0c5c, //9 
-	0x0cdc, //10  
-	0x0d5c, //11  
-	0x0ddc, //12  
-	0x0e5c, //13 
+	0x085c, //1
+	0x08dc, //2
+	0x095c, //3
+	0x09dc, //4
+	0x0a5c, //5
+	0x0adc, //6
+	0x0b5c, //7
+	0x0bdc, //8
+	0x0c5c, //9
+	0x0cdc, //10
+	0x0d5c, //11
+	0x0ddc, //12
+	0x0e5c, //13
 	//0x0f5c, //14
-	0x0f72, // 14  
+	0x0f72, // 14
 };
 #endif
 
+#if 1
 //-
-u16 rtl8225z2_rxgain[]={	
+u16 rtl8225z2_rxgain[]={
 	0x0400, 0x0401, 0x0402, 0x0403, 0x0404, 0x0405, 0x0408, 0x0409,
-	0x040a, 0x040b, 0x0502, 0x0503, 0x0504, 0x0505, 0x0540, 0x0541,  
+	0x040a, 0x040b, 0x0502, 0x0503, 0x0504, 0x0505, 0x0540, 0x0541,
 	0x0542, 0x0543, 0x0544, 0x0545, 0x0580, 0x0581, 0x0582, 0x0583,
-	0x0584, 0x0585, 0x0588, 0x0589, 0x058a, 0x058b, 0x0643, 0x0644, 
+	0x0584, 0x0585, 0x0588, 0x0589, 0x058a, 0x058b, 0x0643, 0x0644,
 	0x0645, 0x0680, 0x0681, 0x0682, 0x0683, 0x0684, 0x0685, 0x0688,
 	0x0689, 0x068a, 0x068b, 0x068c, 0x0742, 0x0743, 0x0744, 0x0745,
 	0x0780, 0x0781, 0x0782, 0x0783, 0x0784, 0x0785, 0x0788, 0x0789,
 	0x078a, 0x078b, 0x078c, 0x078d, 0x0790, 0x0791, 0x0792, 0x0793,
-	0x0794, 0x0795, 0x0798, 0x0799, 0x079a, 0x079b, 0x079c, 0x079d,  
-	0x07a0, 0x07a1, 0x07a2, 0x07a3, 0x07a4, 0x07a5, 0x07a8, 0x07a9,  
-	0x03aa, 0x03ab, 0x03ac, 0x03ad, 0x03b0, 0x03b1, 0x03b2, 0x03b3,  
+	0x0794, 0x0795, 0x0798, 0x0799, 0x079a, 0x079b, 0x079c, 0x079d,
+	0x07a0, 0x07a1, 0x07a2, 0x07a3, 0x07a4, 0x07a5, 0x07a8, 0x07a9,
+	0x03aa, 0x03ab, 0x03ac, 0x03ad, 0x03b0, 0x03b1, 0x03b2, 0x03b3,
 	0x03b4, 0x03b5, 0x03b8, 0x03b9, 0x03ba, 0x03bb, 0x03bb
 
 };
+#else
+u16 rtl8225z2_rxgain[]={
+        0x0000, 0x0001, 0x0002, 0x0003, 0x0004, 0x0005, 0x0008, 0x0009,
+	0x000a,	0x000b, 0x0102, 0x0103, 0x0104, 0x0105, 0x0140, 0x0141,
+        0x0142,	0x0143, 0x0144, 0x0145, 0x0180, 0x0181, 0x0182, 0x0183,
+	0x0184,	0x0185, 0x0188, 0x0189, 0x018a, 0x018b, 0x0243, 0x0244,
+	0x0245,	0x0280, 0x0281, 0x0282, 0x0283, 0x0284, 0x0285, 0x0288,
+        0x0289, 0x028a, 0x028b, 0x028c, 0x0342, 0x0343, 0x0344, 0x0345,
+	0x0380, 0x0381, 0x0382, 0x0383, 0x0384, 0x0385, 0x0388, 0x0389,
+	0x038a, 0x038b, 0x038c, 0x038d, 0x0390, 0x0391, 0x0392, 0x0393,
+	0x0394, 0x0395, 0x0398, 0x0399, 0x039a, 0x039b, 0x039c, 0x039d,
+	0x03a0, 0x03a1, 0x03a2, 0x03a3, 0x03a4, 0x03a5, 0x03a8, 0x03a9,
+	0x03aa, 0x03ab, 0x03ac, 0x03ad, 0x03b0, 0x03b1, 0x03b2, 0x03b3,
+	0x03b4, 0x03b5, 0x03b8, 0x03b9, 0x03ba, 0x03bb, 0x03bb
+};
+#endif
 
 //2005.11.16,
 u8 ZEBRA2_CCK_OFDM_GAIN_SETTING[]={
@@ -129,23 +146,30 @@
 void rtl8225z2_set_gain(struct net_device *dev, short gain)
 {
 	u8* rtl8225_gain;
-	struct r8180_priv *priv = ieee80211_priv(dev);
-	
+	struct r8180_priv *priv = ieee80211_priv_rtl7(dev);
+
 	u8 mode = priv->ieee80211->mode;
-	
-	if(mode == IEEE_B || mode == IEEE_G)
+
+	if((mode&IEEE_B) == IEEE_B || (mode&IEEE_G) == IEEE_G) {
+		//printk(KERN_WARNING "mode ag!\n");
 		rtl8225_gain = rtl8225z2_gain_bg;
-	else
+	} else {
 		rtl8225_gain = rtl8225z2_gain_a;
-		
+		//printk(KERN_WARNING "mode a!\n");
+	}
+
 	//write_phy_ofdm(dev, 0x0d, rtl8225_gain[gain * 3]);
 	//write_phy_ofdm(dev, 0x19, rtl8225_gain[gain * 3 + 1]);
 	//write_phy_ofdm(dev, 0x1b, rtl8225_gain[gain * 3 + 2]);
         //2005.11.17, by ch-hsu
         write_phy_ofdm(dev, 0x0b, rtl8225_gain[gain * 3]);
+	mdelay(1);
         write_phy_ofdm(dev, 0x1b, rtl8225_gain[gain * 3 + 1]);
+	mdelay(1);
         write_phy_ofdm(dev, 0x1d, rtl8225_gain[gain * 3 + 2]);
-	write_phy_ofdm(dev, 0x21, 0x37);
+	mdelay(1);
+	write_phy_ofdm(dev, 0x21, 0x17);
+	mdelay(1);
 
 }
 
@@ -153,33 +177,33 @@
 
 void rtl8225_set_gain(struct net_device *dev, short gain)
 {
-	struct r8180_priv *priv = ieee80211_priv(dev);
-	
+	struct r8180_priv *priv = ieee80211_priv_rtl7(dev);
+
 	rtl8180_set_anaparam(dev, RTL8225_ANAPARAM_ON);
-	
+
 	if(priv->card_8185 == 2)
 		write_phy_ofdm(dev, 0x21, 0x27);
 	else
 		write_phy_ofdm(dev, 0x21, 0x37);
-		
+
 	write_phy_ofdm(dev, 0x25, 0x20);
 	write_phy_ofdm(dev, 0x11, 0x6);
-	
+
 	if(priv->card_8185 == 1 && priv->card_8185_Bversion)
 		write_phy_ofdm(dev, 0x27, 0x8);
 	else
 		write_phy_ofdm(dev, 0x27, 0x88);
-		
+
 	write_phy_ofdm(dev, 0x14, 0);
 	write_phy_ofdm(dev, 0x16, 0);
 	write_phy_ofdm(dev, 0x15, 0x40);
 	write_phy_ofdm(dev, 0x17, 0x40);
-	
+
 	write_phy_ofdm(dev, 0x0d, rtl8225_gain[gain * 4]);
 	write_phy_ofdm(dev, 0x23, rtl8225_gain[gain * 4 + 1]);
 	write_phy_ofdm(dev, 0x1b, rtl8225_gain[gain * 4 + 2]);
 	write_phy_ofdm(dev, 0x1d, rtl8225_gain[gain * 4 + 3]);
-	//rtl8225_set_gain_usb(dev, gain);	
+	//rtl8225_set_gain_usb(dev, gain);
 }
 #endif
 
@@ -193,7 +217,7 @@
 //	ThreeWireReg tdata;
 	int i;
 	short bit, rw;
-	
+
 	u8 wLength = 6;
 	u8 rLength = 12;
 	u8 low2high = 0;
@@ -207,20 +231,20 @@
 
 	dataRead = 0;
 
-	oval &= ~0xf; 
+	oval &= ~0xf;
 
 	write_nic_word(dev, RFPinsOutput, oval | BB_HOST_BANG_EN ); udelay(4);
 
 	write_nic_word(dev, RFPinsOutput, oval ); udelay(5);
-	
+
 	rw = 0;
-	
+
 	mask = (low2high) ? 0x01 : (((u32)0x01)<<(32-1));
 	for(i = 0; i < wLength/2; i++)
 	{
 		bit = ((data2Write&mask) != 0) ? 1 : 0;
 		write_nic_word(dev, RFPinsOutput, bit|oval | rw); udelay(1);
-		
+
 		write_nic_word(dev, RFPinsOutput, bit|oval | BB_HOST_BANG_CLK | rw); udelay(2);
 		write_nic_word(dev, RFPinsOutput, bit|oval | BB_HOST_BANG_CLK | rw); udelay(2);
 
@@ -233,9 +257,9 @@
 			write_nic_word(dev, RFPinsOutput, bit|oval | rw); udelay(2);
 			break;
 		}
-		
+
 		bit = ((data2Write&mask) != 0) ? 1: 0;
-		
+
 		write_nic_word(dev, RFPinsOutput, oval|bit|rw| BB_HOST_BANG_CLK); udelay(2);
 		write_nic_word(dev, RFPinsOutput, oval|bit|rw| BB_HOST_BANG_CLK); udelay(2);
 
@@ -252,22 +276,22 @@
 	for(i = 0; i < rLength; i++)
 	{
 		write_nic_word(dev, RFPinsOutput, rw|oval); udelay(1);
-		
+
 		write_nic_word(dev, RFPinsOutput, rw|oval|BB_HOST_BANG_CLK); udelay(2);
 		write_nic_word(dev, RFPinsOutput, rw|oval|BB_HOST_BANG_CLK); udelay(2);
 		write_nic_word(dev, RFPinsOutput, rw|oval|BB_HOST_BANG_CLK); udelay(2);
 		tmp = read_nic_word(dev, RFPinsInput);
-		
+
 		dataRead |= (tmp & BB_HOST_BANG_CLK ? mask : 0);
 
 		write_nic_word(dev, RFPinsOutput, (rw|oval)); udelay(2);
 
 		mask = (low2high) ? (mask<<1) : (mask>>1);
 	}
-	
+
 	write_nic_word(dev, RFPinsOutput, BB_HOST_BANG_EN|BB_HOST_BANG_RW|oval); udelay(2);
 
-	write_nic_word(dev, RFPinsEnable, oval2);   
+	write_nic_word(dev, RFPinsEnable, oval2);
 	write_nic_word(dev, RFPinsSelect, oval3);   // Set To SW Switch
 	write_nic_word(dev, RFPinsOutput, 0x3a0);
 
@@ -280,61 +304,61 @@
 	u16 out,select;
 	u8 bit;
 	u32 bangdata = (data << 4) | (adr & 0xf);
-	struct r8180_priv *priv = ieee80211_priv(dev);
-	
+	struct r8180_priv *priv = ieee80211_priv_rtl7(dev);
+
 	out = read_nic_word(dev, RFPinsOutput) & 0xfff3;
-		
+
 	write_nic_word(dev,RFPinsEnable,
 		(read_nic_word(dev,RFPinsEnable) | 0x7));
-	
+
 	select = read_nic_word(dev, RFPinsSelect);
-	
-	write_nic_word(dev, RFPinsSelect, select | 0x7 | 
+
+	write_nic_word(dev, RFPinsSelect, select | 0x7 |
 		((priv->card_type == USB) ? 0 : SW_CONTROL_GPIO));
-	
+
 	force_pci_posting(dev);
 	udelay(10);
-	
+
 	write_nic_word(dev, RFPinsOutput, out | BB_HOST_BANG_EN );//| 0x1fff);
-	
+
 	force_pci_posting(dev);
 	udelay(2);
-	
+
 	write_nic_word(dev, RFPinsOutput, out);
-	
+
 	force_pci_posting(dev);
 	udelay(10);
-	
-	
+
+
 	for(i=15; i>=0;i--){
-	
+
 		bit = (bangdata & (1<<i)) >> i;
-		
+
 		write_nic_word(dev, RFPinsOutput, bit | out);
-		
+
 		write_nic_word(dev, RFPinsOutput, bit | out | BB_HOST_BANG_CLK);
 		write_nic_word(dev, RFPinsOutput, bit | out | BB_HOST_BANG_CLK);
 
 		i--;
 		bit = (bangdata & (1<<i)) >> i;
-		
+
 		write_nic_word(dev, RFPinsOutput, bit | out | BB_HOST_BANG_CLK);
 		write_nic_word(dev, RFPinsOutput, bit | out | BB_HOST_BANG_CLK);
 
 		write_nic_word(dev, RFPinsOutput, bit | out);
 
 	}
-	
+
 	write_nic_word(dev, RFPinsOutput, out | BB_HOST_BANG_EN);
-	
+
 	force_pci_posting(dev);
 	udelay(10);
 
-	write_nic_word(dev, RFPinsOutput, out | 
+	write_nic_word(dev, RFPinsOutput, out |
 		((priv->card_type == USB) ? 4 : BB_HOST_BANG_EN));
 
-	write_nic_word(dev, RFPinsSelect, select | 
-		((priv->card_type == USB) ? 0 : SW_CONTROL_GPIO));	
+	write_nic_word(dev, RFPinsSelect, select |
+		((priv->card_type == USB) ? 0 : SW_CONTROL_GPIO));
 
 	if(priv->card_type == USB)
 		mdelay(2);
@@ -348,30 +372,30 @@
 	short vz2 = 1;
 	/* sw to reg pg 1 */
 	write_rtl8225(dev, 0, 0x1b7);
-	
+
 	/* reg 8 pg 1 = 23*/
 	if( read_rtl8225(dev, 8) != 0x588)
 		vz2 = 0;
-	
-	else	/* reg 9 pg 1 = 24 */ 
+
+	else	/* reg 9 pg 1 = 24 */
 		if( read_rtl8225(dev, 9) != 0x700)
 			vz2 = 0;
-	
-	/* sw back to pg 0 */	
+
+	/* sw back to pg 0 */
 	write_rtl8225(dev, 0, 0xb7);
 
 	return vz2;
-	
+
 }
 
 #if 0
 void rtl8225_rf_close(struct net_device *dev)
 {
-	write_rtl8225(dev, 0x4, 0x1f);   
-	
+	write_rtl8225(dev, 0x4, 0x1f);
+
 	force_pci_posting(dev);
 	mdelay(1);
-	
+
 	rtl8180_set_anaparam(dev, RTL8225_ANAPARAM_OFF);
 	rtl8185_set_anaparam2(dev, RTL8225_ANAPARAM2_OFF);
 }
@@ -380,24 +404,24 @@
 short rtl8225_rf_set_sens(struct net_device *dev, short sens)
 {
 	if (sens <0 || sens > 6) return -1;
-	
+
 	if(sens > 4)
 		write_rtl8225(dev, 0x0c, 0x850);
-	else	
+	else
 		write_rtl8225(dev, 0x0c, 0x50);
 
 	sens= 6-sens;
 	rtl8225_set_gain(dev, sens);
-	
+
 	write_phy_cck(dev, 0x41, rtl8225_threshold[sens]);
 	return 0;
-	
+
 }
 #endif
 void rtl8225z2_SetTXPowerLevel(struct net_device *dev, short ch)
 {
-	struct r8180_priv *priv = ieee80211_priv(dev);
-	
+	struct r8180_priv *priv = ieee80211_priv_rtl7(dev);
+
 //	int GainIdx;
 //	int GainSetting;
 	int i;
@@ -406,44 +430,48 @@
 	u8 max_cck_power_level;
 	//u8 min_cck_power_level;
 	u8 max_ofdm_power_level;
-	u8 min_ofdm_power_level;	
+	u8 min_ofdm_power_level;
 	u8 cck_power_level = 0xff & priv->chtxpwr[ch];
 	u8 ofdm_power_level = 0xff & priv->chtxpwr_ofdm[ch];
-	
-		
-	max_cck_power_level = 15;
+
+
+	max_cck_power_level = 35;
 	//min_cck_power_level = 0;
-	max_ofdm_power_level = 25; //  12 -> 25
+	max_ofdm_power_level = 35; //  12 -> 25
 	min_ofdm_power_level = 10;
-	
+
 	/* CCK power setting */
 	if(cck_power_level > max_cck_power_level)
+	{
 		cck_power_level = max_cck_power_level;
-	
+		priv->chtxpwr[ch] = max_cck_power_level;
+	}
+
 	cck_power_level += priv->cck_txpwr_base;
-	
+
 	if(cck_power_level > 35)
 		cck_power_level = 35;
-		
-	if(ch == 14) 
+
+	if(ch == 14)
 		cck_power_table = rtl8225z2_tx_power_cck_ch14;
-	else 
+	else
 		cck_power_table = rtl8225z2_tx_power_cck;
-	
-	
+
+	if(cck_power_level >= 20 && cck_power_level < 30)
+		cck_power_level = 19;
+
 	for(i=0;i<8;i++){
-	
 		power = cck_power_table[i];
 		write_phy_cck(dev, 0x44 + i, power);
 	}
-	
+
 	//write_nic_byte(dev, TX_GAIN_CCK, power);
 	//2005.11.17,
 	write_nic_byte(dev, TX_GAIN_CCK, ZEBRA2_CCK_OFDM_GAIN_SETTING[cck_power_level]);
-	
+
 	force_pci_posting(dev);
 	mdelay(1);
-	
+
 	/* OFDM power setting */
 //  Old:
 //	if(ofdm_power_level > max_ofdm_power_level)
@@ -454,26 +482,26 @@
 		ofdm_power_level = max_ofdm_power_level;
 	else
 		ofdm_power_level += min_ofdm_power_level;
-	
+
 	ofdm_power_level += priv->ofdm_txpwr_base;
-		
+
 	if(ofdm_power_level > 35)
 		ofdm_power_level = 35;
-	
+
 	rtl8185_set_anaparam2(dev,RTL8225_ANAPARAM2_ON);
-		
+
 	write_phy_ofdm(dev,2,0x42);
 	write_phy_ofdm(dev,5,0);
 	write_phy_ofdm(dev,6,0x40);
 	write_phy_ofdm(dev,7,0);
-	write_phy_ofdm(dev,8,0x40);	
-	
+	write_phy_ofdm(dev,8,0x40);
+
 
 	//write_nic_byte(dev, TX_GAIN_OFDM, ofdm_power_level);
 	//2005.11.17,
         write_nic_byte(dev, TX_GAIN_OFDM, ZEBRA2_CCK_OFDM_GAIN_SETTING[ofdm_power_level]);
 
-	
+
 	force_pci_posting(dev);
 	mdelay(1);
 	//write_nic_byte(dev, TX_AGC_CONTROL,4);
@@ -483,39 +511,39 @@
 void rtl8225_set_mode(struct net_device *dev, short modeb)
 {
 	write_phy_ofdm(dev, 0x15, (modeb ? 0x0 : 0x40));
-	write_phy_ofdm(dev, 0x17, (modeb ? 0x0 : 0x40));	
+	write_phy_ofdm(dev, 0x17, (modeb ? 0x0 : 0x40));
 }
 #endif
 
 void rtl8225z2_rf_set_chan(struct net_device *dev, short ch)
 {
-	struct r8180_priv *priv = ieee80211_priv(dev);
+	struct r8180_priv *priv = ieee80211_priv_rtl7(dev);
 	short gset = (priv->ieee80211->state == IEEE80211_LINKED &&
-		ieee80211_is_54g(priv->ieee80211->current_network)) ||
+		ieee80211_is_54g_rtl7(priv->ieee80211->current_network)) ||
 		priv->ieee80211->iw_mode == IW_MODE_MONITOR;
-	
+
 	rtl8225z2_SetTXPowerLevel(dev, ch);
-	
+
 	write_rtl8225(dev, 0x7, rtl8225_chan[ch]);
-	
+
 	force_pci_posting(dev);
 	mdelay(10);
-	
+
 	write_nic_byte(dev,SIFS,0x22);// SIFS: 0x22
-	
+
 	if(gset)
-		write_nic_byte(dev,DIFS,20); //DIFS: 20 
+		write_nic_byte(dev,DIFS,20); //DIFS: 20
 	else
-		write_nic_byte(dev,DIFS,0x24); //DIFS: 36 
-	
+		write_nic_byte(dev,DIFS,0x24); //DIFS: 36
+
 	if(priv->ieee80211->state == IEEE80211_LINKED &&
-		ieee80211_is_shortslot(priv->ieee80211->current_network))
+		ieee80211_is_shortslot_rtl7(priv->ieee80211->current_network))
 		write_nic_byte(dev,SLOT,0x9); //SLOT: 9
-		
+
 	else
 		write_nic_byte(dev,SLOT,0x14); //SLOT: 20 (0x14)
-		
-	
+
+
 	if(gset){
 		write_nic_byte(dev,EIFS,91 - 20); // EIFS: 91 (0x5B)
 		write_nic_byte(dev,CW_VAL,0x73); //CW VALUE: 0x37
@@ -529,68 +557,68 @@
 
 }
 #if 0
-void rtl8225_host_pci_init(struct net_device *dev) 
+void rtl8225_host_pci_init(struct net_device *dev)
 {
 	write_nic_word(dev, RFPinsOutput, 0x480);
-	
+
 	rtl8185_rf_pins_enable(dev);
-	
+
 	//if(priv->card_8185 == 2 && priv->enable_gpio0 ) /* version D */
 	//write_nic_word(dev, RFPinsSelect, 0x88);
 	//else
 	write_nic_word(dev, RFPinsSelect, 0x88 | SW_CONTROL_GPIO); /* 0x488 | SW_CONTROL_GPIO */
-	
+
 	write_nic_byte(dev, GP_ENABLE, 0);
-	
+
 	force_pci_posting(dev);
 	mdelay(200);
-	
+
 	write_nic_word(dev, GP_ENABLE, 0xff & (~(1<<6))); /* bit 6 is for RF on/off detection */
 
-	
+
 }
 
-void rtl8225_host_usb_init(struct net_device *dev) 
+void rtl8225_host_usb_init(struct net_device *dev)
 {
 	write_nic_byte(dev,RFPinsSelect+1,0);
 
 	write_nic_byte(dev,GPIO,0);
-	
+
 	write_nic_byte_E(dev,0x53,read_nic_byte_E(dev,0x53) | (1<<7));
-		
+
 	write_nic_byte(dev,RFPinsSelect+1,4);
 
 	write_nic_byte(dev,GPIO,0x20);
 
 	write_nic_byte(dev,GP_ENABLE,0);
 
-			
-	/* Config BB & RF */	
+
+	/* Config BB & RF */
 	write_nic_word(dev, RFPinsOutput, 0x80);
 
 	write_nic_word(dev, RFPinsSelect, 0x80);
 
 	write_nic_word(dev, RFPinsEnable, 0x80);
 
-	
+
 	mdelay(100);
 
-	mdelay(1000); 
+	mdelay(1000);
 
 }
 #endif
-void rtl8225z2_rf_init(struct net_device *dev) 
+void rtl8225z2_rf_init(struct net_device *dev)
 {
-	struct r8180_priv *priv = ieee80211_priv(dev);
+	struct r8180_priv *priv = ieee80211_priv_rtl7(dev);
 	int i;
 	short channel = 1;
 	u16	brsr;
 	u32	data,addr;
-	
+
 	priv->chan = channel;
 
 	rtl8180_set_anaparam(dev, RTL8225_ANAPARAM_ON);
-	
+
 
 	if(priv->card_type == USB)
 		rtl8225_host_usb_init(dev);
@@ -598,42 +626,42 @@
 		rtl8225_host_pci_init(dev);
 
 	write_nic_dword(dev, RF_TIMING, 0x000a8008);
-	
+
 	brsr = read_nic_word(dev, BRSR);
-	
-	write_nic_word(dev, BRSR, 0xffff); 
+
+	write_nic_word(dev, BRSR, 0xffff);
 
 
 	write_nic_dword(dev, RF_PARA, 0x100044);
-	
+
 	#if 1  //0->1
 	rtl8180_set_mode(dev, EPROM_CMD_CONFIG);
 	write_nic_byte(dev, CONFIG3, 0x44);
 	rtl8180_set_mode(dev, EPROM_CMD_NORMAL);
 	#endif
-	
-	
+
+
 	rtl8185_rf_pins_enable(dev);
 
 //		mdelay(1000);
 
 	write_rtl8225(dev, 0x0, 0x2bf); mdelay(1);
-	
-	
+
+
 	write_rtl8225(dev, 0x1, 0xee0); mdelay(1);
 
 	write_rtl8225(dev, 0x2, 0x44d); mdelay(1);
 
 	write_rtl8225(dev, 0x3, 0x441); mdelay(1);
 
-	
+
 	write_rtl8225(dev, 0x4, 0x8c3);mdelay(1);
-	
-	
-	
+
+
+
 	write_rtl8225(dev, 0x5, 0xc72);mdelay(1);
 //	}
-	
+
 	write_rtl8225(dev, 0x6, 0xe6);  mdelay(1);
 
 	write_rtl8225(dev, 0x7, ((priv->card_type == USB)? 0x82a : rtl8225_chan[channel]));  mdelay(1);
@@ -653,28 +681,28 @@
 
 	write_rtl8225(dev, 0xe, 0x2b);  mdelay(1);
 
-	write_rtl8225(dev, 0xf, 0x114); 
-	
-	
+	write_rtl8225(dev, 0xf, 0x114);
+
+
 	mdelay(100);
-	
-	
+
+
 	//if(priv->card_type != USB) /* maybe not needed even for 8185 */
-//	write_rtl8225(dev, 0x7, rtl8225_chan[channel]); 
-	
+//	write_rtl8225(dev, 0x7, rtl8225_chan[channel]);
+
 	write_rtl8225(dev, 0x0, 0x1b7);
-	
+
 	for(i=0;i<95;i++){
 		write_rtl8225(dev, 0x1, (u8)(i+1));
-		
+
 		#if 0
-		if(priv->phy_ver == 1) 
+		if(priv->phy_ver == 1)
 			/* version A */
 			write_rtl8225(dev, 0x2, rtl8225a_rxgain[i]);
 		else
 		#endif
 		/* version B & C & D*/
-		
+
 		write_rtl8225(dev, 0x2, rtl8225z2_rxgain[i]);
 	}
 	write_rtl8225(dev, 0x3, 0x80);
@@ -683,16 +711,16 @@
 	write_rtl8225(dev, 0x0, 0xb7);
 
 	write_rtl8225(dev, 0x2, 0xc4d);
-	
+
 	if(priv->card_type == USB){
 	//	force_pci_posting(dev);
 		mdelay(200);
-		
+
 		write_rtl8225(dev, 0x2, 0x44d);
-		
+
 	//	force_pci_posting(dev);
 		mdelay(100);
-		
+
 	}//End of if(priv->card_type == USB)
 	/* FIXME!! rtl8187 we have to check if calibrarion
 	 * is successful and eventually cal. again (repeat
@@ -713,23 +741,23 @@
                         }
         }
 	//force_pci_posting(dev);
-	
-	mdelay(200); //200 for 8187 
-	
-	
+
+	mdelay(200); //200 for 8187
+
+
 //	//if(priv->card_type != USB){
 //		write_rtl8225(dev, 0x2, 0x44d);
 //		write_rtl8225(dev, 0x7, rtl8225_chan[channel]);
 //		write_rtl8225(dev, 0x2, 0x47d);
-//		
+//
 //		force_pci_posting(dev);
 //		mdelay(100);
-//		
+//
 //		write_rtl8225(dev, 0x2, 0x44d);
 //	//}
-	
-	write_rtl8225(dev, 0x0, 0x2bf);   
-	
+
+	write_rtl8225(dev, 0x0, 0x2bf);
+
 	if(priv->card_type != USB)
 		rtl8185_rf_pins_enable(dev);
 	//set up ZEBRA AGC table, 2005.11.17,
@@ -744,20 +772,20 @@
 
                 mdelay(1);
         }
-#if 0	
+#if 0
 	for(i=0;i<128;i++){
 		write_phy_ofdm(dev, 0xb, rtl8225_agc[i]);
-		
-		mdelay(1); 
+
+		mdelay(1);
 		write_phy_ofdm(dev, 0xa, (u8)i+ 0x80);
-	
-		mdelay(1); 
+
+		mdelay(1);
 	}
 #endif
-		
+
 	force_pci_posting(dev);
 	mdelay(1);
-	
+
 	write_phy_ofdm(dev, 0x0, 0x1); mdelay(1);
 	write_phy_ofdm(dev, 0x1, 0x2); mdelay(1);
 	write_phy_ofdm(dev, 0x2, ((priv->card_type == USB)? 0x42 : 0x62)); mdelay(1);
@@ -771,20 +799,20 @@
 
 	write_phy_ofdm(dev, 0xa, 0x8); mdelay(1);
 
-	//write_phy_ofdm(dev, 0x18, 0xef); 
+	//write_phy_ofdm(dev, 0x18, 0xef);
 	//	}
 	//}
 	write_phy_ofdm(dev, 0xb, 0x80); mdelay(1);
 
 	write_phy_ofdm(dev, 0xc, 0x1);mdelay(1);
 
-	
+
 	//if(priv->card_type != USB)
-	write_phy_ofdm(dev, 0xd, 0x43); 
-		
+	write_phy_ofdm(dev, 0xd, 0x43);
+
 	write_phy_ofdm(dev, 0xe, 0xd3);mdelay(1);
 
-	
+
 	#if 0
 	if(priv->card_8185 == 1){
 		if(priv->card_8185_Bversion)
@@ -796,17 +824,17 @@
 	write_phy_ofdm(dev, 0xf, 0x38);mdelay(1);
 /*ver D & 8187*/
 //	}
-	
+
 //	if(priv->card_8185 == 1 && priv->card_8185_Bversion)
 //		write_phy_ofdm(dev, 0x10, 0x04);/*ver B*/
 //	else
 	write_phy_ofdm(dev, 0x10, 0x84);mdelay(1);
 /*ver C & D & 8187*/
-	
+
 	write_phy_ofdm(dev, 0x11, 0x07);mdelay(1);
 /*agc resp time 700*/
 
-	
+
 //	if(priv->card_8185 == 2){
 	/* Ver D & 8187*/
 	write_phy_ofdm(dev, 0x12, 0x20);mdelay(1);
@@ -824,47 +852,46 @@
 	write_phy_ofdm(dev, 0x15, 0x40); mdelay(1);
 	write_phy_ofdm(dev, 0x16, 0x0); mdelay(1);
 	write_phy_ofdm(dev, 0x17, 0x40); mdelay(1);
-	
+
 //	if (priv->card_type == USB)
 //		write_phy_ofdm(dev, 0x18, 0xef);
-	
+
 	write_phy_ofdm(dev, 0x18, 0xef);mdelay(1);
- 
+
 
 	write_phy_ofdm(dev, 0x19, 0x19); mdelay(1);
 	write_phy_ofdm(dev, 0x1a, 0x20); mdelay(1);
 	write_phy_ofdm(dev, 0x1b, 0x15);mdelay(1);
-	
+
 	write_phy_ofdm(dev, 0x1c, 0x4);mdelay(1);
 
 	write_phy_ofdm(dev, 0x1d, 0xc5);mdelay(1); //2005.11.17,
-	
+
 	write_phy_ofdm(dev, 0x1e, 0x95);mdelay(1);
 
 	write_phy_ofdm(dev, 0x1f, 0x75);	mdelay(1);
 
 //	}
-	
+
 	write_phy_ofdm(dev, 0x20, 0x1f);mdelay(1);
 
 	write_phy_ofdm(dev, 0x21, 0x17);mdelay(1);
-	
+
 	write_phy_ofdm(dev, 0x22, 0x16);mdelay(1);
 
 //	if(priv->card_type != USB)
 	write_phy_ofdm(dev, 0x23, 0x80);mdelay(1); //FIXME maybe not needed // <>
-	
+
 	write_phy_ofdm(dev, 0x24, 0x46); mdelay(1);
 	write_phy_ofdm(dev, 0x25, 0x00); mdelay(1);
 	write_phy_ofdm(dev, 0x26, 0x90); mdelay(1);
 
 	write_phy_ofdm(dev, 0x27, 0x88); mdelay(1);
 
-	
+
 	// <> Set init. gain to m74dBm.
-	
 	rtl8225z2_set_gain(dev,4);
-	
+
 	write_phy_cck(dev, 0x0, 0x98); mdelay(1);
 	write_phy_cck(dev, 0x3, 0x20); mdelay(1);
 	write_phy_cck(dev, 0x4, 0x7e); mdelay(1);
@@ -875,6 +902,9 @@
  /* Ver C & D & 8187*/
 
 	write_phy_cck(dev, 0x8, 0x2e);mdelay(1);
+	write_phy_cck(dev, 0x9, 0x11);mdelay(1);
+	write_phy_cck(dev, 0xa, 0x17);mdelay(1);
+	write_phy_cck(dev, 0xb, 0x11);mdelay(1);
 
 	write_phy_cck(dev, 0x10, ((priv->card_type == USB) ? 0x9b: 0x93)); mdelay(1);
 	write_phy_cck(dev, 0x11, 0x88); mdelay(1);
@@ -885,52 +915,59 @@
 	else
 #endif
 	write_phy_cck(dev, 0x13, 0xd0); /* Ver C & D & 8187*/
-		
-	write_phy_cck(dev, 0x19, 0x0);
-	write_phy_cck(dev, 0x1a, 0xa0);
-	write_phy_cck(dev, 0x1b, 0x8);
-	write_phy_cck(dev, 0x40, 0x86); /* CCK Carrier Sense Threshold */
-	
-	write_phy_cck(dev, 0x41, 0x8d);mdelay(1);
 
-	
+// 	write_phy_cck(dev, 0x19, 0x0);
+// 	write_phy_cck(dev, 0x1a, 0xa0);
+// 	write_phy_cck(dev, 0x1b, 0x8);
+// 	write_phy_cck(dev, 0x40, 0x86); /* CCK Carrier Sense Threshold */
+	write_phy_cck(dev, 0x19, 0x0); mdelay(1);
+	write_phy_cck(dev, 0x1a, 0xa0); mdelay(1);
+	write_phy_cck(dev, 0x1b, 0x8); mdelay(1);
+	write_phy_cck(dev, 0x1d, 0x0); mdelay(1);
+	write_phy_cck(dev, 0x40, 0x86); /* CCK Carrier Sense Threshold */ mdelay(1);
+	write_phy_cck(dev, 0x41, 0x86); mdelay(1);
+
+
+// 	write_phy_cck(dev, 0x41, 0x8d);mdelay(1);
+
+
 	write_phy_cck(dev, 0x42, 0x15); mdelay(1);
 	write_phy_cck(dev, 0x43, 0x18); mdelay(1);
-	
-	
+
+
 	write_phy_cck(dev, 0x44, 0x36); mdelay(1);
 	write_phy_cck(dev, 0x45, 0x35); mdelay(1);
 	write_phy_cck(dev, 0x46, 0x2e); mdelay(1);
 	write_phy_cck(dev, 0x47, 0x25); mdelay(1);
 	write_phy_cck(dev, 0x48, 0x1c); mdelay(1);
 	write_phy_cck(dev, 0x49, 0x12); mdelay(1);
-	write_phy_cck(dev, 0x4a, 0x9); mdelay(1);
-	write_phy_cck(dev, 0x4b, 0x4); mdelay(1);
+	write_phy_cck(dev, 0x4a, 0x09); mdelay(1);
+	write_phy_cck(dev, 0x4b, 0x04); mdelay(1);
 	write_phy_cck(dev, 0x4c, 0x5);mdelay(1);
 
 
 	write_nic_byte(dev, 0x5b, 0x0d); mdelay(1);
 
-	
+
 
 // <>
 //	// TESTR 0xb 8187
 //	write_phy_cck(dev, 0x10, 0x93);// & 0xfb);
-//	
+//
 //	//if(priv->card_type != USB){
 //		write_phy_ofdm(dev, 0x2, 0x62);
 //		write_phy_ofdm(dev, 0x6, 0x0);
 //		write_phy_ofdm(dev, 0x8, 0x0);
 //	//}
-	
+
 	rtl8225z2_SetTXPowerLevel(dev, channel);
-	
+
 	write_phy_cck(dev, 0x10, 0x9b); mdelay(1); /* Rx ant A, 0xdb for B */
 	write_phy_ofdm(dev, 0x26, 0x90); mdelay(1); /* Rx ant A, 0x10 for B */
-	
+
 	rtl8185_tx_antenna(dev, 0x3); /* TX ant A, 0x0 for B */
-	
-	/* switch to high-speed 3-wire 
+
+	/* switch to high-speed 3-wire
 	 * last digit. 2 for both cck and ofdm
 	 */
 	if(priv->card_type == USB)
@@ -943,23 +980,23 @@
 //	if(priv->card_type != USB)
 //	rtl8225_set_gain(dev, 4); /* FIXME this '1' is random */ // <>
 //	 rtl8225_set_mode(dev, 1); /* FIXME start in B mode */ // <>
-//	
+//
 //	/* make sure is waken up! */
 //	write_rtl8225(dev,0x4, 0x9ff);
-//	rtl8180_set_anaparam(dev, RTL8225_ANAPARAM_ON); 
+//	rtl8180_set_anaparam(dev, RTL8225_ANAPARAM_ON);
 //	rtl8185_set_anaparam2(dev, RTL8225_ANAPARAM2_ON);
-	
+
 	rtl8225_rf_set_chan(dev, priv->chan);
 
 	//write_nic_word(dev,BRSR,brsr);
-	
+
 	//rtl8225z2_rf_set_mode(dev);
 }
 
-void rtl8225z2_rf_set_mode(struct net_device *dev) 
+void rtl8225z2_rf_set_mode(struct net_device *dev)
 {
-	struct r8180_priv *priv = ieee80211_priv(dev);
-	
+	struct r8180_priv *priv = ieee80211_priv_rtl7(dev);
+
 	if(priv->ieee80211->mode == IEEE_A)
 	{
 		write_rtl8225(dev, 0x5, 0x1865);
@@ -970,15 +1007,15 @@
 		write_phy_ofdm(dev, 0xb, 0x99);
 		write_phy_ofdm(dev, 0xf, 0x20);
 		write_phy_ofdm(dev, 0x11, 0x7);
-		
+
 		rtl8225z2_set_gain(dev,4);
-		
+
 		write_phy_ofdm(dev,0x15, 0x40);
 		write_phy_ofdm(dev,0x17, 0x40);
-	
+
 		write_nic_dword(dev, 0x94,0x10000000);
 	}else{
-	
+
 		write_rtl8225(dev, 0x5, 0x1864);
 		write_nic_dword(dev, RF_PARA, 0x10044);
 		write_nic_dword(dev, RF_TIMING, 0xa8008);
@@ -987,12 +1024,12 @@
 		write_phy_ofdm(dev, 0xb, 0x99);
 		write_phy_ofdm(dev, 0xf, 0x20);
 		write_phy_ofdm(dev, 0x11, 0x7);
-		
+
 		rtl8225z2_set_gain(dev,4);
-		
+
 		write_phy_ofdm(dev,0x15, 0x40);
 		write_phy_ofdm(dev,0x17, 0x40);
-	
+
 		write_nic_dword(dev, 0x94,0x04000002);
 	}
 }
diff -Naur rtl8187_linux_26.1010.0622.2006/beta-8187/r8180_wx.c rtl8187_linux_26.1010.0622.2006_rawtx/beta-8187/r8180_wx.c
--- rtl8187_linux_26.1010.0622.2006/beta-8187/r8180_wx.c	2006-06-06 04:58:02.000000000 +0200
+++ rtl8187_linux_26.1010.0622.2006_rawtx/beta-8187/r8180_wx.c	2008-02-22 15:32:50.000000000 +0100
@@ -1,19 +1,19 @@
-/* 
+/*
    This file contains wireless extension handlers.
 
    This is part of rtl8180 OpenSource driver.
-   Copyright (C) Andrea Merello 2004-2005  <andreamrl@tiscali.it> 
+   Copyright (C) Andrea Merello 2004-2005  <andreamrl@tiscali.it>
    Released under the terms of GPL (General Public Licence)
-   
-   Parts of this driver are based on the GPL part 
+
+   Parts of this driver are based on the GPL part
    of the official realtek driver.
-   
-   Parts of this driver are based on the rtl8180 driver skeleton 
+
+   Parts of this driver are based on the rtl8180 driver skeleton
    from Patric Schenke & Andres Salomon.
 
    Parts of this driver are based on the Intel Pro Wireless 2100 GPL driver.
-   
-   We want to tanks the Authors of those projects and the Ndiswrapper 
+
+   We want to tanks the Authors of those projects and the Ndiswrapper
    project Authors.
 */
 
@@ -21,20 +21,21 @@
 
 #include "r8187.h"
 #include "r8180_hw.h"
+#include "r8180_rtl8225.h"
 
 
 #define RATE_COUNT 4
 u32 rtl8180_rates[] = {1000000,2000000,5500000,11000000,
 	6000000,9000000,12000000,18000000,24000000,36000000,48000000,54000000};
-	
+
 
 static int r8180_wx_get_freq(struct net_device *dev,
 			     struct iw_request_info *a,
 			     union iwreq_data *wrqu, char *b)
 {
-	struct r8180_priv *priv = ieee80211_priv(dev);
-	
-	return ieee80211_wx_get_freq(priv->ieee80211,a,wrqu,b);
+	struct r8180_priv *priv = ieee80211_priv_rtl7(dev);
+
+	return ieee80211_wx_get_freq_rtl7(priv->ieee80211,a,wrqu,b);
 }
 
 
@@ -45,28 +46,28 @@
 {
 	int *parms = (int *)b;
 	int bi = parms[0];
-	
-	struct r8180_priv *priv = ieee80211_priv(dev);
-	
+
+	struct r8180_priv *priv = ieee80211_priv_rtl7(dev);
+
 	down(&priv->wx_sem);
 	DMESG("setting beacon interval to %x",bi);
-	
+
 	priv->ieee80211->beacon_interval=bi;
 	rtl8180_commit(dev);
 	up(&priv->wx_sem);
-		
-	return 0;	
+
+	return 0;
 }
 
 
 static int r8180_wx_set_forceassociate(struct net_device *dev, struct iw_request_info *aa,
 			  union iwreq_data *wrqu, char *extra)
 {
-	struct r8180_priv *priv=ieee80211_priv(dev);	
+	struct r8180_priv *priv=ieee80211_priv_rtl7(dev);
 	int *parms = (int *)extra;
-	
+
 	priv->ieee80211->force_associate = (parms[0] > 0);
-	
+
 
 	return 0;
 }
@@ -75,108 +76,228 @@
 static int r8180_wx_get_mode(struct net_device *dev, struct iw_request_info *a,
 			     union iwreq_data *wrqu, char *b)
 {
-	struct r8180_priv *priv=ieee80211_priv(dev);	
+	struct r8180_priv *priv=ieee80211_priv_rtl7(dev);
 
-	return ieee80211_wx_get_mode(priv->ieee80211,a,wrqu,b);
+	return ieee80211_wx_get_mode_rtl7(priv->ieee80211,a,wrqu,b);
 }
 
 
 
-static int r8180_wx_get_rate(struct net_device *dev, 
-			     struct iw_request_info *info, 
+static int r8180_wx_get_rate(struct net_device *dev,
+			     struct iw_request_info *info,
 			     union iwreq_data *wrqu, char *extra)
 {
-	struct r8180_priv *priv = ieee80211_priv(dev);
-	return ieee80211_wx_get_rate(priv->ieee80211,info,wrqu,extra);
+	struct r8180_priv *priv = ieee80211_priv_rtl7(dev);
+	return ieee80211_wx_get_rate_rtl7(priv->ieee80211,info,wrqu,extra);
 }
 
 
 
-static int r8180_wx_set_rate(struct net_device *dev, 
-			     struct iw_request_info *info, 
+static int r8180_wx_set_rate(struct net_device *dev,
+			     struct iw_request_info *info,
 			     union iwreq_data *wrqu, char *extra)
 {
 	int ret;
-	struct r8180_priv *priv = ieee80211_priv(dev);	
-	
+	struct r8180_priv *priv = ieee80211_priv_rtl7(dev);
+
 	down(&priv->wx_sem);
+	ret = ieee80211_wx_set_rate_rtl7(priv->ieee80211,info,wrqu,extra);
 
-	ret = ieee80211_wx_set_rate(priv->ieee80211,info,wrqu,extra);
-	
 	up(&priv->wx_sem);
-	
+
 	return ret;
 }
 
-static int r8180_wx_set_rawtx(struct net_device *dev, 
-			       struct iw_request_info *info, 
-			       union iwreq_data *wrqu, char *extra)
+static int r8180_wx_get_txpow(struct net_device *dev,
+			      struct iw_request_info *info,
+			      union iwreq_data *wrqu, char *extra)
 {
-	struct r8180_priv *priv = ieee80211_priv(dev);
-	int ret;
-	
+	struct r8180_priv *priv = ieee80211_priv_rtl7(dev);
+	int i=0;
 	down(&priv->wx_sem);
-	
-	ret = ieee80211_wx_set_rawtx(priv->ieee80211, info, wrqu, extra);
-	
+	wrqu->power.value = 0;
+	for(i=0; i<15; i++)
+	{
+		if(priv->chtxpwr[i] > wrqu->power.value) wrqu->power.value = priv->chtxpwr[i];
+		if(priv->chtxpwr_ofdm[i] > wrqu->power.value) wrqu->power.value = priv->chtxpwr_ofdm[i];
+	}
+	wrqu->power.fixed = 1;
+	wrqu->power.flags = IW_TXPOW_DBM;
+	wrqu->power.disabled = 0;
 	up(&priv->wx_sem);
-	
+
+	return 0;
+}
+
+#if 1
+static int r8180_wx_set_txpow(struct net_device *dev,
+			      struct iw_request_info *info,
+			      union iwreq_data *wrqu, char *extra)
+{
+	int ret = 0, i=0;
+	struct r8180_priv *priv = ieee80211_priv_rtl7(dev);
+
+	down(&priv->wx_sem);
+
+	if (wrqu->power.flags != IW_TXPOW_DBM)
+	{
+		ret = -EINVAL;
+		goto out;
+	}
+
+	if(!(priv->highpower) && wrqu->power.value > priv->txpwr_max)
+	{
+		ret = -EINVAL;
+		goto out;
+	}
+
+	if(wrqu->power.value > 35)
+	{
+		ret = -EINVAL;
+		goto out;
+	}
+
+	if(wrqu->power.value < 0)
+	{
+		ret = -EINVAL;
+		goto out;
+	}
+
+	for(i=1;i<15;i++)
+	{
+		priv->chtxpwr[i] = priv->chtxpwr_orig[i] - (priv->txpwr_max - wrqu->power.value);
+// 		if(priv->chtxpwr[i] > priv->chtxpwr_orig[i]) priv->chtxpwr[i] = 0;
+
+		priv->chtxpwr_ofdm[i] = priv->chtxpwr_ofdm_orig[i] - (priv->txpwr_max - wrqu->power.value);
+// 		if(priv->chtxpwr_ofdm[i] > priv->chtxpwr_ofdm_orig[i]) priv->chtxpwr_ofdm[i] = 0;
+	}
+	rtl8225z2_SetTXPowerLevel(dev, 1);
+
+	out:
+	up(&priv->wx_sem);
+
 	return ret;
-	 
+
 }
+#endif
 
-static int r8180_wx_set_crcmon(struct net_device *dev, 
-			       struct iw_request_info *info, 
+static int r8180_wx_set_crcmon(struct net_device *dev,
+			       struct iw_request_info *info,
 			       union iwreq_data *wrqu, char *extra)
 {
-	struct r8180_priv *priv = ieee80211_priv(dev);
+	struct r8180_priv *priv = ieee80211_priv_rtl7(dev);
 	int *parms = (int *)extra;
 	int enable = (parms[0] > 0);
 	short prev = priv->crcmon;
 
 	down(&priv->wx_sem);
-	
-	if(enable) 
+
+	if(enable)
 		priv->crcmon=1;
-	else 
+	else
 		priv->crcmon=0;
 
-	DMESG("bad CRC in monitor mode are %s", 
+	DMESG("bad CRC in monitor mode are %s",
 	      priv->crcmon ? "accepted" : "rejected");
 
 	if(prev != priv->crcmon && priv->up){
 		rtl8180_down(dev);
 		rtl8180_up(dev);
 	}
-	
+
+	up(&priv->wx_sem);
+
+	return 0;
+}
+
+static int r8180_wx_set_fasttx(struct net_device *dev,
+			       struct iw_request_info *info,
+			       union iwreq_data *wrqu, char *extra)
+{
+	struct r8180_priv *priv = ieee80211_priv_rtl7(dev);
+	int *parms = (int *)extra;
+	int enable = (parms[0] > 0);
+	short prev = priv->fasttx;
+
+	down(&priv->wx_sem);
+
+	if(enable)
+		priv->fasttx=1;
+	else
+		priv->fasttx=0;
+
+	DMESG("Transmission method (regarding speed) set to: %s",
+	      priv->fasttx ? "fast" : "normal");
+
+	if(prev != priv->fasttx && priv->up){
+		rtl8180_down(dev);
+		rtl8180_up(dev);
+	}
+
 	up(&priv->wx_sem);
-	
+
+	return 0;
+}
+
+static int r8180_wx_set_highpower(struct net_device *dev,
+				  struct iw_request_info *info,
+				  union iwreq_data *wrqu, char *extra)
+{
+	struct r8180_priv *priv = ieee80211_priv_rtl7(dev);
+	int *parms = (int *)extra;
+	int enable = (parms[0] > 0);
+	int i=0;
+	short prev = priv->highpower;
+
+	down(&priv->wx_sem);
+
+	if(enable)
+		priv->highpower=1;
+	else
+		priv->highpower=0;
+
+	DMESG("Increasable transmission power %s",
+	      priv->highpower ? "enabled" : "disabled");
+
+	if( (prev != priv->highpower) && !(priv->highpower) && (priv->chtxpwr[1] > priv->chtxpwr_orig[1]) )
+	{
+		for(i=1;i<15;i++)
+		{
+			priv->chtxpwr[i] = priv->chtxpwr_orig[i];
+			priv->chtxpwr_ofdm[i] = priv->chtxpwr_ofdm_orig[i];
+		}
+		rtl8225z2_SetTXPowerLevel(dev, 1);
+		wrqu->power.value = priv->txpwr_max;
+	}
+
+	up(&priv->wx_sem);
+
 	return 0;
 }
 
 static int r8180_wx_set_mode(struct net_device *dev, struct iw_request_info *a,
 			     union iwreq_data *wrqu, char *b)
 {
-	struct r8180_priv *priv = ieee80211_priv(dev);
+	struct r8180_priv *priv = ieee80211_priv_rtl7(dev);
 	int ret;
-	
+
 	down(&priv->wx_sem);
-	
-	ret = ieee80211_wx_set_mode(priv->ieee80211,a,wrqu,b);
-	
+
+	ret = ieee80211_wx_set_mode_rtl7(priv->ieee80211,a,wrqu,b);
+
 	rtl8187_set_rxconf(dev);
-	
+
 	up(&priv->wx_sem);
 	return ret;
 }
 
 
-static int rtl8180_wx_get_range(struct net_device *dev, 
-				struct iw_request_info *info, 
+static int rtl8180_wx_get_range(struct net_device *dev,
+				struct iw_request_info *info,
 				union iwreq_data *wrqu, char *extra)
 {
 	struct iw_range *range = (struct iw_range *)extra;
-	struct r8180_priv *priv = ieee80211_priv(dev);
+	struct r8180_priv *priv = ieee80211_priv_rtl7(dev);
 	u16 val;
 	int i;
 
@@ -186,26 +307,26 @@
 	/* Let's try to keep this struct in the same order as in
 	 * linux/include/wireless.h
 	 */
-	
+
 	/* TODO: See what values we can set, and remove the ones we can't
 	 * set, or fill them with some default data.
 	 */
 
 	/* ~5 Mb/s real (802.11b) */
-	range->throughput = 5 * 1000 * 1000;     
+	range->throughput = 5 * 1000 * 1000;
 
 	// TODO: Not used in 802.11b?
 //	range->min_nwid;	/* Minimal NWID we are able to set */
 	// TODO: Not used in 802.11b?
 //	range->max_nwid;	/* Maximal NWID we are able to set */
-	
+
         /* Old Frequency (backward compat - moved lower ) */
-//	range->old_num_channels; 
+//	range->old_num_channels;
 //	range->old_num_frequency;
 //	range->old_freq[6]; /* Filler to keep "version" at the same offset */
 	if(priv->rf_set_sens != NULL)
 		range->sensitivity = priv->max_sens;	/* signal level threshold range */
-	
+
 	range->max_qual.qual = 100;
 	/* TODO: Find real max RSSI and stick here */
 	range->max_qual.level = 0;
@@ -219,14 +340,14 @@
 	range->avg_qual.updated = 7; /* Updated all three */
 
 	range->num_bitrates = RATE_COUNT;
-	
+
 	for (i = 0; i < RATE_COUNT && i < IW_MAX_BITRATES; i++) {
 		range->bitrate[i] = rtl8180_rates[i];
 	}
-	
+
 	range->min_frag = MIN_FRAG_THRESHOLD;
 	range->max_frag = MAX_FRAG_THRESHOLD;
-	
+
 	range->pm_capa = 0;
 
 	range->we_version_compiled = WIRELESS_EXT;
@@ -243,18 +364,18 @@
         range->num_channels = 14;
 
 	for (i = 0, val = 0; i < 14; i++) {
-		
+
 		// Include only legal frequencies for some countries
 		if ((priv->challow)[i+1]) {
 		        range->freq[val].i = i + 1;
-			range->freq[val].m = ieee80211_wlan_frequencies[i] * 100000;
+			range->freq[val].m = ieee80211_wlan_frequencies_rtl7[i] * 100000;
 			range->freq[val].e = 1;
 			val++;
 		} else {
 			// FIXME: do we need to set anything for channels
 			// we don't use ?
 		}
-		
+
 		if (val == IW_MAX_FREQUENCIES)
 		break;
 	}
@@ -267,15 +388,15 @@
 static int r8180_wx_set_scan(struct net_device *dev, struct iw_request_info *a,
 			     union iwreq_data *wrqu, char *b)
 {
-	struct r8180_priv *priv = ieee80211_priv(dev);
+	struct r8180_priv *priv = ieee80211_priv_rtl7(dev);
 	int ret;
-	
+
 	if(!priv->up) return -1;
-	
+
 	down(&priv->wx_sem);
-	
-	ret = ieee80211_wx_set_scan(priv->ieee80211,a,wrqu,b);
-	
+
+	ret = ieee80211_wx_set_scan_rtl7(priv->ieee80211,a,wrqu,b);
+
 	up(&priv->wx_sem);
 	return ret;
 }
@@ -286,50 +407,50 @@
 {
 
 	int ret;
-	struct r8180_priv *priv = ieee80211_priv(dev);
-	
+	struct r8180_priv *priv = ieee80211_priv_rtl7(dev);
+
 	if(!priv->up) return -1;
-			
+
 	down(&priv->wx_sem);
 
-	ret = ieee80211_wx_get_scan(priv->ieee80211,a,wrqu,b);
-		
+	ret = ieee80211_wx_get_scan_rtl7(priv->ieee80211,a,wrqu,b);
+
 	up(&priv->wx_sem);
-	
+
 	return ret;
 }
 
 
-static int r8180_wx_set_essid(struct net_device *dev, 
+static int r8180_wx_set_essid(struct net_device *dev,
 			      struct iw_request_info *a,
 			      union iwreq_data *wrqu, char *b)
 {
-	struct r8180_priv *priv = ieee80211_priv(dev);
-	
+	struct r8180_priv *priv = ieee80211_priv_rtl7(dev);
+
 	int ret;
-	
+
 	down(&priv->wx_sem);
-	
-	ret = ieee80211_wx_set_essid(priv->ieee80211,a,wrqu,b);
-	
+
+	ret = ieee80211_wx_set_essid_rtl7(priv->ieee80211,a,wrqu,b);
+
 	up(&priv->wx_sem);
 	return ret;
 }
 
 
-static int r8180_wx_get_essid(struct net_device *dev, 
+static int r8180_wx_get_essid(struct net_device *dev,
 			      struct iw_request_info *a,
 			      union iwreq_data *wrqu, char *b)
 {
 	int ret;
-	struct r8180_priv *priv = ieee80211_priv(dev);
-	
+	struct r8180_priv *priv = ieee80211_priv_rtl7(dev);
+
 	down(&priv->wx_sem);
-	
-	ret = ieee80211_wx_get_essid(priv->ieee80211, a, wrqu, b);
+
+	ret = ieee80211_wx_get_essid_rtl7(priv->ieee80211, a, wrqu, b);
 
 	up(&priv->wx_sem);
-	
+
 	return ret;
 }
 
@@ -338,30 +459,30 @@
 			     union iwreq_data *wrqu, char *b)
 {
 	int ret;
-	struct r8180_priv *priv = ieee80211_priv(dev);
-	
+	struct r8180_priv *priv = ieee80211_priv_rtl7(dev);
+
 	down(&priv->wx_sem);
-	
-	ret = ieee80211_wx_set_freq(priv->ieee80211, a, wrqu, b);
-	
+
+	ret = ieee80211_wx_set_freq_rtl7(priv->ieee80211, a, wrqu, b);
+
 	up(&priv->wx_sem);
 	return ret;
 }
 
-static int r8180_wx_get_name(struct net_device *dev, 
-			     struct iw_request_info *info, 
+static int r8180_wx_get_name(struct net_device *dev,
+			     struct iw_request_info *info,
 			     union iwreq_data *wrqu, char *extra)
 {
-	struct r8180_priv *priv = ieee80211_priv(dev);
-	return ieee80211_wx_get_name(priv->ieee80211, info, wrqu, extra);
+	struct r8180_priv *priv = ieee80211_priv_rtl7(dev);
+	return ieee80211_wx_get_name_rtl7(priv->ieee80211, info, wrqu, extra);
 }
 
 
-static int r8180_wx_set_frag(struct net_device *dev, 
-			     struct iw_request_info *info, 
+static int r8180_wx_set_frag(struct net_device *dev,
+			     struct iw_request_info *info,
 			     union iwreq_data *wrqu, char *extra)
 {
-	struct r8180_priv *priv = ieee80211_priv(dev);
+	struct r8180_priv *priv = ieee80211_priv_rtl7(dev);
 
 	if (wrqu->frag.disabled)
 		priv->ieee80211->fts = DEFAULT_FRAG_THRESHOLD;
@@ -369,7 +490,7 @@
 		if (wrqu->frag.value < MIN_FRAG_THRESHOLD ||
 		    wrqu->frag.value > MAX_FRAG_THRESHOLD)
 			return -EINVAL;
-		
+
 		priv->ieee80211->fts = wrqu->frag.value & ~0x1;
 	}
 
@@ -377,11 +498,11 @@
 }
 
 
-static int r8180_wx_get_frag(struct net_device *dev, 
-			     struct iw_request_info *info, 
+static int r8180_wx_get_frag(struct net_device *dev,
+			     struct iw_request_info *info,
 			     union iwreq_data *wrqu, char *extra)
 {
-	struct r8180_priv *priv = ieee80211_priv(dev);
+	struct r8180_priv *priv = ieee80211_priv_rtl7(dev);
 
 	wrqu->frag.value = priv->ieee80211->fts;
 	wrqu->frag.fixed = 0;	/* no auto select */
@@ -397,49 +518,49 @@
 			 char *extra)
 {
 	int ret;
-	struct r8180_priv *priv = ieee80211_priv(dev);
-	
+	struct r8180_priv *priv = ieee80211_priv_rtl7(dev);
+
 	down(&priv->wx_sem);
-	
-	ret = ieee80211_wx_set_wap(priv->ieee80211,info,awrq,extra);
-	
+
+	ret = ieee80211_wx_set_wap_rtl7(priv->ieee80211,info,awrq,extra);
+
 	up(&priv->wx_sem);
 	return ret;
-	
+
 }
-	
 
-static int r8180_wx_get_wap(struct net_device *dev, 
-			    struct iw_request_info *info, 
+
+static int r8180_wx_get_wap(struct net_device *dev,
+			    struct iw_request_info *info,
 			    union iwreq_data *wrqu, char *extra)
 {
-	struct r8180_priv *priv = ieee80211_priv(dev);
-	
-	return ieee80211_wx_get_wap(priv->ieee80211,info,wrqu,extra);
+	struct r8180_priv *priv = ieee80211_priv_rtl7(dev);
+
+	return ieee80211_wx_get_wap_rtl7(priv->ieee80211,info,wrqu,extra);
 }
 
 
-static int r8180_wx_get_enc(struct net_device *dev, 
-			    struct iw_request_info *info, 
+static int r8180_wx_get_enc(struct net_device *dev,
+			    struct iw_request_info *info,
 			    union iwreq_data *wrqu, char *key)
 {
-	struct r8180_priv *priv = ieee80211_priv(dev);
-	
-	return ieee80211_wx_get_encode(priv->ieee80211, info, wrqu, key);
+	struct r8180_priv *priv = ieee80211_priv_rtl7(dev);
+
+	return ieee80211_wx_get_encode_rtl7(priv->ieee80211, info, wrqu, key);
 }
 
-static int r8180_wx_set_enc(struct net_device *dev, 
-			    struct iw_request_info *info, 
+static int r8180_wx_set_enc(struct net_device *dev,
+			    struct iw_request_info *info,
 			    union iwreq_data *wrqu, char *key)
 {
-	struct r8180_priv *priv = ieee80211_priv(dev);
+	struct r8180_priv *priv = ieee80211_priv_rtl7(dev);
 	int ret;
-	
+
 	down(&priv->wx_sem);
-	
+
 		DMESG("Setting SW wep key");
-		ret = ieee80211_wx_set_encode(priv->ieee80211,info,wrqu,key);
-			
+		ret = ieee80211_wx_set_encode_rtl7(priv->ieee80211,info,wrqu,key);
+
 	up(&priv->wx_sem);
 	return ret;
 }
@@ -447,28 +568,28 @@
 
 static int r8180_wx_set_scan_type(struct net_device *dev, struct iw_request_info *aa, union
  iwreq_data *wrqu, char *p){
-  
- 	struct r8180_priv *priv = ieee80211_priv(dev);
+
+ 	struct r8180_priv *priv = ieee80211_priv_rtl7(dev);
 	int *parms=(int*)p;
 	int mode=parms[0];
-	
+
 	priv->ieee80211->active_scan = mode;
-	
+
 	return 1;
 }
 
 
 
-static int r8180_wx_set_retry(struct net_device *dev, 
-				struct iw_request_info *info, 
+static int r8180_wx_set_retry(struct net_device *dev,
+				struct iw_request_info *info,
 				union iwreq_data *wrqu, char *extra)
 {
-	struct r8180_priv *priv = ieee80211_priv(dev);
+	struct r8180_priv *priv = ieee80211_priv_rtl7(dev);
 	int err = 0;
-	
+
 	down(&priv->wx_sem);
-	
-	if (wrqu->retry.flags & IW_RETRY_LIFETIME || 
+
+	if (wrqu->retry.flags & IW_RETRY_LIFETIME ||
 	    wrqu->retry.disabled){
 		err = -EINVAL;
 		goto exit;
@@ -485,13 +606,13 @@
 	if (wrqu->retry.flags & IW_RETRY_MAX) {
 		priv->retry_rts = wrqu->retry.value;
 		DMESG("Setting retry for RTS/CTS data to %d", wrqu->retry.value);
-	
+
 	}else {
 		priv->retry_data = wrqu->retry.value;
 		DMESG("Setting retry for non RTS/CTS data to %d", wrqu->retry.value);
 	}
-	
-	/* FIXME ! 
+
+	/* FIXME !
 	 * We might try to write directly the TX config register
 	 * or to restart just the (R)TX process.
 	 * I'm unsure if whole reset is really needed
@@ -503,28 +624,28 @@
 		rtl8180_rtx_disable(dev);
 		rtl8180_rx_enable(dev);
 		rtl8180_tx_enable(dev);
-			
+
 	}
 	*/
 exit:
 	up(&priv->wx_sem);
-	
+
 	return err;
 }
 
-static int r8180_wx_get_retry(struct net_device *dev, 
-				struct iw_request_info *info, 
+static int r8180_wx_get_retry(struct net_device *dev,
+				struct iw_request_info *info,
 				union iwreq_data *wrqu, char *extra)
 {
-	struct r8180_priv *priv = ieee80211_priv(dev);
-	
+	struct r8180_priv *priv = ieee80211_priv_rtl7(dev);
+
 
 	wrqu->retry.disabled = 0; /* can't be disabled */
 
-	if ((wrqu->retry.flags & IW_RETRY_TYPE) == 
-	    IW_RETRY_LIFETIME) 
+	if ((wrqu->retry.flags & IW_RETRY_TYPE) ==
+	    IW_RETRY_LIFETIME)
 		return -EINVAL;
-	
+
 	if (wrqu->retry.flags & IW_RETRY_MAX) {
 		wrqu->retry.flags = IW_RETRY_LIMIT & IW_RETRY_MAX;
 		wrqu->retry.value = priv->retry_rts;
@@ -533,30 +654,30 @@
 		wrqu->retry.value = priv->retry_data;
 	}
 	//DMESG("returning %d",wrqu->retry.value);
-	
+
 
 	return 0;
 }
 
-static int r8180_wx_get_sens(struct net_device *dev, 
-				struct iw_request_info *info, 
+static int r8180_wx_get_sens(struct net_device *dev,
+				struct iw_request_info *info,
 				union iwreq_data *wrqu, char *extra)
 {
-	struct r8180_priv *priv = ieee80211_priv(dev);
-	if(priv->rf_set_sens == NULL) 
+	struct r8180_priv *priv = ieee80211_priv_rtl7(dev);
+	if(priv->rf_set_sens == NULL)
 		return -1; /* we have not this support for this radio */
 	wrqu->sens.value = priv->sens;
 	return 0;
 }
 
 
-static int r8180_wx_set_sens(struct net_device *dev, 
-				struct iw_request_info *info, 
+static int r8180_wx_set_sens(struct net_device *dev,
+				struct iw_request_info *info,
 				union iwreq_data *wrqu, char *extra)
 {
-	
-	struct r8180_priv *priv = ieee80211_priv(dev);
-	
+
+	struct r8180_priv *priv = ieee80211_priv_rtl7(dev);
+
 	short err = 0;
 	down(&priv->wx_sem);
 	//DMESG("attempt to set sensivity to %ddb",wrqu->sens.value);
@@ -571,7 +692,7 @@
 
 exit:
 	up(&priv->wx_sem);
-	
+
 	return err;
 }
 
@@ -623,50 +744,55 @@
         dummy,                    /* SIOCGIWRTS */
         r8180_wx_set_frag,        /* SIOCSIWFRAG */
         r8180_wx_get_frag,        /* SIOCGIWFRAG */
-        dummy,                    /* SIOCSIWTXPOW */
-        dummy,                    /* SIOCGIWTXPOW */
+        r8180_wx_set_txpow,       /* SIOCSIWTXPOW */
+        r8180_wx_get_txpow,       /* SIOCGIWTXPOW */
         r8180_wx_set_retry,       /* SIOCSIWRETRY */
         r8180_wx_get_retry,       /* SIOCGIWRETRY */
         r8180_wx_set_enc,         /* SIOCSIWENCODE */
         r8180_wx_get_enc,         /* SIOCGIWENCODE */
         dummy,                    /* SIOCSIWPOWER */
         dummy,                    /* SIOCGIWPOWER */
-}; 
+};
 
 
-static const struct iw_priv_args r8180_private_args[] = { 
-	
+static const struct iw_priv_args r8180_private_args[] = {
 	{
-		SIOCIWFIRSTPRIV + 0x0, 
-		IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "badcrc" 
-	}, 
-	
+		SIOCIWFIRSTPRIV + 0x0,
+		IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "fasttx"
+	},
+
 	{
 		SIOCIWFIRSTPRIV + 0x1,
-		IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "activescan"
-	
+		IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "highpower"
 	},
+
 	{
-		SIOCIWFIRSTPRIV + 0x2, 
-		IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "rawtx" 
+		SIOCIWFIRSTPRIV + 0x2,
+		IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "badcrc"
+	},
+
+	{
+		SIOCIWFIRSTPRIV + 0x3,
+		IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "activescan"
+
 	}
 };
 
 
 static iw_handler r8180_private_handler[] = {
-//	r8180_wx_set_monitor,  /* SIOCIWFIRSTPRIV */
+	r8180_wx_set_fasttx,   /* SIOCIWFIRSTPRIV */
+	r8180_wx_set_highpower,   /*SIOCIWSECONDPRIV*/
 	r8180_wx_set_crcmon,   /*SIOCIWSECONDPRIV*/
 //	r8180_wx_set_forceassociate,
 //	r8180_wx_set_beaconinterval,
 //	r8180_wx_set_monitor_type,
 	r8180_wx_set_scan_type,
-	r8180_wx_set_rawtx,
 };
 
-#if WIRELESS_EXT >= 17	
+#if WIRELESS_EXT >= 17
 static struct iw_statistics *r8180_get_wireless_stats(struct net_device *dev)
 {
-       struct r8180_priv *priv = ieee80211_priv(dev);
+       struct r8180_priv *priv = ieee80211_priv_rtl7(dev);
 
        return &priv->wstats;
 }
@@ -679,8 +805,8 @@
 	.private = r8180_private_handler,
 	.num_private = sizeof(r8180_private_handler) / sizeof(iw_handler),
  	.num_private_args = sizeof(r8180_private_args) / sizeof(struct iw_priv_args),
-#if WIRELESS_EXT >= 17	
+#if WIRELESS_EXT >= 17
 	.get_wireless_stats = r8180_get_wireless_stats,
 #endif
-	.private_args = (struct iw_priv_args *)r8180_private_args,	
+	.private_args = (struct iw_priv_args *)r8180_private_args,
 };
diff -Naur rtl8187_linux_26.1010.0622.2006/beta-8187/r8187_core.c rtl8187_linux_26.1010.0622.2006_rawtx/beta-8187/r8187_core.c
--- rtl8187_linux_26.1010.0622.2006/beta-8187/r8187_core.c	2006-06-22 07:43:30.000000000 +0200
+++ rtl8187_linux_26.1010.0622.2006_rawtx/beta-8187/r8187_core.c	2008-02-15 00:37:05.000000000 +0100
@@ -1,27 +1,27 @@
 /*
    This is part of rtl8187 OpenSource driver - v 0.1
-   Copyright (C) Andrea Merello 2005  <andreamrl@tiscali.it> 
+   Copyright (C) Andrea Merello 2005  <andreamrl@tiscali.it>
    Released under the terms of GPL (General Public License)
-   
-   
-   Parts of this driver are based on the rtl8180 driver skeleton 
+
+
+   Parts of this driver are based on the rtl8180 driver skeleton
    from Patric Schenke & Andres Salomon.
 
    Parts of this driver are based on the Intel Pro Wireless 2*00 GPL drivers.
-   
+
    some ideas might be derived from David Young rtl8180 netbsd driver.
-   
+
    Parts of the usb code are from the r8150.c driver in linux kernel
-   
+
    Some ideas borrowed from the 8139too.c driver included in linux kernel.
-   
-   We (I?) want to thanks the Authors of those projecs and also the 
+
+   We (I?) want to thanks the Authors of those projecs and also the
    Ndiswrapper's project Authors.
-   
-   A special big thanks goes also to Realtek corp. for their help in my 
-   attempt to add RTL8187 and RTL8225 support, and to David Young also. 
 
-	- Please note that this file is a modified version from rtl8180-sa2400 
+   A special big thanks goes also to Realtek corp. for their help in my
+   attempt to add RTL8187 and RTL8225 support, and to David Young also.
+
+	- Please note that this file is a modified version from rtl8180-sa2400
 	drv. So some other people have contributed to this project, and they are
 	thanked in the rtl8180-sa2400 CHANGELOG.
 */
@@ -57,6 +57,7 @@
 #undef DEBUG_IRQ_TASKLET
 #undef DEBUG_TX_ALLOC
 #undef DEBUG_TX_DESC
+#undef DEBUG_TX_POWER
 
 //#define CONFIG_RTL8180_IO_MAP
 
@@ -66,6 +67,9 @@
 #include "r8180_93cx6.h"   /* Card EEPROM */
 #include "r8180_wx.h"
 
+#if !(defined(CONFIG_USB_EHCI_HCD) || defined (CONFIG_USB_EHCI_HCD_MODULE))
+	#error	Build your kernel with ehci_hcd support!
+#endif
 
 // FIXME: check if 2.6.7 is ok
 #if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,7))
@@ -98,6 +102,10 @@
 #endif
 static int channels = 0x3fff;
 
+// #define DEBUG_EPROM
+// #define DEBUG_REGISTERS
+// #define DEBUG_TX_POWER
+
 MODULE_LICENSE("GPL");
 MODULE_VERSION("V 1.1");
 MODULE_DEVICE_TABLE(usb, rtl8187_usb_id_tbl);
@@ -137,7 +145,7 @@
 
 static int __devinit rtl8187_usb_probe(struct usb_interface *intf,
 			 const struct usb_device_id *id);
-			 
+
 static void __devexit rtl8187_usb_disconnect(struct usb_interface *intf);
 
 static struct usb_driver rtl8187_usb_driver = {
@@ -158,13 +166,12 @@
 #endif
 };
 
-
 void write_nic_byte_E(struct net_device *dev, int indx, u8 data)
 {
-	
-	struct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);
+
+	struct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv_rtl7(dev);
 	struct usb_device *udev = priv->udev;
-	
+
 	usb_control_msg(udev, usb_sndctrlpipe(udev, 0),
 			       RTL8187_REQ_SET_REGS, RTL8187_REQT_WRITE,
 			       indx|0xfe00, 0, &data, 1, HZ / 2);
@@ -173,10 +180,10 @@
 
 void write_nic_byte(struct net_device *dev, int indx, u8 data)
 {
-	
-	struct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);
+
+	struct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv_rtl7(dev);
 	struct usb_device *udev = priv->udev;
-	
+
 	usb_control_msg(udev, usb_sndctrlpipe(udev, 0),
 			       RTL8187_REQ_SET_REGS, RTL8187_REQT_WRITE,
 			       indx|0xff00, 0, &data, 1, HZ / 2);
@@ -185,10 +192,10 @@
 
 void write_nic_word(struct net_device *dev, int indx, u16 data)
 {
-	
-	struct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);
+
+	struct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv_rtl7(dev);
 	struct usb_device *udev = priv->udev;
-	
+
 	usb_control_msg(udev, usb_sndctrlpipe(udev, 0),
 			       RTL8187_REQ_SET_REGS, RTL8187_REQT_WRITE,
 			       indx|0xff00, 0, &data, 2, HZ / 2);
@@ -197,23 +204,23 @@
 
 void write_nic_dword(struct net_device *dev, int indx, u32 data)
 {
-	
-	struct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);
+
+	struct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv_rtl7(dev);
 	struct usb_device *udev = priv->udev;
-	
+
 	usb_control_msg(udev, usb_sndctrlpipe(udev, 0),
 			       RTL8187_REQ_SET_REGS, RTL8187_REQT_WRITE,
 			       indx|0xff00, 0, &data, 4, HZ / 2);
 }
- 
- 
- 
+
+
+
 u8 read_nic_byte(struct net_device *dev, int indx)
 {
 	u8 data;
-	struct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);
+	struct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv_rtl7(dev);
 	struct usb_device *udev = priv->udev;
-	
+
 	usb_control_msg(udev, usb_rcvctrlpipe(udev, 0),
 			       RTL8187_REQ_GET_REGS, RTL8187_REQT_READ,
 			       indx|0xff00, 0, &data, 1, HZ / 2);
@@ -223,22 +230,22 @@
 u8 read_nic_byte_E(struct net_device *dev, int indx)
 {
 	u8 data;
-	struct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);
+	struct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv_rtl7(dev);
 	struct usb_device *udev = priv->udev;
-	
+
 	usb_control_msg(udev, usb_rcvctrlpipe(udev, 0),
 			       RTL8187_REQ_GET_REGS, RTL8187_REQT_READ,
 			       indx|0xfe00, 0, &data, 1, HZ / 2);
 	return data;
 }
 
- 
+
 u16 read_nic_word(struct net_device *dev, int indx)
 {
 	u16 data;
-	struct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);
+	struct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv_rtl7(dev);
 	struct usb_device *udev = priv->udev;
-	
+
 	usb_control_msg(udev, usb_rcvctrlpipe(udev, 0),
 			       RTL8187_REQ_GET_REGS, RTL8187_REQT_READ,
 			       indx|0xff00, 0, &data, 2, HZ / 2);
@@ -249,16 +256,16 @@
 u32 read_nic_dword(struct net_device *dev, int indx)
 {
 	u32 data;
-	struct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);
+	struct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv_rtl7(dev);
 	struct usb_device *udev = priv->udev;
-	
+
 	usb_control_msg(udev, usb_rcvctrlpipe(udev, 0),
 			       RTL8187_REQ_GET_REGS, RTL8187_REQT_READ,
 			       indx|0xff00, 0, &data, 4, HZ / 2);
 	return data;
 }
 
-/* this might still called in what was the PHY rtl8185/rtl8187 common code 
+/* this might still called in what was the PHY rtl8185/rtl8187 common code
  * plans are to possibilty turn it again in one common code...
  */
 inline void force_pci_posting(struct net_device *dev)
@@ -271,7 +278,12 @@
 //void set_nic_txring(struct net_device *dev);
 static struct net_device_stats *rtl8180_stats(struct net_device *dev);
 void rtl8180_commit(struct net_device *dev);
+
+# if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20))
+void rtl8180_restart(struct work_struct *work);
+#else
 void rtl8180_restart(struct net_device *dev);
+#endif
 
 /****************************************************************************
    -----------------------------PROCFS STUFF-------------------------
@@ -284,13 +296,13 @@
 			  int *eof, void *data)
 {
 	struct net_device *dev = data;
-//	struct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);
-	
+//	struct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv_rtl7(dev);
+
 	int len = 0;
 	int i,n;
-			
+
 	int max=0xff;
-	
+
 	/* This dump the current register page */
 	for(n=0;n<=max;)
 	{
@@ -307,7 +319,7 @@
 	len += snprintf(page + len, count - len,"\n");
 
 
-		
+
 	*eof = 1;
 	return len;
 
@@ -319,16 +331,16 @@
 			  int *eof, void *data)
 {
 	struct net_device *dev = data;
-	struct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);
-	
+	struct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv_rtl7(dev);
+
 	int len = 0;
-	
+
 	len += snprintf(page + len, count - len,
 		"NIC int: %lu\n"
 		"Total int: %lu\n",
 		priv->stats.ints,
 		priv->stats.shints);
-			
+
 	*eof = 1;
 	return len;
 }
@@ -339,10 +351,10 @@
 			  int *eof, void *data)
 {
 	struct net_device *dev = data;
-	struct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);
-	
+	struct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv_rtl7(dev);
+
 	int len = 0;
-	
+
 	len += snprintf(page + len, count - len,
 		"TX normal priority ok int: %lu\n"
 		"TX normal priority error int: %lu\n"
@@ -359,7 +371,7 @@
 		"TX HW queue: %d\n"
 		"TX lp dropped: %lu\n"
 		"TX np dropped: %lu\n"
-		"TX total data packets %lu\n",		
+		"TX total data packets %lu\n",
 //		"TX beacon aborted: %lu\n",
 		priv->stats.txnpokint,
 		priv->stats.txnperr,
@@ -379,10 +391,10 @@
 		priv->stats.txdatapkt
 //		priv->stats.txbeaconerr
 		);
-			
+
 	*eof = 1;
 	return len;
-}		
+}
 
 
 
@@ -391,10 +403,10 @@
 			  int *eof, void *data)
 {
 	struct net_device *dev = data;
-	struct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);
-	
+	struct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv_rtl7(dev);
+
 	int len = 0;
-	
+
 	len += snprintf(page + len, count - len,
 		"RX packets: %lu\n"
 		"RX urb status error: %lu\n"
@@ -402,35 +414,44 @@
 		priv->stats.rxok,
 		priv->stats.rxstaterr,
 		priv->stats.rxurberr);
-			
+
 	*eof = 1;
 	return len;
-}		
-
+}
 
+#if WIRELESS_EXT < 17
 static struct iw_statistics *r8180_get_wireless_stats(struct net_device *dev)
 {
-       struct r8180_priv *priv = ieee80211_priv(dev);
+       struct r8180_priv *priv = ieee80211_priv_rtl7(dev);
 
        return &priv->wstats;
 }
+#endif
 
 void rtl8180_proc_module_init(void)
-{	
+{
 	DMESG("Initializing proc filesystem");
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,24)
 	rtl8180_proc=create_proc_entry(RTL8187_MODULE_NAME, S_IFDIR, proc_net);
+#else
+	rtl8180_proc=create_proc_entry(RTL8187_MODULE_NAME, S_IFDIR, init_net.proc_net);
+#endif
 }
 
 
 void rtl8180_proc_module_remove(void)
 {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,24)
 	remove_proc_entry(RTL8187_MODULE_NAME, proc_net);
+#else
+	remove_proc_entry(RTL8187_MODULE_NAME, init_net.proc_net);
+#endif
 }
 
 
 void rtl8180_proc_remove_one(struct net_device *dev)
 {
-	struct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);
+	struct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv_rtl7(dev);
 	if (priv->dir_dev) {
 	//	remove_proc_entry("stats-hw", priv->dir_dev);
 		remove_proc_entry("stats-tx", priv->dir_dev);
@@ -447,9 +468,9 @@
 void rtl8180_proc_init_one(struct net_device *dev)
 {
 	struct proc_dir_entry *e;
-	struct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);
-	priv->dir_dev = create_proc_entry(dev->name, 
-					  S_IFDIR | S_IRUGO | S_IXUGO, 
+	struct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv_rtl7(dev);
+	priv->dir_dev = create_proc_entry(dev->name,
+					  S_IFDIR | S_IRUGO | S_IXUGO,
 					  rtl8180_proc);
 	if (!priv->dir_dev) {
 		DMESGE("Unable to initialize /proc/net/rtl8187/%s\n",
@@ -459,7 +480,7 @@
 	#if 0
 	e = create_proc_read_entry("stats-hw", S_IFREG | S_IRUGO,
 				   priv->dir_dev, proc_get_stats_hw, dev);
-				   
+
 	if (!e) {
 		DMESGE("Unable to initialize "
 		      "/proc/net/rtl8187/%s/stats-hw\n",
@@ -468,17 +489,17 @@
 	#endif
 	e = create_proc_read_entry("stats-rx", S_IFREG | S_IRUGO,
 				   priv->dir_dev, proc_get_stats_rx, dev);
-				   
+
 	if (!e) {
 		DMESGE("Unable to initialize "
 		      "/proc/net/rtl8187/%s/stats-rx\n",
 		      dev->name);
 	}
-	
-	
+
+
 	e = create_proc_read_entry("stats-tx", S_IFREG | S_IRUGO,
 				   priv->dir_dev, proc_get_stats_tx, dev);
-				   
+
 	if (!e) {
 		DMESGE("Unable to initialize "
 		      "/proc/net/rtl8187/%s/stats-tx\n",
@@ -487,27 +508,27 @@
 	#if 0
 	e = create_proc_read_entry("stats-ieee", S_IFREG | S_IRUGO,
 				   priv->dir_dev, proc_get_stats_ieee, dev);
-				   
+
 	if (!e) {
 		DMESGE("Unable to initialize "
 		      "/proc/net/rtl8187/%s/stats-ieee\n",
 		      dev->name);
 	}
-	
-	
+
+
 	e = create_proc_read_entry("stats-ap", S_IFREG | S_IRUGO,
 				   priv->dir_dev, proc_get_stats_ap, dev);
-				   
+
 	if (!e) {
 		DMESGE("Unable to initialize "
 		      "/proc/net/rtl8187/%s/stats-ap\n",
 		      dev->name);
 	}
 	#endif
-	
+
 	e = create_proc_read_entry("registers", S_IFREG | S_IRUGO,
 				   priv->dir_dev, proc_get_registers, dev);
-	
+
 	if (!e) {
 		DMESGE("Unable to initialize "
 		      "/proc/net/rtl8187/%s/registers\n",
@@ -523,14 +544,14 @@
 {
 	int i;
 	u8 *buf =(u8*)buffer;
-	
+
 	printk("ASCII BUFFER DUMP (len: %x):\n",len);
-	
+
 	for(i=0;i<len;i++)
 		printk("%c",buf[i]);
-		
+
 	printk("\nBINARY BUFFER DUMP (len: %x):\n",len);
-	
+
 	for(i=0;i<len;i++)
 		printk("%x",buf[i]);
 
@@ -539,17 +560,17 @@
 
 short check_nic_enought_desc(struct net_device *dev, priority_t priority)
 {
-	struct r8180_priv *priv = ieee80211_priv(dev);
-	
-	int used = atomic_read((priority == NORM_PRIORITY) ? 
+	struct r8180_priv *priv = ieee80211_priv_rtl7(dev);
+
+	int used = atomic_read((priority == NORM_PRIORITY) ?
 		&priv->tx_np_pending : &priv->tx_lp_pending);
-	
+
 	return (used < MAX_TX_URB);
 }
 
 void tx_timeout(struct net_device *dev)
 {
-	struct r8180_priv *priv = ieee80211_priv(dev);
+	struct r8180_priv *priv = ieee80211_priv_rtl7(dev);
 	//rtl8180_commit(dev);
 	schedule_work(&priv->reset_wq);
 	//DMESG("TXTIMEOUT");
@@ -561,7 +582,20 @@
 {
 	int i;
 	for(i=0; i<63; i++)
-		DMESG("EEPROM addr %x : %x", i, eprom_read(dev,i));
+		DMESG("EEPROM addr %02X : %04X", i, eprom_read(dev,i));
+}
+
+/* this is only for debug */
+void dump_tx_power(struct net_device *dev)
+{
+	struct r8180_priv *priv = ieee80211_priv_rtl7(dev);
+	int i;
+	DMESG("CCK TX-Power (b-mode):");
+	for(i=1; i<=14; i++)
+		DMESG("Channel %d: %d", i, priv->chtxpwr[i]);
+	DMESG("OFDM TX-Power (g-mode):");
+	for(i=1; i<=14; i++)
+		DMESG("Channel %d: %d", i, priv->chtxpwr_ofdm[i]);
 }
 
 /* this is only for debug */
@@ -570,14 +604,14 @@
 	int i;
 	int n;
 	int max=0xff;
-	
-	DMESG("Dumping NIC register map");	
-	
+
+	DMESG("Dumping NIC register map");
+
 	for(n=0;n<=max;)
 	{
-		printk( "\nD: %2x> ", n);
+		printk( "\nD: %02X> ", n);
 		for(i=0;i<16 && n<=max;i++,n++)
-			printk("%2x ",read_nic_byte(dev,n));
+			printk("%02X ",read_nic_byte(dev,n));
 	}
 	printk("\n");
 }
@@ -589,11 +623,11 @@
 
 void rtl8180_irq_enable(struct net_device *dev)
 {
-	struct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);	
+	struct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv_rtl7(dev);
 	//priv->irq_enabled = 1;
 /*
-	write_nic_word(dev,INTA_MASK,INTA_RXOK | INTA_RXDESCERR | INTA_RXOVERFLOW |\ 
-	INTA_TXOVERFLOW | INTA_HIPRIORITYDESCERR | INTA_HIPRIORITYDESCOK |\ 
+	write_nic_word(dev,INTA_MASK,INTA_RXOK | INTA_RXDESCERR | INTA_RXOVERFLOW |\
+	INTA_TXOVERFLOW | INTA_HIPRIORITYDESCERR | INTA_HIPRIORITYDESCOK |\
 	INTA_NORMPRIORITYDESCERR | INTA_NORMPRIORITYDESCOK |\
 	INTA_LOWPRIORITYDESCERR | INTA_LOWPRIORITYDESCOK | INTA_TIMEOUT);
 */
@@ -603,7 +637,7 @@
 
 void rtl8180_irq_disable(struct net_device *dev)
 {
-//	struct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);	
+//	struct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv_rtl7(dev);
 
 	write_nic_word(dev,INTA_MASK,0);
 	force_pci_posting(dev);
@@ -625,115 +659,119 @@
 
 void rtl8180_update_msr(struct net_device *dev)
 {
-	struct r8180_priv *priv = ieee80211_priv(dev);
+	struct r8180_priv *priv = ieee80211_priv_rtl7(dev);
 	u8 msr;
-	
+
 	msr  = read_nic_byte(dev, MSR);
 	msr &= ~ MSR_LINK_MASK;
-	
+
 	/* do not change in link_state != WLAN_LINK_ASSOCIATED.
-	 * msr must be updated if the state is ASSOCIATING. 
+	 * msr must be updated if the state is ASSOCIATING.
 	 * this is intentional and make sense for ad-hoc and
 	 * master (see the create BSS/IBSS func)
 	 */
-	if (priv->ieee80211->state == IEEE80211_LINKED){ 
-			
+	if (priv->ieee80211->state == IEEE80211_LINKED){
+
 		if (priv->ieee80211->iw_mode == IW_MODE_INFRA)
 			msr |= (MSR_LINK_MANAGED<<MSR_LINK_SHIFT);
 		else if (priv->ieee80211->iw_mode == IW_MODE_ADHOC)
 			msr |= (MSR_LINK_ADHOC<<MSR_LINK_SHIFT);
 		else if (priv->ieee80211->iw_mode == IW_MODE_MASTER)
 			msr |= (MSR_LINK_MASTER<<MSR_LINK_SHIFT);
-		
+
 	}else
 		msr |= (MSR_LINK_NONE<<MSR_LINK_SHIFT);
-		
+
 	write_nic_byte(dev, MSR, msr);
 }
 
 void rtl8180_set_chan(struct net_device *dev,short ch)
 {
-	struct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);
+	struct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv_rtl7(dev);
 	u32 tx;
 	priv->chan=ch;
 	#if 0
-	if(priv->ieee80211->iw_mode == IW_MODE_ADHOC || 
+	if(priv->ieee80211->iw_mode == IW_MODE_ADHOC ||
 		priv->ieee80211->iw_mode == IW_MODE_MASTER){
-	
-			priv->ieee80211->link_state = WLAN_LINK_ASSOCIATED;	
+
+			priv->ieee80211->link_state = WLAN_LINK_ASSOCIATED;
 			priv->ieee80211->master_chan = ch;
-			rtl8180_update_beacon_ch(dev); 
+			rtl8180_update_beacon_ch(dev);
 		}
 	#endif
-	
+
 	/* this hack should avoid frame TX during channel setting*/
 	tx = read_nic_dword(dev,TX_CONF);
 	tx &= ~TX_LOOPBACK_MASK;
 
-#ifndef LOOP_TEST	
+#ifndef LOOP_TEST
 	write_nic_dword(dev,TX_CONF, tx |( TX_LOOPBACK_MAC<<TX_LOOPBACK_SHIFT));
-
 	priv->rf_set_chan(dev,priv->chan);
 	mdelay(10);
-	write_nic_dword(dev,TX_CONF,tx | (TX_LOOPBACK_NONE<<TX_LOOPBACK_SHIFT));
+ 	write_nic_dword(dev,TX_CONF,tx | (TX_LOOPBACK_NONE<<TX_LOOPBACK_SHIFT));
 #endif
 }
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19))
 void rtl8187_rx_isr(struct urb *rx_urb, struct pt_regs *regs);
+#else
+void rtl8187_rx_isr(struct urb *rx_urb);
+#endif
 
 
 void rtl8187_rx_urbsubmit(struct net_device *dev, struct urb* rx_urb)
 {
-	struct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);
+	struct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv_rtl7(dev);
 	int err;
-	
+
 //	u8 *rx;
-	
+
 	//DMESG("starting RX");
 	/*rx = kmalloc(RX_URB_SIZE*sizeof(u8),GFP_ATOMIC);
-	if(!rx){ 
+	if(!rx){
 		DMESGE("unable to allocate RX buffer");
 		return;
 	}*/
-	
+
 	usb_fill_bulk_urb(rx_urb,priv->udev,
 		usb_rcvbulkpipe(priv->udev,0x81), rx_urb->transfer_buffer,
 			RX_URB_SIZE,rtl8187_rx_isr,dev);
-	err = usb_submit_urb(rx_urb, GFP_ATOMIC);	
+	err = usb_submit_urb(rx_urb, GFP_ATOMIC);
 	if(err && err != -EPERM){
 		DMESGE("cannot submit RX command. URB_STATUS %x",rx_urb->status);
-		
+
 	}
-	
+
 }
 
 
 void rtl8187_rx_initiate(struct net_device *dev)
 {
 	int i;
-	struct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);
-	
+	struct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv_rtl7(dev);
+
 	if(!priv->rx_urb)
 		DMESGE("Cannot intiate RX urb mechanism");
-	for(i=0;i<MAX_RX_URB;i++) // RX_MAX_URB is 1 
+	for(i=0;i<MAX_RX_URB;i++) // RX_MAX_URB is 1
 		rtl8187_rx_urbsubmit(dev,priv->rx_urb[i]);
-		
+
 }
 
 void rtl8187_set_rxconf(struct net_device *dev)
 {
-	struct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);
+	struct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv_rtl7(dev);
 	u32 rxconf;
-	
+
 	rxconf=read_nic_dword(dev,RX_CONF);
 	rxconf = rxconf &~ MAC_FILTER_MASK;
 	rxconf = rxconf | (1<<ACCEPT_MNG_FRAME_SHIFT);
 	rxconf = rxconf | (1<<ACCEPT_DATA_FRAME_SHIFT);
 	rxconf = rxconf | (1<<ACCEPT_BCAST_FRAME_SHIFT);
 	rxconf = rxconf | (1<<ACCEPT_MCAST_FRAME_SHIFT);
-	rxconf = rxconf | (1<<ACCEPT_CTL_FRAME_SHIFT);	
+	rxconf = rxconf | (1<<ACCEPT_CTL_FRAME_SHIFT);
 
 	if (dev->flags & IFF_PROMISC) DMESG ("NIC in promisc mode");
-	
+
 	if(priv->ieee80211->iw_mode == IW_MODE_MONITOR || \
 	   dev->flags & IFF_PROMISC){
 		rxconf = rxconf | (1<<ACCEPT_ALLMAC_FRAME_SHIFT);
@@ -741,40 +779,40 @@
 		rxconf = rxconf | (1<<ACCEPT_NICMAC_FRAME_SHIFT);
 		rxconf = rxconf | (1<<RX_CHECK_BSSID_SHIFT);
 	}
-	
+
 	/*if(priv->ieee80211->iw_mode == IW_MODE_MASTER){
 		rxconf = rxconf | (1<<ACCEPT_ALLMAC_FRAME_SHIFT);
 		rxconf = rxconf | (1<<RX_CHECK_BSSID_SHIFT);
 	}*/
-	
+
 	if(priv->ieee80211->iw_mode == IW_MODE_MONITOR){
 		rxconf = rxconf | (1<<ACCEPT_ICVERR_FRAME_SHIFT);
 		rxconf = rxconf | (1<<ACCEPT_PWR_FRAME_SHIFT);
 	}
-	
+
 	if( priv->crcmon == 1 && priv->ieee80211->iw_mode == IW_MODE_MONITOR)
 		rxconf = rxconf | (1<<ACCEPT_CRCERR_FRAME_SHIFT);
-	
-	
+
+
 	rxconf = rxconf &~ RX_FIFO_THRESHOLD_MASK;
 	rxconf = rxconf | (RX_FIFO_THRESHOLD_NONE<<RX_FIFO_THRESHOLD_SHIFT);
-	
-	
+
+
 	rxconf = rxconf | (1<<RX_AUTORESETPHY_SHIFT);
-	
+
 	rxconf = rxconf &~ MAX_RX_DMA_MASK;
 	rxconf = rxconf | (MAX_RX_DMA_2048<<MAX_RX_DMA_SHIFT);
-	
+
 	rxconf = rxconf | RCR_ONLYERLPKT;
-	
+
 //	rxconf = rxconf &~ RCR_CS_MASK;
 //	rxconf = rxconf | (1<<RCR_CS_SHIFT);
 
-	write_nic_dword(dev, RX_CONF, rxconf);	
-	
+	write_nic_dword(dev, RX_CONF, rxconf);
+
 	// V rtl suggested V //
 //	write_nic_dword(dev, RX_CONF, 0x901ce70e);
-	
+
 	//fix_rx_fifo(dev);
 // 	//set_nic_rxring(dev);
 	#ifdef DEBUG_RX
@@ -785,23 +823,23 @@
 void rtl8180_rx_enable(struct net_device *dev)
 {
 	u8 cmd;
-	
-	
+
+
 	rtl8187_rx_initiate(dev);
 
-	rtl8187_set_rxconf(dev);	
+	rtl8187_set_rxconf(dev);
 
 	cmd=read_nic_byte(dev,CMD);
 	write_nic_byte(dev,CMD,cmd | (1<<CMD_RX_ENABLE_SHIFT));
 #if 0
-	/* In rtl8139 driver seems that DMA threshold has to be written 
-	 *  after enabling RX, so we rewrite RX_CONFIG register 
+	/* In rtl8139 driver seems that DMA threshold has to be written
+	 *  after enabling RX, so we rewrite RX_CONFIG register
 	 */
 	//mdelay(100);
-	write_nic_dword(dev, RX_CONF, rxconf); 
-	
+	write_nic_dword(dev, RX_CONF, rxconf);
+
 #endif
-	
+
 }
 
 
@@ -810,37 +848,37 @@
 	u8 cmd;
 	u8 byte;
 	u32 txconf;
-	struct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);
-	
+	struct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv_rtl7(dev);
+
 	byte = read_nic_byte(dev,CW_CONF);
 	byte &= ~(1<<CW_CONF_PERPACKET_CW_SHIFT);
 	byte &= ~(1<<CW_CONF_PERPACKET_RETRY_SHIFT);
 	write_nic_byte(dev, CW_CONF, byte);
-	
+
 	byte = read_nic_byte(dev, TX_AGC_CTL);
 	byte &= ~(1<<TX_AGC_CTL_PERPACKET_GAIN_SHIFT);
 	byte &= ~(1<<TX_AGC_CTL_PERPACKET_ANTSEL_SHIFT);
 	byte &= ~(1<<TX_AGC_CTL_FEEDBACK_ANT);
 	write_nic_byte(dev, TX_AGC_CTL, byte);
-	
+
 	txconf= read_nic_dword(dev,TX_CONF);
-	
+
 	#if 0
 	if(priv->card_8185){
-		
+
 		txconf = txconf &~ (1<<TCR_PROBE_NOTIMESTAMP_SHIFT);
-	
+
 	}else{
-	
-		if(priv->ieee80211->hw_seq) 
+
+		if(priv->ieee80211->hw_seq)
 			txconf= txconf &~ (1<<TX_CONF_HEADER_AUTOICREMENT_SHIFT);
-		else 
+		else
 			txconf= txconf | (1<<TX_CONF_HEADER_AUTOICREMENT_SHIFT);
 	}
 	#endif
 
 	txconf = txconf &~ TX_LOOPBACK_MASK;
-	
+
 #ifndef LOOP_TEST
 	txconf = txconf | (TX_LOOPBACK_NONE<<TX_LOOPBACK_SHIFT);
 #else
@@ -848,23 +886,26 @@
 #endif
 	txconf = txconf &~ TCR_DPRETRY_MASK;
 	txconf = txconf &~ TCR_RTSRETRY_MASK;
-	
-	txconf = txconf | (priv->retry_data<<TX_DPRETRY_SHIFT); // long
-	txconf = txconf | (priv->retry_rts<<TX_RTSRETRY_SHIFT); // short
-	
+
+	if(priv->ieee80211->iw_mode != IW_MODE_MONITOR)
+	{
+		txconf = txconf | (priv->retry_data<<TX_DPRETRY_SHIFT); // long
+		txconf = txconf | (priv->retry_rts<<TX_RTSRETRY_SHIFT); // short
+	}
+
 	txconf = txconf &~ (1<<TX_NOCRC_SHIFT);
-	
+
 	txconf = txconf &~ TCR_MXDMA_MASK;
 	txconf = txconf | (TCR_MXDMA_2048<<TCR_MXDMA_SHIFT);
-	
+
 	txconf = txconf | TCR_CWMIN;
 	txconf = txconf | TCR_DISCW;
 	txconf = txconf &~ TCR_SWPLCPLEN;
-	
+
 	txconf=txconf | (1<<TX_NOICV_SHIFT);
-	
+
 	write_nic_dword(dev,TX_CONF,txconf);
-	
+
 	// V RTL suggested V //
 //	write_nic_dword(dev,TX_CONF,0x00e00707);
 
@@ -872,9 +913,9 @@
 #ifdef DEBUG_TX
 	DMESG("txconf: %x %x",txconf,read_nic_dword(dev,TX_CONF));
 #endif
-	
+
 	cmd=read_nic_byte(dev,CMD);
-	write_nic_byte(dev,CMD,cmd | (1<<CMD_TX_ENABLE_SHIFT));		
+	write_nic_byte(dev,CMD,cmd | (1<<CMD_TX_ENABLE_SHIFT));
 
 //	mdelay(100);
 	//write_nic_dword(dev,TX_CONF,txconf);
@@ -889,18 +930,18 @@
 #if 0
 void rtl8180_beacon_tx_enable(struct net_device *dev)
 {
-	struct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);
+	struct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv_rtl7(dev);
 	priv->dma_poll_mask &=~(1<<TX_DMA_STOP_BEACON_SHIFT);
 	rtl8180_set_mode(dev,EPROM_CMD_CONFIG);
-	write_nic_byte(dev,TX_DMA_POLLING,priv->dma_poll_mask);	
+	write_nic_byte(dev,TX_DMA_POLLING,priv->dma_poll_mask);
 	rtl8180_set_mode(dev,EPROM_CMD_NORMAL);
 }
 
 
 void rtl8180_
-_disable(struct net_device *dev) 
+_disable(struct net_device *dev)
 {
-	struct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);
+	struct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv_rtl7(dev);
 	priv->dma_poll_mask |= (1<<TX_DMA_STOP_BEACON_SHIFT);
 	rtl8180_set_mode(dev,EPROM_CMD_CONFIG);
 	write_nic_byte(dev,TX_DMA_POLLING,priv->dma_poll_mask);
@@ -914,8 +955,8 @@
 {
 	u8 cmd;
 	int i;
-	struct r8180_priv *priv = ieee80211_priv(dev);
-	
+	struct r8180_priv *priv = ieee80211_priv_rtl7(dev);
+
 	cmd=read_nic_byte(dev,CMD);
 	write_nic_byte(dev, CMD, cmd &~ \
 		       ((1<<CMD_RX_ENABLE_SHIFT)|(1<<CMD_TX_ENABLE_SHIFT)));
@@ -926,9 +967,9 @@
 		usb_kill_urb(priv->rx_urb[i]);
 	}
 	/*while (read_nic_byte(dev,CMD) & (1<<CMD_RX_ENABLE_SHIFT))
-	  udelay(10); 
+	  udelay(10);
 	*/
-	
+
 //	if(!priv->rx_skb_complete)
 //		dev_kfree_skb_any(priv->rx_skb);
 }
@@ -939,14 +980,14 @@
 	#if 0
 	int i;
 	u32 *tmp;
-	struct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);
-	
+	struct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv_rtl7(dev);
+
 	priv->txbeaconring = (u32*)pci_alloc_consistent(priv->pdev,
-					  sizeof(u32)*8*count, 
+					  sizeof(u32)*8*count,
 					  &priv->txbeaconringdma);
 	if (!priv->txbeaconring) return -1;
 	for (tmp=priv->txbeaconring,i=0;i<count;i++){
-		*tmp = *tmp &~ (1<<31); // descriptor empty, owned by the drv 
+		*tmp = *tmp &~ (1<<31); // descriptor empty, owned by the drv
 		/*
 		*(tmp+2) = (u32)dma_tmp;
 		*(tmp+3) = bufsize;
@@ -955,7 +996,7 @@
 			*(tmp+4) = (u32)priv->txbeaconringdma+((i+1)*8*4);
 		else
 			*(tmp+4) = (u32)priv->txbeaconringdma;
-		
+
 		tmp=tmp+8;
 	}
 	#endif
@@ -965,15 +1006,15 @@
 
 void rtl8180_reset(struct net_device *dev)
 {
-	
+
 	u8 cr;
-	
+
 	/* make sure the analog power is on before
 	 * reset, otherwise reset may fail
 	 */
 	rtl8180_set_anaparam(dev, RTL8225_ANAPARAM_ON);
 	rtl8185_set_anaparam2(dev, RTL8225_ANAPARAM2_ON);
-	
+
 	rtl8180_irq_disable(dev);
 
 	mdelay(200);
@@ -981,19 +1022,19 @@
 	write_nic_byte_E(dev,0x18,0x11);
 	write_nic_byte_E(dev,0x18,0x00);
 	mdelay(200);
-	
+
 	cr=read_nic_byte(dev,CMD);
 	cr = cr & 2;
 	cr = cr | (1<<CMD_RST_SHIFT);
 	write_nic_byte(dev,CMD,cr);
-	
+
 	force_pci_posting(dev);
-	
+
 	mdelay(200);
-	
-	if(read_nic_byte(dev,CMD) & (1<<CMD_RST_SHIFT)) 
+
+	if(read_nic_byte(dev,CMD) & (1<<CMD_RST_SHIFT))
 		DMESGW("Card reset timeout!");
-	else 
+	else
 		DMESG("Card successfully reset");
 
 	rtl8180_set_mode(dev,EPROM_CMD_LOAD);
@@ -1005,13 +1046,13 @@
 	 */
 	rtl8180_set_anaparam(dev, RTL8225_ANAPARAM_ON);
 	rtl8185_set_anaparam2(dev, RTL8225_ANAPARAM2_ON);
-	
+
 }
 
 inline u16 ieeerate2rtlrate(int rate)
 {
 	switch(rate){
-	case 10:	
+	case 10:
 	return 0;
 	case 20:
 	return 1;
@@ -1037,32 +1078,42 @@
 	return 11;
 	default:
 	return 3;
-	
+
 	}
 }
 static u16 rtl_rate[] = {10,20,55,110,60,90,120,180,240,360,480,540};
 inline u16 rtl8180_rate2rate(short rate)
 {
 	if (rate >11) return 0;
-	return rtl_rate[rate]; 
+	return rtl_rate[rate];
+}
+
+inline u8 rtl8180_IsWirelessBMode(u16 rate)
+{
+	if( ((rate <= 110) && (rate != 60) && (rate != 90)) || (rate == 220) )
+		return 1;
+	else return 0;
 }
-		
 
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19))
 void rtl8187_rx_isr(struct urb *rx_urb, struct pt_regs *regs)
+#else
+void rtl8187_rx_isr(struct urb *rx_urb)
+#endif
 {
 	struct net_device *dev = (struct net_device*)rx_urb->context;
-	struct r8180_priv *priv = ieee80211_priv(dev);
+	struct r8180_priv *priv = ieee80211_priv_rtl7(dev);
 
 	priv->rxurb_task = rx_urb;
 //	DMESGW("David: Rx tasklet start!");
-	tasklet_schedule(&priv->irq_rx_tasklet);	
+	tasklet_schedule(&priv->irq_rx_tasklet);
 //	DMESGW("=David: Rx tasklet finish!");
 }
 
 #if 0
 void rtl8180_tx_queues_stop(struct net_device *dev)
 {
-	//struct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);
+	//struct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv_rtl7(dev);
 	u8 dma_poll_mask = (1<<TX_DMA_STOP_LOWPRIORITY_SHIFT);
 	dma_poll_mask |= (1<<TX_DMA_STOP_HIPRIORITY_SHIFT);
 	dma_poll_mask |= (1<<TX_DMA_STOP_NORMPRIORITY_SHIFT);
@@ -1078,7 +1129,7 @@
 {
 	//FIXME !!
 	#if 0
-	struct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);
+	struct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv_rtl7(dev);
 	priv->dma_poll_mask |= (1<<TX_DMA_STOP_LOWPRIORITY_SHIFT);
 	rtl8180_set_mode(dev,EPROM_CMD_CONFIG);
 	write_nic_byte(dev,TX_DMA_POLLING,priv->dma_poll_mask);
@@ -1091,7 +1142,7 @@
 {
 	// FIXME !!
 	#if 0
-	struct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);
+	struct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv_rtl7(dev);
 	priv->dma_poll_mask &= ~(1<<TX_DMA_STOP_LOWPRIORITY_SHIFT);
 	rtl8180_set_mode(dev,EPROM_CMD_CONFIG);
 	write_nic_byte(dev,TX_DMA_POLLING,priv->dma_poll_mask);
@@ -1105,14 +1156,19 @@
  */
 void rtl8180_hard_data_xmit(struct sk_buff *skb, struct net_device *dev, int rate)
 {
-	struct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);
-	
-	short morefrag = 0;	
+	struct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv_rtl7(dev);
+
+	short morefrag = 0;
 	unsigned long flags;
 	struct ieee80211_hdr *h = (struct ieee80211_hdr  *) skb->data;
 
-	if (le16_to_cpu(h->frame_ctl) & IEEE80211_FCTL_MOREFRAGS)
-		morefrag = 1;
+	if(priv->ieee80211->iw_mode != IW_MODE_MONITOR || priv->ieee80211->raw_tx != 1)
+	{
+		if (le16_to_cpu(h->frame_ctl) & IEEE80211_FCTL_MOREFRAGS)
+		{
+			morefrag = 1;
+		}
+	}
 //	DMESG("%x %x", h->frame_ctl, h->seq_ctl);
 	/*
 	* This function doesn't require lock because we make
@@ -1121,24 +1177,29 @@
 	* the ieee stack, or from the try_wake_queue (again trought
 	* the ieee stack.
 	*/
-	spin_lock_irqsave(&priv->tx_lock,flags);	
-			
-	//DMESG("TX");
-	if (!check_nic_enought_desc(dev, LOW_PRIORITY)){
-		DMESG("Error: no TX slot ");
-		ieee80211_stop_queue(priv->ieee80211);
-	}
-	
-	rtl8180_tx(dev, (u32*)skb->data, skb->len, LOW_PRIORITY, morefrag,
-		ieeerate2rtlrate(rate));
-
-	priv->stats.txdatapkt++;
-	
-	if (!check_nic_enought_desc(dev, LOW_PRIORITY))
-		ieee80211_stop_queue(priv->ieee80211);
-		
-	spin_unlock_irqrestore(&priv->tx_lock,flags);	
-			
+
+	if(priv->ieee80211->iw_mode != IW_MODE_MONITOR || priv->fasttx == 0)
+	{
+		spin_lock_irqsave(&priv->tx_lock,flags);
+		//DMESG("TX");
+		if (!check_nic_enought_desc(dev, LOW_PRIORITY)){
+			DMESG("Error: no TX slot ");
+			ieee80211_stop_queue_rtl7(priv->ieee80211);
+		}
+		rtl8180_tx(dev, (u32*)skb->data, skb->len, LOW_PRIORITY, morefrag,
+			ieeerate2rtlrate(rate));
+
+		priv->stats.txdatapkt++;
+
+		if (!check_nic_enought_desc(dev, LOW_PRIORITY))
+			ieee80211_stop_queue_rtl7(priv->ieee80211);
+		spin_unlock_irqrestore(&priv->tx_lock,flags);
+	}
+	else
+	{
+		rtl8180_tx_fast(dev, (u32*)skb->data, skb->len, ieeerate2rtlrate(rate));
+	}
+
 }
 #if 0
 /* This is a rough attempt to TX a frame
@@ -1148,12 +1209,12 @@
  */
 int rtl8180_hard_start_xmit(struct sk_buff *skb,struct net_device *dev)
 {
-	struct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);
+	struct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv_rtl7(dev);
 	int ret;
 	unsigned long flags;
-	
+
 	spin_lock_irqsave(&priv->tx_lock,flags);
-	
+
 	ret = rtl8180_tx(dev, (u32*)skb->data, skb->len, NORM_PRIORITY, 0,DEFAULT_BASICRATE);
 /*
 	int i;
@@ -1163,9 +1224,9 @@
 */
 	priv->ieee80211->stats.tx_bytes+=skb->len;
 	priv->ieee80211->stats.tx_packets++;
-	
-	spin_unlock_irqrestore(&priv->tx_lock,flags);	
-	
+
+	spin_unlock_irqrestore(&priv->tx_lock,flags);
+
 	dev_kfree_skb_any(skb);
 	return ret;
 }
@@ -1178,7 +1239,7 @@
 	u16 duration;
 	u16 drift;
 	*ext=0;
-	
+
 	switch(rate){
 	case 0://1mbps
 		*ext=0;
@@ -1187,7 +1248,7 @@
 		if(drift ==0 ) break;
 		duration++;
 		break;
-		
+
 	case 1://2mbps
 		*ext=0;
 		duration = ((len+4)<<4) /0x4;
@@ -1195,40 +1256,44 @@
 		if(drift ==0 ) break;
 		duration++;
 		break;
-		
+
 	case 2: //5.5mbps
 		*ext=0;
 		duration = ((len+4)<<4) /0xb;
 		drift = ((len+4)<<4) % 0xb;
-		if(drift ==0 ) 
+		if(drift ==0 )
 			break;
 		duration++;
 		break;
-		
+
 	default:
-	case 3://11mbps				
+	case 3://11mbps
 		*ext=0;
 		duration = ((len+4)<<4) /0x16;
 		drift = ((len+4)<<4) % 0x16;
-		if(drift ==0 ) 
+		if(drift ==0 )
 			break;
 		duration++;
-		if(drift > 6) 
+		if(drift > 6)
 			break;
 		*ext=1;
 		break;
 	}
-	
+
 	return duration;
 }
 #endif
 
 void rtl8180_try_wake_queue(struct net_device *dev, int pri);
 
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19))
 void rtl8187_lptx_isr(struct urb *tx_urb, struct pt_regs *regs)
+#else
+void rtl8187_lptx_isr(struct urb *tx_urb)
+#endif
 {
 	struct net_device *dev = (struct net_device*)tx_urb->context;
-	struct r8180_priv *priv = ieee80211_priv(dev);
+	struct r8180_priv *priv = ieee80211_priv_rtl7(dev);
 	if(tx_urb->status == 0)
 		priv->stats.txlpokint++;
 	else
@@ -1239,6 +1304,15 @@
 	rtl8180_try_wake_queue(dev,LOW_PRIORITY);
 }
 
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19))
+void rtl8187_lptx_isr_fast(struct urb *tx_urb, struct pt_regs *regs)
+#else
+void rtl8187_lptx_isr_fast(struct urb *tx_urb)
+#endif
+{
+	kfree(tx_urb->transfer_buffer);
+	usb_free_urb(tx_urb);
+}
 
 void rtl8187_beacon_stop(struct net_device *dev)
 {
@@ -1249,55 +1323,55 @@
 	if ((msrm == (MSR_LINK_ADHOC<<MSR_LINK_SHIFT) ||
 		(msrm == (MSR_LINK_MASTER<<MSR_LINK_SHIFT)))){
 		write_nic_byte(dev, MSR, msr2 | MSR_LINK_NONE);
-		write_nic_byte(dev, MSR, msr);	
+		write_nic_byte(dev, MSR, msr);
 	}
-	
-	 
+
+
 }
 
 
 void rtl8187_net_update(struct net_device *dev)
 {
 
-	struct r8180_priv *priv = ieee80211_priv(dev);
+	struct r8180_priv *priv = ieee80211_priv_rtl7(dev);
 	struct ieee80211_network *net;
 	net = & priv->ieee80211->current_network;
-	
-	
+
+
 	write_nic_dword(dev,BSSID,((u32*)net->bssid)[0]);
 	write_nic_word(dev,BSSID+4,((u16*)net->bssid)[2]);
 	//for(i=0;i<ETH_ALEN;i++)
 	//	write_nic_byte(dev,BSSID+i,net->bssid[i]);
 
 	rtl8180_update_msr(dev);
-		
+
 //	rtl8180_set_mode(dev,EPROM_CMD_CONFIG);
 	write_nic_word(dev, AtimWnd, 2);
-	write_nic_word(dev, AtimtrItv, 100);	
+	write_nic_word(dev, AtimtrItv, 100);
 	write_nic_word(dev, BEACON_INTERVAL, net->beacon_interval);
 	write_nic_word(dev, BcnIntTime, 100);
-	
+
 
 }
 
 void rtl8187_beacon_tx(struct net_device *dev)
 {
 
-	struct r8180_priv *priv = ieee80211_priv(dev);
+	struct r8180_priv *priv = ieee80211_priv_rtl7(dev);
 	struct sk_buff *skb;
 	int i = 0;
-	
+
 	rtl8187_net_update(dev);
-	
-	skb = ieee80211_get_beacon(priv->ieee80211);
-	
-	
-	if(!skb){ 
+
+	skb = ieee80211_get_beacon_rtl7(priv->ieee80211);
+
+
+	if(!skb){
 		DMESG("not enought memory for allocating beacon");
 		return;
 	}
-	
-#if 0	
+
+#if 0
 	while(MAX_TX_URB!=atomic_read(&priv->tx_np_pending)){
 		msleep_interruptible_rtl(HZ/2);
 		if(i++ > 20){
@@ -1307,7 +1381,7 @@
 	}
 #endif
 	write_nic_byte(dev, BQREQ, read_nic_byte(dev, BQREQ) | (1<<7));
-	
+
 	i=0;
 	//while(!read_nic_byte(dev,BQREQ & (1<<7)))
 	while( (read_nic_byte(dev, BQREQ) & (1<<7)) == 0 )
@@ -1318,16 +1392,20 @@
 			return ;
 		}
 	}
-		
+
 	rtl8180_tx(dev, (u32*)skb->data, skb->len, NORM_PRIORITY,
 		0, priv->ieee80211->basic_rate);
-	
+
 }
 
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19))
 void rtl8187_nptx_isr(struct urb *tx_urb, struct pt_regs *regs)
+#else
+void rtl8187_nptx_isr(struct urb *tx_urb)
+#endif
 {
 	struct net_device *dev = (struct net_device*)tx_urb->context;
-	struct r8180_priv *priv = ieee80211_priv(dev);
+	struct r8180_priv *priv = ieee80211_priv_rtl7(dev);
 	if(tx_urb->status == 0)
 		priv->stats.txnpokint++;
 	else
@@ -1339,10 +1417,10 @@
 }
 
 
-/* This function do the real dirty work: it sends a TX command 
- * descriptor plus data URB 
+/* This function do the real dirty work: it sends a TX command
+ * descriptor plus data URB
  */
- 
+
 short rtl8180_tx(struct net_device *dev, u32* txbuf, int len, priority_t priority,
 		 short morefrag, short rate)
 {
@@ -1352,12 +1430,12 @@
 	int pend ;
 	int status;
 	struct urb *tx_urb;
-	int urb_len;	
-	struct r8180_priv *priv = ieee80211_priv(dev);
+	int urb_len;
+	struct r8180_priv *priv = ieee80211_priv_rtl7(dev);
 //	int rate = ieeerate2rtlrate(priv->ieee80211->rate);
 
-	pend = atomic_read((priority == NORM_PRIORITY)? &priv->tx_np_pending : &priv->tx_lp_pending);
-	/* we are locked here so the two atomic_read and inc are executed without interleaves */
+        pend = atomic_read((priority == NORM_PRIORITY)? &priv->tx_np_pending : &priv->tx_lp_pending);
+        /* we are locked here so the two atomic_read and inc are executed without interleaves */
 	if( pend > MAX_TX_URB){
 		if(priority == NORM_PRIORITY)
 			priv->stats.txnpdrop++;
@@ -1365,52 +1443,38 @@
 			priv->stats.txlpdrop++;
 		return -1;
 	}
-		
-	
+
 	//tx = kmalloc((len + 4*3), GFP_ATOMIC);
 	urb_len = len + 4*3;
 	if((0 == urb_len%64)||(0 == urb_len%512)) {
-	  urb_len += 1;	  
+	  urb_len += 1;
 	}
 	tx = kmalloc(urb_len, GFP_ATOMIC);
 	if(!tx) return -ENOMEM;
-	//printk(KERN_WARNING "urb_len = %d\n", urb_len);	
+	//printk(KERN_WARNING "urb_len = %d\n", urb_len);
 	tx_urb = usb_alloc_urb(0,GFP_ATOMIC);
-	
+
 	if(!tx_urb){
-		
+
 		kfree(tx);
 		return -ENOMEM;
 	}
-	
+
 	memcpy(tx+3,txbuf,len);
 	tx[0] = 0;
 	tx[0] |= len & 0xfff;
 	tx[0] |= (1<<15);
-	
-//	if(priv->shortpre)
-//		tx[0] |= (1<<16);
-	
-	//if(len > priv->rts_threshold){
-//		tx[0] |= (1<<23); //ENABLE RTS
-//		tx[0] |= (1<<18); //ENABLE CTS
-	//}
+
 	if(morefrag) tx[0] |= (1<<17);
 	tx[0] |= (ieeerate2rtlrate(priv->ieee80211->basic_rate) << 19); /* RTS RATE - should be basic rate */
 	tx[0] |= (rate << 24);
 	tx[1] = 0;
-	
-//	duration = rtl8180_len2duration(len,
-//		rate,&ext);	
-//	tx[1] |= (duration & 0x7fff) <<16;
-//	if(ext) tx[1] |= (1<<31);
 
-	
 //	tx[2] = 0x303020;
 	tx[2] = 3;  // CW min
 	tx[2] |= (7<<4); //CW max
 	tx[2] |= (11<<8);//(priv->retry_data<<8); //retry lim
-	
+
 //	printk("%x\n%x\n",tx[0],tx[1]);
 
 	#ifdef DUMP_TX
@@ -1421,7 +1485,7 @@
 	printk("---------------\n");
 	#endif
 
-	
+
 	/* FIXME check what EP is for low/norm PRI */
 	usb_fill_bulk_urb(tx_urb,priv->udev,
 		usb_sndbulkpipe(priv->udev,(priority == LOW_PRIORITY) ? 2:3), tx,
@@ -1438,54 +1502,97 @@
 	}
 }
 
- 
+/* This function do the real dirty work: it sends a TX command
+ * descriptor plus data URB (fast)
+ */
+
+short rtl8180_tx_fast(struct net_device *dev, u32* txbuf, int len, short rate)
+{
+	u32 *tx;
+	int status;
+	struct urb *tx_urb;
+	int urb_len;
+	struct r8180_priv *priv = ieee80211_priv_rtl7(dev);
+
+	urb_len = len + 4*3;
+	if((0 == urb_len%64)||(0 == urb_len%512)) {
+	  urb_len += 1;
+	}
+	tx = kmalloc(urb_len, GFP_ATOMIC);
+	if(!tx) return -ENOMEM;
+
+	tx_urb = usb_alloc_urb(0,GFP_ATOMIC);
+
+	if(!tx_urb){
+		kfree(tx);
+		return -ENOMEM;
+	}
+
+	memcpy(tx+3,txbuf,len);
+	tx[0] = (len & 0xfff) + 0x8000;
+	tx[0] |= (ieeerate2rtlrate(priv->ieee80211->basic_rate) << 19); /* RTS RATE - should be basic rate */
+	tx[0] |= (rate << 24);
+	tx[1] = 0;
+	tx[2] = 2931;
+
+	/* FIXME check what EP is for low/norm PRI */
+	usb_fill_bulk_urb(tx_urb,priv->udev,
+		usb_sndbulkpipe(priv->udev, 2), tx, urb_len, rtl8187_lptx_isr_fast, dev);
+	status = usb_submit_urb(tx_urb, GFP_ATOMIC);
+	if (!status){
+		return 0;
+	}else{
+		return -1;
+	}
+}
+
 
 void rtl8180_irq_rx_tasklet(struct r8180_priv * priv);
 
 
 short rtl8187_usb_initendpoints(struct net_device *dev)
 {
-	struct r8180_priv *priv = ieee80211_priv(dev);
+	struct r8180_priv *priv = ieee80211_priv_rtl7(dev);
 	int i;
-	
+
 	priv->rx_urb = (struct urb**) kmalloc (sizeof(struct urb*) * MAX_RX_URB, GFP_KERNEL);
-	
+
 	for(i=0;i<MAX_RX_URB;i++){
 		priv->rx_urb[i] = usb_alloc_urb(0,GFP_KERNEL);
-		if(!priv->rx_urb[i]) 
+		if(!priv->rx_urb[i])
 			goto destroy;
-		
+
 		priv->rx_urb[i]->transfer_buffer = kmalloc(RX_URB_SIZE, GFP_KERNEL);
-		if(!priv->rx_urb[i]->transfer_buffer) 
+		if(!priv->rx_urb[i]->transfer_buffer)
 			goto destroy1;
-			
+
 		priv->rx_urb[i]->transfer_buffer_length = RX_URB_SIZE;
 	}
-	
+
 	return 0;
-	
+
 destroy1:
 	usb_free_urb(priv->rx_urb[i]);
-	
+
 destroy:
 	while (--i >= 0){
 		kfree(priv->rx_urb[i]->transfer_buffer);
 		usb_free_urb(priv->rx_urb[i]);
 	}
-	
+
 	kfree(priv->rx_urb);
-	
+
 	priv->rx_urb = NULL;
 	DMESGE("Endpoint Alloc Failure");
 	return -ENOMEM;
-		
+
 }
 
 void rtl8187_usb_deleteendpoints(struct net_device *dev)
 {
-	struct r8180_priv *priv = ieee80211_priv(dev);
+	struct r8180_priv *priv = ieee80211_priv_rtl7(dev);
 	int i;
-	
+
 	if(priv->rx_urb){
 		for(i=0;i<MAX_RX_URB;i++){
 			usb_kill_urb(priv->rx_urb[i]);
@@ -1494,9 +1601,9 @@
 		}
 		kfree(priv->rx_urb);
 		priv->rx_urb = NULL;
-		
+
 	}
-	
+
 }
 
 
@@ -1505,16 +1612,16 @@
 	int i;
 	u16 word;
 	int basic_rate,min_rr_rate,max_rr_rate;
-	
-//	struct r8180_priv *priv = ieee80211_priv(dev);
-	
-	//if (ieee80211_is_54g(priv->ieee80211->current_network) && 
+
+//	struct r8180_priv *priv = ieee80211_priv_rtl7(dev);
+
+	//if (ieee80211_is_54g_rtl7(priv->ieee80211->current_network) &&
 //		priv->ieee80211->state == IEEE80211_LINKED){
 	basic_rate = ieeerate2rtlrate(240);
 	min_rr_rate = ieeerate2rtlrate(60);
 	max_rr_rate = ieeerate2rtlrate(240);
-	
-//	
+
+//
 //	}else{
 //		basic_rate = ieeerate2rtlrate(20);
 //		min_rr_rate = ieeerate2rtlrate(10);
@@ -1526,21 +1633,21 @@
 
 	word  = read_nic_word(dev, BRSR);
 	word &= ~BRSR_MBR_8185;
-		
+
 
 	for(i=0;i<=basic_rate;i++)
 		word |= (1<<i);
 
 	write_nic_word(dev, BRSR, word);
-	//DMESG("RR:%x BRSR: %x", read_nic_byte(dev,RESP_RATE), read_nic_word(dev,BRSR));
+	DMESG("RR:%x BRSR: %x", read_nic_byte(dev,RESP_RATE), read_nic_word(dev,BRSR));
 }
 
 
 void rtl8187_link_change(struct net_device *dev)
 {
 //	int i;
-	
-	struct r8180_priv *priv = ieee80211_priv(dev);
+
+	struct r8180_priv *priv = ieee80211_priv_rtl7(dev);
 	//write_nic_word(dev, BintrItv, net->beacon_interval);
 	rtl8187_net_update(dev);
 	/*update timing params*/
@@ -1553,24 +1660,24 @@
 
 short rtl8180_init(struct net_device *dev)
 {
-		
-	struct r8180_priv *priv = ieee80211_priv(dev);
+
+	struct r8180_priv *priv = ieee80211_priv_rtl7(dev);
 	int i, j;
 	u16 word;
-	int ch;
+	int ch, chans;
 	//u16 version;
-	//u8 hw_version;
-	//u8 config3;
-	
+	u8 hw_version;
+	u8 config3;
+
 	//FIXME: these constants are placed in a bad pleace.
 
 //	priv->txbuffsize = 1024;
 //	priv->txringcount = 32;
 //	priv->rxbuffersize = 1024;
-//	priv->rxringcount = 32; 
+//	priv->rxringcount = 32;
 //	priv->txbeaconcount = 3;
 //	priv->rx_skb_complete = 1;
-	//priv->txnp_pending.ispending=0; 
+	//priv->txnp_pending.ispending=0;
 	/* ^^ the SKB does not containt a partial RXed
 	 * packet (is empty)
 	 */
@@ -1580,15 +1687,24 @@
 		return -1;
 	}
 	ch=channels;
+	chans=0;
+	for (i=1; i<=14; i++) {
+		if( (u8)(ch & 0x01) ) chans++;
+		ch >>= 1;
+	}
+	DMESG("Enabling %d channels.", chans);
+	ch=channels;
 	 // set channels 1..14 allowed in given locale
 	for (i=1; i<=14; i++) {
 		(priv->ieee80211->channel_map)[i] = (u8)(ch & 0x01);
 		ch >>= 1;
 	}
 	//memcpy(priv->stats,0,sizeof(struct Stats));
-	
+
 	//priv->irq_enabled=0;
-	
+
+	priv->dev = dev;
+
 //	priv->stats.rxdmafail=0;
 	priv->stats.txrdu=0;
 //	priv->stats.rxrdu=0;
@@ -1612,33 +1728,37 @@
 //	priv->stats.txbeaconerr=0;
 	priv->stats.txlperr=0;
 	priv->stats.txlpokint=0;
-	
+
 	priv->ieee80211->iw_mode = IW_MODE_INFRA;
-	
+
 	priv->retry_rts = DEFAULT_RETRY_RTS;
 	priv->retry_data = DEFAULT_RETRY_DATA;
 	priv->ieee80211->rate = 110; //11 mbps
 	priv->ieee80211->short_slot = 1;
-	priv->ieee80211->mode = IEEE_G;
+	priv->ieee80211->mode = IEEE_G|IEEE_B;
 	priv->promisc = (dev->flags & IFF_PROMISC) ? 1:0;
 	spin_lock_init(&priv->tx_lock);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,20)
 	INIT_WORK(&priv->reset_wq,(void(*)(void*)) rtl8180_restart,dev);
+#else
+	INIT_WORK(&priv->reset_wq, rtl8180_restart);
+#endif
 	sema_init(&priv->wx_sem,1);
 	tasklet_init(&priv->irq_rx_tasklet,
 		     (void(*)(unsigned long))rtl8180_irq_rx_tasklet,
 		     (unsigned long)priv);
 
-	//priv->ieee80211->func = 
+	//priv->ieee80211->func =
 	//	kmalloc(sizeof(struct ieee80211_helper_functions),GFP_KERNEL);
 	//memset(priv->ieee80211->func, 0,
 	  //     sizeof(struct ieee80211_helper_functions));
-	priv->ieee80211->current_network.beacon_interval = DEFAULT_BEACONINTERVAL;	
+	priv->ieee80211->current_network.beacon_interval = DEFAULT_BEACONINTERVAL;
 	priv->ieee80211->iw_mode = IW_MODE_INFRA;
-	priv->ieee80211->softmac_features  = IEEE_SOFTMAC_SCAN | 
-		IEEE_SOFTMAC_ASSOCIATE | IEEE_SOFTMAC_PROBERQ | 
+	priv->ieee80211->softmac_features  = IEEE_SOFTMAC_SCAN |
+		IEEE_SOFTMAC_ASSOCIATE | IEEE_SOFTMAC_PROBERQ |
 		IEEE_SOFTMAC_PROBERS | IEEE_SOFTMAC_TX_QUEUE |
 		/*IEEE_SOFTMAC_BEACONS | */IEEE_SOFTMAC_SINGLE_QUEUE;
-	
+
 	priv->ieee80211->active_scan = 1;
 	priv->ieee80211->rate = 110; //11 mbps
 	priv->ieee80211->modulation = IEEE80211_CCK_MODULATION | IEEE80211_OFDM_MODULATION;
@@ -1655,51 +1775,51 @@
 	priv->ieee80211->data_hard_resume = rtl8180_data_hard_resume;
 	//priv->ieee80211->start_send_beacons = NULL;
 	//priv->ieee80211->stop_send_beacons = NULL;
-	
+
 	priv->ieee80211->fts = DEFAULT_FRAG_THRESHOLD;
-	
+
 	priv->card_8185 = 2;
 	priv->phy_ver = 2;
 	priv->card_type = USB;
-	
+
 	#if 0
 	hw_version =( read_nic_dword(dev, TCR) & TCR_HWVERID_MASK)>>TCR_HWVERID_SHIFT;
-	
+
 	switch (hw_version){
 		case HW_VERID_R8185_ABC:
-			DMESG("MAC controller is a RTL8185 b/g");	
+			DMESG("MAC controller is a RTL8185 b/g");
 			priv->card_8185 = 1;
 			/* you should not find a card with 8225 PHY ver < C*/
 			priv->phy_ver = 2;
 			break;
-			 
+
 		case HW_VERID_R8185_D:
-			DMESG("MAC controller is a RTL8185 b/g (V. D)");	
+			DMESG("MAC controller is a RTL8185 b/g (V. D)");
 			priv->card_8185 = 2;
 			/* you should not find a card with 8225 PHY ver < C*/
 			priv->phy_ver = 2;
 			break;
-			
+
 		case HW_VERID_R8180_ABCD:
 			DMESG("MAC controller is a RTL8180");
 			priv->card_8185 = 0;
 			break;
-		
+
 		case HW_VERID_R8180_F:
 			DMESG("MAC controller is a RTL8180 (v. F)");
 			priv->card_8185 = 0;
 			break;
-		
+
 		default:
 			DMESGW("MAC chip not recognized: version %x. Assuming RTL8180",hw_version);
 			priv->card_8185 = 0;
 			break;
 	}
-	
-	
+
+
 	/* you should not found any 8185 Ver B Card */
 	priv->card_8185_Bversion = 0;
-	
+
 	config3 = read_nic_byte(dev, CONFIG3);
 	if(config3 & 0x8){
 		priv->card_type = CARDBUS;
@@ -1715,13 +1835,19 @@
 	#endif
 	priv->enable_gpio0 = 0;
 
-	
+
+	hw_version =( read_nic_dword(dev, TCR) & TCR_HWVERID_MASK)>>TCR_HWVERID_SHIFT;
+	config3 = read_nic_byte(dev, CONFIG3);
+
+	DMESG("MAC chip version: %02X", hw_version);
+	DMESG("Card type: %02X", config3);
+
 	/* commented out just because we already do
 	   this when resetting the card
 	   andrea 20050924
 	 */
 	#if 0
-		
+
 	u8 txcr, txreg50;
 	u32 txreg54, txreg60;
 
@@ -1757,8 +1883,8 @@
        // DMESG("<<txcr:%x>>", txcr);
 
 #endif
-	
-	/*the eeprom type is stored in RCR register bit #6 */ 
+
+	/*the eeprom type is stored in RCR register bit #6 */
 	if (RCR_9356SEL & read_nic_dword(dev, RCR)){
 		priv->epromtype=EPROM_93c56;
 		DMESG("Reported EEPROM chip is a 93c56 (2Kbit)");
@@ -1766,58 +1892,73 @@
 		priv->epromtype=EPROM_93c46;
 		DMESG("Reported EEPROM chip is a 93c46 (1Kbit)");
 	}
-	
+
 	dev->get_stats = rtl8180_stats;
-	
+
 	dev->dev_addr[0]=eprom_read(dev,MAC_ADR) & 0xff;
 	dev->dev_addr[1]=(eprom_read(dev,MAC_ADR) & 0xff00)>>8;
 	dev->dev_addr[2]=eprom_read(dev,MAC_ADR+1) & 0xff;
 	dev->dev_addr[3]=(eprom_read(dev,MAC_ADR+1) & 0xff00)>>8;
 	dev->dev_addr[4]=eprom_read(dev,MAC_ADR+2) & 0xff;
 	dev->dev_addr[5]=(eprom_read(dev,MAC_ADR+2) & 0xff00)>>8;
-	
+
 	DMESG("Card MAC address is "MAC_FMT, MAC_ARG(dev->dev_addr));
-		
+
 	for(i=1,j=0; i<6; i+=2,j++){
-		
+
 		word = eprom_read(dev,EPROM_TXPW0 + j);
 		priv->chtxpwr[i]=word & 0xf;
 		priv->chtxpwr_ofdm[i]=(word & 0xf0)>>4;
 		priv->chtxpwr[i+1]=(word & 0xf00)>>8;
 		priv->chtxpwr_ofdm[i+1]=(word & 0xf000)>>12;
 	}
-	
+
 	for(i=1,j=0; i<4; i+=2,j++){
-			
+
 		word = eprom_read(dev,EPROM_TXPW1 + j);
 		priv->chtxpwr[i+6]=word & 0xf;
 		priv->chtxpwr_ofdm[i+6]=(word & 0xf0)>>4;
 		priv->chtxpwr[i+6+1]=(word & 0xf00)>>8;
 		priv->chtxpwr_ofdm[i+6+1]=(word & 0xf000)>>12;
 	}
-	
+
 	for(i=1,j=0; i<4; i+=2,j++){
-			
+
 		word = eprom_read(dev,EPROM_TXPW2 + j);
 		priv->chtxpwr[i+6+4]=word & 0xf;
 		priv->chtxpwr_ofdm[i+6+4]=(word & 0xf0)>>4;
 		priv->chtxpwr[i+6+4+1]=(word & 0xf00)>>8;
 		priv->chtxpwr_ofdm[i+6+4+1]=(word & 0xf000)>>12;
 	}
-	
-		
+
+
 	priv->rf_chip = 0xff & eprom_read(dev,EPROM_RFCHIPID);
-	
+
+#ifdef DEBUG_TX_POWER
+	dump_tx_power(dev);
+#endif
+
+	DMESG("RF Chip ID: %02X", priv->rf_chip);
+
 	word = eprom_read(dev,EPROM_TXPW_BASE);
 	priv->cck_txpwr_base = word & 0xf;
 	priv->ofdm_txpwr_base = (word>>4) & 0xf;
-	
+
+	priv->txpwr_max = 0;
+	for(i=1; i<15; i++)
+	{
+		if(priv->chtxpwr[i] > priv->txpwr_max) priv->txpwr_max = priv->chtxpwr[i];
+		if(priv->chtxpwr_ofdm[i] > priv->txpwr_max) priv->txpwr_max = priv->chtxpwr_ofdm[i];
+		priv->chtxpwr_orig[i] = priv->chtxpwr[i];
+		priv->chtxpwr_ofdm_orig[i] = priv->chtxpwr_ofdm[i];
+	}
+
 	/* check RF frontend chipset */
-	
+
 	switch (priv->rf_chip) {
-		
+
 		case EPROM_RFCHIPID_RTL8225U:
-		
+
 		DMESG("Card reports RF frontend Realtek 8225");
 		DMESGW("This driver has EXPERIMENTAL support for this chipset.");
 		DMESGW("use it with care and at your own risk and");
@@ -1834,28 +1975,28 @@
 			DMESG("This seems a legacy 1st version radio");
 		}
 		priv->rf_close = rtl8225_rf_close;
-		
+
 		priv->max_sens = RTL8225_RF_MAX_SENS;
 		priv->sens = RTL8225_RF_DEF_SENS;
 		break;
-				
+
 		default:
 		DMESGW("Unknown RF module %x",priv->rf_chip);
 		DMESGW("Exiting...");
 		return -1;
-		
+
 	}
-	
+
 //	DMESG("Energy threshold: %x",priv->cs_treshold);
 	DMESG("PAPE from CONFIG2: %x",read_nic_byte(dev,CONFIG2)&0x7);
 	//DMESG("CONFIG2: %x ECONFIG2: %x",read_nic_byte(dev,CONFIG2),eprom_read(dev,EPROM_CONFIG2));
-	
-	if(rtl8187_usb_initendpoints(dev)!=0){ 
+
+	if(rtl8187_usb_initendpoints(dev)!=0){
 		DMESG("Endopoints initialization failed");
 		return -ENOMEM;
 	}
-#if 0		
-	if (0!=alloc_rx_desc_ring(dev, priv->rxbuffersize, priv->rxringcount)) 
+#if 0
+	if (0!=alloc_rx_desc_ring(dev, priv->rxbuffersize, priv->rxringcount))
 		return -ENOMEM;
 
 	if (0!=alloc_tx_desc_ring(dev, priv->txbuffsize, priv->txringcount,
@@ -1869,16 +2010,16 @@
 	if (0!=alloc_tx_desc_ring(dev, priv->txbuffsize, priv->txringcount,
 				  TX_LOWPRIORITY_RING_ADDR))
 		return -ENOMEM;
-	
-	
+
+
 	if (0!=alloc_tx_beacon_desc_ring(dev, priv->txbeaconcount))
 		return -ENOMEM;
 #endif
-	
+
 
 #ifdef DEBUG_EPROM
 	dump_eprom(dev);
-#endif 
+#endif
 	return 0;
 
 }
@@ -1898,7 +2039,7 @@
 	rtl8180_set_mode(dev, EPROM_CMD_CONFIG);
 
 	conf3 = read_nic_byte(dev, CONFIG3);
-	write_nic_byte(dev, CONFIG3, conf3 | (1<<CONFIG3_ANAPARAM_W_SHIFT));	
+	write_nic_byte(dev, CONFIG3, conf3 | (1<<CONFIG3_ANAPARAM_W_SHIFT));
 
 	write_nic_dword(dev, ANAPARAM2, a);
 
@@ -1918,23 +2059,23 @@
 
 	conf3 = read_nic_byte(dev, CONFIG3);
 	write_nic_byte(dev, CONFIG3, conf3 | (1<<CONFIG3_ANAPARAM_W_SHIFT));
-	
+
 	write_nic_dword(dev, ANAPARAM, a);
 
 	conf3 = read_nic_byte(dev, CONFIG3);
 	write_nic_byte(dev, CONFIG3, conf3 &~(1<<CONFIG3_ANAPARAM_W_SHIFT));
 
 	rtl8180_set_mode(dev, EPROM_CMD_NORMAL);
-	
+
 }
 
 
 void rtl8185_tx_antenna(struct net_device *dev, u8 ant)
 {
-	write_nic_byte(dev, TX_ANTENNA, ant); 
+	write_nic_byte(dev, TX_ANTENNA, ant);
 	force_pci_posting(dev);
 	mdelay(1);
-}	
+}
 
 
 void rtl8187_write_phy(struct net_device *dev, u8 adr, u32 data)
@@ -1942,26 +2083,26 @@
 	//u8 phyr;
 	u32 phyw;
 //	int i;
-	
+
 	adr |= 0x80;
-	 
+
 	phyw= ((data<<8) | adr);
-	
-	
-	
-	// Note that, we must write 0xff7c after 0x7d-0x7f to write BB register. 
+
+
+
+	// Note that, we must write 0xff7c after 0x7d-0x7f to write BB register.
 	write_nic_byte(dev, 0x7f, ((phyw & 0xff000000) >> 24));
 	write_nic_byte(dev, 0x7e, ((phyw & 0x00ff0000) >> 16));
 	write_nic_byte(dev, 0x7d, ((phyw & 0x0000ff00) >> 8));
 	write_nic_byte(dev, 0x7c, ((phyw & 0x000000ff) ));
 
 	//read_nic_dword(dev, PHY_ADR);
-#if 0	
+#if 0
 	for(i=0;i<10;i++){
 		write_nic_dword(dev, PHY_ADR, 0xffffff7f & phyw);
 		phyr = read_nic_byte(dev, PHY_READ);
 		if(phyr == (data&0xff)) break;
-			
+
 	}
 #endif
 	/* this is ok to fail when we write AGC table. check for AGC table might be
@@ -1988,60 +2129,60 @@
 
 void rtl8180_adapter_start(struct net_device *dev)
 {
-        struct r8180_priv *priv = ieee80211_priv(dev);
+        struct r8180_priv *priv = ieee80211_priv_rtl7(dev);
 	//u32 anaparam;
 	//u8 config3;
-	
+
 	//rtl8180_rtx_disable(dev);
 	rtl8180_reset(dev);
 
 	write_nic_byte(dev,0x85,0);
 	write_nic_byte(dev,0x91,0);
-	
+
 	/* light blink! */
 	write_nic_byte(dev,0x85,4);
 	write_nic_byte(dev,0x91,1);
 	write_nic_byte(dev,0x90,0);
-	
+
 	priv->irq_mask = 0xffff;
 /*
 	priv->dma_poll_mask = 0;
 	priv->dma_poll_mask|= (1<<TX_DMA_STOP_BEACON_SHIFT);
-*/	
+*/
 //	rtl8180_beacon_tx_disable(dev);
-	
+
 	rtl8180_set_mode(dev, EPROM_CMD_CONFIG);
 	write_nic_dword(dev, MAC0, ((u32*)dev->dev_addr)[0]);
 	write_nic_word(dev, MAC4, ((u32*)dev->dev_addr)[1] & 0xffff );
 
 	rtl8180_set_mode(dev, EPROM_CMD_NORMAL);
 	rtl8180_update_msr(dev);
-		
+
 	rtl8180_set_mode(dev, EPROM_CMD_CONFIG);
-	
+
 	write_nic_word(dev,0xf4,0xffff);
 	write_nic_byte(dev,
-		       CONFIG1, (read_nic_byte(dev,CONFIG1) & 0x3f) | 0x80);	
+		       CONFIG1, (read_nic_byte(dev,CONFIG1) & 0x3f) | 0x80);
 
 	rtl8180_set_mode(dev,EPROM_CMD_NORMAL);
-	
-	write_nic_dword(dev,INT_TIMEOUT,0);	
+
+	write_nic_dword(dev,INT_TIMEOUT,0);
 
 #ifdef DEBUG_REGISTERS
-	rtl8180_dump_reg(dev);	
+	rtl8180_dump_reg(dev);
 #endif
-	
-	
-	write_nic_byte(dev, WPA_CONFIG, 0);	
+
+
+	write_nic_byte(dev, WPA_CONFIG, 0);
 
 	write_nic_byte(dev, RATE_FALLBACK, 0x81);
 	rtl8187_set_rate(dev);
-		
-	priv->rf_init(dev);	
+
+	priv->rf_init(dev);
 
 	if(priv->rf_set_sens != NULL)
-		priv->rf_set_sens(dev,priv->sens);	
-	
+		priv->rf_set_sens(dev,priv->sens);
+
 	write_nic_word(dev,0x5e,1);
 
 	#if 1
@@ -2054,13 +2195,13 @@
 	write_nic_byte(dev, 0xff, 0x60);
 
 	write_nic_word(dev,0x5e,0);
-	
-		
+
+
 	rtl8180_irq_enable(dev);
 	/*DMESG ("lfree %d",get_curr_tx_free_desc(dev,LOW_PRIORITY));
-	
+
 	DMESG ("nfree %d",get_curr_tx_free_desc(dev,NORM_PRIORITY));
-	
+
 	DMESG ("hfree %d",get_curr_tx_free_desc(dev,HI_PRIORITY));
 	if(check_nic_enought_desc(dev,NORM_PRIORITY)) DMESG("NORM OK");
 	if(check_nic_enought_desc(dev,HI_PRIORITY)) DMESG("HI OK");
@@ -2077,8 +2218,8 @@
 void rtl8180_start_tx_beacon(struct net_device *dev)
 {
 	int i;
-	struct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);
-	u16 word;	
+	struct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv_rtl7(dev);
+	u16 word;
 	DMESG("Enabling beacon TX");
 	//write_nic_byte(dev, 0x42,0xe6);// TCR
 	//rtl8180_init_beacon(dev);
@@ -2091,41 +2232,41 @@
 	//write_nic_word(dev,0x7a,0);
 	//write_nic_word(dev,0x7a,0x8000);
 
-	
+
 	word  = read_nic_word(dev, BcnItv);
 	word &= ~BcnItv_BcnItv; // clear Bcn_Itv
 	write_nic_word(dev, BcnItv, word);
 
-	write_nic_word(dev, AtimWnd, 
+	write_nic_word(dev, AtimWnd,
 		       read_nic_word(dev, AtimWnd) &~ AtimWnd_AtimWnd);
-	
+
 	word  = read_nic_word(dev, BintrItv);
 	word &= ~BintrItv_BintrItv;
-	
-	//word |= priv->ieee80211->beacon_interval * 
+
+	//word |= priv->ieee80211->beacon_interval *
 	//	((priv->txbeaconcount > 1)?(priv->txbeaconcount-1):1);
 	// FIXME:FIXME check if correct ^^ worked with 0x3e8;
-	
+
 	write_nic_word(dev, BintrItv, word);
-	
+
 	//write_nic_word(dev,0x2e,0xe002);
 	//write_nic_dword(dev,0x30,0xb8c7832e);
 	for(i=0; i<ETH_ALEN; i++)
 		write_nic_byte(dev, BSSID+i, priv->ieee80211->beacon_cell_ssid[i]);
-	
+
 //	rtl8180_update_msr(dev);
 
-	
+
 	//write_nic_byte(dev,CONFIG4,3); /* !!!!!!!!!! */
-	
+
 	rtl8180_set_mode(dev, EPROM_CMD_NORMAL);
-	
+
 	rtl8180_irq_enable(dev);
-	
+
 	/* VV !!!!!!!!!! VV*/
 	/*
 	rtl8180_set_mode(dev,EPROM_CMD_CONFIG);
-	write_nic_byte(dev,0x9d,0x00); 	
+	write_nic_byte(dev,0x9d,0x00);
 	rtl8180_set_mode(dev,EPROM_CMD_NORMAL);
 */
 }
@@ -2135,137 +2276,138 @@
 ***************************************************************************/
 static struct net_device_stats *rtl8180_stats(struct net_device *dev)
 {
-	struct r8180_priv *priv = ieee80211_priv(dev);
-	
+	struct r8180_priv *priv = ieee80211_priv_rtl7(dev);
+
 	return &priv->ieee80211->stats;
 }
 
 
 int _rtl8180_up(struct net_device *dev)
 {
-	struct r8180_priv *priv = ieee80211_priv(dev);
+	struct r8180_priv *priv = ieee80211_priv_rtl7(dev);
 
 	priv->up=1;
-	
-	//DMESG("Bringing up iface");
+
+// 	DMESG("Bringing up iface");
 
 	rtl8180_adapter_start(dev);
-	
 	rtl8180_rx_enable(dev);
-
 	rtl8180_tx_enable(dev);
-	
-	ieee80211_softmac_start_protocol(priv->ieee80211);
-	
-	ieee80211_reset_queue(priv->ieee80211);
+	ieee80211_softmac_start_protocol_rtl7(priv->ieee80211);
+	ieee80211_reset_queue_rtl7(priv->ieee80211);
 	if(!netif_queue_stopped(dev))
 		netif_start_queue(dev);
 	else
 		netif_wake_queue(dev);
-		
 	return 0;
 }
 
 
 int rtl8180_open(struct net_device *dev)
 {
-	struct r8180_priv *priv = ieee80211_priv(dev);
+	struct r8180_priv *priv = ieee80211_priv_rtl7(dev);
 	int ret;
-	
+
 	down(&priv->wx_sem);
+
 	ret = rtl8180_up(dev);
 	up(&priv->wx_sem);
 	return ret;
-	
+
 }
 
 
 int rtl8180_up(struct net_device *dev)
 {
-	struct r8180_priv *priv = ieee80211_priv(dev);
+	struct r8180_priv *priv = ieee80211_priv_rtl7(dev);
 
 	if (priv->up == 1) return -1;
-	
+
 	return _rtl8180_up(dev);
 }
 
 
 int rtl8180_close(struct net_device *dev)
 {
-	struct r8180_priv *priv = ieee80211_priv(dev);
+	struct r8180_priv *priv = ieee80211_priv_rtl7(dev);
 	int ret;
-	
+
 	down(&priv->wx_sem);
-	
+
 	ret = rtl8180_down(dev);
-	
+
 	up(&priv->wx_sem);
-	
+
 	return ret;
 
 }
 
 int rtl8180_down(struct net_device *dev)
 {
-	struct r8180_priv *priv = ieee80211_priv(dev);
+	struct r8180_priv *priv = ieee80211_priv_rtl7(dev);
 
 	if (priv->up == 0) return -1;
-	
+
 	priv->up=0;
 
 /* FIXME */
 	if (!netif_queue_stopped(dev))
 		netif_stop_queue(dev);
-	
+
 	rtl8180_rtx_disable(dev);
 	rtl8180_irq_disable(dev);
 
-	ieee80211_softmac_stop_protocol(priv->ieee80211);
-		
+	ieee80211_softmac_stop_protocol_rtl7(priv->ieee80211);
+
 	return 0;
 }
 
 
 void rtl8180_commit(struct net_device *dev)
 {
-	struct r8180_priv *priv = ieee80211_priv(dev);
+	struct r8180_priv *priv = ieee80211_priv_rtl7(dev);
 
 	if (priv->up == 0) return ;
-	
-	ieee80211_softmac_stop_protocol(priv->ieee80211);
-	
+
+	ieee80211_softmac_stop_protocol_rtl7(priv->ieee80211);
+
 	rtl8180_irq_disable(dev);
 	rtl8180_rtx_disable(dev);
 	_rtl8180_up(dev);
 }
 
+# if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20))
+void rtl8180_restart(struct work_struct *work)
+{
+	struct r8180_priv *priv = container_of(work, struct r8180_priv, reset_wq);
+	struct net_device *dev = priv->dev;
+#else
 void rtl8180_restart(struct net_device *dev)
 {
-	struct r8180_priv *priv = ieee80211_priv(dev);
-
+	struct r8180_priv *priv = ieee80211_priv_rtl7(dev);
+#endif
 	down(&priv->wx_sem);
-	
 	rtl8180_commit(dev);
-	
+
 	up(&priv->wx_sem);
 }
 
 static void r8180_set_multicast(struct net_device *dev)
 {
-	struct r8180_priv *priv = ieee80211_priv(dev);
+	struct r8180_priv *priv = ieee80211_priv_rtl7(dev);
 	short promisc;
 
 	//down(&priv->wx_sem);
-	
+
 	/* FIXME FIXME */
-	
+
 	promisc = (dev->flags & IFF_PROMISC) ? 1:0;
-	
+
 	if (promisc != priv->promisc)
 	//	rtl8180_commit(dev);
-	
+
 	priv->promisc = promisc;
-	
+
 	//schedule_work(&priv->reset_wq);
 	//up(&priv->wx_sem);
 }
@@ -2273,17 +2415,17 @@
 
 int r8180_set_mac_adr(struct net_device *dev, void *mac)
 {
-	struct r8180_priv *priv = ieee80211_priv(dev);
+	struct r8180_priv *priv = ieee80211_priv_rtl7(dev);
 	struct sockaddr *addr = mac;
-	
+
 	down(&priv->wx_sem);
-	
+
 	memcpy(dev->dev_addr, addr->sa_data, ETH_ALEN);
-		
+
 	schedule_work(&priv->reset_wq);
-	
+
 	up(&priv->wx_sem);
-	
+
 	return 0;
 }
 
@@ -2291,16 +2433,18 @@
 /* based on ipw2200 driver */
 int rtl8180_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
 {
-	struct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);
-	
+	struct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv_rtl7(dev);
+	struct iwreq *wrq;
+	int ret;
+
 	down(&priv->wx_sem);
-	
-	struct iwreq *wrq = (struct iwreq *)rq;
-        
-	int ret=-1;
+
+	wrq = (struct iwreq *)rq;
+
+	ret=-1;
 	switch (cmd) {
 	    case RTL_IOCTL_WPA_SUPPLICANT:
-		ret = ieee80211_wpa_supplicant_ioctl(priv->ieee80211, &wrq->u.data);
+		ret = ieee80211_wpa_supplicant_ioctl_rtl7(priv->ieee80211, &wrq->u.data);
 		break;
 
 	    default:
@@ -2309,7 +2453,7 @@
 	}
 
 	up(&priv->wx_sem);
-	
+
 	return ret;
 }
 
@@ -2320,10 +2464,11 @@
 	struct net_device *dev = (struct net_device*)rx_urb->context;
 	int status,len,flen;
 	struct sk_buff *skb;
-	u32 *desc;
-	
+	u8 *desc;
+	u8 signal,quality,rate;
+
 	//DMESG("rtl8187_rx_isr");
-	
+
 	struct ieee80211_rx_stats stats = {
 		.signal = 0,
 		.noise = -98,
@@ -2332,43 +2477,109 @@
 		.freq = IEEE80211_24GHZ_BAND,
 	};
 
+
 	//DMESG("RX %d ",rx_urb->status);
 	status = rx_urb->status;
 	if(status == 0){
-		
+
 		len = rx_urb->actual_length;
-	//	len = len - 4 - 15 - 1; /* CRC, DESC, SEPARATOR*/ 
+	//	len = len - 4 - 15 - 1; /* CRC, DESC, SEPARATOR*/
 		len -= 4*4;/* 4 dword and 4 byte CRC */
-		
+#if 0
 		desc = (u32*)(rx_urb->transfer_buffer + len);
-		
+
 		flen = desc[0] & 0xfff;
-		
+
 		if( flen <= rx_urb->actual_length){
-		
-			stats.signal = (desc[1] & 0x7f00)>>8;
-			stats.noise = desc[1] &0xff;
-			stats.rate = desc[0] >> 20 & 0xf;
+
+			//stats.signal = (desc[1] & 0x7f00)>>8;
+			//stats.noise = desc[1] &0xff;
+			signal=(desc[1]& (0xff0000))>>16;
+			signal=(signal&0xfe)>>1;	// Modify by hikaru 6.6
+
+			quality=(desc[1] & (0xff));
+
+			rate=(desc[0] &((1<<23)|(1<<22)|(1<<21)|(1<<20)))>>20;
+		//	printk(KERN_INFO "rate is %d!\n",rate);
+			stats.rate = rtl8180_rate2rate(rate);
+		//	printk(KERN_INFO "stats.rate is %d!\n",stats.rate);
+			//stats.rate = desc[0] >> 20 & 0xf;
 			stats.mac_time[0] = desc[2];
 			stats.mac_time[1] = desc[3];
+#endif
+
+		desc = rx_urb->transfer_buffer + len;
+
+		flen = ((desc[1] & 0x0f) << 8) + (desc[0] & 0xff);
+
+		if( flen <= rx_urb->actual_length){
+			//stats.signal = (desc[1] & 0x7f00)>>8;
+			//stats.noise = desc[1] &0xff;
+			signal=(desc[6]& 0xfe)>>1;
+			//signal=(signal&0xfe)>>1;	// Modify by hikaru 6.6
+
+			quality=desc[4] & 0xff;
+
+			//rate=(desc[2] &((1<<7)|(1<<6)|(1<<5)|(1<<4)))>>4;
+			rate=(desc[2] & 0xf0)>>4;
+		//	printk(KERN_INFO "rate is %d!\n",rate);
+			stats.rate = rtl8180_rate2rate(rate);
+		//	printk(KERN_INFO "stats.rate is %d!\n",stats.rate);
+			//stats.rate = desc[0] >> 20 & 0xf;
+			stats.mac_time[0] = desc[8] + (desc[9]<<8) + (desc[10]<<16) + (desc[11]<<24);
+			stats.mac_time[1] = desc[12] + (desc[13]<<8) + (desc[14]<<16) + (desc[15]<<24);
+
+
+			//calculate link quality begin
+			if(!rtl8180_IsWirelessBMode(stats.rate) )
+			{ // OFDM rate.
+				if(signal>90)
+					signal=90;
+				else if(signal<25)
+					signal=25;
+				signal = (90-signal)*100/65;
+			}
+			else
+			{ // CCK rate.
+				if(signal>95)
+					signal = 95;
+				else if(signal<30)
+					signal = 30;
+				signal =(95-signal )*100/65;
+			}
+			priv->wstats.qual.level = signal;
+		//	printk(KERN_INFO "signal is %d!\n",signal);
+			if(quality > 64)
+				priv ->wstats.qual.qual = 0;
+			else
+				priv ->wstats.qual.qual = ((64-quality) * 100) / 64;  // SQ value is the SIGNAL_QUALITY returned to IORequest,
+						//and this value only appear when STA is associated to AP or
+						// STA is in IBSS mode
+		//	printk(KERN_INFO "quality is %d!\n",priv->wstats.qual.qual);
+			priv->wstats.qual.noise = 100 - priv ->wstats.qual.qual;
+			priv->wstats.qual.updated = 7;
+			if(priv->ieee80211->iw_mode == IW_MODE_MONITOR)
+			{
+				stats.signal = priv->wstats.qual.level;
+				stats.noise = priv->wstats.qual.noise;
+			}
+			//calculate link quality end
 			skb = dev_alloc_skb(flen-4);
-			//skb_reserve(skb,2);
-			if(skb){ 
+			if(skb){
 			memcpy(skb_put(skb,flen-4),
 				rx_urb->transfer_buffer,flen -4);
-			
+
 			#ifdef DUMP_RX
 			int i;
 			for(i=0;i<flen-4;i++)
 				printk("%2x ",((u8*)(rx_urb->transfer_buffer))[i]);
 			printk("------RATE %x:w---------------\n",stats.rate);
-			
+
 			#endif
 			priv->stats.rxok++;
 		//	priv->rxskb = skb;
 		//	priv->tempstats = &stats;
-
-			if(!ieee80211_rx(priv->ieee80211, 
+			if(!ieee80211_rx_rtl7(priv->ieee80211,
 				skb, &stats))
 			dev_kfree_skb_any(skb);
 			}
@@ -2376,9 +2587,8 @@
 	}else{
 		priv->stats.rxstaterr++;
 		priv->ieee80211->stats.rx_errors++;
-		
 	}
-	
+
 	if(status != -ENOENT)rtl8187_rx_urbsubmit(dev,rx_urb);
 	else DMESG("RX process aborted due to explicit shutdown");
 }
@@ -2396,20 +2606,22 @@
 	struct r8180_priv *priv= NULL;
 	struct usb_device *udev = interface_to_usbdev(intf);
 
-//printk("===> rtl8187_usb_probe()\n");	
-	
-	dev = alloc_ieee80211(sizeof(struct r8180_priv));
-	
+//printk("===> rtl8187_usb_probe()\n");
+
+	dev = alloc_ieee80211_rtl7(sizeof(struct r8180_priv));
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,24)
 	SET_MODULE_OWNER(dev);
-	usb_set_intfdata(intf, dev);	
-	
+#endif
+	usb_set_intfdata(intf, dev);
+
 	SET_NETDEV_DEV(dev, &intf->dev);
 
-	priv = ieee80211_priv(dev);
+	priv = ieee80211_priv_rtl7(dev);
 	priv->ieee80211 = netdev_priv(dev);
-	
+
 	priv->udev=udev;
-	
+
 	dev->open = rtl8180_open;
 	dev->stop = rtl8180_close;
 	//dev->hard_start_xmit = rtl8180_8023_hard_start_xmit;
@@ -2418,41 +2630,46 @@
 	dev->do_ioctl = rtl8180_ioctl;
 	dev->set_multicast_list = r8180_set_multicast;
 	dev->set_mac_address = r8180_set_mac_adr;
+#if WIRELESS_EXT >= 12
+#if WIRELESS_EXT < 17
 	dev->get_wireless_stats = r8180_get_wireless_stats;
+#endif
+	dev->wireless_handlers = (struct iw_handler_def *) &r8180_wx_handlers_def;
+#endif
 	dev->type=ARPHRD_ETHER;
-	
+
 	if (dev_alloc_name(dev, ifname) < 0){
                 DMESG("Oops: devname already taken! Trying wlan%%d...\n");
 		ifname = "wlan%d";
 		dev_alloc_name(dev, ifname);
         }
-	
+
 //	dev->open=rtl8180_init;
-	
-	if(rtl8180_init(dev)!=0){ 
+
+	if(rtl8180_init(dev)!=0){
 		DMESG("Initialization failed");
 		goto fail;
 	}
-	
+
 	netif_carrier_off(dev);
 	netif_stop_queue(dev);
-	
+
 	register_netdev(dev);
-	
+
 	rtl8180_proc_init_one(dev);
-	
-	
+
+
 	DMESG("Driver probe completed\n");
-	return 0;	
+	return 0;
+
 
-	
 fail:
-	free_ieee80211(dev);
-		
+	free_ieee80211_rtl7(dev);
+
 	DMESG("wlan driver load failed\n");
-	
+
 	return -ENODEV;
-	
+
 }
 
 
@@ -2461,13 +2678,13 @@
 	struct r8180_priv *priv;
 	struct net_device *dev = usb_get_intfdata(intf);
  	if(dev){
-		
+
 		unregister_netdev(dev);
-		
-		priv=ieee80211_priv(dev);
-		
+
+		priv=ieee80211_priv_rtl7(dev);
+
 		rtl8180_proc_remove_one(dev);
-		
+
 		rtl8180_down(dev);
 		priv->rf_close(dev);
 		//rtl8180_rtx_disable(dev);
@@ -2478,12 +2695,12 @@
 
 	}
 //	pci_disable_device(pdev);
-	free_ieee80211(dev);
+	free_ieee80211_rtl7(dev);
 	DMESG("wlan driver removed\n");
 }
 
 
-static int __init rtl8187_usb_module_init(void)
+static int __init rtl8187_usb_module_init_rtl7(void)
 {
 	printk(KERN_INFO "\nLinux kernel driver for RTL8187 \
 based WLAN cards\n");
@@ -2495,7 +2712,7 @@
 }
 
 
-static void __exit rtl8187_usb_module_exit(void)
+static void __exit rtl8187_usb_module_exit_rtl7(void)
 {
 	usb_deregister(&rtl8187_usb_driver);
 
@@ -2508,14 +2725,14 @@
 {
 	unsigned long flags;
 	short enough_desc;
-	struct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);
-	
+	struct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv_rtl7(dev);
+
 	spin_lock_irqsave(&priv->tx_lock,flags);
 	enough_desc = check_nic_enought_desc(dev,pri);
-        spin_unlock_irqrestore(&priv->tx_lock,flags);	
-	
+        spin_unlock_irqrestore(&priv->tx_lock,flags);
+
 	if(enough_desc)
-		ieee80211_wake_queue(priv->ieee80211);
+		ieee80211_wake_queue_rtl7(priv->ieee80211);
 }
 
 
@@ -2523,5 +2740,5 @@
 /***************************************************************************
      ------------------- module init / exit stubs ----------------
 ****************************************************************************/
-module_init(rtl8187_usb_module_init);
-module_exit(rtl8187_usb_module_exit);
+module_init(rtl8187_usb_module_init_rtl7);
+module_exit(rtl8187_usb_module_exit_rtl7);
diff -Naur rtl8187_linux_26.1010.0622.2006/beta-8187/r8187_core.c~ rtl8187_linux_26.1010.0622.2006_rawtx/beta-8187/r8187_core.c~
--- rtl8187_linux_26.1010.0622.2006/beta-8187/r8187_core.c~	2006-06-22 07:40:10.000000000 +0200
+++ rtl8187_linux_26.1010.0622.2006_rawtx/beta-8187/r8187_core.c~	1970-01-01 01:00:00.000000000 +0100
@@ -1,2527 +0,0 @@
-/*
-   This is part of rtl8187 OpenSource driver - v 0.1
-   Copyright (C) Andrea Merello 2005  <andreamrl@tiscali.it> 
-   Released under the terms of GPL (General Public License)
-   
-   
-   Parts of this driver are based on the rtl8180 driver skeleton 
-   from Patric Schenke & Andres Salomon.
-
-   Parts of this driver are based on the Intel Pro Wireless 2*00 GPL drivers.
-   
-   some ideas might be derived from David Young rtl8180 netbsd driver.
-   
-   Parts of the usb code are from the r8150.c driver in linux kernel
-   
-   Some ideas borrowed from the 8139too.c driver included in linux kernel.
-   
-   We (I?) want to thanks the Authors of those projecs and also the 
-   Ndiswrapper's project Authors.
-   
-   A special big thanks goes also to Realtek corp. for their help in my 
-   attempt to add RTL8187 and RTL8225 support, and to David Young also. 
-
-	- Please note that this file is a modified version from rtl8180-sa2400 
-	drv. So some other people have contributed to this project, and they are
-	thanked in the rtl8180-sa2400 CHANGELOG.
-*/
-
-#ifndef CONFIG_FORCE_HARD_FLOAT
-double __floatsidf (int i) { return i; }
-unsigned int __fixunsdfsi (double d) { return d; }
-double __adddf3(double a, double b) { return a+b; }
-double __addsf3(float a, float b) { return a+b; }
-double __subdf3(double a, double b) { return a-b; }
-double __extendsfdf2(float a) {return a;}
-#endif
-
-#undef LOOP_TEST
-#undef DUMP_RX
-#undef DUMP_TX
-#undef DEBUG_TX_DESC2
-#undef RX_DONT_PASS_UL
-#undef DEBUG_EPROM
-#undef DEBUG_RX_VERBOSE
-#undef DUMMY_RX
-#undef DEBUG_ZERO_RX
-#undef DEBUG_RX_SKB
-#undef DEBUG_TX_FRAG
-#undef DEBUG_RX_FRAG
-#undef DEBUG_TX_FILLDESC
-#undef DEBUG_TX
-#undef DEBUG_IRQ
-#undef DEBUG_RX
-#undef DEBUG_RXALLOC
-#undef DEBUG_REGISTERS
-#undef DEBUG_RING
-#undef DEBUG_IRQ_TASKLET
-#undef DEBUG_TX_ALLOC
-#undef DEBUG_TX_DESC
-
-//#define CONFIG_RTL8180_IO_MAP
-
-#include "r8180_hw.h"
-#include "r8187.h"
-#include "r8180_rtl8225.h" /* RTL8225 Radio frontend */
-#include "r8180_93cx6.h"   /* Card EEPROM */
-#include "r8180_wx.h"
-
-
-// FIXME: check if 2.6.7 is ok
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,7))
-#define usb_kill_urb usb_unlink_urb
-#endif
-
-#ifdef CONFIG_RTL8180_PM
-#include "r8180_pm.h"
-#endif
-
-#ifndef USB_VENDOR_ID_REALTEK
-#define USB_VENDOR_ID_REALTEK		0x0bda
-#endif
-#ifndef USB_VENDOR_ID_NETGEAR
-#define USB_VENDOR_ID_NETGEAR		0x0846
-#endif
-
-static struct usb_device_id rtl8187_usb_id_tbl[] = {
-	{USB_DEVICE(USB_VENDOR_ID_REALTEK, 0x8187)},
-	{USB_DEVICE(USB_VENDOR_ID_NETGEAR, 0x6100)},
-	{USB_DEVICE(USB_VENDOR_ID_NETGEAR, 0x6a00)},
-
-	{}
-};
-
-static char* ifname = "wlan%d";
-#if 0
-static int hwseqnum = 0;
-static int hwwep = 0;
-#endif
-static int channels = 0x3fff;
-
-MODULE_LICENSE("GPL");
-MODULE_VERSION("V 1.1");
-MODULE_DEVICE_TABLE(usb, rtl8187_usb_id_tbl);
-MODULE_AUTHOR("Andrea Merello <andreamrl@tiscali.it>");
-MODULE_DESCRIPTION("Linux driver for Realtek RTL8187 WiFi cards");
-
-#if 0
-MODULE_PARM(ifname,"s");
-MODULE_PARM_DESC(devname," Net interface name, wlan%d=default");
-
-MODULE_PARM(hwseqnum,"i");
-MODULE_PARM_DESC(hwseqnum," Try to use hardware 802.11 header sequence numbers. Zero=default");
-
-MODULE_PARM(hwwep,"i");
-MODULE_PARM_DESC(hwwep," Try to use hardware WEP support. Still broken and not available on all cards");
-
-MODULE_PARM(channels,"i");
-MODULE_PARM_DESC(channels," Channel bitmask for specific locales. NYI");
-#endif
-
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 9)
-module_param(ifname, charp, S_IRUGO|S_IWUSR );
-//module_param(hwseqnum,int, S_IRUGO|S_IWUSR);
-//module_param(hwwep,int, S_IRUGO|S_IWUSR);
-module_param(channels,int, S_IRUGO|S_IWUSR);
-#else
-MODULE_PARM(ifname, "s");
-//MODULE_PARM(hwseqnum,"i");
-//MODULE_PARM(hwwep,"i");
-MODULE_PARM(channels,"i");
-#endif
-
-MODULE_PARM_DESC(devname," Net interface name, wlan%d=default");
-//MODULE_PARM_DESC(hwseqnum," Try to use hardware 802.11 header sequence numbers. Zero=default");
-//MODULE_PARM_DESC(hwwep," Try to use hardware WEP support. Still broken and not available on all cards");
-MODULE_PARM_DESC(channels," Channel bitmask for specific locales. NYI");
-
-static int __devinit rtl8187_usb_probe(struct usb_interface *intf,
-			 const struct usb_device_id *id);
-			 
-static void __devexit rtl8187_usb_disconnect(struct usb_interface *intf);
-
-static struct usb_driver rtl8187_usb_driver = {
-
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 16)
-	.owner		= THIS_MODULE,
-#endif
-	.name		= RTL8187_MODULE_NAME,	          /* Driver name   */
-	.id_table	= rtl8187_usb_id_tbl,	          /* PCI_ID table  */
-	.probe		= rtl8187_usb_probe,	          /* probe fn      */
-	.disconnect	= rtl8187_usb_disconnect,	  /* remove fn     */
-#ifdef CONFIG_RTL8180_PM
-	.suspend	= rtl8180_suspend,	          /* PM suspend fn */
-	.resume		= rtl8180_resume,                 /* PM resume fn  */
-#else
-	.suspend	= NULL,			          /* PM suspend fn */
-	.resume      	= NULL,			          /* PM resume fn  */
-#endif
-};
-
-
-void write_nic_byte_E(struct net_device *dev, int indx, u8 data)
-{
-	
-	struct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);
-	struct usb_device *udev = priv->udev;
-	
-	usb_control_msg(udev, usb_sndctrlpipe(udev, 0),
-			       RTL8187_REQ_SET_REGS, RTL8187_REQT_WRITE,
-			       indx|0xfe00, 0, &data, 1, HZ / 2);
-}
-
-
-void write_nic_byte(struct net_device *dev, int indx, u8 data)
-{
-	
-	struct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);
-	struct usb_device *udev = priv->udev;
-	
-	usb_control_msg(udev, usb_sndctrlpipe(udev, 0),
-			       RTL8187_REQ_SET_REGS, RTL8187_REQT_WRITE,
-			       indx|0xff00, 0, &data, 1, HZ / 2);
-}
-
-
-void write_nic_word(struct net_device *dev, int indx, u16 data)
-{
-	
-	struct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);
-	struct usb_device *udev = priv->udev;
-	
-	usb_control_msg(udev, usb_sndctrlpipe(udev, 0),
-			       RTL8187_REQ_SET_REGS, RTL8187_REQT_WRITE,
-			       indx|0xff00, 0, &data, 2, HZ / 2);
-}
-
-
-void write_nic_dword(struct net_device *dev, int indx, u32 data)
-{
-	
-	struct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);
-	struct usb_device *udev = priv->udev;
-	
-	usb_control_msg(udev, usb_sndctrlpipe(udev, 0),
-			       RTL8187_REQ_SET_REGS, RTL8187_REQT_WRITE,
-			       indx|0xff00, 0, &data, 4, HZ / 2);
-}
- 
- 
- 
-u8 read_nic_byte(struct net_device *dev, int indx)
-{
-	u8 data;
-	struct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);
-	struct usb_device *udev = priv->udev;
-	
-	usb_control_msg(udev, usb_rcvctrlpipe(udev, 0),
-			       RTL8187_REQ_GET_REGS, RTL8187_REQT_READ,
-			       indx|0xff00, 0, &data, 1, HZ / 2);
-	return data;
-}
-
-u8 read_nic_byte_E(struct net_device *dev, int indx)
-{
-	u8 data;
-	struct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);
-	struct usb_device *udev = priv->udev;
-	
-	usb_control_msg(udev, usb_rcvctrlpipe(udev, 0),
-			       RTL8187_REQ_GET_REGS, RTL8187_REQT_READ,
-			       indx|0xfe00, 0, &data, 1, HZ / 2);
-	return data;
-}
-
- 
-u16 read_nic_word(struct net_device *dev, int indx)
-{
-	u16 data;
-	struct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);
-	struct usb_device *udev = priv->udev;
-	
-	usb_control_msg(udev, usb_rcvctrlpipe(udev, 0),
-			       RTL8187_REQ_GET_REGS, RTL8187_REQT_READ,
-			       indx|0xff00, 0, &data, 2, HZ / 2);
-	return data;
-}
-
-
-u32 read_nic_dword(struct net_device *dev, int indx)
-{
-	u32 data;
-	struct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);
-	struct usb_device *udev = priv->udev;
-	
-	usb_control_msg(udev, usb_rcvctrlpipe(udev, 0),
-			       RTL8187_REQ_GET_REGS, RTL8187_REQT_READ,
-			       indx|0xff00, 0, &data, 4, HZ / 2);
-	return data;
-}
-
-/* this might still called in what was the PHY rtl8185/rtl8187 common code 
- * plans are to possibilty turn it again in one common code...
- */
-inline void force_pci_posting(struct net_device *dev)
-{
-}
-
-
-//irqreturn_t rtl8180_interrupt(int irq, void *netdev, struct pt_regs *regs);
-//void set_nic_rxring(struct net_device *dev);
-//void set_nic_txring(struct net_device *dev);
-static struct net_device_stats *rtl8180_stats(struct net_device *dev);
-void rtl8180_commit(struct net_device *dev);
-void rtl8180_restart(struct net_device *dev);
-
-/****************************************************************************
-   -----------------------------PROCFS STUFF-------------------------
-*****************************************************************************/
-
-static struct proc_dir_entry *rtl8180_proc = NULL;
-
-static int proc_get_registers(char *page, char **start,
-			  off_t offset, int count,
-			  int *eof, void *data)
-{
-	struct net_device *dev = data;
-//	struct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);
-	
-	int len = 0;
-	int i,n;
-			
-	int max=0xff;
-	
-	/* This dump the current register page */
-	for(n=0;n<=max;)
-	{
-		//printk( "\nD: %2x> ", n);
-		len += snprintf(page + len, count - len,
-			"\nD:  %2x > ",n);
-
-		for(i=0;i<16 && n<=max;i++,n++)
-		len += snprintf(page + len, count - len,
-			"%2x ",read_nic_byte(dev,n));
-
-		//	printk("%2x ",read_nic_byte(dev,n));
-	}
-	len += snprintf(page + len, count - len,"\n");
-
-
-		
-	*eof = 1;
-	return len;
-
-}
-
-#if 0
-static int proc_get_stats_hw(char *page, char **start,
-			  off_t offset, int count,
-			  int *eof, void *data)
-{
-	struct net_device *dev = data;
-	struct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);
-	
-	int len = 0;
-	
-	len += snprintf(page + len, count - len,
-		"NIC int: %lu\n"
-		"Total int: %lu\n",
-		priv->stats.ints,
-		priv->stats.shints);
-			
-	*eof = 1;
-	return len;
-}
-#endif
-
-static int proc_get_stats_tx(char *page, char **start,
-			  off_t offset, int count,
-			  int *eof, void *data)
-{
-	struct net_device *dev = data;
-	struct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);
-	
-	int len = 0;
-	
-	len += snprintf(page + len, count - len,
-		"TX normal priority ok int: %lu\n"
-		"TX normal priority error int: %lu\n"
-//		"TX high priority ok int: %lu\n"
-//		"TX high priority failed error int: %lu\n"
-		"TX low priority ok int: %lu\n"
-		"TX low priority failed error int: %lu\n"
-		"TX queue resume: %lu\n"
-		"TX queue stopped?: %d\n"
-		"TX fifo overflow: %lu\n"
-//		"TX beacon: %lu\n"
-		"TX lp queue: %d\n"
-		"TX np queue: %d\n"
-		"TX HW queue: %d\n"
-		"TX lp dropped: %lu\n"
-		"TX np dropped: %lu\n"
-		"TX total data packets %lu\n",		
-//		"TX beacon aborted: %lu\n",
-		priv->stats.txnpokint,
-		priv->stats.txnperr,
-//		priv->stats.txhpokint,
-//		priv->stats.txhperr,
-		priv->stats.txlpokint,
-		priv->stats.txlperr,
-		priv->stats.txresumed,
-		netif_queue_stopped(dev),
-		priv->stats.txoverflow,
-//		priv->stats.txbeacon,
-		atomic_read(&(priv->tx_lp_pending)),
-		atomic_read(&(priv->tx_np_pending)),
-		read_nic_byte(dev, TXFIFOCOUNT),
-		priv->stats.txlpdrop,
-		priv->stats.txnpdrop,
-		priv->stats.txdatapkt
-//		priv->stats.txbeaconerr
-		);
-			
-	*eof = 1;
-	return len;
-}		
-
-
-
-static int proc_get_stats_rx(char *page, char **start,
-			  off_t offset, int count,
-			  int *eof, void *data)
-{
-	struct net_device *dev = data;
-	struct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);
-	
-	int len = 0;
-	
-	len += snprintf(page + len, count - len,
-		"RX packets: %lu\n"
-		"RX urb status error: %lu\n"
-		"RX invalid urb error: %lu\n",
-		priv->stats.rxok,
-		priv->stats.rxstaterr,
-		priv->stats.rxurberr);
-			
-	*eof = 1;
-	return len;
-}		
-
-
-static struct iw_statistics *r8180_get_wireless_stats(struct net_device *dev)
-{
-       struct r8180_priv *priv = ieee80211_priv(dev);
-
-       return &priv->wstats;
-}
-
-void rtl8180_proc_module_init(void)
-{	
-	DMESG("Initializing proc filesystem");
-	rtl8180_proc=create_proc_entry(RTL8187_MODULE_NAME, S_IFDIR, proc_net);
-}
-
-
-void rtl8180_proc_module_remove(void)
-{
-	remove_proc_entry(RTL8187_MODULE_NAME, proc_net);
-}
-
-
-void rtl8180_proc_remove_one(struct net_device *dev)
-{
-	struct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);
-	if (priv->dir_dev) {
-	//	remove_proc_entry("stats-hw", priv->dir_dev);
-		remove_proc_entry("stats-tx", priv->dir_dev);
-		remove_proc_entry("stats-rx", priv->dir_dev);
-	//	remove_proc_entry("stats-ieee", priv->dir_dev);
-	//	remove_proc_entry("stats-ap", priv->dir_dev);
-		remove_proc_entry("registers", priv->dir_dev);
-		remove_proc_entry(dev->name, rtl8180_proc);
-		priv->dir_dev = NULL;
-	}
-}
-
-
-void rtl8180_proc_init_one(struct net_device *dev)
-{
-	struct proc_dir_entry *e;
-	struct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);
-	priv->dir_dev = create_proc_entry(dev->name, 
-					  S_IFDIR | S_IRUGO | S_IXUGO, 
-					  rtl8180_proc);
-	if (!priv->dir_dev) {
-		DMESGE("Unable to initialize /proc/net/rtl8187/%s\n",
-		      dev->name);
-		return;
-	}
-	#if 0
-	e = create_proc_read_entry("stats-hw", S_IFREG | S_IRUGO,
-				   priv->dir_dev, proc_get_stats_hw, dev);
-				   
-	if (!e) {
-		DMESGE("Unable to initialize "
-		      "/proc/net/rtl8187/%s/stats-hw\n",
-		      dev->name);
-	}
-	#endif
-	e = create_proc_read_entry("stats-rx", S_IFREG | S_IRUGO,
-				   priv->dir_dev, proc_get_stats_rx, dev);
-				   
-	if (!e) {
-		DMESGE("Unable to initialize "
-		      "/proc/net/rtl8187/%s/stats-rx\n",
-		      dev->name);
-	}
-	
-	
-	e = create_proc_read_entry("stats-tx", S_IFREG | S_IRUGO,
-				   priv->dir_dev, proc_get_stats_tx, dev);
-				   
-	if (!e) {
-		DMESGE("Unable to initialize "
-		      "/proc/net/rtl8187/%s/stats-tx\n",
-		      dev->name);
-	}
-	#if 0
-	e = create_proc_read_entry("stats-ieee", S_IFREG | S_IRUGO,
-				   priv->dir_dev, proc_get_stats_ieee, dev);
-				   
-	if (!e) {
-		DMESGE("Unable to initialize "
-		      "/proc/net/rtl8187/%s/stats-ieee\n",
-		      dev->name);
-	}
-	
-	
-	e = create_proc_read_entry("stats-ap", S_IFREG | S_IRUGO,
-				   priv->dir_dev, proc_get_stats_ap, dev);
-				   
-	if (!e) {
-		DMESGE("Unable to initialize "
-		      "/proc/net/rtl8187/%s/stats-ap\n",
-		      dev->name);
-	}
-	#endif
-	
-	e = create_proc_read_entry("registers", S_IFREG | S_IRUGO,
-				   priv->dir_dev, proc_get_registers, dev);
-	
-	if (!e) {
-		DMESGE("Unable to initialize "
-		      "/proc/net/rtl8187/%s/registers\n",
-		      dev->name);
-	}
-}
-/****************************************************************************
-   -----------------------------MISC STUFF-------------------------
-*****************************************************************************/
-
-/* this is only for debugging */
-void print_buffer(u32 *buffer, int len)
-{
-	int i;
-	u8 *buf =(u8*)buffer;
-	
-	printk("ASCII BUFFER DUMP (len: %x):\n",len);
-	
-	for(i=0;i<len;i++)
-		printk("%c",buf[i]);
-		
-	printk("\nBINARY BUFFER DUMP (len: %x):\n",len);
-	
-	for(i=0;i<len;i++)
-		printk("%x",buf[i]);
-
-	printk("\n");
-}
-
-short check_nic_enought_desc(struct net_device *dev, priority_t priority)
-{
-	struct r8180_priv *priv = ieee80211_priv(dev);
-	
-	int used = atomic_read((priority == NORM_PRIORITY) ? 
-		&priv->tx_np_pending : &priv->tx_lp_pending);
-	
-	return (used < MAX_TX_URB);
-}
-
-void tx_timeout(struct net_device *dev)
-{
-	struct r8180_priv *priv = ieee80211_priv(dev);
-	//rtl8180_commit(dev);
-	schedule_work(&priv->reset_wq);
-	//DMESG("TXTIMEOUT");
-}
-
-
-/* this is only for debug */
-void dump_eprom(struct net_device *dev)
-{
-	int i;
-	for(i=0; i<63; i++)
-		DMESG("EEPROM addr %x : %x", i, eprom_read(dev,i));
-}
-
-/* this is only for debug */
-void rtl8180_dump_reg(struct net_device *dev)
-{
-	int i;
-	int n;
-	int max=0xff;
-	
-	DMESG("Dumping NIC register map");	
-	
-	for(n=0;n<=max;)
-	{
-		printk( "\nD: %2x> ", n);
-		for(i=0;i<16 && n<=max;i++,n++)
-			printk("%2x ",read_nic_byte(dev,n));
-	}
-	printk("\n");
-}
-
-/****************************************************************************
-      ------------------------------HW STUFF---------------------------
-*****************************************************************************/
-
-
-void rtl8180_irq_enable(struct net_device *dev)
-{
-	struct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);	
-	//priv->irq_enabled = 1;
-/*
-	write_nic_word(dev,INTA_MASK,INTA_RXOK | INTA_RXDESCERR | INTA_RXOVERFLOW |\ 
-	INTA_TXOVERFLOW | INTA_HIPRIORITYDESCERR | INTA_HIPRIORITYDESCOK |\ 
-	INTA_NORMPRIORITYDESCERR | INTA_NORMPRIORITYDESCOK |\
-	INTA_LOWPRIORITYDESCERR | INTA_LOWPRIORITYDESCOK | INTA_TIMEOUT);
-*/
-	write_nic_word(dev,INTA_MASK, priv->irq_mask);
-}
-
-
-void rtl8180_irq_disable(struct net_device *dev)
-{
-//	struct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);	
-
-	write_nic_word(dev,INTA_MASK,0);
-	force_pci_posting(dev);
-//	priv->irq_enabled = 0;
-}
-
-
-void rtl8180_set_mode(struct net_device *dev,int mode)
-{
-	u8 ecmd;
-	ecmd=read_nic_byte(dev, EPROM_CMD);
-	ecmd=ecmd &~ EPROM_CMD_OPERATING_MODE_MASK;
-	ecmd=ecmd | (mode<<EPROM_CMD_OPERATING_MODE_SHIFT);
-	ecmd=ecmd &~ (1<<EPROM_CS_SHIFT);
-	ecmd=ecmd &~ (1<<EPROM_CK_SHIFT);
-	write_nic_byte(dev, EPROM_CMD, ecmd);
-}
-
-
-void rtl8180_update_msr(struct net_device *dev)
-{
-	struct r8180_priv *priv = ieee80211_priv(dev);
-	u8 msr;
-	
-	msr  = read_nic_byte(dev, MSR);
-	msr &= ~ MSR_LINK_MASK;
-	
-	/* do not change in link_state != WLAN_LINK_ASSOCIATED.
-	 * msr must be updated if the state is ASSOCIATING. 
-	 * this is intentional and make sense for ad-hoc and
-	 * master (see the create BSS/IBSS func)
-	 */
-	if (priv->ieee80211->state == IEEE80211_LINKED){ 
-			
-		if (priv->ieee80211->iw_mode == IW_MODE_INFRA)
-			msr |= (MSR_LINK_MANAGED<<MSR_LINK_SHIFT);
-		else if (priv->ieee80211->iw_mode == IW_MODE_ADHOC)
-			msr |= (MSR_LINK_ADHOC<<MSR_LINK_SHIFT);
-		else if (priv->ieee80211->iw_mode == IW_MODE_MASTER)
-			msr |= (MSR_LINK_MASTER<<MSR_LINK_SHIFT);
-		
-	}else
-		msr |= (MSR_LINK_NONE<<MSR_LINK_SHIFT);
-		
-	write_nic_byte(dev, MSR, msr);
-}
-
-void rtl8180_set_chan(struct net_device *dev,short ch)
-{
-	struct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);
-	u32 tx;
-	priv->chan=ch;
-	#if 0
-	if(priv->ieee80211->iw_mode == IW_MODE_ADHOC || 
-		priv->ieee80211->iw_mode == IW_MODE_MASTER){
-	
-			priv->ieee80211->link_state = WLAN_LINK_ASSOCIATED;	
-			priv->ieee80211->master_chan = ch;
-			rtl8180_update_beacon_ch(dev); 
-		}
-	#endif
-	
-	/* this hack should avoid frame TX during channel setting*/
-	tx = read_nic_dword(dev,TX_CONF);
-	tx &= ~TX_LOOPBACK_MASK;
-
-#ifndef LOOP_TEST	
-	write_nic_dword(dev,TX_CONF, tx |( TX_LOOPBACK_MAC<<TX_LOOPBACK_SHIFT));
-
-	priv->rf_set_chan(dev,priv->chan);
-	mdelay(10);
-	write_nic_dword(dev,TX_CONF,tx | (TX_LOOPBACK_NONE<<TX_LOOPBACK_SHIFT));
-#endif
-}
-void rtl8187_rx_isr(struct urb *rx_urb, struct pt_regs *regs);
-
-
-void rtl8187_rx_urbsubmit(struct net_device *dev, struct urb* rx_urb)
-{
-	struct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);
-	int err;
-	
-//	u8 *rx;
-	
-	//DMESG("starting RX");
-	/*rx = kmalloc(RX_URB_SIZE*sizeof(u8),GFP_ATOMIC);
-	if(!rx){ 
-		DMESGE("unable to allocate RX buffer");
-		return;
-	}*/
-	
-	usb_fill_bulk_urb(rx_urb,priv->udev,
-		usb_rcvbulkpipe(priv->udev,0x81), rx_urb->transfer_buffer,
-			RX_URB_SIZE,rtl8187_rx_isr,dev);
-	err = usb_submit_urb(rx_urb, GFP_ATOMIC);	
-	if(err && err != -EPERM){
-		DMESGE("cannot submit RX command. URB_STATUS %x",rx_urb->status);
-		
-	}
-	
-}
-
-
-void rtl8187_rx_initiate(struct net_device *dev)
-{
-	int i;
-	struct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);
-	
-	if(!priv->rx_urb)
-		DMESGE("Cannot intiate RX urb mechanism");
-	for(i=0;i<MAX_RX_URB;i++) // RX_MAX_URB is 1 
-		rtl8187_rx_urbsubmit(dev,priv->rx_urb[i]);
-		
-}
-
-void rtl8187_set_rxconf(struct net_device *dev)
-{
-	struct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);
-	u32 rxconf;
-	
-	rxconf=read_nic_dword(dev,RX_CONF);
-	rxconf = rxconf &~ MAC_FILTER_MASK;
-	rxconf = rxconf | (1<<ACCEPT_MNG_FRAME_SHIFT);
-	rxconf = rxconf | (1<<ACCEPT_DATA_FRAME_SHIFT);
-	rxconf = rxconf | (1<<ACCEPT_BCAST_FRAME_SHIFT);
-	rxconf = rxconf | (1<<ACCEPT_MCAST_FRAME_SHIFT);
-	rxconf = rxconf | (1<<ACCEPT_CTL_FRAME_SHIFT);	
-
-	if (dev->flags & IFF_PROMISC) DMESG ("NIC in promisc mode");
-	
-	if(priv->ieee80211->iw_mode == IW_MODE_MONITOR || \
-	   dev->flags & IFF_PROMISC){
-		rxconf = rxconf | (1<<ACCEPT_ALLMAC_FRAME_SHIFT);
-	}else{
-		rxconf = rxconf | (1<<ACCEPT_NICMAC_FRAME_SHIFT);
-		rxconf = rxconf | (1<<RX_CHECK_BSSID_SHIFT);
-	}
-	
-	/*if(priv->ieee80211->iw_mode == IW_MODE_MASTER){
-		rxconf = rxconf | (1<<ACCEPT_ALLMAC_FRAME_SHIFT);
-		rxconf = rxconf | (1<<RX_CHECK_BSSID_SHIFT);
-	}*/
-	
-	if(priv->ieee80211->iw_mode == IW_MODE_MONITOR){
-		rxconf = rxconf | (1<<ACCEPT_ICVERR_FRAME_SHIFT);
-		rxconf = rxconf | (1<<ACCEPT_PWR_FRAME_SHIFT);
-	}
-	
-	if( priv->crcmon == 1 && priv->ieee80211->iw_mode == IW_MODE_MONITOR)
-		rxconf = rxconf | (1<<ACCEPT_CRCERR_FRAME_SHIFT);
-	
-	
-	rxconf = rxconf &~ RX_FIFO_THRESHOLD_MASK;
-	rxconf = rxconf | (RX_FIFO_THRESHOLD_NONE<<RX_FIFO_THRESHOLD_SHIFT);
-	
-	
-	rxconf = rxconf | (1<<RX_AUTORESETPHY_SHIFT);
-	
-	rxconf = rxconf &~ MAX_RX_DMA_MASK;
-	rxconf = rxconf | (MAX_RX_DMA_2048<<MAX_RX_DMA_SHIFT);
-	
-	rxconf = rxconf | RCR_ONLYERLPKT;
-	
-//	rxconf = rxconf &~ RCR_CS_MASK;
-//	rxconf = rxconf | (1<<RCR_CS_SHIFT);
-
-	write_nic_dword(dev, RX_CONF, rxconf);	
-	
-	// V rtl suggested V //
-//	write_nic_dword(dev, RX_CONF, 0x901ce70e);
-	
-	//fix_rx_fifo(dev);
-// 	//set_nic_rxring(dev);
-	#ifdef DEBUG_RX
-	DMESG("rxconf: %x %x",rxconf ,read_nic_dword(dev,RX_CONF));
-	#endif
-}
-
-void rtl8180_rx_enable(struct net_device *dev)
-{
-	u8 cmd;
-	
-	
-	rtl8187_rx_initiate(dev);
-
-	rtl8187_set_rxconf(dev);	
-
-	cmd=read_nic_byte(dev,CMD);
-	write_nic_byte(dev,CMD,cmd | (1<<CMD_RX_ENABLE_SHIFT));
-#if 0
-	/* In rtl8139 driver seems that DMA threshold has to be written 
-	 *  after enabling RX, so we rewrite RX_CONFIG register 
-	 */
-	//mdelay(100);
-	write_nic_dword(dev, RX_CONF, rxconf); 
-	
-#endif
-	
-}
-
-
-void rtl8180_tx_enable(struct net_device *dev)
-{
-	u8 cmd;
-	u8 byte;
-	u32 txconf;
-	struct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);
-	
-	byte = read_nic_byte(dev,CW_CONF);
-	byte &= ~(1<<CW_CONF_PERPACKET_CW_SHIFT);
-	byte &= ~(1<<CW_CONF_PERPACKET_RETRY_SHIFT);
-	write_nic_byte(dev, CW_CONF, byte);
-	
-	byte = read_nic_byte(dev, TX_AGC_CTL);
-	byte &= ~(1<<TX_AGC_CTL_PERPACKET_GAIN_SHIFT);
-	byte &= ~(1<<TX_AGC_CTL_PERPACKET_ANTSEL_SHIFT);
-	byte &= ~(1<<TX_AGC_CTL_FEEDBACK_ANT);
-	write_nic_byte(dev, TX_AGC_CTL, byte);
-	
-	txconf= read_nic_dword(dev,TX_CONF);
-	
-	#if 0
-	if(priv->card_8185){
-		
-		txconf = txconf &~ (1<<TCR_PROBE_NOTIMESTAMP_SHIFT);
-	
-	}else{
-	
-		if(priv->ieee80211->hw_seq) 
-			txconf= txconf &~ (1<<TX_CONF_HEADER_AUTOICREMENT_SHIFT);
-		else 
-			txconf= txconf | (1<<TX_CONF_HEADER_AUTOICREMENT_SHIFT);
-	}
-	#endif
-
-	txconf = txconf &~ TX_LOOPBACK_MASK;
-	
-#ifndef LOOP_TEST
-	txconf = txconf | (TX_LOOPBACK_NONE<<TX_LOOPBACK_SHIFT);
-#else
-	txconf = txconf | (TX_LOOPBACK_BASEBAND<<TX_LOOPBACK_SHIFT);
-#endif
-	txconf = txconf &~ TCR_DPRETRY_MASK;
-	txconf = txconf &~ TCR_RTSRETRY_MASK;
-	
-	txconf = txconf | (priv->retry_data<<TX_DPRETRY_SHIFT); // long
-	txconf = txconf | (priv->retry_rts<<TX_RTSRETRY_SHIFT); // short
-	
-	txconf = txconf &~ (1<<TX_NOCRC_SHIFT);
-	
-	txconf = txconf &~ TCR_MXDMA_MASK;
-	txconf = txconf | (TCR_MXDMA_2048<<TCR_MXDMA_SHIFT);
-	
-	txconf = txconf | TCR_CWMIN;
-	txconf = txconf | TCR_DISCW;
-	txconf = txconf &~ TCR_SWPLCPLEN;
-	
-	txconf=txconf | (1<<TX_NOICV_SHIFT);
-	
-	write_nic_dword(dev,TX_CONF,txconf);
-	
-	// V RTL suggested V //
-//	write_nic_dword(dev,TX_CONF,0x00e00707);
-
-
-#ifdef DEBUG_TX
-	DMESG("txconf: %x %x",txconf,read_nic_dword(dev,TX_CONF));
-#endif
-	
-	cmd=read_nic_byte(dev,CMD);
-	write_nic_byte(dev,CMD,cmd | (1<<CMD_TX_ENABLE_SHIFT));		
-
-//	mdelay(100);
-	//write_nic_dword(dev,TX_CONF,txconf);
-//	#endif
-/*
-	rtl8180_set_mode(dev,EPROM_CMD_CONFIG);
-	write_nic_byte(dev, TX_DMA_POLLING, priv->dma_poll_mask);
-	rtl8180_set_mode(dev,EPROM_CMD_NORMAL);
-	*/
-}
-
-#if 0
-void rtl8180_beacon_tx_enable(struct net_device *dev)
-{
-	struct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);
-	priv->dma_poll_mask &=~(1<<TX_DMA_STOP_BEACON_SHIFT);
-	rtl8180_set_mode(dev,EPROM_CMD_CONFIG);
-	write_nic_byte(dev,TX_DMA_POLLING,priv->dma_poll_mask);	
-	rtl8180_set_mode(dev,EPROM_CMD_NORMAL);
-}
-
-
-void rtl8180_
-_disable(struct net_device *dev) 
-{
-	struct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);
-	priv->dma_poll_mask |= (1<<TX_DMA_STOP_BEACON_SHIFT);
-	rtl8180_set_mode(dev,EPROM_CMD_CONFIG);
-	write_nic_byte(dev,TX_DMA_POLLING,priv->dma_poll_mask);
-	rtl8180_set_mode(dev,EPROM_CMD_NORMAL);
-}
-
-#endif
-
-
-void rtl8180_rtx_disable(struct net_device *dev)
-{
-	u8 cmd;
-	int i;
-	struct r8180_priv *priv = ieee80211_priv(dev);
-	
-	cmd=read_nic_byte(dev,CMD);
-	write_nic_byte(dev, CMD, cmd &~ \
-		       ((1<<CMD_RX_ENABLE_SHIFT)|(1<<CMD_TX_ENABLE_SHIFT)));
-	force_pci_posting(dev);
-	mdelay(10);
-	if(priv->rx_urb){
-		for(i=0;i<MAX_RX_URB;i++)
-		usb_kill_urb(priv->rx_urb[i]);
-	}
-	/*while (read_nic_byte(dev,CMD) & (1<<CMD_RX_ENABLE_SHIFT))
-	  udelay(10); 
-	*/
-	
-//	if(!priv->rx_skb_complete)
-//		dev_kfree_skb_any(priv->rx_skb);
-}
-
-
-int alloc_tx_beacon_desc_ring(struct net_device *dev, int count)
-{
-	#if 0
-	int i;
-	u32 *tmp;
-	struct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);
-	
-	priv->txbeaconring = (u32*)pci_alloc_consistent(priv->pdev,
-					  sizeof(u32)*8*count, 
-					  &priv->txbeaconringdma);
-	if (!priv->txbeaconring) return -1;
-	for (tmp=priv->txbeaconring,i=0;i<count;i++){
-		*tmp = *tmp &~ (1<<31); // descriptor empty, owned by the drv 
-		/*
-		*(tmp+2) = (u32)dma_tmp;
-		*(tmp+3) = bufsize;
-		*/
-		if(i+1<count)
-			*(tmp+4) = (u32)priv->txbeaconringdma+((i+1)*8*4);
-		else
-			*(tmp+4) = (u32)priv->txbeaconringdma;
-		
-		tmp=tmp+8;
-	}
-	#endif
-	return 0;
-}
-
-
-void rtl8180_reset(struct net_device *dev)
-{
-	
-	u8 cr;
-	
-	/* make sure the analog power is on before
-	 * reset, otherwise reset may fail
-	 */
-	rtl8180_set_anaparam(dev, RTL8225_ANAPARAM_ON);
-	rtl8185_set_anaparam2(dev, RTL8225_ANAPARAM2_ON);
-	
-	rtl8180_irq_disable(dev);
-
-	mdelay(200);
-	write_nic_byte_E(dev,0x18,0x10);
-	write_nic_byte_E(dev,0x18,0x11);
-	write_nic_byte_E(dev,0x18,0x00);
-	mdelay(200);
-	
-	cr=read_nic_byte(dev,CMD);
-	cr = cr & 2;
-	cr = cr | (1<<CMD_RST_SHIFT);
-	write_nic_byte(dev,CMD,cr);
-	
-	force_pci_posting(dev);
-	
-	mdelay(200);
-	
-	if(read_nic_byte(dev,CMD) & (1<<CMD_RST_SHIFT)) 
-		DMESGW("Card reset timeout!");
-	else 
-		DMESG("Card successfully reset");
-
-	rtl8180_set_mode(dev,EPROM_CMD_LOAD);
-	force_pci_posting(dev);
-	mdelay(200);
-
-	/* after the eeprom load cycle, make sure we have
-	 * correct anaparams
-	 */
-	rtl8180_set_anaparam(dev, RTL8225_ANAPARAM_ON);
-	rtl8185_set_anaparam2(dev, RTL8225_ANAPARAM2_ON);
-	
-}
-
-inline u16 ieeerate2rtlrate(int rate)
-{
-	switch(rate){
-	case 10:	
-	return 0;
-	case 20:
-	return 1;
-	case 55:
-	return 2;
-	case 110:
-	return 3;
-	case 60:
-	return 4;
-	case 90:
-	return 5;
-	case 120:
-	return 6;
-	case 180:
-	return 7;
-	case 240:
-	return 8;
-	case 360:
-	return 9;
-	case 480:
-	return 10;
-	case 540:
-	return 11;
-	default:
-	return 3;
-	
-	}
-}
-static u16 rtl_rate[] = {10,20,55,110,60,90,120,180,240,360,480,540};
-inline u16 rtl8180_rate2rate(short rate)
-{
-	if (rate >11) return 0;
-	return rtl_rate[rate]; 
-}
-		
-
-void rtl8187_rx_isr(struct urb *rx_urb, struct pt_regs *regs)
-{
-	struct net_device *dev = (struct net_device*)rx_urb->context;
-	struct r8180_priv *priv = ieee80211_priv(dev);
-
-	priv->rxurb_task = rx_urb;
-//	DMESGW("David: Rx tasklet start!");
-	tasklet_schedule(&priv->irq_rx_tasklet);	
-//	DMESGW("=David: Rx tasklet finish!");
-}
-
-#if 0
-void rtl8180_tx_queues_stop(struct net_device *dev)
-{
-	//struct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);
-	u8 dma_poll_mask = (1<<TX_DMA_STOP_LOWPRIORITY_SHIFT);
-	dma_poll_mask |= (1<<TX_DMA_STOP_HIPRIORITY_SHIFT);
-	dma_poll_mask |= (1<<TX_DMA_STOP_NORMPRIORITY_SHIFT);
-	dma_poll_mask |= (1<<TX_DMA_STOP_BEACON_SHIFT);
-
-	rtl8180_set_mode(dev,EPROM_CMD_CONFIG);
-	write_nic_byte(dev,TX_DMA_POLLING,dma_poll_mask);
-	rtl8180_set_mode(dev,EPROM_CMD_NORMAL);
-}
-#endif
-
-void rtl8180_data_hard_stop(struct net_device *dev)
-{
-	//FIXME !!
-	#if 0
-	struct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);
-	priv->dma_poll_mask |= (1<<TX_DMA_STOP_LOWPRIORITY_SHIFT);
-	rtl8180_set_mode(dev,EPROM_CMD_CONFIG);
-	write_nic_byte(dev,TX_DMA_POLLING,priv->dma_poll_mask);
-	rtl8180_set_mode(dev,EPROM_CMD_NORMAL);
-	#endif
-}
-
-
-void rtl8180_data_hard_resume(struct net_device *dev)
-{
-	// FIXME !!
-	#if 0
-	struct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);
-	priv->dma_poll_mask &= ~(1<<TX_DMA_STOP_LOWPRIORITY_SHIFT);
-	rtl8180_set_mode(dev,EPROM_CMD_CONFIG);
-	write_nic_byte(dev,TX_DMA_POLLING,priv->dma_poll_mask);
-	rtl8180_set_mode(dev,EPROM_CMD_NORMAL);
-	#endif
-}
-
-
-/* this function TX data frames when the ieee80211 stack requires this.
- * It checks also if we need to stop the ieee tx queue, eventually do it
- */
-void rtl8180_hard_data_xmit(struct sk_buff *skb, struct net_device *dev, int rate)
-{
-	struct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);
-	
-	short morefrag = 0;	
-	unsigned long flags;
-	struct ieee80211_hdr *h = (struct ieee80211_hdr  *) skb->data;
-
-	if (le16_to_cpu(h->frame_ctl) & IEEE80211_FCTL_MOREFRAGS)
-		morefrag = 1;
-//	DMESG("%x %x", h->frame_ctl, h->seq_ctl);
-	/*
-	* This function doesn't require lock because we make
-	* sure it's called with the tx_lock already acquired.
-	* this come from the kernel's hard_xmit callback (trought
-	* the ieee stack, or from the try_wake_queue (again trought
-	* the ieee stack.
-	*/
-	spin_lock_irqsave(&priv->tx_lock,flags);	
-			
-	//DMESG("TX");
-	if (!check_nic_enought_desc(dev, LOW_PRIORITY)){
-		DMESG("Error: no TX slot ");
-		ieee80211_stop_queue(priv->ieee80211);
-	}
-	
-	rtl8180_tx(dev, (u32*)skb->data, skb->len, LOW_PRIORITY, morefrag,
-		ieeerate2rtlrate(rate));
-
-	priv->stats.txdatapkt++;
-	
-	if (!check_nic_enought_desc(dev, LOW_PRIORITY))
-		ieee80211_stop_queue(priv->ieee80211);
-		
-	spin_unlock_irqrestore(&priv->tx_lock,flags);	
-			
-}
-#if 0
-/* This is a rough attempt to TX a frame
- * This is called by the ieee 80211 stack to TX management frames.
- * If the ring is full packet are dropped (for data frame the queue
- * is stopped before this can happen).
- */
-int rtl8180_hard_start_xmit(struct sk_buff *skb,struct net_device *dev)
-{
-	struct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);
-	int ret;
-	unsigned long flags;
-	
-	spin_lock_irqsave(&priv->tx_lock,flags);
-	
-	ret = rtl8180_tx(dev, (u32*)skb->data, skb->len, NORM_PRIORITY, 0,DEFAULT_BASICRATE);
-/*
-	int i;
-	for(i=0;i<skb->len;i++)
-		printk("%x ", skb->data[i]);
-	printk("--------------------\n");
-*/
-	priv->ieee80211->stats.tx_bytes+=skb->len;
-	priv->ieee80211->stats.tx_packets++;
-	
-	spin_unlock_irqrestore(&priv->tx_lock,flags);	
-	
-	dev_kfree_skb_any(skb);
-	return ret;
-}
-#endif
-
-#if 0
-// longpre 144+48 shortpre 72+24
-u16 rtl8180_len2duration(u32 len, short rate,short* ext)
-{
-	u16 duration;
-	u16 drift;
-	*ext=0;
-	
-	switch(rate){
-	case 0://1mbps
-		*ext=0;
-		duration = ((len+4)<<4) /0x2;
-		drift = ((len+4)<<4) % 0x2;
-		if(drift ==0 ) break;
-		duration++;
-		break;
-		
-	case 1://2mbps
-		*ext=0;
-		duration = ((len+4)<<4) /0x4;
-		drift = ((len+4)<<4) % 0x4;
-		if(drift ==0 ) break;
-		duration++;
-		break;
-		
-	case 2: //5.5mbps
-		*ext=0;
-		duration = ((len+4)<<4) /0xb;
-		drift = ((len+4)<<4) % 0xb;
-		if(drift ==0 ) 
-			break;
-		duration++;
-		break;
-		
-	default:
-	case 3://11mbps				
-		*ext=0;
-		duration = ((len+4)<<4) /0x16;
-		drift = ((len+4)<<4) % 0x16;
-		if(drift ==0 ) 
-			break;
-		duration++;
-		if(drift > 6) 
-			break;
-		*ext=1;
-		break;
-	}
-	
-	return duration;
-}
-#endif
-
-void rtl8180_try_wake_queue(struct net_device *dev, int pri);
-
-void rtl8187_lptx_isr(struct urb *tx_urb, struct pt_regs *regs)
-{
-	struct net_device *dev = (struct net_device*)tx_urb->context;
-	struct r8180_priv *priv = ieee80211_priv(dev);
-	if(tx_urb->status == 0)
-		priv->stats.txlpokint++;
-	else
-		priv->stats.txlperr++;
-	kfree(tx_urb->transfer_buffer);
-	usb_free_urb(tx_urb);
-	atomic_dec(&priv->tx_lp_pending);
-	rtl8180_try_wake_queue(dev,LOW_PRIORITY);
-}
-
-
-void rtl8187_beacon_stop(struct net_device *dev)
-{
-	u8 msr, msrm, msr2;
-	msr  = read_nic_byte(dev, MSR);
-	msrm = msr & MSR_LINK_MASK;
-	msr2 = msr & ~MSR_LINK_MASK;
-	if ((msrm == (MSR_LINK_ADHOC<<MSR_LINK_SHIFT) ||
-		(msrm == (MSR_LINK_MASTER<<MSR_LINK_SHIFT)))){
-		write_nic_byte(dev, MSR, msr2 | MSR_LINK_NONE);
-		write_nic_byte(dev, MSR, msr);	
-	}
-	
-	 
-}
-
-
-void rtl8187_net_update(struct net_device *dev)
-{
-
-	struct r8180_priv *priv = ieee80211_priv(dev);
-	struct ieee80211_network *net;
-	net = & priv->ieee80211->current_network;
-	
-	
-	write_nic_dword(dev,BSSID,((u32*)net->bssid)[0]);
-	write_nic_word(dev,BSSID+4,((u16*)net->bssid)[2]);
-	//for(i=0;i<ETH_ALEN;i++)
-	//	write_nic_byte(dev,BSSID+i,net->bssid[i]);
-
-	rtl8180_update_msr(dev);
-		
-//	rtl8180_set_mode(dev,EPROM_CMD_CONFIG);
-	write_nic_word(dev, AtimWnd, 2);
-	write_nic_word(dev, AtimtrItv, 100);	
-	write_nic_word(dev, BEACON_INTERVAL, net->beacon_interval);
-	write_nic_word(dev, BcnIntTime, 100);
-	
-
-}
-
-void rtl8187_beacon_tx(struct net_device *dev)
-{
-
-	struct r8180_priv *priv = ieee80211_priv(dev);
-	struct sk_buff *skb;
-	int i = 0;
-	
-	rtl8187_net_update(dev);
-	
-	skb = ieee80211_get_beacon(priv->ieee80211);
-	
-	
-	if(!skb){ 
-		DMESG("not enought memory for allocating beacon");
-		return;
-	}
-	
-#if 0	
-	while(MAX_TX_URB!=atomic_read(&priv->tx_np_pending)){
-		msleep_interruptible_rtl(HZ/2);
-		if(i++ > 20){
-			DMESG("get stuck to wait EP3 become ready");
-			return ;
-		}
-	}
-#endif
-	write_nic_byte(dev, BQREQ, read_nic_byte(dev, BQREQ) | (1<<7));
-	
-	i=0;
-	//while(!read_nic_byte(dev,BQREQ & (1<<7)))
-	while( (read_nic_byte(dev, BQREQ) & (1<<7)) == 0 )
-	{
-		msleep_interruptible_rtl(HZ/2);
-		if(i++ > 10){
-			DMESG("get stuck to wait HW beacon to be ready");
-			return ;
-		}
-	}
-		
-	rtl8180_tx(dev, (u32*)skb->data, skb->len, NORM_PRIORITY,
-		0, priv->ieee80211->basic_rate);
-	
-}
-
-void rtl8187_nptx_isr(struct urb *tx_urb, struct pt_regs *regs)
-{
-	struct net_device *dev = (struct net_device*)tx_urb->context;
-	struct r8180_priv *priv = ieee80211_priv(dev);
-	if(tx_urb->status == 0)
-		priv->stats.txnpokint++;
-	else
-		priv->stats.txnperr++;
-	kfree(tx_urb->transfer_buffer);
-	usb_free_urb(tx_urb);
-	atomic_dec(&priv->tx_np_pending);
-	//rtl8180_try_wake_queue(dev,NORM_PRIORITY);
-}
-
-
-/* This function do the real dirty work: it sends a TX command 
- * descriptor plus data URB 
- */
- 
-short rtl8180_tx(struct net_device *dev, u32* txbuf, int len, priority_t priority,
-		 short morefrag, short rate)
-{
-	u32 *tx;
-//	u16 duration;
-//	short ext;
-	int pend ;
-	int status;
-	struct urb *tx_urb;
-	int urb_len;	
-	struct r8180_priv *priv = ieee80211_priv(dev);
-//	int rate = ieeerate2rtlrate(priv->ieee80211->rate);
-
-	pend = atomic_read((priority == NORM_PRIORITY)? &priv->tx_np_pending : &priv->tx_lp_pending);
-	/* we are locked here so the two atomic_read and inc are executed without interleaves */
-	if( pend > MAX_TX_URB){
-		if(priority == NORM_PRIORITY)
-			priv->stats.txnpdrop++;
-		else
-			priv->stats.txlpdrop++;
-		return -1;
-	}
-		
-	
-	//tx = kmalloc((len + 4*3), GFP_ATOMIC);
-	urb_len = len + 4*3;
-	if((0 == urb_len%64)||(0 == urb_len%512)) {
-	  urb_len += 1;	  
-	}
-	tx = kmalloc(urb_len, GFP_ATOMIC);
-	if(!tx) return -ENOMEM;
-printk(KERN_WARNING "urb_len = %d\n", urb_len);	
-	tx_urb = usb_alloc_urb(0,GFP_ATOMIC);
-	
-	if(!tx_urb){
-		
-		kfree(tx);
-		return -ENOMEM;
-	}
-	
-	memcpy(tx+3,txbuf,len);
-	tx[0] = 0;
-	tx[0] |= len & 0xfff;
-	tx[0] |= (1<<15);
-	
-//	if(priv->shortpre)
-//		tx[0] |= (1<<16);
-	
-	//if(len > priv->rts_threshold){
-//		tx[0] |= (1<<23); //ENABLE RTS
-//		tx[0] |= (1<<18); //ENABLE CTS
-	//}
-	if(morefrag) tx[0] |= (1<<17);
-	tx[0] |= (ieeerate2rtlrate(priv->ieee80211->basic_rate) << 19); /* RTS RATE - should be basic rate */
-	tx[0] |= (rate << 24);
-	tx[1] = 0;
-	
-//	duration = rtl8180_len2duration(len,
-//		rate,&ext);	
-//	tx[1] |= (duration & 0x7fff) <<16;
-//	if(ext) tx[1] |= (1<<31);
-
-	
-//	tx[2] = 0x303020;
-	tx[2] = 3;  // CW min
-	tx[2] |= (7<<4); //CW max
-	tx[2] |= (11<<8);//(priv->retry_data<<8); //retry lim
-	
-//	printk("%x\n%x\n",tx[0],tx[1]);
-
-	#ifdef DUMP_TX
-	int i;
-	printk("<Tx pkt>--rate %x---",rate);
-	for (i = 0; i < (len + 3); i++)
-		printk("%2x", ((u8*)tx)[i]);
-	printk("---------------\n");
-	#endif
-
-	
-	/* FIXME check what EP is for low/norm PRI */
-	usb_fill_bulk_urb(tx_urb,priv->udev,
-		usb_sndbulkpipe(priv->udev,(priority == LOW_PRIORITY) ? 2:3), tx,
-			urb_len, (priority == LOW_PRIORITY)?rtl8187_lptx_isr:rtl8187_nptx_isr, dev);
-	status = usb_submit_urb(tx_urb, GFP_ATOMIC);
-	if (!status){
-		atomic_inc((priority == NORM_PRIORITY)? &priv->tx_np_pending : &priv->tx_lp_pending);
-		return 0;
-	}else{
-		DMESGE("Error TX URB %d, error %d",
-			atomic_read((priority == NORM_PRIORITY)? &priv->tx_np_pending : &priv->tx_lp_pending),
-			status);
-		return -1;
-	}
-}
-
- 
-
-void rtl8180_irq_rx_tasklet(struct r8180_priv * priv);
-
-
-short rtl8187_usb_initendpoints(struct net_device *dev)
-{
-	struct r8180_priv *priv = ieee80211_priv(dev);
-	int i;
-	
-	priv->rx_urb = (struct urb**) kmalloc (sizeof(struct urb*) * MAX_RX_URB, GFP_KERNEL);
-	
-	for(i=0;i<MAX_RX_URB;i++){
-		priv->rx_urb[i] = usb_alloc_urb(0,GFP_KERNEL);
-		if(!priv->rx_urb[i]) 
-			goto destroy;
-		
-		priv->rx_urb[i]->transfer_buffer = kmalloc(RX_URB_SIZE, GFP_KERNEL);
-		if(!priv->rx_urb[i]->transfer_buffer) 
-			goto destroy1;
-			
-		priv->rx_urb[i]->transfer_buffer_length = RX_URB_SIZE;
-	}
-	
-	return 0;
-	
-destroy1:
-	usb_free_urb(priv->rx_urb[i]);
-	
-destroy:
-	while (--i >= 0){
-		kfree(priv->rx_urb[i]->transfer_buffer);
-		usb_free_urb(priv->rx_urb[i]);
-	}
-	
-	kfree(priv->rx_urb);
-	
-	priv->rx_urb = NULL;
-	DMESGE("Endpoint Alloc Failure");
-	return -ENOMEM;
-		
-}
-
-void rtl8187_usb_deleteendpoints(struct net_device *dev)
-{
-	struct r8180_priv *priv = ieee80211_priv(dev);
-	int i;
-	
-	if(priv->rx_urb){
-		for(i=0;i<MAX_RX_URB;i++){
-			usb_kill_urb(priv->rx_urb[i]);
-			kfree(priv->rx_urb[i]->transfer_buffer);
-			usb_free_urb(priv->rx_urb[i]);
-		}
-		kfree(priv->rx_urb);
-		priv->rx_urb = NULL;
-		
-	}
-	
-}
-
-
-void rtl8187_set_rate(struct net_device *dev)
-{
-	int i;
-	u16 word;
-	int basic_rate,min_rr_rate,max_rr_rate;
-	
-//	struct r8180_priv *priv = ieee80211_priv(dev);
-	
-	//if (ieee80211_is_54g(priv->ieee80211->current_network) && 
-//		priv->ieee80211->state == IEEE80211_LINKED){
-	basic_rate = ieeerate2rtlrate(240);
-	min_rr_rate = ieeerate2rtlrate(60);
-	max_rr_rate = ieeerate2rtlrate(240);
-	
-//	
-//	}else{
-//		basic_rate = ieeerate2rtlrate(20);
-//		min_rr_rate = ieeerate2rtlrate(10);
-//		max_rr_rate = ieeerate2rtlrate(110);
-//	}
-
-	write_nic_byte(dev, RESP_RATE,
-			max_rr_rate<<MAX_RESP_RATE_SHIFT| min_rr_rate<<MIN_RESP_RATE_SHIFT);
-
-	word  = read_nic_word(dev, BRSR);
-	word &= ~BRSR_MBR_8185;
-		
-
-	for(i=0;i<=basic_rate;i++)
-		word |= (1<<i);
-
-	write_nic_word(dev, BRSR, word);
-	//DMESG("RR:%x BRSR: %x", read_nic_byte(dev,RESP_RATE), read_nic_word(dev,BRSR));
-}
-
-
-void rtl8187_link_change(struct net_device *dev)
-{
-//	int i;
-	
-	struct r8180_priv *priv = ieee80211_priv(dev);
-	//write_nic_word(dev, BintrItv, net->beacon_interval);
-	rtl8187_net_update(dev);
-	/*update timing params*/
-	rtl8180_set_chan(dev, priv->chan);
-
-	rtl8187_set_rxconf(dev);
-}
-
-void rtl8180_irq_rx_tasklet(struct r8180_priv *priv);
-
-short rtl8180_init(struct net_device *dev)
-{
-		
-	struct r8180_priv *priv = ieee80211_priv(dev);
-	int i, j;
-	u16 word;
-	int ch;
-	//u16 version;
-	//u8 hw_version;
-	//u8 config3;
-	
-	//FIXME: these constants are placed in a bad pleace.
-
-//	priv->txbuffsize = 1024;
-//	priv->txringcount = 32;
-//	priv->rxbuffersize = 1024;
-//	priv->rxringcount = 32; 
-//	priv->txbeaconcount = 3;
-//	priv->rx_skb_complete = 1;
-	//priv->txnp_pending.ispending=0; 
-	/* ^^ the SKB does not containt a partial RXed
-	 * packet (is empty)
-	 */
-
-	if(!channels){
-		DMESG("No channels, aborting");
-		return -1;
-	}
-	ch=channels;
-	 // set channels 1..14 allowed in given locale
-	for (i=1; i<=14; i++) {
-		(priv->ieee80211->channel_map)[i] = (u8)(ch & 0x01);
-		ch >>= 1;
-	}
-	//memcpy(priv->stats,0,sizeof(struct Stats));
-	
-	//priv->irq_enabled=0;
-	
-//	priv->stats.rxdmafail=0;
-	priv->stats.txrdu=0;
-//	priv->stats.rxrdu=0;
-//	priv->stats.rxnolast=0;
-//	priv->stats.rxnodata=0;
-	//priv->stats.rxreset=0;
-	//priv->stats.rxwrkaround=0;
-//	priv->stats.rxnopointer=0;
-	priv->stats.txnperr=0;
-	priv->stats.txresumed=0;
-//	priv->stats.rxerr=0;
-//	priv->stats.rxoverflow=0;
-//	priv->stats.rxint=0;
-	priv->stats.txnpokint=0;
-	/*priv->stats.txhpokint=0;
-	priv->stats.txhperr=0;*/
-	priv->stats.rxurberr=0;
-	priv->stats.rxstaterr=0;
-	priv->stats.txoverflow=0;
-	priv->stats.rxok=0;
-//	priv->stats.txbeaconerr=0;
-	priv->stats.txlperr=0;
-	priv->stats.txlpokint=0;
-	
-	priv->ieee80211->iw_mode = IW_MODE_INFRA;
-	
-	priv->retry_rts = DEFAULT_RETRY_RTS;
-	priv->retry_data = DEFAULT_RETRY_DATA;
-	priv->ieee80211->rate = 110; //11 mbps
-	priv->ieee80211->short_slot = 1;
-	priv->ieee80211->mode = IEEE_G;
-	priv->promisc = (dev->flags & IFF_PROMISC) ? 1:0;
-	spin_lock_init(&priv->tx_lock);
-	INIT_WORK(&priv->reset_wq,(void(*)(void*)) rtl8180_restart,dev);
-	sema_init(&priv->wx_sem,1);
-	tasklet_init(&priv->irq_rx_tasklet,
-		     (void(*)(unsigned long))rtl8180_irq_rx_tasklet,
-		     (unsigned long)priv);
-
-	//priv->ieee80211->func = 
-	//	kmalloc(sizeof(struct ieee80211_helper_functions),GFP_KERNEL);
-	//memset(priv->ieee80211->func, 0,
-	  //     sizeof(struct ieee80211_helper_functions));
-	priv->ieee80211->current_network.beacon_interval = DEFAULT_BEACONINTERVAL;	
-	priv->ieee80211->iw_mode = IW_MODE_INFRA;
-	priv->ieee80211->softmac_features  = IEEE_SOFTMAC_SCAN | 
-		IEEE_SOFTMAC_ASSOCIATE | IEEE_SOFTMAC_PROBERQ | 
-		IEEE_SOFTMAC_PROBERS | IEEE_SOFTMAC_TX_QUEUE |
-		/*IEEE_SOFTMAC_BEACONS | */IEEE_SOFTMAC_SINGLE_QUEUE;
-	
-	priv->ieee80211->active_scan = 1;
-	priv->ieee80211->rate = 110; //11 mbps
-	priv->ieee80211->modulation = IEEE80211_CCK_MODULATION | IEEE80211_OFDM_MODULATION;
-	priv->ieee80211->host_encrypt = 1;
-	priv->ieee80211->host_decrypt = 1;
-	priv->ieee80211->start_send_beacons = rtl8187_beacon_tx;
-	priv->ieee80211->stop_send_beacons = rtl8187_beacon_stop;
-	//priv->ieee80211->softmac_hard_start_xmit = rtl8180_hard_start_xmit;
-	priv->ieee80211->softmac_hard_start_xmit = NULL;
-	priv->ieee80211->set_chan = rtl8180_set_chan;
-	priv->ieee80211->link_change = rtl8187_link_change;
-	priv->ieee80211->softmac_data_hard_start_xmit = rtl8180_hard_data_xmit;
-	priv->ieee80211->data_hard_stop = rtl8180_data_hard_stop;
-	priv->ieee80211->data_hard_resume = rtl8180_data_hard_resume;
-	//priv->ieee80211->start_send_beacons = NULL;
-	//priv->ieee80211->stop_send_beacons = NULL;
-	
-	priv->ieee80211->fts = DEFAULT_FRAG_THRESHOLD;
-	
-	priv->card_8185 = 2;
-	priv->phy_ver = 2;
-	priv->card_type = USB;
-	
-	#if 0
-	hw_version =( read_nic_dword(dev, TCR) & TCR_HWVERID_MASK)>>TCR_HWVERID_SHIFT;
-	
-	switch (hw_version){
-		case HW_VERID_R8185_ABC:
-			DMESG("MAC controller is a RTL8185 b/g");	
-			priv->card_8185 = 1;
-			/* you should not find a card with 8225 PHY ver < C*/
-			priv->phy_ver = 2;
-			break;
-			 
-		case HW_VERID_R8185_D:
-			DMESG("MAC controller is a RTL8185 b/g (V. D)");	
-			priv->card_8185 = 2;
-			/* you should not find a card with 8225 PHY ver < C*/
-			priv->phy_ver = 2;
-			break;
-			
-		case HW_VERID_R8180_ABCD:
-			DMESG("MAC controller is a RTL8180");
-			priv->card_8185 = 0;
-			break;
-		
-		case HW_VERID_R8180_F:
-			DMESG("MAC controller is a RTL8180 (v. F)");
-			priv->card_8185 = 0;
-			break;
-		
-		default:
-			DMESGW("MAC chip not recognized: version %x. Assuming RTL8180",hw_version);
-			priv->card_8185 = 0;
-			break;
-	}
-	
-	
-	/* you should not found any 8185 Ver B Card */
-	priv->card_8185_Bversion = 0;
-	
-	config3 = read_nic_byte(dev, CONFIG3);
-	if(config3 & 0x8){
-		priv->card_type = CARDBUS;
-		DMESG("This is a CARDBUS NIC");
-	}
-	else if( config3 & 0x4){
-		priv->card_type = MINIPCI;
-		DMESG("This is a MINI-PCI NIC");
-	}else{
-		priv->card_type = PCI;
-		DMESG("This is a PCI NIC");
-	}
-	#endif
-	priv->enable_gpio0 = 0;
-
-	
-	/* commented out just because we already do
-	   this when resetting the card
-	   andrea 20050924
-	 */
-	#if 0
-		
-	u8 txcr, txreg50;
-	u32 txreg54, txreg60;
-
-	/* enable A/D D/A register */
-	txcr = read_nic_byte(dev, 0x59);
-//	DMESG("<txcr:%x>", txcr);
-	//write_nic_word(dev, 0x59, 0x44);
-	write_nic_byte(dev, 0x59, 0x44);
-	//write_nic_byte(dev, 0x59, 0xea);
-	txcr = read_nic_byte(dev, 0x59);
-//	DMESG("<<txcr:%x>>", txcr);
-
-        txreg50 = read_nic_byte(dev, 0x50);
-  //      DMESG("<txreg50:%x>", txreg50);
-        write_nic_byte(dev, 0x50, 0xc0);
-        txreg50 = read_nic_byte(dev, 0x50);
-    //    DMESG("<<txreg50:%x>>", txreg50);
-
-
-        txreg54 = read_nic_dword(dev, 0x54);
-     //   DMESG("<txreg54:%x>", txreg54);
-        txreg54 = 0xa0000a59;
-    //    DMESG("<<txreg54:%x>>", txreg54);
-        write_nic_dword(dev, 0x54, txreg54);
-        txreg54 = read_nic_dword(dev, 0x54);
-   //     DMESG("<<<txreg54:%x>>>", txreg54);
-
-        txreg60 = read_nic_dword(dev, 0x60);
-     //   DMESG("<txreg60:%x>", txreg60);
-
-        write_nic_byte(dev, 0x50, 0x0);
-        txcr = read_nic_byte(dev, 0x50);
-       // DMESG("<<txcr:%x>>", txcr);
-
-#endif
-	
-	/*the eeprom type is stored in RCR register bit #6 */ 
-	if (RCR_9356SEL & read_nic_dword(dev, RCR)){
-		priv->epromtype=EPROM_93c56;
-		DMESG("Reported EEPROM chip is a 93c56 (2Kbit)");
-	}else{
-		priv->epromtype=EPROM_93c46;
-		DMESG("Reported EEPROM chip is a 93c46 (1Kbit)");
-	}
-	
-	dev->get_stats = rtl8180_stats;
-	
-	dev->dev_addr[0]=eprom_read(dev,MAC_ADR) & 0xff;
-	dev->dev_addr[1]=(eprom_read(dev,MAC_ADR) & 0xff00)>>8;
-	dev->dev_addr[2]=eprom_read(dev,MAC_ADR+1) & 0xff;
-	dev->dev_addr[3]=(eprom_read(dev,MAC_ADR+1) & 0xff00)>>8;
-	dev->dev_addr[4]=eprom_read(dev,MAC_ADR+2) & 0xff;
-	dev->dev_addr[5]=(eprom_read(dev,MAC_ADR+2) & 0xff00)>>8;
-	
-	DMESG("Card MAC address is "MAC_FMT, MAC_ARG(dev->dev_addr));
-		
-	for(i=1,j=0; i<6; i+=2,j++){
-		
-		word = eprom_read(dev,EPROM_TXPW0 + j);
-		priv->chtxpwr[i]=word & 0xf;
-		priv->chtxpwr_ofdm[i]=(word & 0xf0)>>4;
-		priv->chtxpwr[i+1]=(word & 0xf00)>>8;
-		priv->chtxpwr_ofdm[i+1]=(word & 0xf000)>>12;
-	}
-	
-	for(i=1,j=0; i<4; i+=2,j++){
-			
-		word = eprom_read(dev,EPROM_TXPW1 + j);
-		priv->chtxpwr[i+6]=word & 0xf;
-		priv->chtxpwr_ofdm[i+6]=(word & 0xf0)>>4;
-		priv->chtxpwr[i+6+1]=(word & 0xf00)>>8;
-		priv->chtxpwr_ofdm[i+6+1]=(word & 0xf000)>>12;
-	}
-	
-	for(i=1,j=0; i<4; i+=2,j++){
-			
-		word = eprom_read(dev,EPROM_TXPW2 + j);
-		priv->chtxpwr[i+6+4]=word & 0xf;
-		priv->chtxpwr_ofdm[i+6+4]=(word & 0xf0)>>4;
-		priv->chtxpwr[i+6+4+1]=(word & 0xf00)>>8;
-		priv->chtxpwr_ofdm[i+6+4+1]=(word & 0xf000)>>12;
-	}
-	
-		
-	priv->rf_chip = 0xff & eprom_read(dev,EPROM_RFCHIPID);
-	
-	word = eprom_read(dev,EPROM_TXPW_BASE);
-	priv->cck_txpwr_base = word & 0xf;
-	priv->ofdm_txpwr_base = (word>>4) & 0xf;
-	
-	/* check RF frontend chipset */
-	
-	switch (priv->rf_chip) {
-		
-		case EPROM_RFCHIPID_RTL8225U:
-		
-		DMESG("Card reports RF frontend Realtek 8225");
-		DMESGW("This driver has EXPERIMENTAL support for this chipset.");
-		DMESGW("use it with care and at your own risk and");
-		DMESGW("**PLEASE** REPORT SUCCESS/INSUCCESS TO andreamrl@tiscali.it");
-		if(rtl8225_is_V_z2(dev)){
-			priv->rf_init = rtl8225z2_rf_init;
-			priv->rf_set_chan = rtl8225z2_rf_set_chan;
-			priv->rf_set_sens = NULL;
-			DMESG("This seems a new V2 radio");
-		}else{
-			priv->rf_init = rtl8225_rf_init;
-			priv->rf_set_chan = rtl8225_rf_set_chan;
-			priv->rf_set_sens = rtl8225_rf_set_sens;
-			DMESG("This seems a legacy 1st version radio");
-		}
-		priv->rf_close = rtl8225_rf_close;
-		
-		priv->max_sens = RTL8225_RF_MAX_SENS;
-		priv->sens = RTL8225_RF_DEF_SENS;
-		break;
-				
-		default:
-		DMESGW("Unknown RF module %x",priv->rf_chip);
-		DMESGW("Exiting...");
-		return -1;
-		
-	}
-	
-//	DMESG("Energy threshold: %x",priv->cs_treshold);
-	DMESG("PAPE from CONFIG2: %x",read_nic_byte(dev,CONFIG2)&0x7);
-	//DMESG("CONFIG2: %x ECONFIG2: %x",read_nic_byte(dev,CONFIG2),eprom_read(dev,EPROM_CONFIG2));
-	
-	if(rtl8187_usb_initendpoints(dev)!=0){ 
-		DMESG("Endopoints initialization failed");
-		return -ENOMEM;
-	}
-#if 0		
-	if (0!=alloc_rx_desc_ring(dev, priv->rxbuffersize, priv->rxringcount)) 
-		return -ENOMEM;
-
-	if (0!=alloc_tx_desc_ring(dev, priv->txbuffsize, priv->txringcount,
-				  TX_NORMPRIORITY_RING_ADDR))
-		return -ENOMEM;
-
-	if (0!=alloc_tx_desc_ring(dev, priv->txbuffsize, priv->txringcount,
-				  TX_HIGHPRIORITY_RING_ADDR))
-		return -ENOMEM;
-
-	if (0!=alloc_tx_desc_ring(dev, priv->txbuffsize, priv->txringcount,
-				  TX_LOWPRIORITY_RING_ADDR))
-		return -ENOMEM;
-	
-	
-	if (0!=alloc_tx_beacon_desc_ring(dev, priv->txbeaconcount))
-		return -ENOMEM;
-#endif
-	
-
-#ifdef DEBUG_EPROM
-	dump_eprom(dev);
-#endif 
-	return 0;
-
-}
-
-void rtl8185_rf_pins_enable(struct net_device *dev)
-{
-/*	u16 tmp;
-	tmp = read_nic_word(dev, RFPinsEnable);*/
-	write_nic_word(dev, RFPinsEnable, 0x1ff7);// | tmp);
-}
-
-
-void rtl8185_set_anaparam2(struct net_device *dev, u32 a)
-{
-	u8 conf3;
-
-	rtl8180_set_mode(dev, EPROM_CMD_CONFIG);
-
-	conf3 = read_nic_byte(dev, CONFIG3);
-	write_nic_byte(dev, CONFIG3, conf3 | (1<<CONFIG3_ANAPARAM_W_SHIFT));	
-
-	write_nic_dword(dev, ANAPARAM2, a);
-
-	conf3 = read_nic_byte(dev, CONFIG3);
-	write_nic_byte(dev, CONFIG3, conf3 &~(1<<CONFIG3_ANAPARAM_W_SHIFT));
-
-	rtl8180_set_mode(dev, EPROM_CMD_NORMAL);
-
-}
-
-
-void rtl8180_set_anaparam(struct net_device *dev, u32 a)
-{
-	u8 conf3;
-
-	rtl8180_set_mode(dev, EPROM_CMD_CONFIG);
-
-	conf3 = read_nic_byte(dev, CONFIG3);
-	write_nic_byte(dev, CONFIG3, conf3 | (1<<CONFIG3_ANAPARAM_W_SHIFT));
-	
-	write_nic_dword(dev, ANAPARAM, a);
-
-	conf3 = read_nic_byte(dev, CONFIG3);
-	write_nic_byte(dev, CONFIG3, conf3 &~(1<<CONFIG3_ANAPARAM_W_SHIFT));
-
-	rtl8180_set_mode(dev, EPROM_CMD_NORMAL);
-	
-}
-
-
-void rtl8185_tx_antenna(struct net_device *dev, u8 ant)
-{
-	write_nic_byte(dev, TX_ANTENNA, ant); 
-	force_pci_posting(dev);
-	mdelay(1);
-}	
-
-
-void rtl8187_write_phy(struct net_device *dev, u8 adr, u32 data)
-{
-	//u8 phyr;
-	u32 phyw;
-//	int i;
-	
-	adr |= 0x80;
-	 
-	phyw= ((data<<8) | adr);
-	
-	
-	
-	// Note that, we must write 0xff7c after 0x7d-0x7f to write BB register. 
-	write_nic_byte(dev, 0x7f, ((phyw & 0xff000000) >> 24));
-	write_nic_byte(dev, 0x7e, ((phyw & 0x00ff0000) >> 16));
-	write_nic_byte(dev, 0x7d, ((phyw & 0x0000ff00) >> 8));
-	write_nic_byte(dev, 0x7c, ((phyw & 0x000000ff) ));
-
-	//read_nic_dword(dev, PHY_ADR);
-#if 0	
-	for(i=0;i<10;i++){
-		write_nic_dword(dev, PHY_ADR, 0xffffff7f & phyw);
-		phyr = read_nic_byte(dev, PHY_READ);
-		if(phyr == (data&0xff)) break;
-			
-	}
-#endif
-	/* this is ok to fail when we write AGC table. check for AGC table might be
-	 * done by masking with 0x7f instead of 0xff
-	 */
-	//if(phyr != (data&0xff)) DMESGW("Phy write timeout %x %x %x", phyr, data, adr);
-	mdelay(1);
-}
-
-
-inline void write_phy_ofdm (struct net_device *dev, u8 adr, u32 data)
-{
-	data = data & 0xff;
-	rtl8187_write_phy(dev, adr, data);
-}
-
-
-void write_phy_cck (struct net_device *dev, u8 adr, u32 data)
-{
-	data = data & 0xff;
-	rtl8187_write_phy(dev, adr, data | 0x10000);
-}
-
-
-void rtl8180_adapter_start(struct net_device *dev)
-{
-        struct r8180_priv *priv = ieee80211_priv(dev);
-	//u32 anaparam;
-	//u8 config3;
-	
-	//rtl8180_rtx_disable(dev);
-	rtl8180_reset(dev);
-
-	write_nic_byte(dev,0x85,0);
-	write_nic_byte(dev,0x91,0);
-	
-	/* light blink! */
-	write_nic_byte(dev,0x85,4);
-	write_nic_byte(dev,0x91,1);
-	write_nic_byte(dev,0x90,0);
-	
-	priv->irq_mask = 0xffff;
-/*
-	priv->dma_poll_mask = 0;
-	priv->dma_poll_mask|= (1<<TX_DMA_STOP_BEACON_SHIFT);
-*/	
-//	rtl8180_beacon_tx_disable(dev);
-	
-	rtl8180_set_mode(dev, EPROM_CMD_CONFIG);
-	write_nic_dword(dev, MAC0, ((u32*)dev->dev_addr)[0]);
-	write_nic_word(dev, MAC4, ((u32*)dev->dev_addr)[1] & 0xffff );
-
-	rtl8180_set_mode(dev, EPROM_CMD_NORMAL);
-	rtl8180_update_msr(dev);
-		
-	rtl8180_set_mode(dev, EPROM_CMD_CONFIG);
-	
-	write_nic_word(dev,0xf4,0xffff);
-	write_nic_byte(dev,
-		       CONFIG1, (read_nic_byte(dev,CONFIG1) & 0x3f) | 0x80);	
-
-	rtl8180_set_mode(dev,EPROM_CMD_NORMAL);
-	
-	write_nic_dword(dev,INT_TIMEOUT,0);	
-
-#ifdef DEBUG_REGISTERS
-	rtl8180_dump_reg(dev);	
-#endif
-	
-	
-	write_nic_byte(dev, WPA_CONFIG, 0);	
-
-	write_nic_byte(dev, RATE_FALLBACK, 0x81);
-	rtl8187_set_rate(dev);
-		
-	priv->rf_init(dev);	
-
-	if(priv->rf_set_sens != NULL)
-		priv->rf_set_sens(dev,priv->sens);	
-	
-	write_nic_word(dev,0x5e,1);
-
-	#if 1
-	//mdelay(1);
-	write_nic_word(dev,0xfe,0x10);
-//	mdelay(1);
-	#endif
-	write_nic_byte(dev, TALLY_SEL, 0x80);//Set NQ retry count
-
-	write_nic_byte(dev, 0xff, 0x60);
-
-	write_nic_word(dev,0x5e,0);
-	
-		
-	rtl8180_irq_enable(dev);
-	/*DMESG ("lfree %d",get_curr_tx_free_desc(dev,LOW_PRIORITY));
-	
-	DMESG ("nfree %d",get_curr_tx_free_desc(dev,NORM_PRIORITY));
-	
-	DMESG ("hfree %d",get_curr_tx_free_desc(dev,HI_PRIORITY));
-	if(check_nic_enought_desc(dev,NORM_PRIORITY)) DMESG("NORM OK");
-	if(check_nic_enought_desc(dev,HI_PRIORITY)) DMESG("HI OK");
-	if(check_nic_enought_desc(dev,LOW_PRIORITY)) DMESG("LOW OK");*/
-}
-
-
-
-/* this configures registers for beacon tx and enables it via
- * rtl8180_beacon_tx_enable(). rtl8180_beacon_tx_disable() might
- * be used to stop beacon transmission
- */
-#if 0
-void rtl8180_start_tx_beacon(struct net_device *dev)
-{
-	int i;
-	struct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);
-	u16 word;	
-	DMESG("Enabling beacon TX");
-	//write_nic_byte(dev, 0x42,0xe6);// TCR
-	//rtl8180_init_beacon(dev);
-	//set_nic_txring(dev);
-//	rtl8180_prepare_beacon(dev);
-	rtl8180_irq_disable(dev);
-//	rtl8180_beacon_tx_enable(dev);
-	rtl8180_set_mode(dev,EPROM_CMD_CONFIG);
-	//write_nic_byte(dev,0x9d,0x20); //DMA Poll
-	//write_nic_word(dev,0x7a,0);
-	//write_nic_word(dev,0x7a,0x8000);
-
-	
-	word  = read_nic_word(dev, BcnItv);
-	word &= ~BcnItv_BcnItv; // clear Bcn_Itv
-	write_nic_word(dev, BcnItv, word);
-
-	write_nic_word(dev, AtimWnd, 
-		       read_nic_word(dev, AtimWnd) &~ AtimWnd_AtimWnd);
-	
-	word  = read_nic_word(dev, BintrItv);
-	word &= ~BintrItv_BintrItv;
-	
-	//word |= priv->ieee80211->beacon_interval * 
-	//	((priv->txbeaconcount > 1)?(priv->txbeaconcount-1):1);
-	// FIXME:FIXME check if correct ^^ worked with 0x3e8;
-	
-	write_nic_word(dev, BintrItv, word);
-	
-	//write_nic_word(dev,0x2e,0xe002);
-	//write_nic_dword(dev,0x30,0xb8c7832e);
-	for(i=0; i<ETH_ALEN; i++)
-		write_nic_byte(dev, BSSID+i, priv->ieee80211->beacon_cell_ssid[i]);
-	
-//	rtl8180_update_msr(dev);
-
-	
-	//write_nic_byte(dev,CONFIG4,3); /* !!!!!!!!!! */
-	
-	rtl8180_set_mode(dev, EPROM_CMD_NORMAL);
-	
-	rtl8180_irq_enable(dev);
-	
-	/* VV !!!!!!!!!! VV*/
-	/*
-	rtl8180_set_mode(dev,EPROM_CMD_CONFIG);
-	write_nic_byte(dev,0x9d,0x00); 	
-	rtl8180_set_mode(dev,EPROM_CMD_NORMAL);
-*/
-}
-#endif
-/***************************************************************************
-    -------------------------------NET STUFF---------------------------
-***************************************************************************/
-static struct net_device_stats *rtl8180_stats(struct net_device *dev)
-{
-	struct r8180_priv *priv = ieee80211_priv(dev);
-	
-	return &priv->ieee80211->stats;
-}
-
-
-int _rtl8180_up(struct net_device *dev)
-{
-	struct r8180_priv *priv = ieee80211_priv(dev);
-
-	priv->up=1;
-	
-	//DMESG("Bringing up iface");
-
-	rtl8180_adapter_start(dev);
-	
-	rtl8180_rx_enable(dev);
-
-	rtl8180_tx_enable(dev);
-	
-	ieee80211_softmac_start_protocol(priv->ieee80211);
-	
-	ieee80211_reset_queue(priv->ieee80211);
-	if(!netif_queue_stopped(dev))
-		netif_start_queue(dev);
-	else
-		netif_wake_queue(dev);
-		
-	return 0;
-}
-
-
-int rtl8180_open(struct net_device *dev)
-{
-	struct r8180_priv *priv = ieee80211_priv(dev);
-	int ret;
-	
-	down(&priv->wx_sem);
-	ret = rtl8180_up(dev);
-	up(&priv->wx_sem);
-	return ret;
-	
-}
-
-
-int rtl8180_up(struct net_device *dev)
-{
-	struct r8180_priv *priv = ieee80211_priv(dev);
-
-	if (priv->up == 1) return -1;
-	
-	return _rtl8180_up(dev);
-}
-
-
-int rtl8180_close(struct net_device *dev)
-{
-	struct r8180_priv *priv = ieee80211_priv(dev);
-	int ret;
-	
-	down(&priv->wx_sem);
-	
-	ret = rtl8180_down(dev);
-	
-	up(&priv->wx_sem);
-	
-	return ret;
-
-}
-
-int rtl8180_down(struct net_device *dev)
-{
-	struct r8180_priv *priv = ieee80211_priv(dev);
-
-	if (priv->up == 0) return -1;
-	
-	priv->up=0;
-
-/* FIXME */
-	if (!netif_queue_stopped(dev))
-		netif_stop_queue(dev);
-	
-	rtl8180_rtx_disable(dev);
-	rtl8180_irq_disable(dev);
-
-	ieee80211_softmac_stop_protocol(priv->ieee80211);
-		
-	return 0;
-}
-
-
-void rtl8180_commit(struct net_device *dev)
-{
-	struct r8180_priv *priv = ieee80211_priv(dev);
-
-	if (priv->up == 0) return ;
-	
-	ieee80211_softmac_stop_protocol(priv->ieee80211);
-	
-	rtl8180_irq_disable(dev);
-	rtl8180_rtx_disable(dev);
-	_rtl8180_up(dev);
-}
-
-void rtl8180_restart(struct net_device *dev)
-{
-	struct r8180_priv *priv = ieee80211_priv(dev);
-
-	down(&priv->wx_sem);
-	
-	rtl8180_commit(dev);
-	
-	up(&priv->wx_sem);
-}
-
-static void r8180_set_multicast(struct net_device *dev)
-{
-	struct r8180_priv *priv = ieee80211_priv(dev);
-	short promisc;
-
-	//down(&priv->wx_sem);
-	
-	/* FIXME FIXME */
-	
-	promisc = (dev->flags & IFF_PROMISC) ? 1:0;
-	
-	if (promisc != priv->promisc)
-	//	rtl8180_commit(dev);
-	
-	priv->promisc = promisc;
-	
-	//schedule_work(&priv->reset_wq);
-	//up(&priv->wx_sem);
-}
-
-
-int r8180_set_mac_adr(struct net_device *dev, void *mac)
-{
-	struct r8180_priv *priv = ieee80211_priv(dev);
-	struct sockaddr *addr = mac;
-	
-	down(&priv->wx_sem);
-	
-	memcpy(dev->dev_addr, addr->sa_data, ETH_ALEN);
-		
-	schedule_work(&priv->reset_wq);
-	
-	up(&priv->wx_sem);
-	
-	return 0;
-}
-
-
-/* based on ipw2200 driver */
-int rtl8180_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
-{
-	struct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);
-	
-	down(&priv->wx_sem);
-	
-	struct iwreq *wrq = (struct iwreq *)rq;
-        
-	int ret=-1;
-	switch (cmd) {
-	    case RTL_IOCTL_WPA_SUPPLICANT:
-		ret = ieee80211_wpa_supplicant_ioctl(priv->ieee80211, &wrq->u.data);
-		break;
-
-	    default:
-		ret = -EOPNOTSUPP;
-		break;
-	}
-
-	up(&priv->wx_sem);
-	
-	return ret;
-}
-
-
-void rtl8180_irq_rx_tasklet(struct r8180_priv *priv)
-{
-	struct urb *rx_urb = priv->rxurb_task;
-	struct net_device *dev = (struct net_device*)rx_urb->context;
-	int status,len,flen;
-	struct sk_buff *skb;
-	u32 *desc;
-	
-	//DMESG("rtl8187_rx_isr");
-	
-	struct ieee80211_rx_stats stats = {
-		.signal = 0,
-		.noise = -98,
-		.rate = 0,
-	//	.mac_time = jiffies,
-		.freq = IEEE80211_24GHZ_BAND,
-	};
-
-	//DMESG("RX %d ",rx_urb->status);
-	status = rx_urb->status;
-	if(status == 0){
-		
-		len = rx_urb->actual_length;
-	//	len = len - 4 - 15 - 1; /* CRC, DESC, SEPARATOR*/ 
-		len -= 4*4;/* 4 dword and 4 byte CRC */
-		
-		desc = (u32*)(rx_urb->transfer_buffer + len);
-		
-		flen = desc[0] & 0xfff;
-		
-		if( flen <= rx_urb->actual_length){
-		
-			stats.signal = (desc[1] & 0x7f00)>>8;
-			stats.noise = desc[1] &0xff;
-			stats.rate = desc[0] >> 20 & 0xf;
-			stats.mac_time[0] = desc[2];
-			stats.mac_time[1] = desc[3];
-			skb = dev_alloc_skb(flen-4);
-			//skb_reserve(skb,2);
-			if(skb){ 
-			memcpy(skb_put(skb,flen-4),
-				rx_urb->transfer_buffer,flen -4);
-			
-			#ifdef DUMP_RX
-			int i;
-			for(i=0;i<flen-4;i++)
-				printk("%2x ",((u8*)(rx_urb->transfer_buffer))[i]);
-			printk("------RATE %x:w---------------\n",stats.rate);
-			
-			#endif
-			priv->stats.rxok++;
-		//	priv->rxskb = skb;
-		//	priv->tempstats = &stats;
-
-			if(!ieee80211_rx(priv->ieee80211, 
-				skb, &stats))
-			dev_kfree_skb_any(skb);
-			}
-		}else priv->stats.rxurberr++;
-	}else{
-		priv->stats.rxstaterr++;
-		priv->ieee80211->stats.rx_errors++;
-		
-	}
-	
-	if(status != -ENOENT)rtl8187_rx_urbsubmit(dev,rx_urb);
-	else DMESG("RX process aborted due to explicit shutdown");
-}
-
-/****************************************************************************
-     ---------------------------- USB_STUFF---------------------------
-*****************************************************************************/
-
-
-static int __devinit rtl8187_usb_probe(struct usb_interface *intf,
-			 const struct usb_device_id *id)
-{
-//	unsigned long ioaddr = 0;
-	struct net_device *dev = NULL;
-	struct r8180_priv *priv= NULL;
-	struct usb_device *udev = interface_to_usbdev(intf);
-
-//printk("===> rtl8187_usb_probe()\n");	
-	
-	dev = alloc_ieee80211(sizeof(struct r8180_priv));
-	
-	SET_MODULE_OWNER(dev);
-	usb_set_intfdata(intf, dev);	
-	
-	SET_NETDEV_DEV(dev, &intf->dev);
-
-	priv = ieee80211_priv(dev);
-	priv->ieee80211 = netdev_priv(dev);
-	
-	priv->udev=udev;
-	
-	dev->open = rtl8180_open;
-	dev->stop = rtl8180_close;
-	//dev->hard_start_xmit = rtl8180_8023_hard_start_xmit;
-	dev->tx_timeout = tx_timeout;
-	dev->wireless_handlers = &r8180_wx_handlers_def;
-	dev->do_ioctl = rtl8180_ioctl;
-	dev->set_multicast_list = r8180_set_multicast;
-	dev->set_mac_address = r8180_set_mac_adr;
-	dev->get_wireless_stats = r8180_get_wireless_stats;
-	dev->type=ARPHRD_ETHER;
-	
-	if (dev_alloc_name(dev, ifname) < 0){
-                DMESG("Oops: devname already taken! Trying wlan%%d...\n");
-		ifname = "wlan%d";
-		dev_alloc_name(dev, ifname);
-        }
-	
-//	dev->open=rtl8180_init;
-	
-	if(rtl8180_init(dev)!=0){ 
-		DMESG("Initialization failed");
-		goto fail;
-	}
-	
-	netif_carrier_off(dev);
-	netif_stop_queue(dev);
-	
-	register_netdev(dev);
-	
-	rtl8180_proc_init_one(dev);
-	
-	
-	DMESG("Driver probe completed\n");
-	return 0;	
-
-	
-fail:
-	free_ieee80211(dev);
-		
-	DMESG("wlan driver load failed\n");
-	
-	return -ENODEV;
-	
-}
-
-
-static void __devexit rtl8187_usb_disconnect(struct usb_interface *intf)
-{
-	struct r8180_priv *priv;
-	struct net_device *dev = usb_get_intfdata(intf);
- 	if(dev){
-		
-		unregister_netdev(dev);
-		
-		priv=ieee80211_priv(dev);
-		
-		rtl8180_proc_remove_one(dev);
-		
-		rtl8180_down(dev);
-		priv->rf_close(dev);
-		//rtl8180_rtx_disable(dev);
-		rtl8187_usb_deleteendpoints(dev);
-		rtl8180_irq_disable(dev);
-		rtl8180_reset(dev);
-		mdelay(10);
-
-	}
-//	pci_disable_device(pdev);
-	free_ieee80211(dev);
-	DMESG("wlan driver removed\n");
-}
-
-
-static int __init rtl8187_usb_module_init(void)
-{
-	printk(KERN_INFO "\nLinux kernel driver for RTL8187 \
-based WLAN cards\n");
-	printk(KERN_INFO "Copyright (c) 2004-2005, Andrea Merello\n");
-	DMESG("Initializing module");
-	DMESG("Wireless extensions version %d", WIRELESS_EXT);
-	rtl8180_proc_module_init();
-	return usb_register(&rtl8187_usb_driver);
-}
-
-
-static void __exit rtl8187_usb_module_exit(void)
-{
-	usb_deregister(&rtl8187_usb_driver);
-
-	rtl8180_proc_module_remove();
-	DMESG("Exiting");
-}
-
-
-void rtl8180_try_wake_queue(struct net_device *dev, int pri)
-{
-	unsigned long flags;
-	short enough_desc;
-	struct r8180_priv *priv = (struct r8180_priv *)ieee80211_priv(dev);
-	
-	spin_lock_irqsave(&priv->tx_lock,flags);
-	enough_desc = check_nic_enought_desc(dev,pri);
-        spin_unlock_irqrestore(&priv->tx_lock,flags);	
-	
-	if(enough_desc)
-		ieee80211_wake_queue(priv->ieee80211);
-}
-
-
-
-/***************************************************************************
-     ------------------- module init / exit stubs ----------------
-****************************************************************************/
-module_init(rtl8187_usb_module_init);
-module_exit(rtl8187_usb_module_exit);
diff -Naur rtl8187_linux_26.1010.0622.2006/beta-8187/r8187.h rtl8187_linux_26.1010.0622.2006_rawtx/beta-8187/r8187.h
--- rtl8187_linux_26.1010.0622.2006/beta-8187/r8187.h	2006-06-06 08:48:10.000000000 +0200
+++ rtl8187_linux_26.1010.0622.2006_rawtx/beta-8187/r8187.h	2008-02-22 15:02:01.000000000 +0100
@@ -1,17 +1,17 @@
-/* 
+/*
    This is part of rtl8187 OpenSource driver.
-   Copyright (C) Andrea Merello 2004-2005  <andreamrl@tiscali.it> 
+   Copyright (C) Andrea Merello 2004-2005  <andreamrl@tiscali.it>
    Released under the terms of GPL (General Public Licence)
-   
-   Parts of this driver are based on the GPL part of the 
+
+   Parts of this driver are based on the GPL part of the
    official realtek driver
-   
-   Parts of this driver are based on the rtl8180 driver skeleton 
+
+   Parts of this driver are based on the rtl8180 driver skeleton
    from Patric Schenke & Andres Salomon
-   
+
    Parts of this driver are based on the Intel Pro Wireless 2100 GPL driver
-   
-   We want to tanks the Authors of those projects and the Ndiswrapper 
+
+   We want to tanks the Authors of those projects and the Ndiswrapper
    project Authors.
 */
 
@@ -26,7 +26,6 @@
 
 #include <linux/module.h>
 #include <linux/kernel.h>
-#include <linux/config.h>
 #include <linux/init.h>
 #include <linux/ioport.h>
 #include <linux/sched.h>
@@ -47,6 +46,12 @@
 #include <asm/io.h>
 #include <asm/semaphore.h>
 
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19))
+#include <linux/config.h>
+#else
+#include <linux/autoconf.h>
+#endif
+
 #include "ieee80211.h"
 
 #define EPROM_93c46 0
@@ -68,7 +73,7 @@
 {
 	struct buffer *next;
 	u32 *buf;
-	
+
 } buffer;
 
 #if 0
@@ -123,18 +128,18 @@
 	short epromtype;
 	int irq;
 	struct ieee80211_device *ieee80211;
-	
+
 	short card_8185; /* O: rtl8180, 1:rtl8185 V B/C, 2:rtl8185 V D */
 	short card_8185_Bversion; /* if TCR reports card V B/C this discriminates */
 	short phy_ver; /* meaningful for rtl8225 1:A 2:B 3:C */
 	short enable_gpio0;
 	enum card_type {PCI,MINIPCI,CARDBUS,USB/*rtl8187*/}card_type;
 	short hw_plcp_len;
-		
+
 //	spinlock_t irq_lock;
 //	spinlock_t irq_th_lock;
 	spinlock_t tx_lock;
-	
+
 	u16 irq_mask;
 //	short irq_enabled;
 	struct net_device *dev;
@@ -143,13 +148,18 @@
 	short max_sens;
 	u8 chtxpwr[15]; //channels from 1 to 14, 0 not used
 	u8 chtxpwr_ofdm[15]; //channels from 1 to 14, 0 not used
+	u8 chtxpwr_orig[15]; //channels from 1 to 14, 0 not used
+	u8 chtxpwr_ofdm_orig[15]; //channels from 1 to 14, 0 not used
 	u8 cck_txpwr_base;
 	u8 ofdm_txpwr_base;
+	u8 txpwr_max;
 	u8 challow[15]; //channels from 1 to 14, 0 not used
 	short up;
 	short crcmon; //if 1 allow bad crc frame reception in monitor mode
-//	short prism_hdr;
-	
+	short prism_hdr;
+	short fasttx;
+	short highpower;
+
 //	struct timer_list scan_timer;
 	/*short scanpending;
 	short stopscan;*/
@@ -158,7 +168,7 @@
 	//u8 active_scan_num;
 	struct semaphore wx_sem;
 //	short hw_wep;
-		
+
 //	short digphy;
 //	short antb;
 //	short diversity;
@@ -171,31 +181,31 @@
 	void (*rf_close)(struct net_device *dev);
 	void (*rf_init)(struct net_device *dev);
 	//short rate;
-	short promisc;	
+	short promisc;
 	/*stats*/
 	struct Stats stats;
 	struct iw_statistics wstats;
 	struct proc_dir_entry *dir_dev;
-	
+
 	/*RX stuff*/
 //	u32 *rxring;
 //	u32 *rxringtail;
 //	dma_addr_t rxringdma;
 	struct urb **rx_urb;
-	
+
 	//struct buffer *rxbuffer;
 	//struct buffer *rxbufferhead;
 	//int rxringcount;
 	//u16 rxbuffersize;
-	
-	//struct sk_buff *rx_skb; 
+
+	//struct sk_buff *rx_skb;
 
 	//short rx_skb_complete;
 
 	//u32 rx_prevlen;
 	atomic_t tx_lp_pending;
 	atomic_t tx_np_pending;
-#if 0	
+#if 0
 	/*TX stuff*/
 	u32 *txlpring;
 	u32 *txhpring;
@@ -225,7 +235,7 @@
 	struct urb *rxurb_task;
 //	u8 dma_poll_mask;
 	//short tx_suspend;
-	
+
 	/* adhoc/master mode stuff */
 #if 0
 	u32 *txbeacontail;
@@ -239,22 +249,23 @@
 	//u16 master_beaconinterval;
 //	u32 master_beaconsize;
 	//u16 beacon_interval;
-	
+
 	u8 retry_data;
 	u8 retry_rts;
-	
+
 	struct work_struct reset_wq;
-	
+
 }r8180_priv;
 
 
-typedef enum{ 
+typedef enum{
 	LOW_PRIORITY ,
-	NORM_PRIORITY 
+	NORM_PRIORITY
 	} priority_t;
 
 
 short rtl8180_tx(struct net_device *dev,u32* skbuf, int len,priority_t priority,short morefrag,short rate);
+short rtl8180_tx_fast(struct net_device *dev,u32* skbuf, int len, short rate);
 
 u8 read_nic_byte(struct net_device *dev, int x);
 u8 read_nic_byte_E(struct net_device *dev, int x);
diff -Naur rtl8187_linux_26.1010.0622.2006/beta-8187/r8187.h~ rtl8187_linux_26.1010.0622.2006_rawtx/beta-8187/r8187.h~
--- rtl8187_linux_26.1010.0622.2006/beta-8187/r8187.h~	2006-06-06 04:58:02.000000000 +0200
+++ rtl8187_linux_26.1010.0622.2006_rawtx/beta-8187/r8187.h~	1970-01-01 01:00:00.000000000 +0100
@@ -1,288 +0,0 @@
-/* 
-   This is part of rtl8187 OpenSource driver.
-   Copyright (C) Andrea Merello 2004-2005  <andreamrl@tiscali.it> 
-   Released under the terms of GPL (General Public Licence)
-   
-   Parts of this driver are based on the GPL part of the 
-   official realtek driver
-   
-   Parts of this driver are based on the rtl8180 driver skeleton 
-   from Patric Schenke & Andres Salomon
-   
-   Parts of this driver are based on the Intel Pro Wireless 2100 GPL driver
-   
-   We want to tanks the Authors of those projects and the Ndiswrapper 
-   project Authors.
-*/
-
-#ifndef R8180H
-#define R8180H
-
-
-#define RTL8187_MODULE_NAME "rtl8187"
-#define DMESG(x,a...) printk(KERN_INFO RTL8187_MODULE_NAME ": " x "\n", ## a)
-#define DMESGW(x,a...) printk(KERN_WARNING RTL8187_MODULE_NAME ": WW:" x "\n", ## a)
-#define DMESGE(x,a...) printk(KERN_WARNING RTL8187_MODULE_NAME ": EE:" x "\n", ## a)
-
-#include <linux/module.h>
-#include <linux/kernel.h>
-#include <linux/config.h>
-#include <linux/init.h>
-#include <linux/ioport.h>
-#include <linux/sched.h>
-#include <linux/types.h>
-#include <linux/slab.h>
-#include <linux/netdevice.h>
-//#include <linux/pci.h>
-#include <linux/usb.h>
-#include <linux/etherdevice.h>
-#include <linux/delay.h>
-#include <linux/rtnetlink.h>	//for rtnl_lock()
-#include <linux/wireless.h>
-#include <linux/timer.h>
-#include <linux/proc_fs.h>	// Necessary because we use the proc fs
-#include <linux/if_arp.h>
-#include <linux/random.h>
-#include <linux/version.h>
-#include <asm/io.h>
-#include <asm/semaphore.h>
-
-#include "ieee80211.h"
-
-#define EPROM_93c46 0
-#define EPROM_93c56 1
-
-#define DEFAULT_FRAG_THRESHOLD 2342U
-#define MIN_FRAG_THRESHOLD     256U
-#define DEFAULT_BEACONINTERVAL 0x64U
-#define DEFAULT_BEACON_ESSID "Rtl8187"
-
-#define DEFAULT_SSID ""
-#define DEFAULT_RETRY_RTS 7
-#define DEFAULT_RETRY_DATA 7
-#define PRISM_HDR_SIZE 64
-
-#define RTL_IOCTL_WPA_SUPPLICANT		SIOCIWFIRSTPRIV+30
-
-typedef struct buffer
-{
-	struct buffer *next;
-	u32 *buf;
-	
-} buffer;
-
-#if 0
-
-typedef struct tx_pendingbuf
-{
-	struct ieee80211_txb *txb;
-	short ispending;
-	short descfrag;
-} tx_pendigbuf;
-
-#endif
-
-typedef struct Stats
-{
-	unsigned long txrdu;
-//	unsigned long rxrdu;
-	//unsigned long rxnolast;
-	//unsigned long rxnodata;
-//	unsigned long rxreset;
-//	unsigned long rxwrkaround;
-//	unsigned long rxnopointer;
-	unsigned long rxok;
-	unsigned long rxurberr;
-	unsigned long rxstaterr;
-	unsigned long txnperr;
-	unsigned long txnpdrop;
-	unsigned long txresumed;
-//	unsigned long rxerr;
-//	unsigned long rxoverflow;
-//	unsigned long rxint;
-	unsigned long txnpokint;
-//	unsigned long txhpokint;
-//	unsigned long txhperr;
-//	unsigned long ints;
-//	unsigned long shints;
-	unsigned long txoverflow;
-//	unsigned long rxdmafail;
-//	unsigned long txbeacon;
-//	unsigned long txbeaconerr;
-	unsigned long txlpokint;
-	unsigned long txlpdrop;
-	unsigned long txlperr;
-	unsigned long txdatapkt;
-} Stats;
-
-
-
-typedef struct r8180_priv
-{
-	struct usb_device *udev;
-	short epromtype;
-	int irq;
-	struct ieee80211_device *ieee80211;
-	
-	short card_8185; /* O: rtl8180, 1:rtl8185 V B/C, 2:rtl8185 V D */
-	short card_8185_Bversion; /* if TCR reports card V B/C this discriminates */
-	short phy_ver; /* meaningful for rtl8225 1:A 2:B 3:C */
-	short enable_gpio0;
-	enum card_type {PCI,MINIPCI,CARDBUS,USB/*rtl8187*/}card_type;
-	short hw_plcp_len;
-		
-//	spinlock_t irq_lock;
-//	spinlock_t irq_th_lock;
-	spinlock_t tx_lock;
-	
-	u16 irq_mask;
-//	short irq_enabled;
-	struct net_device *dev;
-	short chan;
-	short sens;
-	short max_sens;
-	u8 chtxpwr[15]; //channels from 1 to 14, 0 not used
-	u8 chtxpwr_ofdm[15]; //channels from 1 to 14, 0 not used
-	u8 cck_txpwr_base;
-	u8 ofdm_txpwr_base;
-	u8 challow[15]; //channels from 1 to 14, 0 not used
-	short up;
-	short crcmon; //if 1 allow bad crc frame reception in monitor mode
-//	short prism_hdr;
-	
-//	struct timer_list scan_timer;
-	/*short scanpending;
-	short stopscan;*/
-//	spinlock_t scan_lock;
-//	u8 active_probe;
-	//u8 active_scan_num;
-	struct semaphore wx_sem;
-//	short hw_wep;
-		
-//	short digphy;
-//	short antb;
-//	short diversity;
-//	u8 cs_treshold;
-//	short rcr_csense;
-	short rf_chip;
-//	u32 key0[4];
-	short (*rf_set_sens)(struct net_device *dev,short sens);
-	void (*rf_set_chan)(struct net_device *dev,short ch);
-	void (*rf_close)(struct net_device *dev);
-	void (*rf_init)(struct net_device *dev);
-	//short rate;
-	short promisc;	
-	/*stats*/
-	struct Stats stats;
-	struct iw_statistics wstats;
-	struct proc_dir_entry *dir_dev;
-	
-	/*RX stuff*/
-//	u32 *rxring;
-//	u32 *rxringtail;
-//	dma_addr_t rxringdma;
-	struct urb **rx_urb;
-	
-	//struct buffer *rxbuffer;
-	//struct buffer *rxbufferhead;
-	//int rxringcount;
-	//u16 rxbuffersize;
-	
-	//struct sk_buff *rx_skb; 
-
-	//short rx_skb_complete;
-
-	//u32 rx_prevlen;
-	atomic_t tx_lp_pending;
-	atomic_t tx_np_pending;
-#if 0	
-	/*TX stuff*/
-	u32 *txlpring;
-	u32 *txhpring;
-	u32 *txnpring;
-	dma_addr_t txlpringdma;
-	dma_addr_t txhpringdma;
-	dma_addr_t txnpringdma;
-	u32 *txlpringtail;
-	u32 *txhpringtail;
-	u32 *txnpringtail;
-	u32 *txlpringhead;
-	u32 *txhpringhead;
-	u32 *txnpringhead;
-	struct buffer *txlpbufs;
-	struct buffer *txhpbufs;
-	struct buffer *txnpbufs;
-	struct buffer *txlpbufstail;
-	struct buffer *txhpbufstail;
-	struct buffer *txnpbufstail;
-	int txringcount;
-	int txbuffsize;
-
-	//struct tx_pendingbuf txnp_pending;
-	struct tasklet_struct irq_tx_tasklet;
-#endif
-//	struct tasklet_struct irq_rx_tasklet;
-//	u8 dma_poll_mask;
-	//short tx_suspend;
-	
-	/* adhoc/master mode stuff */
-#if 0
-	u32 *txbeacontail;
-	dma_addr_t txbeaconringdma;
-	u32 *txbeaconring;
-	int txbeaconcount;
-#endif
-//	struct ieee_tx_beacon *beacon_buf;
-	//char *master_essid;
-//	dma_addr_t beacondmabuf;
-	//u16 master_beaconinterval;
-//	u32 master_beaconsize;
-	//u16 beacon_interval;
-	
-	u8 retry_data;
-	u8 retry_rts;
-	
-	struct work_struct reset_wq;
-	
-}r8180_priv;
-
-
-typedef enum{ 
-	LOW_PRIORITY ,
-	NORM_PRIORITY 
-	} priority_t;
-
-
-short rtl8180_tx(struct net_device *dev,u32* skbuf, int len,priority_t priority,short morefrag,short rate);
-
-u8 read_nic_byte(struct net_device *dev, int x);
-u8 read_nic_byte_E(struct net_device *dev, int x);
-u32 read_nic_dword(struct net_device *dev, int x);
-u16 read_nic_word(struct net_device *dev, int x) ;
-void write_nic_byte(struct net_device *dev, int x,u8 y);
-void write_nic_byte_E(struct net_device *dev, int x,u8 y);
-void write_nic_word(struct net_device *dev, int x,u16 y);
-void write_nic_dword(struct net_device *dev, int x,u32 y);
-void force_pci_posting(struct net_device *dev);
-
-void rtl8180_rtx_disable(struct net_device *);
-void rtl8180_rx_enable(struct net_device *);
-void rtl8180_tx_enable(struct net_device *);
-
-void rtl8180_disassociate(struct net_device *dev);
-//void fix_rx_fifo(struct net_device *dev);
-void rtl8185_set_rf_pins_enable(struct net_device *dev,u32 a);
-
-void rtl8180_set_anaparam(struct net_device *dev,u32 a);
-void rtl8185_set_anaparam2(struct net_device *dev,u32 a);
-void rtl8180_update_msr(struct net_device *dev);
-int rtl8180_down(struct net_device *dev);
-int rtl8180_up(struct net_device *dev);
-void rtl8180_commit(struct net_device *dev);
-void rtl8180_set_chan(struct net_device *dev,short ch);
-void write_phy(struct net_device *dev, u8 adr, u8 data);
-void write_phy_cck(struct net_device *dev, u8 adr, u32 data);
-void write_phy_ofdm(struct net_device *dev, u8 adr, u32 data);
-void rtl8185_tx_antenna(struct net_device *dev, u8 ant);
-void rtl8187_set_rxconf(struct net_device *dev);
-#endif
diff -Naur rtl8187_linux_26.1010.0622.2006/beta-8187/.tmp_versions/r8187.mod rtl8187_linux_26.1010.0622.2006_rawtx/beta-8187/.tmp_versions/r8187.mod
--- rtl8187_linux_26.1010.0622.2006/beta-8187/.tmp_versions/r8187.mod	2006-06-22 07:40:15.000000000 +0200
+++ rtl8187_linux_26.1010.0622.2006_rawtx/beta-8187/.tmp_versions/r8187.mod	2008-02-22 15:33:11.000000000 +0100
@@ -1,2 +1,2 @@
-/usr/rtl8187_linux_26.1010.0619.2006/beta-8187/r8187.ko
-/usr/rtl8187_linux_26.1010.0619.2006/beta-8187/r8187_core.o /usr/rtl8187_linux_26.1010.0619.2006/beta-8187/r8180_93cx6.o /usr/rtl8187_linux_26.1010.0619.2006/beta-8187/r8180_wx.o /usr/rtl8187_linux_26.1010.0619.2006/beta-8187/r8180_rtl8225.o /usr/rtl8187_linux_26.1010.0619.2006/beta-8187/r8180_rtl8225z2.o
+/home/pete/rtl8187_linux_26.1010.0622.2006_rawtx/beta-8187/r8187.ko
+/home/pete/rtl8187_linux_26.1010.0622.2006_rawtx/beta-8187/r8187_core.o /home/pete/rtl8187_linux_26.1010.0622.2006_rawtx/beta-8187/r8180_93cx6.o /home/pete/rtl8187_linux_26.1010.0622.2006_rawtx/beta-8187/r8180_wx.o /home/pete/rtl8187_linux_26.1010.0622.2006_rawtx/beta-8187/r8180_rtl8225.o /home/pete/rtl8187_linux_26.1010.0622.2006_rawtx/beta-8187/r8180_rtl8225z2.o
diff -Naur rtl8187_linux_26.1010.0622.2006/ieee80211/ieee80211_crypt.c rtl8187_linux_26.1010.0622.2006_rawtx/ieee80211/ieee80211_crypt.c
--- rtl8187_linux_26.1010.0622.2006/ieee80211/ieee80211_crypt.c	2006-06-06 04:57:56.000000000 +0200
+++ rtl8187_linux_26.1010.0622.2006_rawtx/ieee80211/ieee80211_crypt.c	2008-01-30 17:38:11.000000000 +0100
@@ -11,7 +11,6 @@
  *
  */
 
-#include <linux/config.h>
 #include <linux/version.h>
 #include <linux/module.h>
 #include <linux/init.h>
@@ -19,6 +18,12 @@
 #include <asm/string.h>
 #include <asm/errno.h>
 
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19))
+#include <linux/config.h>
+#else
+#include <linux/autoconf.h>
+#endif
+
 #include "ieee80211.h"
 
 MODULE_AUTHOR("Jouni Malinen");
@@ -38,7 +43,7 @@
 
 static struct ieee80211_crypto *hcrypt;
 
-void ieee80211_crypt_deinit_entries(struct ieee80211_device *ieee,
+void ieee80211_crypt_deinit_entries_rtl7(struct ieee80211_device *ieee,
 					   int force)
 {
 	struct list_head *ptr, *n;
@@ -61,13 +66,13 @@
 	}
 }
 
-void ieee80211_crypt_deinit_handler(unsigned long data)
+void ieee80211_crypt_deinit_handler_rtl7(unsigned long data)
 {
 	struct ieee80211_device *ieee = (struct ieee80211_device *)data;
 	unsigned long flags;
 
 	spin_lock_irqsave(&ieee->lock, flags);
-	ieee80211_crypt_deinit_entries(ieee, 0);
+	ieee80211_crypt_deinit_entries_rtl7(ieee, 0);
 	if (!list_empty(&ieee->crypt_deinit_list)) {
 		printk(KERN_DEBUG "%s: entries remaining in delayed crypt "
 		       "deletion list\n", ieee->dev->name);
@@ -78,7 +83,7 @@
 
 }
 
-void ieee80211_crypt_delayed_deinit(struct ieee80211_device *ieee,
+void ieee80211_crypt_delayed_deinit_rtl7(struct ieee80211_device *ieee,
 				    struct ieee80211_crypt_data **crypt)
 {
 	struct ieee80211_crypt_data *tmp;
@@ -103,7 +108,7 @@
 	spin_unlock_irqrestore(&ieee->lock, flags);
 }
 
-int ieee80211_register_crypto_ops(struct ieee80211_crypto_ops *ops)
+int ieee80211_register_crypto_ops_rtl7(struct ieee80211_crypto_ops *ops)
 {
 	unsigned long flags;
 	struct ieee80211_crypto_alg *alg;
@@ -128,7 +133,7 @@
 	return 0;
 }
 
-int ieee80211_unregister_crypto_ops(struct ieee80211_crypto_ops *ops)
+int ieee80211_unregister_crypto_ops_rtl7(struct ieee80211_crypto_ops *ops)
 {
 	unsigned long flags;
 	struct list_head *ptr;
@@ -159,7 +164,7 @@
 }
 
 
-struct ieee80211_crypto_ops * ieee80211_get_crypto_ops(const char *name)
+struct ieee80211_crypto_ops * ieee80211_get_crypto_ops_rtl7(const char *name)
 {
 	unsigned long flags;
 	struct list_head *ptr;
@@ -186,13 +191,13 @@
 }
 
 
-static void * ieee80211_crypt_null_init(int keyidx) { return (void *) 1; }
-static void ieee80211_crypt_null_deinit(void *priv) {}
+static void * ieee80211_crypt_null_init_rtl7(int keyidx) { return (void *) 1; }
+static void ieee80211_crypt_null_deinit_rtl7(void *priv) {}
 
 static struct ieee80211_crypto_ops ieee80211_crypt_null = {
 	.name			= "NULL",
-	.init			= ieee80211_crypt_null_init,
-	.deinit			= ieee80211_crypt_null_deinit,
+	.init			= ieee80211_crypt_null_init_rtl7,
+	.deinit			= ieee80211_crypt_null_deinit_rtl7,
 	.encrypt_mpdu		= NULL,
 	.decrypt_mpdu		= NULL,
 	.encrypt_msdu		= NULL,
@@ -205,7 +210,7 @@
 };
 
 
-static int __init ieee80211_crypto_init(void)
+static int __init ieee80211_crypto_init_rtl7(void)
 {
 	int ret = -ENOMEM;
 
@@ -217,7 +222,7 @@
 	INIT_LIST_HEAD(&hcrypt->algs);
 	spin_lock_init(&hcrypt->lock);
 
-	ret = ieee80211_register_crypto_ops(&ieee80211_crypt_null);
+	ret = ieee80211_register_crypto_ops_rtl7(&ieee80211_crypt_null);
 	if (ret < 0) {
 		kfree(hcrypt);
 		hcrypt = NULL;
@@ -227,7 +232,7 @@
 }
 
 
-static void __exit ieee80211_crypto_deinit(void)
+static void __exit ieee80211_crypto_deinit_rtl7(void)
 {
 	struct list_head *ptr, *n;
 
@@ -247,13 +252,13 @@
 	kfree(hcrypt);
 }
 
-EXPORT_SYMBOL(ieee80211_crypt_deinit_entries);
-EXPORT_SYMBOL(ieee80211_crypt_deinit_handler);
-EXPORT_SYMBOL(ieee80211_crypt_delayed_deinit);
-
-EXPORT_SYMBOL(ieee80211_register_crypto_ops);
-EXPORT_SYMBOL(ieee80211_unregister_crypto_ops);
-EXPORT_SYMBOL(ieee80211_get_crypto_ops);
+EXPORT_SYMBOL(ieee80211_crypt_deinit_entries_rtl7);
+EXPORT_SYMBOL(ieee80211_crypt_deinit_handler_rtl7);
+EXPORT_SYMBOL(ieee80211_crypt_delayed_deinit_rtl7);
+
+EXPORT_SYMBOL(ieee80211_register_crypto_ops_rtl7);
+EXPORT_SYMBOL(ieee80211_unregister_crypto_ops_rtl7);
+EXPORT_SYMBOL(ieee80211_get_crypto_ops_rtl7);
 
-module_init(ieee80211_crypto_init);
-module_exit(ieee80211_crypto_deinit);
+module_init(ieee80211_crypto_init_rtl7);
+module_exit(ieee80211_crypto_deinit_rtl7);
diff -Naur rtl8187_linux_26.1010.0622.2006/ieee80211/ieee80211_crypt_ccmp.c rtl8187_linux_26.1010.0622.2006_rawtx/ieee80211/ieee80211_crypt_ccmp.c
--- rtl8187_linux_26.1010.0622.2006/ieee80211/ieee80211_crypt_ccmp.c	2006-06-06 04:58:00.000000000 +0200
+++ rtl8187_linux_26.1010.0622.2006_rawtx/ieee80211/ieee80211_crypt_ccmp.c	2008-01-30 17:38:11.000000000 +0100
@@ -9,7 +9,6 @@
  * more details.
  */
 
-#include <linux/config.h>
 #include <linux/version.h>
 #include <linux/module.h>
 #include <linux/init.h>
@@ -22,11 +21,22 @@
 #include <asm/string.h>
 #include <linux/wireless.h>
 
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19))
+#include <linux/config.h>
+#else
+#include <linux/autoconf.h>
+#endif
+
 #include "ieee80211.h"
 
 
 #include <linux/crypto.h>
-#include <asm/scatterlist.h>
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,20)
+    #include <asm/scatterlist.h>
+#else
+    #include <linux/scatterlist.h>
+#endif
 
 MODULE_AUTHOR("Jouni Malinen");
 MODULE_DESCRIPTION("Host AP crypt: CCMP");
@@ -51,7 +61,11 @@
 
 	int key_idx;
 
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19))
 	struct crypto_tfm *tfm;
+#else
+	struct crypto_cipher *tfm;
+#endif
 
 	/* scratch buffers for virt_to_page() (crypto API) */
 	u8 tx_b0[AES_BLOCK_LEN], tx_b[AES_BLOCK_LEN],
@@ -59,7 +73,8 @@
 	u8 rx_b0[AES_BLOCK_LEN], rx_b[AES_BLOCK_LEN], rx_a[AES_BLOCK_LEN];
 };
 
-void ieee80211_ccmp_aes_encrypt(struct crypto_tfm *tfm,
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19))
+void ieee80211_ccmp_aes_encrypt_rtl7(struct crypto_tfm *tfm,
 			     const u8 pt[16], u8 ct[16])
 {
 	struct scatterlist src, dst;
@@ -74,8 +89,15 @@
 
 	crypto_cipher_encrypt(tfm, &dst, &src, AES_BLOCK_LEN);
 }
+#else
+static inline void ieee80211_ccmp_aes_encrypt_rtl7(struct crypto_cipher *tfm,
+					      const u8 pt[16], u8 ct[16])
+{
+	crypto_cipher_encrypt_one(tfm, ct, pt);
+}
+#endif
 
-static void * ieee80211_ccmp_init(int key_idx)
+static void * ieee80211_ccmp_init_rtl7(int key_idx)
 {
 	struct ieee80211_ccmp_data *priv;
 
@@ -85,19 +107,33 @@
 	memset(priv, 0, sizeof(*priv));
 	priv->key_idx = key_idx;
 
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19))
 	priv->tfm = crypto_alloc_tfm("aes", 0);
 	if (priv->tfm == NULL) {
 		printk(KERN_DEBUG "ieee80211_crypt_ccmp: could not allocate "
 		       "crypto API aes\n");
 		goto fail;
 	}
+#else
+	priv->tfm = crypto_alloc_cipher("aes", 0, CRYPTO_ALG_ASYNC);
+	if (IS_ERR(priv->tfm)) {
+		printk(KERN_DEBUG "ieee80211_crypt_ccmp: could not allocate "
+		       "crypto API aes\n");
+		priv->tfm = NULL;
+		goto fail;
+	}
+#endif
 
 	return priv;
 
 fail:
 	if (priv) {
 		if (priv->tfm)
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19))
 			crypto_free_tfm(priv->tfm);
+#else
+			crypto_free_cipher(priv->tfm);
+#endif
 		kfree(priv);
 	}
 
@@ -105,16 +141,20 @@
 }
 
 
-static void ieee80211_ccmp_deinit(void *priv)
+static void ieee80211_ccmp_deinit_rtl7(void *priv)
 {
 	struct ieee80211_ccmp_data *_priv = priv;
 	if (_priv && _priv->tfm)
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19))
 		crypto_free_tfm(_priv->tfm);
+#else
+		crypto_free_cipher(_priv->tfm);
+#endif
 	kfree(priv);
 }
 
 
-static inline void xor_block(u8 *b, u8 *a, size_t len)
+static inline void xor_block_rtl7(u8 *b, u8 *a, size_t len)
 {
 	int i;
 	for (i = 0; i < len; i++)
@@ -122,7 +162,11 @@
 }
 
 
-static void ccmp_init_blocks(struct crypto_tfm *tfm,
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19))
+static void ccmp_init_blocks_rtl7(struct crypto_tfm *tfm,
+#else
+static void ccmp_init_blocks_rtl7(struct crypto_cipher *tfm,
+#endif
 			     struct ieee80211_hdr *hdr,
 			     u8 *pn, size_t dlen, u8 *b0, u8 *auth,
 			     u8 *s0)
@@ -186,18 +230,18 @@
 	}
 
 	/* Start with the first block and AAD */
-	ieee80211_ccmp_aes_encrypt(tfm, b0, auth);
-	xor_block(auth, aad, AES_BLOCK_LEN);
-	ieee80211_ccmp_aes_encrypt(tfm, auth, auth);
-	xor_block(auth, &aad[AES_BLOCK_LEN], AES_BLOCK_LEN);
-	ieee80211_ccmp_aes_encrypt(tfm, auth, auth);
+	ieee80211_ccmp_aes_encrypt_rtl7(tfm, b0, auth);
+	xor_block_rtl7(auth, aad, AES_BLOCK_LEN);
+	ieee80211_ccmp_aes_encrypt_rtl7(tfm, auth, auth);
+	xor_block_rtl7(auth, &aad[AES_BLOCK_LEN], AES_BLOCK_LEN);
+	ieee80211_ccmp_aes_encrypt_rtl7(tfm, auth, auth);
 	b0[0] &= 0x07;
 	b0[14] = b0[15] = 0;
-	ieee80211_ccmp_aes_encrypt(tfm, b0, s0);
+	ieee80211_ccmp_aes_encrypt_rtl7(tfm, b0, s0);
 }
 
 
-static int ieee80211_ccmp_encrypt(struct sk_buff *skb, int hdr_len, void *priv)
+static int ieee80211_ccmp_encrypt_rtl7(struct sk_buff *skb, int hdr_len, void *priv)
 {
 	struct ieee80211_ccmp_data *key = priv;
 	int data_len, i, blocks, last, len;
@@ -237,7 +281,7 @@
 	*pos++ = key->tx_pn[0];
 
 	hdr = (struct ieee80211_hdr *) skb->data;
-	ccmp_init_blocks(key->tfm, hdr, key->tx_pn, data_len, b0, b, s0);
+	ccmp_init_blocks_rtl7(key->tfm, hdr, key->tx_pn, data_len, b0, b, s0);
 
 	blocks = (data_len + AES_BLOCK_LEN - 1) / AES_BLOCK_LEN;
 	last = data_len % AES_BLOCK_LEN;
@@ -245,13 +289,13 @@
 	for (i = 1; i <= blocks; i++) {
 		len = (i == blocks && last) ? last : AES_BLOCK_LEN;
 		/* Authentication */
-		xor_block(b, pos, len);
-		ieee80211_ccmp_aes_encrypt(key->tfm, b, b);
+		xor_block_rtl7(b, pos, len);
+		ieee80211_ccmp_aes_encrypt_rtl7(key->tfm, b, b);
 		/* Encryption, with counter */
 		b0[14] = (i >> 8) & 0xff;
 		b0[15] = i & 0xff;
-		ieee80211_ccmp_aes_encrypt(key->tfm, b0, e);
-		xor_block(pos, e, len);
+		ieee80211_ccmp_aes_encrypt_rtl7(key->tfm, b0, e);
+		xor_block_rtl7(pos, e, len);
 		pos += len;
 	}
 
@@ -262,7 +306,7 @@
 }
 
 
-static int ieee80211_ccmp_decrypt(struct sk_buff *skb, int hdr_len, void *priv)
+static int ieee80211_ccmp_decrypt_rtl7(struct sk_buff *skb, int hdr_len, void *priv)
 {
 	struct ieee80211_ccmp_data *key = priv;
 	u8 keyidx, *pos;
@@ -326,8 +370,8 @@
 		return -4;
 	}
 
-	ccmp_init_blocks(key->tfm, hdr, pn, data_len, b0, a, b);
-	xor_block(mic, b, CCMP_MIC_LEN);
+	ccmp_init_blocks_rtl7(key->tfm, hdr, pn, data_len, b0, a, b);
+	xor_block_rtl7(mic, b, CCMP_MIC_LEN);
 
 	blocks = (data_len + AES_BLOCK_LEN - 1) / AES_BLOCK_LEN;
 	last = data_len % AES_BLOCK_LEN;
@@ -337,11 +381,11 @@
 		/* Decrypt, with counter */
 		b0[14] = (i >> 8) & 0xff;
 		b0[15] = i & 0xff;
-		ieee80211_ccmp_aes_encrypt(key->tfm, b0, b);
-		xor_block(pos, b, len);
+		ieee80211_ccmp_aes_encrypt_rtl7(key->tfm, b0, b);
+		xor_block_rtl7(pos, b, len);
 		/* Authentication */
-		xor_block(a, pos, len);
-		ieee80211_ccmp_aes_encrypt(key->tfm, a, a);
+		xor_block_rtl7(a, pos, len);
+		ieee80211_ccmp_aes_encrypt_rtl7(key->tfm, a, a);
 		pos += len;
 	}
 
@@ -365,11 +409,15 @@
 }
 
 
-static int ieee80211_ccmp_set_key(void *key, int len, u8 *seq, void *priv)
+static int ieee80211_ccmp_set_key_rtl7(void *key, int len, u8 *seq, void *priv)
 {
 	struct ieee80211_ccmp_data *data = priv;
 	int keyidx;
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19))
 	struct crypto_tfm *tfm = data->tfm;
+#else
+	struct crypto_cipher *tfm = data->tfm;
+#endif
 
 	keyidx = data->key_idx;
 	memset(data, 0, sizeof(*data));
@@ -396,7 +444,7 @@
 }
 
 
-static int ieee80211_ccmp_get_key(void *key, int len, u8 *seq, void *priv)
+static int ieee80211_ccmp_get_key_rtl7(void *key, int len, u8 *seq, void *priv)
 {
 	struct ieee80211_ccmp_data *data = priv;
 
@@ -420,7 +468,7 @@
 }
 
 
-static char * ieee80211_ccmp_print_stats(char *p, void *priv)
+static char * ieee80211_ccmp_print_stats_rtl7(char *p, void *priv)
 {
 	struct ieee80211_ccmp_data *ccmp = priv;
 	p += sprintf(p, "key[%d] alg=CCMP key_set=%d "
@@ -437,34 +485,34 @@
 }
 
 
-static struct ieee80211_crypto_ops ieee80211_crypt_ccmp = {
+static struct ieee80211_crypto_ops ieee80211_crypt_ccmp_rtl7 = {
 	.name			= "CCMP",
-	.init			= ieee80211_ccmp_init,
-	.deinit			= ieee80211_ccmp_deinit,
-	.encrypt_mpdu		= ieee80211_ccmp_encrypt,
-	.decrypt_mpdu		= ieee80211_ccmp_decrypt,
+	.init			= ieee80211_ccmp_init_rtl7,
+	.deinit			= ieee80211_ccmp_deinit_rtl7,
+	.encrypt_mpdu		= ieee80211_ccmp_encrypt_rtl7,
+	.decrypt_mpdu		= ieee80211_ccmp_decrypt_rtl7,
 	.encrypt_msdu		= NULL,
 	.decrypt_msdu		= NULL,
-	.set_key		= ieee80211_ccmp_set_key,
-	.get_key		= ieee80211_ccmp_get_key,
-	.print_stats		= ieee80211_ccmp_print_stats,
+	.set_key		= ieee80211_ccmp_set_key_rtl7,
+	.get_key		= ieee80211_ccmp_get_key_rtl7,
+	.print_stats		= ieee80211_ccmp_print_stats_rtl7,
 	.extra_prefix_len	= CCMP_HDR_LEN,
 	.extra_postfix_len	= CCMP_MIC_LEN,
 	.owner			= THIS_MODULE,
 };
 
 
-static int __init ieee80211_crypto_ccmp_init(void)
+static int __init ieee80211_crypto_ccmp_init_rtl7(void)
 {
-	return ieee80211_register_crypto_ops(&ieee80211_crypt_ccmp);
+	return ieee80211_register_crypto_ops_rtl7(&ieee80211_crypt_ccmp_rtl7);
 }
 
 
-static void __exit ieee80211_crypto_ccmp_exit(void)
+static void __exit ieee80211_crypto_ccmp_exit_rtl7(void)
 {
-	ieee80211_unregister_crypto_ops(&ieee80211_crypt_ccmp);
+	ieee80211_unregister_crypto_ops_rtl7(&ieee80211_crypt_ccmp_rtl7);
 }
 
 
-module_init(ieee80211_crypto_ccmp_init);
-module_exit(ieee80211_crypto_ccmp_exit);
+module_init(ieee80211_crypto_ccmp_init_rtl7);
+module_exit(ieee80211_crypto_ccmp_exit_rtl7);
diff -Naur rtl8187_linux_26.1010.0622.2006/ieee80211/ieee80211_crypt.h rtl8187_linux_26.1010.0622.2006_rawtx/ieee80211/ieee80211_crypt.h
--- rtl8187_linux_26.1010.0622.2006/ieee80211/ieee80211_crypt.h	2006-06-06 04:58:00.000000000 +0200
+++ rtl8187_linux_26.1010.0622.2006_rawtx/ieee80211/ieee80211_crypt.h	2008-01-30 17:38:11.000000000 +0100
@@ -75,12 +75,12 @@
 	atomic_t refcnt;
 };
 
-int ieee80211_register_crypto_ops(struct ieee80211_crypto_ops *ops);
-int ieee80211_unregister_crypto_ops(struct ieee80211_crypto_ops *ops);
-struct ieee80211_crypto_ops * ieee80211_get_crypto_ops(const char *name);
-void ieee80211_crypt_deinit_entries(struct ieee80211_device *, int);
-void ieee80211_crypt_deinit_handler(unsigned long);
-void ieee80211_crypt_delayed_deinit(struct ieee80211_device *ieee,
+int ieee80211_register_crypto_ops_rtl7(struct ieee80211_crypto_ops *ops);
+int ieee80211_unregister_crypto_ops_rtl7(struct ieee80211_crypto_ops *ops);
+struct ieee80211_crypto_ops * ieee80211_get_crypto_ops_rtl7(const char *name);
+void ieee80211_crypt_deinit_entries_rtl7(struct ieee80211_device *, int);
+void ieee80211_crypt_deinit_handler_rtl7(unsigned long);
+void ieee80211_crypt_delayed_deinit_rtl7(struct ieee80211_device *ieee,
 				    struct ieee80211_crypt_data **crypt);
 
 #endif
diff -Naur rtl8187_linux_26.1010.0622.2006/ieee80211/ieee80211_crypt_tkip.c rtl8187_linux_26.1010.0622.2006_rawtx/ieee80211/ieee80211_crypt_tkip.c
--- rtl8187_linux_26.1010.0622.2006/ieee80211/ieee80211_crypt_tkip.c	2006-06-06 04:57:54.000000000 +0200
+++ rtl8187_linux_26.1010.0622.2006_rawtx/ieee80211/ieee80211_crypt_tkip.c	2008-01-30 17:39:05.000000000 +0100
@@ -9,7 +9,6 @@
  * more details.
  */
 
-#include <linux/config.h>
 #include <linux/version.h>
 #include <linux/module.h>
 #include <linux/init.h>
@@ -21,13 +20,24 @@
 #include <linux/if_arp.h>
 #include <asm/string.h>
 
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19))
+#include <linux/config.h>
+#else
+#include <linux/autoconf.h>
+#endif
+
 #include "ieee80211.h"
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,20)
+    #include <asm/scatterlist.h>
+#else
+    #include <linux/scatterlist.h>
+#endif
 
 #include <linux/crypto.h>
-#include <asm/scatterlist.h>
 #include <linux/crc32.h>
 
+
 MODULE_AUTHOR("Jouni Malinen");
 MODULE_DESCRIPTION("Host AP crypt: TKIP");
 MODULE_LICENSE("GPL");
@@ -55,14 +65,21 @@
 
 	int key_idx;
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19)
 	struct crypto_tfm *tfm_arc4;
 	struct crypto_tfm *tfm_michael;
+#else
+	struct crypto_blkcipher *rx_tfm_arc4;
+	struct crypto_blkcipher *tx_tfm_arc4;
+	struct crypto_hash *rx_tfm_michael;
+	struct crypto_hash *tx_tfm_michael;
+#endif
 
 	/* scratch buffers for virt_to_page() (crypto API) */
 	u8 rx_hdr[16], tx_hdr[16];
 };
 
-static void * ieee80211_tkip_init(int key_idx)
+static void * ieee80211_tkip_init_rtl7(int key_idx)
 {
 	struct ieee80211_tkip_data *priv;
 
@@ -72,28 +89,74 @@
 	memset(priv, 0, sizeof(*priv));
 	priv->key_idx = key_idx;
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19)
 	priv->tfm_arc4 = crypto_alloc_tfm("arc4", 0);
 	if (priv->tfm_arc4 == NULL) {
 		printk(KERN_DEBUG "ieee80211_crypt_tkip: could not allocate "
 		       "crypto API arc4\n");
 		goto fail;
 	}
-
 	priv->tfm_michael = crypto_alloc_tfm("michael_mic", 0);
 	if (priv->tfm_michael == NULL) {
 		printk(KERN_DEBUG "ieee80211_crypt_tkip: could not allocate "
 		       "crypto API michael_mic\n");
 		goto fail;
 	}
+#else
+	priv->tx_tfm_arc4 = crypto_alloc_blkcipher("ecb(arc4)", 0, CRYPTO_ALG_ASYNC);
+	if (IS_ERR(priv->tx_tfm_arc4)) {
+		printk(KERN_DEBUG "ieee80211_crypt_wep: could not allocate "
+		       "crypto API arc4\n");
+		priv->tx_tfm_arc4 = NULL;
+		goto fail;
+	}
+
+	priv->tx_tfm_michael = crypto_alloc_hash("michael_mic", 0,
+						 CRYPTO_ALG_ASYNC);
+	if (IS_ERR(priv->tx_tfm_michael)) {
+		printk(KERN_DEBUG "ieee80211_crypt_tkip: could not allocate "
+		       "crypto API michael_mic\n");
+		priv->tx_tfm_michael = NULL;
+		goto fail;
+	}
+
+	priv->rx_tfm_arc4 = crypto_alloc_blkcipher("ecb(arc4)", 0, CRYPTO_ALG_ASYNC);
+	if (IS_ERR(priv->rx_tfm_arc4)) {
+		printk(KERN_DEBUG "ieee80211_crypt_wep: could not allocate "
+		       "crypto API arc4\n");
+		priv->rx_tfm_arc4 = NULL;
+		goto fail;
+	}
+
+	priv->rx_tfm_michael = crypto_alloc_hash("michael_mic", 0,
+						 CRYPTO_ALG_ASYNC);
+	if (IS_ERR(priv->rx_tfm_michael)) {
+		printk(KERN_DEBUG "ieee80211_crypt_tkip: could not allocate "
+		       "crypto API michael_mic\n");
+		priv->rx_tfm_michael = NULL;
+		goto fail;
+	}
+#endif
 
 	return priv;
 
 fail:
 	if (priv) {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19)
 		if (priv->tfm_michael)
 			crypto_free_tfm(priv->tfm_michael);
 		if (priv->tfm_arc4)
 			crypto_free_tfm(priv->tfm_arc4);
+#else
+		if (priv->tx_tfm_michael)
+			crypto_free_hash(priv->tx_tfm_michael);
+		if (priv->tx_tfm_arc4)
+			crypto_free_blkcipher(priv->tx_tfm_arc4);
+		if (priv->rx_tfm_michael)
+			crypto_free_hash(priv->rx_tfm_michael);
+		if (priv->rx_tfm_arc4)
+			crypto_free_blkcipher(priv->rx_tfm_arc4);
+#endif
 		kfree(priv);
 	}
 
@@ -101,13 +164,26 @@
 }
 
 
-static void ieee80211_tkip_deinit(void *priv)
+static void ieee80211_tkip_deinit_rtl7(void *priv)
 {
 	struct ieee80211_tkip_data *_priv = priv;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19)
 	if (_priv && _priv->tfm_michael)
 		crypto_free_tfm(_priv->tfm_michael);
 	if (_priv && _priv->tfm_arc4)
 		crypto_free_tfm(_priv->tfm_arc4);
+#else
+	if (_priv) {
+		if (_priv->tx_tfm_michael)
+			crypto_free_hash(_priv->tx_tfm_michael);
+		if (_priv->tx_tfm_arc4)
+			crypto_free_blkcipher(_priv->tx_tfm_arc4);
+		if (_priv->rx_tfm_michael)
+			crypto_free_hash(_priv->rx_tfm_michael);
+		if (_priv->rx_tfm_arc4)
+			crypto_free_blkcipher(_priv->rx_tfm_arc4);
+	}
+#endif
 	kfree(priv);
 }
 
@@ -200,7 +276,7 @@
 
 #define PHASE1_LOOP_COUNT 8
 
-static void tkip_mixing_phase1(u16 *TTAK, const u8 *TK, const u8 *TA, u32 IV32)
+static void tkip_mixing_phase1_rtl7(u16 *TTAK, const u8 *TK, const u8 *TA, u32 IV32)
 {
 	int i, j;
 
@@ -222,7 +298,7 @@
 }
 
 
-static void tkip_mixing_phase2(u8 *WEPSeed, const u8 *TK, const u16 *TTAK,
+static void tkip_mixing_phase2_rtl7(u8 *WEPSeed, const u8 *TK, const u16 *TTAK,
 			       u16 IV16)
 {
 	/* Make temporary area overlap WEP seed so that the final copy can be
@@ -268,7 +344,7 @@
 #endif
 }
 
-static int ieee80211_tkip_encrypt(struct sk_buff *skb, int hdr_len, void *priv)
+static int ieee80211_tkip_encrypt_rtl7(struct sk_buff *skb, int hdr_len, void *priv)
 {
 	struct ieee80211_tkip_data *tkey = priv;
 	int len;
@@ -276,6 +352,9 @@
 	struct ieee80211_hdr *hdr;
 	u32 crc;
 	struct scatterlist sg;
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,19))
+	struct blkcipher_desc desc = { .tfm = tkey->tx_tfm_arc4 };
+#endif
 
 	if (skb_headroom(skb) < 8 || skb_tailroom(skb) < 4 ||
 	    skb->len < hdr_len)
@@ -283,11 +362,11 @@
 
 	hdr = (struct ieee80211_hdr *) skb->data;
 	if (!tkey->tx_phase1_done) {
-		tkip_mixing_phase1(tkey->tx_ttak, tkey->key, hdr->addr2,
+		tkip_mixing_phase1_rtl7(tkey->tx_ttak, tkey->key, hdr->addr2,
 				   tkey->tx_iv32);
 		tkey->tx_phase1_done = 1;
 	}
-	tkip_mixing_phase2(rc4key, tkey->key, tkey->tx_ttak, tkey->tx_iv16);
+	tkip_mixing_phase2_rtl7(rc4key, tkey->key, tkey->tx_ttak, tkey->tx_iv16);
 
 	len = skb->len - hdr_len;
 	pos = skb_push(skb, 8);
@@ -310,11 +389,23 @@
 	icv[2] = crc >> 16;
 	icv[3] = crc >> 24;
 
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19))
 	crypto_cipher_setkey(tkey->tfm_arc4, rc4key, 16);
+#else
+	crypto_blkcipher_setkey(tkey->tx_tfm_arc4, rc4key, 16);
+#endif
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,24))
 	sg.page = virt_to_page(pos);
 	sg.offset = offset_in_page(pos);
 	sg.length = len + 4;
+#else
+	sg_set_page(&sg, virt_to_page(pos), len + 2, offset_in_page(pos));
+#endif
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19))
 	crypto_cipher_encrypt(tkey->tfm_arc4, &sg, &sg, len + 4);
+#else
+	crypto_blkcipher_encrypt(&desc, &sg, &sg, len + 4);
+#endif
 
 	tkey->tx_iv16++;
 	if (tkey->tx_iv16 == 0) {
@@ -325,7 +416,7 @@
 	return 0;
 }
 
-static int ieee80211_tkip_decrypt(struct sk_buff *skb, int hdr_len, void *priv)
+static int ieee80211_tkip_decrypt_rtl7(struct sk_buff *skb, int hdr_len, void *priv)
 {
 	struct ieee80211_tkip_data *tkey = priv;
 	u8 rc4key[16];
@@ -337,6 +428,9 @@
 	u32 crc;
 	struct scatterlist sg;
 	int plen;
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,19))
+	struct blkcipher_desc desc = { .tfm = tkey->rx_tfm_arc4 };
+#endif
 
 	if (skb->len < hdr_len + 8 + 4)
 		return -1;
@@ -382,18 +476,30 @@
 	}
 
 	if (iv32 != tkey->rx_iv32 || !tkey->rx_phase1_done) {
-		tkip_mixing_phase1(tkey->rx_ttak, tkey->key, hdr->addr2, iv32);
+		tkip_mixing_phase1_rtl7(tkey->rx_ttak, tkey->key, hdr->addr2, iv32);
 		tkey->rx_phase1_done = 1;
 	}
-	tkip_mixing_phase2(rc4key, tkey->key, tkey->rx_ttak, iv16);
+	tkip_mixing_phase2_rtl7(rc4key, tkey->key, tkey->rx_ttak, iv16);
 
 	plen = skb->len - hdr_len - 12;
 
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19))
 	crypto_cipher_setkey(tkey->tfm_arc4, rc4key, 16);
+#else
+	crypto_blkcipher_setkey(tkey->rx_tfm_arc4, rc4key, 16);
+#endif
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,24))
 	sg.page = virt_to_page(pos);
 	sg.offset = offset_in_page(pos);
 	sg.length = plen + 4;
+#else
+	sg_set_page(&sg, virt_to_page(pos), plen + 4, offset_in_page(pos));
+#endif
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19))
 	crypto_cipher_decrypt(tkey->tfm_arc4, &sg, &sg, plen + 4);
+#else
+	crypto_blkcipher_decrypt(&desc, &sg, &sg, plen + 4);
+#endif
 
 	crc = ~crc32_le(~0, pos, plen);
 	icv[0] = crc;
@@ -427,33 +533,59 @@
 	return keyidx;
 }
 
-
-static int michael_mic(struct ieee80211_tkip_data *tkey, u8 *key, u8 *hdr,
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19)
+static int michael_mic_rtl7(struct ieee80211_tkip_data *tkey, u8 *key, u8 *hdr,
 		       u8 *data, size_t data_len, u8 *mic)
 {
 	struct scatterlist sg[2];
 
 	if (tkey->tfm_michael == NULL) {
+#else
+static int michael_mic_rtl7(struct crypto_hash *tfm_michael, u8 *key, u8 *hdr,
+		       u8 *data, size_t data_len, u8 *mic)
+{
+	struct hash_desc desc;
+	struct scatterlist sg[2];
+
+	if (tfm_michael == NULL) {
+#endif
 		printk(KERN_WARNING "michael_mic: tfm_michael == NULL\n");
 		return -1;
 	}
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,24))
 	sg[0].page = virt_to_page(hdr);
 	sg[0].offset = offset_in_page(hdr);
 	sg[0].length = 16;
+#else
+	sg_set_page(&sg[0], virt_to_page(hdr), 16, offset_in_page(hdr));
+#endif
 
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,24))
 	sg[1].page = virt_to_page(data);
 	sg[1].offset = offset_in_page(data);
 	sg[1].length = data_len;
+#else
+	sg_set_page(&sg[1], virt_to_page(data), data_len, offset_in_page(data));
+#endif
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19)
 	crypto_digest_init(tkey->tfm_michael);
 	crypto_digest_setkey(tkey->tfm_michael, key, 8);
 	crypto_digest_update(tkey->tfm_michael, sg, 2);
 	crypto_digest_final(tkey->tfm_michael, mic);
 
 	return 0;
+#else
+	if (crypto_hash_setkey(tfm_michael, key, 8))
+		return -1;
+
+	desc.tfm = tfm_michael;
+	desc.flags = 0;
+	return crypto_hash_digest(&desc, sg, data_len + 16, mic);
+#endif
 }
 
-static void michael_mic_hdr(struct sk_buff *skb, u8 *hdr)
+static void michael_mic_hdr_rtl7(struct sk_buff *skb, u8 *hdr)
 {
 	struct ieee80211_hdr *hdr11;
 
@@ -483,7 +615,7 @@
 }
 
 
-static int ieee80211_michael_mic_add(struct sk_buff *skb, int hdr_len, void *priv)
+static int ieee80211_michael_mic_add_rtl7(struct sk_buff *skb, int hdr_len, void *priv)
 {
 	struct ieee80211_tkip_data *tkey = priv;
 	u8 *pos;
@@ -495,18 +627,24 @@
 		return -1;
 	}
 
-	michael_mic_hdr(skb, tkey->tx_hdr);
+	michael_mic_hdr_rtl7(skb, tkey->tx_hdr);
 	pos = skb_put(skb, 8);
-	if (michael_mic(tkey, &tkey->key[16], tkey->tx_hdr,
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19)
+	if (michael_mic_rtl7(tkey, &tkey->key[16], tkey->tx_hdr,
+			skb->data + hdr_len, skb->len - 8 - hdr_len, pos))
+		return -1;
+#else
+	if (michael_mic_rtl7(tkey->tx_tfm_michael, &tkey->key[16], tkey->tx_hdr,
 			skb->data + hdr_len, skb->len - 8 - hdr_len, pos))
 		return -1;
+#endif
 
 	return 0;
 }
 
 
 #if WIRELESS_EXT >= 18
-static void ieee80211_michael_mic_failure(struct net_device *dev,
+static void ieee80211_michael_mic_failure_rtl7(struct net_device *dev,
 				       struct ieee80211_hdr *hdr,
 				       int keyidx)
 {
@@ -527,7 +665,7 @@
 	wireless_send_event(dev, IWEVMICHAELMICFAILURE, &wrqu, (char *) &ev);
 }
 #elif WIRELESS_EXT >= 15
-static void ieee80211_michael_mic_failure(struct net_device *dev,
+static void ieee80211_michael_mic_failure_rtl7(struct net_device *dev,
 				       struct ieee80211_hdr *hdr,
 				       int keyidx)
 {
@@ -543,7 +681,7 @@
 	wireless_send_event(dev, IWEVCUSTOM, &wrqu, buf);
 }
 #else /* WIRELESS_EXT >= 15 */
-static inline void ieee80211_michael_mic_failure(struct net_device *dev,
+static inline void ieee80211_michael_mic_failure_rtl7(struct net_device *dev,
 					      struct ieee80211_hdr *hdr,
 					      int keyidx)
 {
@@ -551,7 +689,7 @@
 #endif /* WIRELESS_EXT >= 15 */
 
 
-static int ieee80211_michael_mic_verify(struct sk_buff *skb, int keyidx,
+static int ieee80211_michael_mic_verify_rtl7(struct sk_buff *skb, int keyidx,
 				     int hdr_len, void *priv)
 {
 	struct ieee80211_tkip_data *tkey = priv;
@@ -560,10 +698,16 @@
 	if (!tkey->key_set)
 		return -1;
 
-	michael_mic_hdr(skb, tkey->rx_hdr);
-	if (michael_mic(tkey, &tkey->key[24], tkey->rx_hdr,
+	michael_mic_hdr_rtl7(skb, tkey->rx_hdr);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19)
+	if (michael_mic_rtl7(tkey, &tkey->key[24], tkey->rx_hdr,
+			skb->data + hdr_len, skb->len - 8 - hdr_len, mic))
+		return -1;
+#else
+	if (michael_mic_rtl7(tkey->rx_tfm_michael, &tkey->key[24], tkey->rx_hdr,
 			skb->data + hdr_len, skb->len - 8 - hdr_len, mic))
 		return -1;
+#endif
 	if (memcmp(mic, skb->data + skb->len - 8, 8) != 0) {
 		struct ieee80211_hdr *hdr;
 		hdr = (struct ieee80211_hdr *) skb->data;
@@ -572,7 +716,7 @@
 		       skb->dev ? skb->dev->name : "N/A", MAC_ARG(hdr->addr2),
 		       keyidx);
 		if (skb->dev)
-			ieee80211_michael_mic_failure(skb->dev, hdr, keyidx);
+			ieee80211_michael_mic_failure_rtl7(skb->dev, hdr, keyidx);
 		tkey->dot11RSNAStatsTKIPLocalMICFailures++;
 		return -1;
 	}
@@ -588,18 +732,33 @@
 }
 
 
-static int ieee80211_tkip_set_key(void *key, int len, u8 *seq, void *priv)
+static int ieee80211_tkip_set_key_rtl7(void *key, int len, u8 *seq, void *priv)
 {
 	struct ieee80211_tkip_data *tkey = priv;
 	int keyidx;
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19))
 	struct crypto_tfm *tfm = tkey->tfm_michael;
 	struct crypto_tfm *tfm2 = tkey->tfm_arc4;
+#else
+	struct crypto_hash *tfm = tkey->tx_tfm_michael;
+	struct crypto_blkcipher *tfm2 = tkey->tx_tfm_arc4;
+	struct crypto_hash *tfm3 = tkey->rx_tfm_michael;
+	struct crypto_blkcipher *tfm4 = tkey->rx_tfm_arc4;
+#endif
 
 	keyidx = tkey->key_idx;
 	memset(tkey, 0, sizeof(*tkey));
 	tkey->key_idx = keyidx;
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19))
 	tkey->tfm_michael = tfm;
 	tkey->tfm_arc4 = tfm2;
+#else
+	tkey->tx_tfm_michael = tfm;
+	tkey->tx_tfm_arc4 = tfm2;
+	tkey->rx_tfm_michael = tfm3;
+	tkey->rx_tfm_arc4 = tfm4;
+#endif
+
 	if (len == TKIP_KEY_LEN) {
 		memcpy(tkey->key, key, TKIP_KEY_LEN);
 		tkey->key_set = 1;
@@ -618,7 +777,7 @@
 }
 
 
-static int ieee80211_tkip_get_key(void *key, int len, u8 *seq, void *priv)
+static int ieee80211_tkip_get_key_rtl7(void *key, int len, u8 *seq, void *priv)
 {
 	struct ieee80211_tkip_data *tkey = priv;
 
@@ -648,7 +807,7 @@
 }
 
 
-static char * ieee80211_tkip_print_stats(char *p, void *priv)
+static char * ieee80211_tkip_print_stats_rtl7(char *p, void *priv)
 {
 	struct ieee80211_tkip_data *tkip = priv;
 	p += sprintf(p, "key[%d] alg=TKIP key_set=%d "
@@ -675,34 +834,34 @@
 }
 
 
-static struct ieee80211_crypto_ops ieee80211_crypt_tkip = {
+static struct ieee80211_crypto_ops ieee80211_crypt_tkip_rtl7 = {
 	.name			= "TKIP",
-	.init			= ieee80211_tkip_init,
-	.deinit			= ieee80211_tkip_deinit,
-	.encrypt_mpdu		= ieee80211_tkip_encrypt,
-	.decrypt_mpdu		= ieee80211_tkip_decrypt,
-	.encrypt_msdu		= ieee80211_michael_mic_add,
-	.decrypt_msdu		= ieee80211_michael_mic_verify,
-	.set_key		= ieee80211_tkip_set_key,
-	.get_key		= ieee80211_tkip_get_key,
-	.print_stats		= ieee80211_tkip_print_stats,
+	.init			= ieee80211_tkip_init_rtl7,
+	.deinit			= ieee80211_tkip_deinit_rtl7,
+	.encrypt_mpdu		= ieee80211_tkip_encrypt_rtl7,
+	.decrypt_mpdu		= ieee80211_tkip_decrypt_rtl7,
+	.encrypt_msdu		= ieee80211_michael_mic_add_rtl7,
+	.decrypt_msdu		= ieee80211_michael_mic_verify_rtl7,
+	.set_key		= ieee80211_tkip_set_key_rtl7,
+	.get_key		= ieee80211_tkip_get_key_rtl7,
+	.print_stats		= ieee80211_tkip_print_stats_rtl7,
 	.extra_prefix_len	= 4 + 4, /* IV + ExtIV */
 	.extra_postfix_len	= 8 + 4, /* MIC + ICV */
 	.owner		        = THIS_MODULE,
 };
 
 
-static int __init ieee80211_crypto_tkip_init(void)
+static int __init ieee80211_crypto_tkip_init_rtl7(void)
 {
-	return ieee80211_register_crypto_ops(&ieee80211_crypt_tkip);
+	return ieee80211_register_crypto_ops_rtl7(&ieee80211_crypt_tkip_rtl7);
 }
 
 
-static void __exit ieee80211_crypto_tkip_exit(void)
+static void __exit ieee80211_crypto_tkip_exit_rtl7(void)
 {
-	ieee80211_unregister_crypto_ops(&ieee80211_crypt_tkip);
+	ieee80211_unregister_crypto_ops_rtl7(&ieee80211_crypt_tkip_rtl7);
 }
 
 
-module_init(ieee80211_crypto_tkip_init);
-module_exit(ieee80211_crypto_tkip_exit);
+module_init(ieee80211_crypto_tkip_init_rtl7);
+module_exit(ieee80211_crypto_tkip_exit_rtl7);
diff -Naur rtl8187_linux_26.1010.0622.2006/ieee80211/ieee80211_crypt_wep.c rtl8187_linux_26.1010.0622.2006_rawtx/ieee80211/ieee80211_crypt_wep.c
--- rtl8187_linux_26.1010.0622.2006/ieee80211/ieee80211_crypt_wep.c	2006-06-06 04:57:54.000000000 +0200
+++ rtl8187_linux_26.1010.0622.2006_rawtx/ieee80211/ieee80211_crypt_wep.c	2008-01-30 17:39:05.000000000 +0100
@@ -9,7 +9,6 @@
  * more details.
  */
 
-#include <linux/config.h>
 #include <linux/version.h>
 #include <linux/module.h>
 #include <linux/init.h>
@@ -18,13 +17,24 @@
 #include <linux/skbuff.h>
 #include <asm/string.h>
 
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19))
+#include <linux/config.h>
+#else
+#include <linux/autoconf.h>
+#endif
+
 #include "ieee80211.h"
 
 
 #include <linux/crypto.h>
-#include <asm/scatterlist.h>
 #include <linux/crc32.h>
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,20)
+    #include <asm/scatterlist.h>
+#else
+    #include <linux/scatterlist.h>
+#endif
+
 MODULE_AUTHOR("Jouni Malinen");
 MODULE_DESCRIPTION("Host AP crypt: WEP");
 MODULE_LICENSE("GPL");
@@ -36,11 +46,16 @@
 	u8 key[WEP_KEY_LEN + 1];
 	u8 key_len;
 	u8 key_idx;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19)
 	struct crypto_tfm *tfm;
+#else
+	struct crypto_blkcipher *rx_tfm;
+	struct crypto_blkcipher *tx_tfm;
+#endif
 };
 
 
-static void * prism2_wep_init(int keyidx)
+static void * prism2_wep_init_rtl7(int keyidx)
 {
 	struct prism2_wep_data *priv;
 
@@ -50,13 +65,30 @@
 	memset(priv, 0, sizeof(*priv));
 	priv->key_idx = keyidx;
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19)
 	priv->tfm = crypto_alloc_tfm("arc4", 0);
 	if (priv->tfm == NULL) {
 		printk(KERN_DEBUG "ieee80211_crypt_wep: could not allocate "
 		       "crypto API arc4\n");
 		goto fail;
 	}
+#else
+	priv->tx_tfm = crypto_alloc_blkcipher("ecb(arc4)", 0, CRYPTO_ALG_ASYNC);
+	if (IS_ERR(priv->tx_tfm)) {
+		printk(KERN_DEBUG "ieee80211_crypt_wep: could not allocate "
+		       "crypto API arc4\n");
+		priv->tx_tfm = NULL;
+		goto fail;
+	}
 
+	priv->rx_tfm = crypto_alloc_blkcipher("ecb(arc4)", 0, CRYPTO_ALG_ASYNC);
+	if (IS_ERR(priv->rx_tfm)) {
+		printk(KERN_DEBUG "ieee80211_crypt_wep: could not allocate "
+		       "crypto API arc4\n");
+		priv->rx_tfm = NULL;
+		goto fail;
+	}
+#endif
 	/* start WEP IV from a random value */
 	get_random_bytes(&priv->iv, 4);
 
@@ -64,19 +96,35 @@
 
 fail:
 	if (priv) {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19)
 		if (priv->tfm)
 			crypto_free_tfm(priv->tfm);
+#else
+		if (priv->tx_tfm)
+			crypto_free_blkcipher(priv->tx_tfm);
+		if (priv->rx_tfm)
+			crypto_free_blkcipher(priv->rx_tfm);
+#endif
 		kfree(priv);
 	}
 	return NULL;
 }
 
 
-static void prism2_wep_deinit(void *priv)
+static void prism2_wep_deinit_rtl7(void *priv)
 {
 	struct prism2_wep_data *_priv = priv;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19)
 	if (_priv && _priv->tfm)
 		crypto_free_tfm(_priv->tfm);
+#else
+	if (_priv) {
+		if (_priv->tx_tfm)
+			crypto_free_blkcipher(_priv->tx_tfm);
+		if (_priv->rx_tfm)
+			crypto_free_blkcipher(_priv->rx_tfm);
+	}
+#endif
 	kfree(priv);
 }
 
@@ -87,13 +135,16 @@
  *
  * WEP frame payload: IV + TX key idx, RC4(data), ICV = RC4(CRC32(data))
  */
-static int prism2_wep_encrypt(struct sk_buff *skb, int hdr_len, void *priv)
+static int prism2_wep_encrypt_rtl7(struct sk_buff *skb, int hdr_len, void *priv)
 {
 	struct prism2_wep_data *wep = priv;
 	u32 crc, klen, len;
 	u8 key[WEP_KEY_LEN + 3];
 	u8 *pos, *icv;
 	struct scatterlist sg;
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,19))
+	struct blkcipher_desc desc = { .tfm = wep->tx_tfm };
+#endif
 
 	if (skb_headroom(skb) < 4 || skb_tailroom(skb) < 4 ||
 	    skb->len < hdr_len)
@@ -134,13 +185,25 @@
 	icv[2] = crc >> 16;
 	icv[3] = crc >> 24;
 
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19))
 	crypto_cipher_setkey(wep->tfm, key, klen);
+#else
+	crypto_blkcipher_setkey(wep->tx_tfm, key, klen);
+#endif
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,24))
 	sg.page = virt_to_page(pos);
 	sg.offset = offset_in_page(pos);
 	sg.length = len + 4;
-	crypto_cipher_encrypt(wep->tfm, &sg, &sg, len + 4);
+#else
+	sg_set_page(&sg, virt_to_page(pos), len + 4, offset_in_page(pos));
+#endif
 
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19))
+	crypto_cipher_encrypt(wep->tfm, &sg, &sg, len + 4);
 	return 0;
+#else
+	return crypto_blkcipher_encrypt(&desc, &sg, &sg, len + 4);
+#endif
 }
 
 
@@ -151,13 +214,16 @@
  * Returns 0 if frame was decrypted successfully and ICV was correct and -1 on
  * failure. If frame is OK, IV and ICV will be removed.
  */
-static int prism2_wep_decrypt(struct sk_buff *skb, int hdr_len, void *priv)
+static int prism2_wep_decrypt_rtl7(struct sk_buff *skb, int hdr_len, void *priv)
 {
 	struct prism2_wep_data *wep = priv;
 	u32 crc, klen, plen;
 	u8 key[WEP_KEY_LEN + 3];
 	u8 keyidx, *pos, icv[4];
 	struct scatterlist sg;
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,19))
+	struct blkcipher_desc desc = { .tfm = wep->rx_tfm };
+#endif
 
 	if (skb->len < hdr_len + 8)
 		return -1;
@@ -178,11 +244,26 @@
 	/* Apply RC4 to data and compute CRC32 over decrypted data */
 	plen = skb->len - hdr_len - 8;
 
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19))
 	crypto_cipher_setkey(wep->tfm, key, klen);
+#else
+	crypto_blkcipher_setkey(wep->rx_tfm, key, klen);
+#endif
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,24))
 	sg.page = virt_to_page(pos);
 	sg.offset = offset_in_page(pos);
 	sg.length = plen + 4;
+#else
+	sg_set_page(&sg, virt_to_page(pos), plen + 4, offset_in_page(pos));
+#endif
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19))
 	crypto_cipher_decrypt(wep->tfm, &sg, &sg, plen + 4);
+#else
+	if(crypto_blkcipher_decrypt(&desc, &sg, &sg, plen + 4))
+		return -7;
+#endif
 
 	crc = ~crc32_le(~0, pos, plen);
 	icv[0] = crc;
@@ -203,7 +284,7 @@
 }
 
 
-static int prism2_wep_set_key(void *key, int len, u8 *seq, void *priv)
+static int prism2_wep_set_key_rtl7(void *key, int len, u8 *seq, void *priv)
 {
 	struct prism2_wep_data *wep = priv;
 
@@ -217,7 +298,7 @@
 }
 
 
-static int prism2_wep_get_key(void *key, int len, u8 *seq, void *priv)
+static int prism2_wep_get_key_rtl7(void *key, int len, u8 *seq, void *priv)
 {
 	struct prism2_wep_data *wep = priv;
 
@@ -230,7 +311,7 @@
 }
 
 
-static char * prism2_wep_print_stats(char *p, void *priv)
+static char * prism2_wep_print_stats_rtl7(char *p, void *priv)
 {
 	struct prism2_wep_data *wep = priv;
 	p += sprintf(p, "key[%d] alg=WEP len=%d\n",
@@ -239,34 +320,34 @@
 }
 
 
-static struct ieee80211_crypto_ops ieee80211_crypt_wep = {
+static struct ieee80211_crypto_ops ieee80211_crypt_wep_rtl7 = {
 	.name			= "WEP",
-	.init			= prism2_wep_init,
-	.deinit			= prism2_wep_deinit,
-	.encrypt_mpdu		= prism2_wep_encrypt,
-	.decrypt_mpdu		= prism2_wep_decrypt,
+	.init			= prism2_wep_init_rtl7,
+	.deinit			= prism2_wep_deinit_rtl7,
+	.encrypt_mpdu		= prism2_wep_encrypt_rtl7,
+	.decrypt_mpdu		= prism2_wep_decrypt_rtl7,
 	.encrypt_msdu		= NULL,
 	.decrypt_msdu		= NULL,
-	.set_key		= prism2_wep_set_key,
-	.get_key		= prism2_wep_get_key,
-	.print_stats		= prism2_wep_print_stats,
+	.set_key		= prism2_wep_set_key_rtl7,
+	.get_key		= prism2_wep_get_key_rtl7,
+	.print_stats		= prism2_wep_print_stats_rtl7,
 	.extra_prefix_len	= 4, /* IV */
 	.extra_postfix_len	= 4, /* ICV */
 	.owner			= THIS_MODULE,
 };
 
 
-static int __init ieee80211_crypto_wep_init(void)
+static int __init ieee80211_crypto_wep_init_rtl7(void)
 {
-	return ieee80211_register_crypto_ops(&ieee80211_crypt_wep);
+	return ieee80211_register_crypto_ops_rtl7(&ieee80211_crypt_wep_rtl7);
 }
 
 
-static void __exit ieee80211_crypto_wep_exit(void)
+static void __exit ieee80211_crypto_wep_exit_rtl7(void)
 {
-	ieee80211_unregister_crypto_ops(&ieee80211_crypt_wep);
+	ieee80211_unregister_crypto_ops_rtl7(&ieee80211_crypt_wep_rtl7);
 }
 
 
-module_init(ieee80211_crypto_wep_init);
-module_exit(ieee80211_crypto_wep_exit);
+module_init(ieee80211_crypto_wep_init_rtl7);
+module_exit(ieee80211_crypto_wep_exit_rtl7);
diff -Naur rtl8187_linux_26.1010.0622.2006/ieee80211/ieee80211.h rtl8187_linux_26.1010.0622.2006_rawtx/ieee80211/ieee80211.h
--- rtl8187_linux_26.1010.0622.2006/ieee80211/ieee80211.h	2006-06-06 04:57:56.000000000 +0200
+++ rtl8187_linux_26.1010.0622.2006_rawtx/ieee80211/ieee80211.h	2008-01-30 17:38:11.000000000 +0100
@@ -120,7 +120,7 @@
 static inline unsigned long msleep_interruptible_rtl(unsigned int msecs)
 {
          unsigned long timeout = MSECS(msecs) + 1;
- 
+
          while (timeout) {
                  set_current_state(TASK_UNINTERRUPTIBLE);
                  timeout = schedule_timeout(timeout);
@@ -156,6 +156,22 @@
 	struct list_head list;
 };
 
+#define LWNG_CAP_DID_BASE   (4 | (1 << 6)) /* section 4, group 1 */
+/* ARPHRD_IEEE80211_PRISM uses a bloated version of Prism2 RX frame header
+ * (from linux-wlan-ng) */
+struct linux_wlan_ng_val {
+	u32 did;
+	u16 status, len;
+	u32 data;
+} __attribute__ ((packed));
+
+struct linux_wlan_ng_prism_hdr {
+	u32 msgcode, msglen;
+	char devname[16];
+	struct linux_wlan_ng_val hosttime, mactime, channel, rssi, sq, signal,
+		noise, rate, istx, frmlen;
+} __attribute__ ((packed));
+
 struct ieee80211_hdr {
 	u16 frame_ctl;
 	u16 duration_id;
@@ -798,7 +814,7 @@
 
 	/* the card is not linked at all */
 	IEEE80211_NOLINK = 0,
-	
+
 	/* IEEE80211_ASSOCIATING* are for BSS client mode
 	 * the driver shall not perform RX filtering unless
 	 * the state is LINKED.
@@ -806,31 +822,31 @@
 	 * defaults to NOLINK for ALL the other states (including
 	 * LINKED_SCANNING)
 	 */
-	
+
 	/* the association procedure will start (wq scheduling)*/
 	IEEE80211_ASSOCIATING,
 	IEEE80211_ASSOCIATING_RETRY,
-	
+
 	/* the association procedure is sending AUTH request*/
 	IEEE80211_ASSOCIATING_AUTHENTICATING,
-	
+
 	/* the association procedure has successfully authentcated
 	 * and is sending association request
 	 */
 	IEEE80211_ASSOCIATING_AUTHENTICATED,
-	
+
 	/* the link is ok. the card associated to a BSS or linked
 	 * to a ibss cell or acting as an AP and creating the bss
 	 */
 	IEEE80211_LINKED,
-	
+
 	/* same as LINKED, but the driver shall apply RX filter
 	 * rules as we are in NO_LINK mode. As the card is still
 	 * logically linked, but it is doing a syncro site survey
 	 * then it will be back to LINKED state.
 	 */
 	IEEE80211_LINKED_SCANNING,
-	
+
 };
 
 #define DEFAULT_MAX_SCAN_AGE (15 * HZ)
@@ -840,14 +856,14 @@
 
 
 #if (LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,11))
-extern inline int is_multicast_ether_addr(const u8 *addr)
+extern inline int is_multicast_ether_addr_rtl7(const u8 *addr)
 {
         return ((addr[0] != 0xff) && (0x01 & addr[0]));
 }
 #endif
 
 #if (LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,13))
-extern inline int is_broadcast_ether_addr(const u8 *addr)
+extern inline int is_broadcast_ether_addr_rtl7(const u8 *addr)
 {
 	return ((addr[0] == 0xff) && (addr[1] == 0xff) && (addr[2] == 0xff) &&   \
 		(addr[3] == 0xff) && (addr[4] == 0xff) && (addr[5] == 0xff));
@@ -870,7 +886,7 @@
 	struct net_device_stats stats;
 	struct ieee80211_stats ieee_stats;
 	struct ieee80211_softmac_stats softmac_stats;
-	
+
 	/* Probe / Beacon management */
 	struct list_head network_free_list;
 	struct list_head network_list;
@@ -881,7 +897,7 @@
 	int iw_mode; /* operating mode (IW_MODE_*) */
 
 	spinlock_t lock;
-	
+
 	int tx_headroom; /* Set to size of any additional room needed at front
 			  * of allocated Tx SKBs */
 	u32 config;
@@ -924,11 +940,11 @@
 	 * ad-hoc is a mixture ;-).
 	 * Note that in infrastructure mode, even when not associated,
 	 * fields bssid and essid may be valid (if wpa_set and essid_set
-	 * are true) as thy carry the value set by the user via iwconfig  
+	 * are true) as thy carry the value set by the user via iwconfig
 	 */
 	struct ieee80211_network current_network;
 
-	
+
 	enum ieee80211_state state;
 
 	int short_slot;
@@ -936,33 +952,33 @@
 	int modulation; /* CCK, OFDM */
 	int freq_band;  /* 2.4Ghz, 5.2Ghz, Mixed */
 	int abg_true;   /* ABG flag              */
-	
-	/* used for forcing the ibss workqueue to terminate 
+
+	/* used for forcing the ibss workqueue to terminate
 	 * without wait for the syncro scan to terminate
 	 */
-	short sync_scan_hurryup; 
-	
+	short sync_scan_hurryup;
+
 	/* map of allowed channels. 0 is dummy */
 	// FIXME: remeber to default to a basic channel plan depending of the PHY type
 	int channel_map[MAX_CHANNEL_NUMBER+1];
-	
+
 	int rate;       /* current rate */
 	int basic_rate;
 	//FIXME: pleace callback, see if redundant with softmac_features
 	short active_scan;
-	
+
 	/* this contains flags for selectively enable softmac support */
 	u16 softmac_features;
-	
+
 	/* if the sequence control field is not filled by HW */
 	u16 seq_ctrl;
-	
+
 	/* association procedure transaction sequence number */
 	u16 associate_seq;
-	
+
 	/* AID for RTXed association responses */
 	u16 assoc_id;
-	
+
 	/* power save mode related*/
 	short ps;
 	short sta_sleep;
@@ -970,147 +986,153 @@
 	struct tasklet_struct ps_task;
 	u32 ps_th;
 	u32 ps_tl;
-	
+
 	short raw_tx;
 	/* used if IEEE_SOFTMAC_TX_QUEUE is set */
 	short queue_stop;
 	short scanning;
 	short proto_started;
-	
+
 	struct semaphore wx_sem;
 	struct semaphore scan_sem;
-	
-	spinlock_t mgmt_tx_lock;	
+
+	spinlock_t mgmt_tx_lock;
 	spinlock_t beacon_lock;
 
 	short beacon_txing;
 
 	short wap_set;
 	short ssid_set;
-	
+
 	/* for discarding duplicated packets in IBSS */
 	struct list_head ibss_mac_hash[IEEE_IBSS_MAC_HASH_SIZE];
-	
+
 	/* for discarding duplicated packets in BSS */
 	u16 last_seq_num;
 	u16 last_frag_num;
 	unsigned long last_packet_time;
-	
+
 	/* for PS mode */
 	unsigned long last_rx_ps_time;
-	
+
 	/* used if IEEE_SOFTMAC_SINGLE_QUEUE is set */
 	struct sk_buff *mgmt_queue_ring[MGMT_QUEUE_NUM];
 	int mgmt_queue_head;
 	int mgmt_queue_tail;
-	
-	
+
+
 	/* used if IEEE_SOFTMAC_TX_QUEUE is set */
 	struct  tx_pending_t tx_pending;
-	
+
 	/* used if IEEE_SOFTMAC_ASSOCIATE is set */
 	struct timer_list associate_timer;
 
 	/* used if IEEE_SOFTMAC_BEACONS is set */
 	struct timer_list beacon_timer;
-	
+
 	struct work_struct associate_complete_wq;
+
+# if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20))
+	struct delayed_work associate_retry_wq;
+	struct delayed_work softmac_scan_wq;
+#else
 	struct work_struct associate_retry_wq;
+	struct work_struct softmac_scan_wq;
+#endif
 	struct work_struct start_ibss_wq;
 	struct work_struct associate_procedure_wq;
-	struct work_struct softmac_scan_wq;
 	struct work_struct wx_sync_scan_wq;
-	
+
 	struct workqueue_struct *wq;
 	/* Callback functions */
 	void (*set_security)(struct net_device *dev,
 			     struct ieee80211_security *sec);
-	
+
 	/* Used to TX data frame by using txb structs.
 	 * this is not used if in the softmac_features
 	 * is set the flag IEEE_SOFTMAC_TX_QUEUE
 	 */
 	int (*hard_start_xmit)(struct ieee80211_txb *txb,
 			       struct net_device *dev);
-	
+
 	int (*reset_port)(struct net_device *dev);
 
-	/* Softmac-generated frames (mamagement) are TXed via this 
-	 * callback if the flag IEEE_SOFTMAC_SINGLE_QUEUE is 
-	 * not set. As some cards may have different HW queues that 
+	/* Softmac-generated frames (mamagement) are TXed via this
+	 * callback if the flag IEEE_SOFTMAC_SINGLE_QUEUE is
+	 * not set. As some cards may have different HW queues that
 	 * one might want to use for data and management frames
 	 * the option to have two callbacks might be useful.
 	 * This fucntion can't sleep.
 	 */
 	int (*softmac_hard_start_xmit)(struct sk_buff *skb,
 			       struct net_device *dev);
-	
+
 	/* used instead of hard_start_xmit (not softmac_hard_start_xmit)
 	 * if the IEEE_SOFTMAC_TX_QUEUE feature is used to TX data
 	 * frames. I the option IEEE_SOFTMAC_SINGLE_QUEUE is also set
 	 * then also management frames are sent via this callback.
 	 * This function can't sleep.
-	 */    
+	 */
 	void (*softmac_data_hard_start_xmit)(struct sk_buff *skb,
 			       struct net_device *dev,int rate);
 
 	/* stops the HW queue for DATA frames. Useful to avoid
 	 * waste time to TX data frame when we are reassociating
 	 * This function can sleep.
-	 */	 
+	 */
 	void (*data_hard_stop)(struct net_device *dev);
-	
+
 	/* OK this is complementar to data_poll_hard_stop */
 	void (*data_hard_resume)(struct net_device *dev);
-	
+
 	/* ask to the driver to retune the radio .
 	 * This function can sleep. the driver should ensure
 	 * the radio has been swithced before return.
 	 */
 	void (*set_chan)(struct net_device *dev,short ch);
-	
+
 	/* These are not used if the ieee stack takes care of
-	 * scanning (IEEE_SOFTMAC_SCAN feature set). 
+	 * scanning (IEEE_SOFTMAC_SCAN feature set).
 	 * In this case only the set_chan is used.
 	 *
 	 * The syncro version is similar to the start_scan but
 	 * does not return until all channels has been scanned.
-	 * this is called in user context and should sleep, 
+	 * this is called in user context and should sleep,
 	 * it is called in a work_queue when swithcing to ad-hoc mode
-	 * or in behalf of iwlist scan when the card is associated 
-	 * and root user ask for a scan. 
+	 * or in behalf of iwlist scan when the card is associated
+	 * and root user ask for a scan.
 	 * the fucntion stop_scan should stop both the syncro and
 	 * background scanning and can sleep.
-	 * The fucntion start_scan should initiate the background 
+	 * The fucntion start_scan should initiate the background
 	 * scanning and can't sleep.
-	 */ 
+	 */
 	void (*scan_syncro)(struct net_device *dev);
 	void (*start_scan)(struct net_device *dev);
 	void (*stop_scan)(struct net_device *dev);
-	
+
 	/* indicate the driver that the link state is changed
 	 * for example it may indicate the card is associated now.
-	 * Driver might be interested in this to apply RX filter 
-	 * rules or simply light the LINK led 
+	 * Driver might be interested in this to apply RX filter
+	 * rules or simply light the LINK led
 	 */
 	void (*link_change)(struct net_device *dev);
-	
+
 	/* these two function indicates to the HW when to start
-	 * and stop to send beacons. This is used when the 
+	 * and stop to send beacons. This is used when the
 	 * IEEE_SOFTMAC_BEACONS is not set. For now the
 	 * stop_send_bacons is NOT guaranteed to be called only
 	 * after start_send_beacons.
 	 */
 	void (*start_send_beacons) (struct net_device *dev);
 	void (*stop_send_beacons) (struct net_device *dev);
-	
+
 	/* power save mode related */
 	void (*sta_wake_up) (struct net_device *dev);
 	void (*ps_request_tx_ack) (struct net_device *dev);
 	void (*enter_sleep_state) (struct net_device *dev, u32 th, u32 tl);
 	short (*ps_is_queue_empty) (struct net_device *dev);
-	
-	
+
+
 	/* This must be the last item so that it points to the data
 	 * allocated beyond this structure by alloc_ieee80211 */
 	u8 priv[0];
@@ -1148,18 +1170,18 @@
 #define IEEE_SOFTMAC_SINGLE_QUEUE (1<<8)
 
 /* Generate beacons.  The stack will enqueue beacons
- * to the card 
- */ 
+ * to the card
+ */
 #define IEEE_SOFTMAC_BEACONS (1<<6)
 
 
 
-extern inline void *ieee80211_priv(struct net_device *dev)
+extern inline void *ieee80211_priv_rtl7(struct net_device *dev)
 {
 	return ((struct ieee80211_device *)netdev_priv(dev))->priv;
 }
 
-extern inline int ieee80211_is_empty_essid(const char *essid, int essid_len)
+extern inline int ieee80211_is_empty_essid_rtl7(const char *essid, int essid_len)
 {
 	/* Single white space is for Linksys APs */
 	if (essid_len == 1 && essid[0] == ' ')
@@ -1175,7 +1197,7 @@
 	return 1;
 }
 
-extern inline int ieee80211_is_valid_mode(struct ieee80211_device *ieee, int mode)
+extern inline int ieee80211_is_valid_mode_rtl7(struct ieee80211_device *ieee, int mode)
 {
 	/*
 	 * It is possible for both access points and our device to support
@@ -1201,7 +1223,7 @@
 	return 0;
 }
 
-extern inline int ieee80211_get_hdrlen(u16 fc)
+extern inline int ieee80211_get_hdrlen_rtl7(u16 fc)
 {
 	int hdrlen = 24;
 
@@ -1229,140 +1251,144 @@
 
 
 /* ieee80211.c */
-extern void free_ieee80211(struct net_device *dev);
-extern struct net_device *alloc_ieee80211(int sizeof_priv);
+extern void free_ieee80211_rtl7(struct net_device *dev);
+extern struct net_device *alloc_ieee80211_rtl7(int sizeof_priv);
 
-extern int ieee80211_set_encryption(struct ieee80211_device *ieee);
+extern int ieee80211_set_encryption_rtl7(struct ieee80211_device *ieee);
 
 /* ieee80211_tx.c */
 
-extern int ieee80211_encrypt_fragment(
+extern int ieee80211_encrypt_fragment_rtl7(
 	struct ieee80211_device *ieee,
 	struct sk_buff *frag,
 	int hdr_len);
-	
-extern int ieee80211_xmit(struct sk_buff *skb,
+
+extern int ieee80211_xmit_rtl7(struct sk_buff *skb,
 			  struct net_device *dev);
-extern void ieee80211_txb_free(struct ieee80211_txb *);
+extern void ieee80211_txb_free_rtl7(struct ieee80211_txb *);
 
 
 /* ieee80211_rx.c */
-extern int ieee80211_rx(struct ieee80211_device *ieee, struct sk_buff *skb,
+extern int ieee80211_rx_rtl7(struct ieee80211_device *ieee, struct sk_buff *skb,
 			struct ieee80211_rx_stats *rx_stats);
-extern void ieee80211_rx_mgt(struct ieee80211_device *ieee,
+extern void ieee80211_rx_mgt_rtl7(struct ieee80211_device *ieee,
 			     struct ieee80211_hdr *header,
 			     struct ieee80211_rx_stats *stats);
 
 /* ieee80211_wx.c */
-extern int ieee80211_wx_get_scan(struct ieee80211_device *ieee,
+extern int ieee80211_wx_get_scan_rtl7(struct ieee80211_device *ieee,
 				 struct iw_request_info *info,
 				 union iwreq_data *wrqu, char *key);
-extern int ieee80211_wx_set_encode(struct ieee80211_device *ieee,
+extern int ieee80211_wx_set_encode_rtl7(struct ieee80211_device *ieee,
 				   struct iw_request_info *info,
 				   union iwreq_data *wrqu, char *key);
-extern int ieee80211_wx_get_encode(struct ieee80211_device *ieee,
+extern int ieee80211_wx_get_encode_rtl7(struct ieee80211_device *ieee,
 				   struct iw_request_info *info,
 				   union iwreq_data *wrqu, char *key);
 /* ieee80211_softmac.c */
-extern short ieee80211_is_54g(struct ieee80211_network net);
-extern short ieee80211_is_shortslot(struct ieee80211_network net);
-extern int ieee80211_rx_frame_softmac(struct ieee80211_device *ieee, struct sk_buff *skb,
+extern short ieee80211_is_54g_rtl7(struct ieee80211_network net);
+extern short ieee80211_is_shortslot_rtl7(struct ieee80211_network net);
+extern int ieee80211_rx_frame_softmac_rtl7(struct ieee80211_device *ieee, struct sk_buff *skb,
 			struct ieee80211_rx_stats *rx_stats, u16 type,
 			u16 stype);
-extern void ieee80211_softmac_new_net(struct ieee80211_device *ieee, struct ieee80211_network *net);
+extern void ieee80211_softmac_new_net_rtl7(struct ieee80211_device *ieee, struct ieee80211_network *net);
 
-extern void ieee80211_softmac_xmit(struct ieee80211_txb *txb, struct ieee80211_device *ieee);
-extern void ieee80211_softmac_check_all_nets(struct ieee80211_device *ieee);
-extern void ieee80211_start_bss(struct ieee80211_device *ieee);
-extern void ieee80211_start_master_bss(struct ieee80211_device *ieee);
-extern void ieee80211_start_ibss(struct ieee80211_device *ieee);
-extern void ieee80211_softmac_init(struct ieee80211_device *ieee);
-extern void ieee80211_softmac_free(struct ieee80211_device *ieee);
-extern void ieee80211_associate_abort(struct ieee80211_device *ieee);
-extern void ieee80211_disassociate(struct ieee80211_device *ieee);
-extern void ieee80211_stop_scan(struct ieee80211_device *ieee);
-extern void ieee80211_start_scan_syncro(struct ieee80211_device *ieee);
-extern void ieee80211_check_all_nets(struct ieee80211_device *ieee);
-extern void ieee80211_start_protocol(struct ieee80211_device *ieee);
-extern void ieee80211_stop_protocol(struct ieee80211_device *ieee);
-extern void ieee80211_softmac_start_protocol(struct ieee80211_device *ieee);
-extern void ieee80211_softmac_stop_protocol(struct ieee80211_device *ieee);
-extern void ieee80211_reset_queue(struct ieee80211_device *ieee);
-extern void ieee80211_wake_queue(struct ieee80211_device *ieee);
-extern void ieee80211_stop_queue(struct ieee80211_device *ieee);
-extern struct sk_buff *ieee80211_get_beacon(struct ieee80211_device *ieee);
-extern void ieee80211_start_send_beacons(struct ieee80211_device *ieee);
-extern void ieee80211_stop_send_beacons(struct ieee80211_device *ieee);
-extern int ieee80211_wpa_supplicant_ioctl(struct ieee80211_device *ieee, struct iw_point *p);
-extern void notify_wx_assoc_event(struct ieee80211_device *ieee);
-extern void ieee80211_ps_tx_ack(struct ieee80211_device *ieee, short success);
+extern void ieee80211_softmac_xmit_rtl7(struct ieee80211_txb *txb, struct ieee80211_device *ieee);
+extern void ieee80211_softmac_check_all_nets_rtl7(struct ieee80211_device *ieee);
+extern void ieee80211_start_bss_rtl7(struct ieee80211_device *ieee);
+extern void ieee80211_start_master_bss_rtl7(struct ieee80211_device *ieee);
+extern void ieee80211_start_ibss_rtl7(struct ieee80211_device *ieee);
+extern void ieee80211_softmac_init_rtl7(struct ieee80211_device *ieee);
+extern void ieee80211_softmac_free_rtl7(struct ieee80211_device *ieee);
+extern void ieee80211_associate_abort_rtl7(struct ieee80211_device *ieee);
+extern void ieee80211_disassociate_rtl7(struct ieee80211_device *ieee);
+extern void ieee80211_stop_scan_rtl7(struct ieee80211_device *ieee);
+extern void ieee80211_start_scan_syncro_rtl7(struct ieee80211_device *ieee);
+extern void ieee80211_check_all_nets_rtl7(struct ieee80211_device *ieee);
+extern void ieee80211_start_protocol_rtl7(struct ieee80211_device *ieee);
+extern void ieee80211_stop_protocol_rtl7(struct ieee80211_device *ieee);
+extern void ieee80211_softmac_start_protocol_rtl7(struct ieee80211_device *ieee);
+extern void ieee80211_softmac_stop_protocol_rtl7(struct ieee80211_device *ieee);
+extern void ieee80211_reset_queue_rtl7(struct ieee80211_device *ieee);
+extern void ieee80211_wake_queue_rtl7(struct ieee80211_device *ieee);
+extern void ieee80211_stop_queue_rtl7(struct ieee80211_device *ieee);
+extern struct sk_buff *ieee80211_get_beacon_rtl7(struct ieee80211_device *ieee);
+extern void ieee80211_start_send_beacons_rtl7(struct ieee80211_device *ieee);
+extern void ieee80211_stop_send_beacons_rtl7(struct ieee80211_device *ieee);
+extern int ieee80211_wpa_supplicant_ioctl_rtl7(struct ieee80211_device *ieee, struct iw_point *p);
+extern void notify_wx_assoc_event_rtl7(struct ieee80211_device *ieee);
+extern void ieee80211_ps_tx_ack_rtl7(struct ieee80211_device *ieee, short success);
 
 /* ieee80211_softmac_wx.c */
 
-extern int ieee80211_wx_get_wap(struct ieee80211_device *ieee, 
-			    struct iw_request_info *info, 
+extern int ieee80211_wx_get_wap_rtl7(struct ieee80211_device *ieee,
+			    struct iw_request_info *info,
 			    union iwreq_data *wrqu, char *ext);
-			    
-extern int ieee80211_wx_set_wap(struct ieee80211_device *ieee,
+
+extern int ieee80211_wx_set_wap_rtl7(struct ieee80211_device *ieee,
 			 struct iw_request_info *info,
 			 union iwreq_data *awrq,
 			 char *extra);
-			 
-extern int ieee80211_wx_get_essid(struct ieee80211_device *ieee, struct iw_request_info *a,union iwreq_data *wrqu,char *b);
 
-extern int ieee80211_wx_set_rate(struct ieee80211_device *ieee, 
+extern int ieee80211_wx_get_essid_rtl7(struct ieee80211_device *ieee, struct iw_request_info *a,union iwreq_data *wrqu,char *b);
+
+extern int ieee80211_wx_set_rate_rtl7(struct ieee80211_device *ieee,
 			     struct iw_request_info *info,
 			     union iwreq_data *wrqu, char *extra);
-			     
-extern int ieee80211_wx_get_rate(struct ieee80211_device *ieee, 
-			     struct iw_request_info *info, 
+
+extern int ieee80211_wx_get_rate_rtl7(struct ieee80211_device *ieee,
+			     struct iw_request_info *info,
 			     union iwreq_data *wrqu, char *extra);
-			     
-extern int ieee80211_wx_set_mode(struct ieee80211_device *ieee, struct iw_request_info *a,
+
+extern int ieee80211_wx_set_mode_rtl7(struct ieee80211_device *ieee, struct iw_request_info *a,
 			     union iwreq_data *wrqu, char *b);
-			     
-extern int ieee80211_wx_set_scan(struct ieee80211_device *ieee, struct iw_request_info *a,
+
+extern int ieee80211_wx_set_scan_rtl7(struct ieee80211_device *ieee, struct iw_request_info *a,
 			     union iwreq_data *wrqu, char *b);
-			     
-extern int ieee80211_wx_set_essid(struct ieee80211_device *ieee, 
+
+extern int ieee80211_wx_set_essid_rtl7(struct ieee80211_device *ieee,
 			      struct iw_request_info *a,
 			      union iwreq_data *wrqu, char *extra);
-			      
-extern int ieee80211_wx_get_mode(struct ieee80211_device *ieee, struct iw_request_info *a,
+
+extern int ieee80211_wx_get_mode_rtl7(struct ieee80211_device *ieee, struct iw_request_info *a,
 			     union iwreq_data *wrqu, char *b);
 
-extern int ieee80211_wx_set_freq(struct ieee80211_device *ieee, struct iw_request_info *a,
+extern int ieee80211_wx_set_freq_rtl7(struct ieee80211_device *ieee, struct iw_request_info *a,
 			     union iwreq_data *wrqu, char *b);
 
-extern int ieee80211_wx_get_freq(struct ieee80211_device *ieee, struct iw_request_info *a,
+extern int ieee80211_wx_get_freq_rtl7(struct ieee80211_device *ieee, struct iw_request_info *a,
 			     union iwreq_data *wrqu, char *b);
 
-extern void ieee80211_wx_sync_scan_wq(struct ieee80211_device *ieee);
+# if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20))
+extern void ieee80211_wx_sync_scan_wq_rtl7(struct work_struct *work);
+#else
+extern void ieee80211_wx_sync_scan_wq_rtl7(struct ieee80211_device *ieee);
+#endif
 
-extern int ieee80211_wx_set_rawtx(struct ieee80211_device *ieee, 
-			       struct iw_request_info *info, 
+extern int ieee80211_wx_set_rawtx_rtl7(struct ieee80211_device *ieee,
+			       struct iw_request_info *info,
 			       union iwreq_data *wrqu, char *extra);
-			       
-extern int ieee80211_wx_get_name(struct ieee80211_device *ieee, 
-			     struct iw_request_info *info, 
+
+extern int ieee80211_wx_get_name_rtl7(struct ieee80211_device *ieee,
+			     struct iw_request_info *info,
 			     union iwreq_data *wrqu, char *extra);
 
-extern int ieee80211_wx_set_power(struct ieee80211_device *ieee,
+extern int ieee80211_wx_set_power_rtl7(struct ieee80211_device *ieee,
 				 struct iw_request_info *info,
 				 union iwreq_data *wrqu, char *extra);
 
-extern int ieee80211_wx_get_power(struct ieee80211_device *ieee,
+extern int ieee80211_wx_get_power_rtl7(struct ieee80211_device *ieee,
 				 struct iw_request_info *info,
 				 union iwreq_data *wrqu, char *extra);
-				 			     
-extern const long ieee80211_wlan_frequencies[];
 
-extern inline void ieee80211_increment_scans(struct ieee80211_device *ieee)
+extern const long ieee80211_wlan_frequencies_rtl7[];
+
+extern inline void ieee80211_increment_scans_rtl7(struct ieee80211_device *ieee)
 {
 	ieee->scans++;
 }
 
-extern inline int ieee80211_get_scans(struct ieee80211_device *ieee)
+extern inline int ieee80211_get_scans_rtl7(struct ieee80211_device *ieee)
 {
 	return ieee->scans;
 }
@@ -1372,7 +1398,7 @@
 	const char *s = essid;
 	char *d = escaped;
 
-	if (ieee80211_is_empty_essid(essid, essid_len)) {
+	if (ieee80211_is_empty_essid_rtl7(essid, essid_len)) {
 		memcpy(escaped, "<hidden>", sizeof("<hidden>"));
 		return escaped;
 	}
@@ -1390,4 +1416,5 @@
 	*d = '\0';
 	return escaped;
 }
+
 #endif /* IEEE80211_H */
diff -Naur rtl8187_linux_26.1010.0622.2006/ieee80211/ieee80211_module.c rtl8187_linux_26.1010.0622.2006_rawtx/ieee80211/ieee80211_module.c
--- rtl8187_linux_26.1010.0622.2006/ieee80211/ieee80211_module.c	2006-06-06 04:58:00.000000000 +0200
+++ rtl8187_linux_26.1010.0622.2006_rawtx/ieee80211/ieee80211_module.c	2008-01-30 17:38:11.000000000 +0100
@@ -31,7 +31,6 @@
 *******************************************************************************/
 
 #include <linux/compiler.h>
-#include <linux/config.h>
 #include <linux/errno.h>
 #include <linux/if_arp.h>
 #include <linux/in6.h>
@@ -52,6 +51,12 @@
 #include <asm/uaccess.h>
 #include <net/arp.h>
 
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19))
+#include <linux/config.h>
+#else
+#include <linux/autoconf.h>
+#endif
+
 #include "ieee80211.h"
 
 MODULE_DESCRIPTION("802.11 data/management/control stack");
@@ -60,7 +65,7 @@
 
 #define DRV_NAME "ieee80211"
 
-static inline int ieee80211_networks_allocate(struct ieee80211_device *ieee)
+static inline int ieee80211_networks_allocate_rtl7(struct ieee80211_device *ieee)
 {
 	if (ieee->networks)
 		return 0;
@@ -80,7 +85,7 @@
 	return 0;
 }
 
-static inline void ieee80211_networks_free(struct ieee80211_device *ieee)
+static inline void ieee80211_networks_free_rtl7(struct ieee80211_device *ieee)
 {
 	if (!ieee->networks)
 		return;
@@ -88,7 +93,7 @@
 	ieee->networks = NULL;
 }
 
-static inline void ieee80211_networks_initialize(struct ieee80211_device *ieee)
+static inline void ieee80211_networks_initialize_rtl7(struct ieee80211_device *ieee)
 {
 	int i;
 
@@ -99,7 +104,7 @@
 }
 
 
-struct net_device *alloc_ieee80211(int sizeof_priv)
+struct net_device *alloc_ieee80211_rtl7(int sizeof_priv)
 {
 	struct ieee80211_device *ieee;
 	struct net_device *dev;
@@ -113,17 +118,17 @@
 		goto failed;
 	}
 	ieee = netdev_priv(dev);
-	dev->hard_start_xmit = ieee80211_xmit;
+	dev->hard_start_xmit = ieee80211_xmit_rtl7;
 
 	ieee->dev = dev;
 
-	err = ieee80211_networks_allocate(ieee);
+	err = ieee80211_networks_allocate_rtl7(ieee);
 	if (err) {
 		IEEE80211_ERROR("Unable to allocate beacon storage: %d\n",
 				err);
 		goto failed;
 	}
-	ieee80211_networks_initialize(ieee);
+	ieee80211_networks_initialize_rtl7(ieee);
 
 	/* Default fragmentation threshold is maximum payload size */
 	ieee->fts = DEFAULT_FTS;
@@ -138,7 +143,7 @@
 	INIT_LIST_HEAD(&ieee->crypt_deinit_list);
 	init_timer(&ieee->crypt_deinit_timer);
 	ieee->crypt_deinit_timer.data = (unsigned long)ieee;
-	ieee->crypt_deinit_timer.function = ieee80211_crypt_deinit_handler;
+	ieee->crypt_deinit_timer.function = ieee80211_crypt_deinit_handler_rtl7;
 
 	spin_lock_init(&ieee->lock);
 
@@ -149,7 +154,7 @@
  	ieee->ieee802_1x = 1;
 	ieee->raw_tx = 0;
 	
-	ieee80211_softmac_init(ieee);
+	ieee80211_softmac_init_rtl7(ieee);
 	
 	for (i = 0; i < IEEE_IBSS_MAC_HASH_SIZE; i++)
 		INIT_LIST_HEAD(&ieee->ibss_mac_hash[i]);
@@ -167,7 +172,7 @@
 }
 
 
-void free_ieee80211(struct net_device *dev)
+void free_ieee80211_rtl7(struct net_device *dev)
 {
 	struct ieee80211_device *ieee = netdev_priv(dev);
 
@@ -175,9 +180,9 @@
 	struct list_head *p, *q;
 	
 	
-	ieee80211_softmac_free(ieee);
+	ieee80211_softmac_free_rtl7(ieee);
 	del_timer_sync(&ieee->crypt_deinit_timer);
-	ieee80211_crypt_deinit_entries(ieee, 1);
+	ieee80211_crypt_deinit_entries_rtl7(ieee, 1);
 
 	for (i = 0; i < WEP_KEYS; i++) {
 		struct ieee80211_crypt_data *crypt = ieee->crypt[i];
@@ -191,7 +196,7 @@
 		}
 	}
 
-	ieee80211_networks_free(ieee);
+	ieee80211_networks_free_rtl7(ieee);
 	
 	for (i = 0; i < IEEE_IBSS_MAC_HASH_SIZE; i++) {
 		list_for_each_safe(p, q, &ieee->ibss_mac_hash[i]) {
@@ -210,13 +215,13 @@
 u32 ieee80211_debug_level = 0;
 struct proc_dir_entry *ieee80211_proc = NULL;
 
-static int show_debug_level(char *page, char **start, off_t offset,
+static int show_debug_level_rtl7(char *page, char **start, off_t offset,
 			    int count, int *eof, void *data)
 {
 	return snprintf(page, count, "0x%08X\n", ieee80211_debug_level);
 }
 
-static int store_debug_level(struct file *file, const char *buffer,
+static int store_debug_level_rtl7(struct file *file, const char *buffer,
 			     unsigned long count, void *data)
 {
 	char buf[] = "0x00000000";
@@ -243,7 +248,7 @@
 	return strnlen(buf, count);
 }
 
-static int __init ieee80211_init(void)
+static int __init ieee80211_init_rtl7(void)
 {
 	struct proc_dir_entry *e;
 
@@ -268,7 +273,7 @@
 	return 0;
 }
 
-static void __exit ieee80211_exit(void)
+static void __exit ieee80211_exit_rtl7(void)
 {
 	if (ieee80211_proc) {
 		remove_proc_entry("debug_level", ieee80211_proc);
@@ -282,9 +287,9 @@
 MODULE_PARM_DESC(debug, "debug output mask");
 
 
-module_exit(ieee80211_exit);
-module_init(ieee80211_init);
+module_exit(ieee80211_exit_rtl7);
+module_init(ieee80211_init_rtl7);
 #endif
 
-EXPORT_SYMBOL(alloc_ieee80211);
-EXPORT_SYMBOL(free_ieee80211);
+EXPORT_SYMBOL(alloc_ieee80211_rtl7);
+EXPORT_SYMBOL(free_ieee80211_rtl7);
diff -Naur rtl8187_linux_26.1010.0622.2006/ieee80211/ieee80211_rx.c rtl8187_linux_26.1010.0622.2006_rawtx/ieee80211/ieee80211_rx.c
--- rtl8187_linux_26.1010.0622.2006/ieee80211/ieee80211_rx.c	2006-06-06 04:58:00.000000000 +0200
+++ rtl8187_linux_26.1010.0622.2006_rawtx/ieee80211/ieee80211_rx.c	2008-01-30 17:38:11.000000000 +0100
@@ -13,16 +13,15 @@
  * more details.
  ******************************************************************************
 
-  Few modifications for Realtek's Wi-Fi drivers by 
+  Few modifications for Realtek's Wi-Fi drivers by
   Andrea Merello <andreamrl@tiscali.it>
-  
-  A special thanks goes to Realtek for their support ! 
+
+  A special thanks goes to Realtek for their support !
 
 ******************************************************************************/
- 
+
 
 #include <linux/compiler.h>
-#include <linux/config.h>
 #include <linux/errno.h>
 #include <linux/if_arp.h>
 #include <linux/in6.h>
@@ -43,18 +42,89 @@
 #include <asm/uaccess.h>
 #include <linux/ctype.h>
 
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19))
+#include <linux/config.h>
+#else
+#include <linux/autoconf.h>
+#endif
+
+
 #include "ieee80211.h"
 
-static inline void ieee80211_monitor_rx(struct ieee80211_device *ieee,
+static inline void ieee80211_monitor_rx_rtl7(struct ieee80211_device *ieee,
 					struct sk_buff *skb,
 					struct ieee80211_rx_stats *rx_stats)
 {
-	struct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;
-	u16 fc = le16_to_cpu(hdr->frame_ctl);
+	struct ieee80211_hdr *hdr1 = (struct ieee80211_hdr *)skb->data;
+	u16 fc = le16_to_cpu(hdr1->frame_ctl);
+	int prism_header;
+	int hdrlen, phdrlen, head_need, tail_need;
+
+	if (ieee->dev->type == ARPHRD_IEEE80211_PRISM) {
+		prism_header = 1;
+		phdrlen = sizeof(struct linux_wlan_ng_prism_hdr);
+	} else {
+		prism_header = 0;
+		phdrlen = 0;
+	}
+
+	hdrlen = ieee80211_get_hdrlen_rtl7(fc);
+
+	/* check if there is enough room for extra data; if not, expand skb
+	 * buffer to be large enough for the changes */
+	head_need = phdrlen;
+	tail_need = 0;
+#ifdef PRISM2_ADD_BOGUS_CRC
+	tail_need += 4;
+#endif /* PRISM2_ADD_BOGUS_CRC */
+
+	head_need -= skb_headroom(skb);
+	tail_need -= skb_tailroom(skb);
+
+	if (head_need > 0 || tail_need > 0) {
+		if (pskb_expand_head(skb, head_need > 0 ? head_need : 0,
+				     tail_need > 0 ? tail_need : 0,
+				     GFP_ATOMIC)) {
+			printk(KERN_DEBUG "%s: ieee80211_rx failed to "
+			       "reallocate skb buffer\n", ieee->dev->name);
+			dev_kfree_skb_any(skb);
+			return;
+		}
+	}
+
+	if (prism_header == 1) {
+		struct linux_wlan_ng_prism_hdr *hdr;
+		hdr = (struct linux_wlan_ng_prism_hdr *)
+			skb_push(skb, phdrlen);
+		memset(hdr, 0, phdrlen);
+		hdr->msgcode = LWNG_CAP_DID_BASE;
+		hdr->msglen = sizeof(*hdr);
+		memcpy(hdr->devname, ieee->dev->name, sizeof(hdr->devname));
+#define LWNG_SETVAL(f,i,s,l,d) \
+hdr->f.did = LWNG_CAP_DID_BASE | (i << 12); \
+hdr->f.status = s; hdr->f.len = l; hdr->f.data = d
+		LWNG_SETVAL(hosttime, 1, 0, 4, jiffies);
+		LWNG_SETVAL(mactime, 2, 0, 4, ((u32)rx_stats->mac_time));
+		LWNG_SETVAL(channel, 3, 1 /* no value */, 4, 0);
+		LWNG_SETVAL(rssi, 4, 1 /* no value */, 4, 0);
+		LWNG_SETVAL(sq, 5, 1 /* no value */, 4, 0);
+		LWNG_SETVAL(signal, 6, 0, 4, rx_stats->signal);
+		LWNG_SETVAL(noise, 7, 0, 4, rx_stats->noise);
+		LWNG_SETVAL(rate, 8, 0, 4, rx_stats->rate / 5);
+		LWNG_SETVAL(istx, 9, 0, 4, 0);
+		LWNG_SETVAL(frmlen, 10, 0, 4, skb->len - phdrlen);
+#undef LWNG_SETVAL
+	}
 
 	skb->dev = ieee->dev;
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,22))
 	skb->mac.raw = skb->data;
-	skb_pull(skb, ieee80211_get_hdrlen(fc));
+#else
+	skb_reset_mac_header(skb);
+#endif
+	skb_pull(skb, hdrlen);
+	if (prism_header)
+		skb_pull(skb, phdrlen);
 	skb->pkt_type = PACKET_OTHERHOST;
 	skb->protocol = __constant_htons(ETH_P_80211_RAW);
 	memset(skb->cb, 0, sizeof(skb->cb));
@@ -64,7 +134,7 @@
 
 /* Called only as a tasklet (software IRQ) */
 static struct ieee80211_frag_entry *
-ieee80211_frag_cache_find(struct ieee80211_device *ieee, unsigned int seq,
+ieee80211_frag_cache_find_rtl7(struct ieee80211_device *ieee, unsigned int seq,
 			  unsigned int frag, u8 *src, u8 *dst)
 {
 	struct ieee80211_frag_entry *entry;
@@ -94,7 +164,7 @@
 
 /* Called only as a tasklet (software IRQ) */
 static struct sk_buff *
-ieee80211_frag_cache_get(struct ieee80211_device *ieee,
+ieee80211_frag_cache_get_rtl7(struct ieee80211_device *ieee,
 			 struct ieee80211_hdr *hdr)
 {
 	struct sk_buff *skb = NULL;
@@ -133,7 +203,7 @@
 	} else {
 		/* received a fragment of a frame for which the head fragment
 		 * should have already been received */
-		entry = ieee80211_frag_cache_find(ieee, seq, frag, hdr->addr2,
+		entry = ieee80211_frag_cache_find_rtl7(ieee, seq, frag, hdr->addr2,
 						  hdr->addr1);
 		if (entry != NULL) {
 			entry->last_frag = frag;
@@ -146,7 +216,7 @@
 
 
 /* Called only as a tasklet (software IRQ) */
-static int ieee80211_frag_cache_invalidate(struct ieee80211_device *ieee,
+static int ieee80211_frag_cache_invalidate_rtl7(struct ieee80211_device *ieee,
 					   struct ieee80211_hdr *hdr)
 {
 	u16 sc;
@@ -156,7 +226,7 @@
 	sc = le16_to_cpu(hdr->seq_ctl);
 	seq = WLAN_GET_SEQ_SEQ(sc);
 
-	entry = ieee80211_frag_cache_find(ieee, seq, -1, hdr->addr2,
+	entry = ieee80211_frag_cache_find_rtl7(ieee, seq, -1, hdr->addr2,
 					  hdr->addr1);
 
 	if (entry == NULL) {
@@ -178,7 +248,7 @@
  *
  * Called by ieee80211_rx */
 static inline int
-ieee80211_rx_frame_mgmt(struct ieee80211_device *ieee, struct sk_buff *skb,
+ieee80211_rx_frame_mgmt_rtl7(struct ieee80211_device *ieee, struct sk_buff *skb,
 			struct ieee80211_rx_stats *rx_stats, u16 type,
 			u16 stype)
 {
@@ -187,13 +257,13 @@
 	 * response parser uses it
 	 */
 	rx_stats->len = skb->len;
-	ieee80211_rx_mgt(ieee,(struct ieee80211_hdr *)skb->data,rx_stats);	
-	ieee80211_rx_frame_softmac(ieee, skb, rx_stats, type, stype);
+	ieee80211_rx_mgt_rtl7(ieee,(struct ieee80211_hdr *)skb->data,rx_stats);
+	ieee80211_rx_frame_softmac_rtl7(ieee, skb, rx_stats, type, stype);
 
 	dev_kfree_skb_any(skb);
-	
+
 	return 0;
-	
+
 	#ifdef NOT_YET
 	if (ieee->iw_mode == IW_MODE_MASTER) {
 		printk(KERN_DEBUG "%s: Master mode not yet suppported.\n",
@@ -253,7 +323,7 @@
 /* No encapsulation header if EtherType < 0x600 (=length) */
 
 /* Called by ieee80211_rx_frame_decrypt */
-static int ieee80211_is_eapol_frame(struct ieee80211_device *ieee,
+static int ieee80211_is_eapol_frame_rtl7(struct ieee80211_device *ieee,
 				    struct sk_buff *skb)
 {
 	struct net_device *dev = ieee->dev;
@@ -294,7 +364,7 @@
 
 /* Called only as a tasklet (software IRQ), by ieee80211_rx */
 static inline int
-ieee80211_rx_frame_decrypt(struct ieee80211_device* ieee, struct sk_buff *skb,
+ieee80211_rx_frame_decrypt_rtl7(struct ieee80211_device* ieee, struct sk_buff *skb,
 			   struct ieee80211_crypt_data *crypt)
 {
 	struct ieee80211_hdr *hdr;
@@ -304,7 +374,7 @@
 		return 0;
 
 	hdr = (struct ieee80211_hdr *) skb->data;
-	hdrlen = ieee80211_get_hdrlen(le16_to_cpu(hdr->frame_ctl));
+	hdrlen = ieee80211_get_hdrlen_rtl7(le16_to_cpu(hdr->frame_ctl));
 
 #ifdef CONFIG_IEEE80211_CRYPT_TKIP
 	if (ieee->tkip_countermeasures &&
@@ -339,7 +409,7 @@
 
 /* Called only as a tasklet (software IRQ), by ieee80211_rx */
 static inline int
-ieee80211_rx_frame_decrypt_msdu(struct ieee80211_device* ieee, struct sk_buff *skb,
+ieee80211_rx_frame_decrypt_msdu_rtl7(struct ieee80211_device* ieee, struct sk_buff *skb,
 			     int keyidx, struct ieee80211_crypt_data *crypt)
 {
 	struct ieee80211_hdr *hdr;
@@ -349,7 +419,7 @@
 		return 0;
 
 	hdr = (struct ieee80211_hdr *) skb->data;
-	hdrlen = ieee80211_get_hdrlen(le16_to_cpu(hdr->frame_ctl));
+	hdrlen = ieee80211_get_hdrlen_rtl7(le16_to_cpu(hdr->frame_ctl));
 
 	atomic_inc(&crypt->refcnt);
 	res = crypt->ops->decrypt_msdu(skb, keyidx, hdrlen, crypt->priv);
@@ -367,7 +437,7 @@
 
 /* this function is stolen from ipw2200 driver*/
 #define IEEE_PACKET_RETRY_TIME (5*HZ)
-static int is_duplicate_packet(struct ieee80211_device *ieee,
+static int is_duplicate_packet_rtl7(struct ieee80211_device *ieee,
 				      struct ieee80211_hdr *header)
 {
 //	u16 fc = le16_to_cpu(header->frame_ctl);
@@ -413,7 +483,7 @@
 		last_seq = &ieee->last_seq_num;
 		last_frag = &ieee->last_frag_num;
 		last_time = &ieee->last_packet_time;
-		
+
 		break;
 	default:
 		return 0;
@@ -436,7 +506,7 @@
 drop:
 //	BUG_ON(!(fc & IEEE80211_FCTL_RETRY));
 //	printk("DUP\n");
-	
+
 	return 1;
 }
 
@@ -444,7 +514,7 @@
 /* All received frames are sent to this function. @skb contains the frame in
  * IEEE 802.11 format, i.e., in the format it was sent over air.
  * This function is called only as a tasklet (software IRQ). */
-int ieee80211_rx(struct ieee80211_device *ieee, struct sk_buff *skb,
+int ieee80211_rx_rtl7(struct ieee80211_device *ieee, struct sk_buff *skb,
 		 struct ieee80211_rx_stats *rx_stats)
 {
 	struct net_device *dev = ieee->dev;
@@ -481,9 +551,9 @@
 	type = WLAN_FC_GET_TYPE(fc);
 	stype = WLAN_FC_GET_STYPE(fc);
 	sc = le16_to_cpu(hdr->seq_ctl);
-	
+
 	frag = WLAN_GET_SEQ_FRAG(sc);
-	hdrlen = ieee80211_get_hdrlen(fc);
+	hdrlen = ieee80211_get_hdrlen_rtl7(fc);
 
 #ifdef NOT_YET
 #if WIRELESS_EXT > 15
@@ -501,12 +571,12 @@
 	}
 #endif /* IW_WIRELESS_SPY */
 #endif /* WIRELESS_EXT > 15 */
-	hostap_update_rx_stats(local->ap, hdr, rx_stats);
+	hostap_update_rx_stats_rtl7(local->ap, hdr, rx_stats);
 #endif
 
 #if WIRELESS_EXT > 15
 	if (ieee->iw_mode == IW_MODE_MONITOR) {
-		ieee80211_monitor_rx(ieee, skb, rx_stats);
+		ieee80211_monitor_rx_rtl7(ieee, skb, rx_stats);
 		stats->rx_packets++;
 		stats->rx_bytes += skb->len;
 		return 1;
@@ -529,7 +599,7 @@
 		 * stations that do not support WEP key mapping). */
 
 		if (!(hdr->addr1[0] & 0x01) || local->bcrx_sta_key)
-			(void) hostap_handle_sta_crypto(local, hdr, &crypt,
+			(void) hostap_handle_sta_crypto_rtl7(local, hdr, &crypt,
 							&sta);
 #endif
 
@@ -555,7 +625,7 @@
 	if (skb->len < IEEE80211_DATA_HDR3_LEN)
 		goto rx_dropped;
 
-	if (is_duplicate_packet(ieee, hdr))
+	if (is_duplicate_packet_rtl7(ieee, hdr))
 		goto rx_dropped;
 
 
@@ -573,9 +643,9 @@
 			goto rx_dropped;
 		}
 	#endif
-		
-	
-		if (ieee80211_rx_frame_mgmt(ieee, skb, rx_stats, type, stype))
+
+
+		if (ieee80211_rx_frame_mgmt_rtl7(ieee, skb, rx_stats, type, stype))
 			goto rx_dropped;
 		else
 			goto rx_exit;
@@ -583,7 +653,7 @@
 
 
 	/* Data frame - extract src/dst addresses */
-	
+
 	switch (fc & (IEEE80211_FCTL_FROMDS | IEEE80211_FCTL_TODS)) {
 	case IEEE80211_FCTL_FROMDS:
 		memcpy(dst, hdr->addr1, ETH_ALEN);
@@ -606,7 +676,7 @@
 	}
 
 #ifdef NOT_YET
-	if (hostap_rx_frame_wds(ieee, hdr, fc, &wds))
+	if (hostap_rx_frame_wds_rtl7(ieee, hdr, fc, &wds))
 		goto rx_dropped;
 	if (wds) {
 		skb->dev = dev = wds;
@@ -619,7 +689,7 @@
 	    memcmp(hdr->addr2, ieee->assoc_ap_addr, ETH_ALEN) == 0) {
 		/* Frame from BSSID of the AP for which we are a client */
 		skb->dev = dev = ieee->stadev;
-		stats = hostap_get_stats(dev);
+		stats = hostap_get_stats_rtl7(dev);
 		from_assoc_ap = 1;
 	}
 #endif
@@ -630,7 +700,7 @@
 	if ((ieee->iw_mode == IW_MODE_MASTER ||
 	     ieee->iw_mode == IW_MODE_REPEAT) &&
 	    !from_assoc_ap) {
-		switch (hostap_handle_sta_rx(ieee, dev, skb, rx_stats,
+		switch (hostap_handle_sta_rx_rtl7(ieee, dev, skb, rx_stats,
 					     wds != NULL)) {
 		case AP_RX_CONTINUE_NOT_AUTHORIZED:
 			frame_authorized = 0;
@@ -664,7 +734,7 @@
 	/* skb: hdr + (possibly fragmented, possibly encrypted) payload */
 
 	if (ieee->host_decrypt && (fc & IEEE80211_FCTL_WEP) &&
-	    (keyidx = ieee80211_rx_frame_decrypt(ieee, skb, crypt)) < 0)
+	    (keyidx = ieee80211_rx_frame_decrypt_rtl7(ieee, skb, crypt)) < 0)
 		goto rx_dropped;
 
 	hdr = (struct ieee80211_hdr *) skb->data;
@@ -674,7 +744,7 @@
 	// ieee->host_decrypt && (fc & IEEE80211_FCTL_WEP) &&
 	if ((frag != 0 || (fc & IEEE80211_FCTL_MOREFRAGS))) {
 		int flen;
-		struct sk_buff *frag_skb = ieee80211_frag_cache_get(ieee, hdr);
+		struct sk_buff *frag_skb = ieee80211_frag_cache_get_rtl7(ieee, hdr);
 		IEEE80211_DEBUG_FRAG("Rx Fragment received (%u)\n", frag);
 
 		if (!frag_skb) {
@@ -694,7 +764,7 @@
 			printk(KERN_WARNING "%s: host decrypted and "
 			       "reassembled frame did not fit skb\n",
 			       dev->name);
-			ieee80211_frag_cache_invalidate(ieee, hdr);
+			ieee80211_frag_cache_invalidate_rtl7(ieee, hdr);
 			goto rx_dropped;
 		}
 
@@ -722,19 +792,19 @@
 		 * delivered, so remove skb from fragment cache */
 		skb = frag_skb;
 		hdr = (struct ieee80211_hdr *) skb->data;
-		ieee80211_frag_cache_invalidate(ieee, hdr);
+		ieee80211_frag_cache_invalidate_rtl7(ieee, hdr);
 	}
 
 	/* skb: hdr + (possible reassembled) full MSDU payload; possibly still
 	 * encrypted/authenticated */
 	if (ieee->host_decrypt && (fc & IEEE80211_FCTL_WEP) &&
-	    ieee80211_rx_frame_decrypt_msdu(ieee, skb, keyidx, crypt))
+	    ieee80211_rx_frame_decrypt_msdu_rtl7(ieee, skb, keyidx, crypt))
 		goto rx_dropped;
 
 	hdr = (struct ieee80211_hdr *) skb->data;
 	if (crypt && !(fc & IEEE80211_FCTL_WEP) && !ieee->open_wep) {
 		if (/*ieee->ieee802_1x &&*/
-		    ieee80211_is_eapol_frame(ieee, skb)) {
+		    ieee80211_is_eapol_frame_rtl7(ieee, skb)) {
 #ifdef CONFIG_IEEE80211_DEBUG
 			/* pass unencrypted EAPOL frames even if encryption is
 			 * configured */
@@ -763,7 +833,7 @@
 #endif
 
 	if (crypt && !(fc & IEEE80211_FCTL_WEP) && !ieee->open_wep &&
-	    !ieee80211_is_eapol_frame(ieee, skb)) {
+	    !ieee80211_is_eapol_frame_rtl7(ieee, skb)) {
 		IEEE80211_DEBUG_DROP(
 			"dropped unencrypted RX data "
 			"frame from " MAC_FMT
@@ -861,7 +931,12 @@
 	if (skb2 != NULL) {
 		/* send to wireless media */
 		skb2->protocol = __constant_htons(ETH_P_802_3);
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,22))
 		skb2->mac.raw = skb2->nh.raw = skb2->data;
+#else
+		skb_reset_mac_header(skb2);
+		skb_reset_network_header(skb2);
+#endif
 		/* skb2->nh.raw = skb2->data + ETH_HLEN; */
 		skb2->dev = dev;
 		dev_queue_xmit(skb2);
@@ -896,7 +971,7 @@
 
 #define MGMT_FRAME_FIXED_PART_LENGTH		0x24
 
-static inline int ieee80211_is_ofdm_rate(u8 rate)
+static inline int ieee80211_is_ofdm_rate_rtl7(u8 rate)
 {
 	switch (rate & ~IEEE80211_BASIC_RATE_MASK) {
 	case IEEE80211_OFDM_RATE_6MB:
@@ -913,7 +988,7 @@
 }
 
 
-static inline int ieee80211_network_init(
+static inline int ieee80211_network_init_rtl7(
 	struct ieee80211_device *ieee,
 	struct ieee80211_probe_response *beacon,
 	struct ieee80211_network *network,
@@ -964,7 +1039,7 @@
 
 		switch (info_element->id) {
 		case MFIE_TYPE_SSID:
-			if (ieee80211_is_empty_essid(info_element->data,
+			if (ieee80211_is_empty_essid_rtl7(info_element->data,
 						     info_element->len)) {
 				network->flags |= NETWORK_EMPTY_ESSID;
 				break;
@@ -991,7 +1066,7 @@
 #ifdef CONFIG_IEEE80211_DEBUG
 				p += snprintf(p, sizeof(rates_str) - (p - rates_str), "%02X ", network->rates[i]);
 #endif
-				if (ieee80211_is_ofdm_rate(info_element->data[i])) {
+				if (ieee80211_is_ofdm_rate_rtl7(info_element->data[i])) {
 					network->flags |= NETWORK_HAS_OFDM;
 					if (info_element->data[i] &
 					    IEEE80211_BASIC_RATE_MASK)
@@ -1014,7 +1089,7 @@
 #ifdef CONFIG_IEEE80211_DEBUG
 				p += snprintf(p, sizeof(rates_str) - (p - rates_str), "%02X ", network->rates[i]);
 #endif
-				if (ieee80211_is_ofdm_rate(info_element->data[i])) {
+				if (ieee80211_is_ofdm_rate_rtl7(info_element->data[i])) {
 					network->flags |= NETWORK_HAS_OFDM;
 					if (info_element->data[i] &
 					    IEEE80211_BASIC_RATE_MASK)
@@ -1043,47 +1118,47 @@
 			break;
 
 		case MFIE_TYPE_TIM:
-		
-			if(info_element->len < 4) 
+
+			if(info_element->len < 4)
 				break;
-			
+
 			network->dtim_period = info_element->data[1];
-			
+
 			if(ieee->state != IEEE80211_LINKED)
 				break;
-			
-			network->last_dtim_sta_time[0] = stats->mac_time[0];	
+
+			network->last_dtim_sta_time[0] = stats->mac_time[0];
 			network->last_dtim_sta_time[1] = stats->mac_time[1];
-			
+
 			network->dtim_data = IEEE80211_DTIM_VALID;
-			
-			if(info_element->data[0] != 0)	
+
+			if(info_element->data[0] != 0)
 				break;
-			
+
 			if(info_element->data[2] & 1)
 				network->dtim_data |= IEEE80211_DTIM_MBCAST;
-				
+
 			offset = (info_element->data[2] >> 1)*2;
-			
-			//printk("offset1:%x aid:%x\n",offset, ieee->assoc_id); 
-		
-			if(ieee->assoc_id < offset || 
+
+			//printk("offset1:%x aid:%x\n",offset, ieee->assoc_id);
+
+			if(ieee->assoc_id < offset ||
 				ieee->assoc_id > 8*(offset + info_element->len -3))
-				
+
 				break;
-			
-			
+
+
 			offset = offset + ieee->assoc_id / 8;// + ((aid % 8)? 0 : 1) ;
-			
-		//	printk("offset:%x data:%x, ucast:%d\n", offset, 
+
+		//	printk("offset:%x data:%x, ucast:%d\n", offset,
 			//	info_element->data[3+offset] ,
 			//	info_element->data[3+offset] & (1<<(ieee->assoc_id%8)));
-				
+
 			if(info_element->data[3+offset] & (1<<(ieee->assoc_id%8)))
 				network->dtim_data |= IEEE80211_DTIM_UCAST;
-				
+
 			break;
-			
+
 		case MFIE_TYPE_IBSS_SET:
 			IEEE80211_DEBUG_SCAN("MFIE_TYPE_IBSS_SET: ignored\n");
 			break;
@@ -1115,7 +1190,7 @@
 			memcpy(network->rsn_ie, info_element,
 			       network->rsn_ie_len);
 			break;
-			
+
 		default:
 			IEEE80211_DEBUG_SCAN("unsupported IE %d\n",
 					     info_element->id);
@@ -1147,7 +1222,7 @@
 		return 1;
 	}
 
-	if (ieee80211_is_empty_essid(network->ssid, network->ssid_len))
+	if (ieee80211_is_empty_essid_rtl7(network->ssid, network->ssid_len))
 		network->flags |= NETWORK_EMPTY_ESSID;
 
 	memcpy(&network->stats, stats, sizeof(network->stats));
@@ -1155,24 +1230,24 @@
 	return 0;
 }
 
-static inline int is_same_network(struct ieee80211_network *src,
+static inline int is_same_network_rtl7(struct ieee80211_network *src,
 				  struct ieee80211_network *dst)
 {
 	/* A network is only a duplicate if the channel, BSSID, ESSID
-	 * and the capability field (in particular IBSS and BSS) all match.  
+	 * and the capability field (in particular IBSS and BSS) all match.
 	 * We treat all <hidden> with the same BSSID and channel
 	 * as one network */
 	return ((src->ssid_len == dst->ssid_len) &&
 		(src->channel == dst->channel) &&
 		!memcmp(src->bssid, dst->bssid, ETH_ALEN) &&
 		!memcmp(src->ssid, dst->ssid, src->ssid_len) &&
-		((src->capability & WLAN_CAPABILITY_IBSS) == 
+		((src->capability & WLAN_CAPABILITY_IBSS) ==
 		(dst->capability & WLAN_CAPABILITY_IBSS)) &&
-		((src->capability & WLAN_CAPABILITY_BSS) == 
+		((src->capability & WLAN_CAPABILITY_BSS) ==
 		(dst->capability & WLAN_CAPABILITY_BSS)));
 }
 
-static inline void update_network(struct ieee80211_network *dst,
+static inline void update_network_rtl7(struct ieee80211_network *dst,
 				  struct ieee80211_network *src)
 {
 	memcpy(&dst->stats, &src->stats, sizeof(struct ieee80211_rx_stats));
@@ -1194,7 +1269,7 @@
 	dst->dtim_data = src->dtim_data;
 	dst->last_dtim_sta_time[0] = src->last_dtim_sta_time[0];
 	dst->last_dtim_sta_time[1] = src->last_dtim_sta_time[1];
-	
+
 	memcpy(dst->wpa_ie, src->wpa_ie, src->wpa_ie_len);
 	dst->wpa_ie_len = src->wpa_ie_len;
 	memcpy(dst->rsn_ie, src->rsn_ie, src->rsn_ie_len);
@@ -1204,7 +1279,7 @@
 	/* dst->last_associate is not overwritten */
 }
 
-static inline void ieee80211_process_probe_response(
+static inline void ieee80211_process_probe_response_rtl7(
 	struct ieee80211_device *ieee,
 	struct ieee80211_probe_response *beacon,
 	struct ieee80211_rx_stats *stats)
@@ -1239,7 +1314,7 @@
 		(beacon->capability & (1<<0x1)) ? '1' : '0',
 		(beacon->capability & (1<<0x0)) ? '1' : '0');
 
-	if (ieee80211_network_init(ieee, beacon, &network, stats)) {
+	if (ieee80211_network_init_rtl7(ieee, beacon, &network, stats)) {
 		IEEE80211_DEBUG_SCAN("Dropped '%s' (" MAC_FMT ") via %s.\n",
 				     escape_essid(info_element->data,
 						  info_element->len),
@@ -1261,12 +1336,12 @@
 	 * already there. */
 
 	spin_lock_irqsave(&ieee->lock, flags);
-	
-	if(is_same_network(&ieee->current_network, &network))
-		update_network(&ieee->current_network, &network);
-		
+
+	if(is_same_network_rtl7(&ieee->current_network, &network))
+		update_network_rtl7(&ieee->current_network, &network);
+
 	list_for_each_entry(target, &ieee->network_list, list) {
-		if (is_same_network(target, &network))
+		if (is_same_network_rtl7(target, &network))
 			break;
 
 		if ((oldest == NULL) ||
@@ -1306,7 +1381,7 @@
 		memcpy(target, &network, sizeof(*target));
 		list_add_tail(&target->list, &ieee->network_list);
 		if(ieee->softmac_features & IEEE_SOFTMAC_ASSOCIATE)
-			ieee80211_softmac_new_net(ieee,&network); 
+			ieee80211_softmac_new_net_rtl7(ieee,&network);
 	} else {
 		IEEE80211_DEBUG_SCAN("Updating '%s' (" MAC_FMT ") via %s.\n",
 				     escape_essid(target->ssid,
@@ -1315,39 +1390,39 @@
 				     WLAN_FC_GET_STYPE(beacon->header.frame_ctl) ==
 				     IEEE80211_STYPE_PROBE_RESP ?
 				     "PROBE RESPONSE" : "BEACON");
-		
+
 		/* we have an entry and we are going to update it. But this entry may
-		 * be already expired. In this case we do the same as we found a new 
+		 * be already expired. In this case we do the same as we found a new
 		 * net and call the new_net handler
 		 */
 		renew = !time_after(target->last_scanned + ieee->scan_age, jiffies);
-		update_network(target, &network);
+		update_network_rtl7(target, &network);
 		if(renew && (ieee->softmac_features & IEEE_SOFTMAC_ASSOCIATE))
-			ieee80211_softmac_new_net(ieee,&network); 
+			ieee80211_softmac_new_net_rtl7(ieee,&network);
 	}
 
 	spin_unlock_irqrestore(&ieee->lock, flags);
 }
 
-void ieee80211_rx_mgt(struct ieee80211_device *ieee,
+void ieee80211_rx_mgt_rtl7(struct ieee80211_device *ieee,
 		      struct ieee80211_hdr *header,
 		      struct ieee80211_rx_stats *stats)
 {
 	switch (WLAN_FC_GET_STYPE(header->frame_ctl)) {
-	
+
 	case IEEE80211_STYPE_BEACON:
 		IEEE80211_DEBUG_MGMT("received BEACON (%d)\n",
 				     WLAN_FC_GET_STYPE(header->frame_ctl));
 		IEEE80211_DEBUG_SCAN("Beacon\n");
-		ieee80211_process_probe_response(
+		ieee80211_process_probe_response_rtl7(
 			ieee, (struct ieee80211_probe_response *)header, stats);
 		break;
-		
+
 	case IEEE80211_STYPE_PROBE_RESP:
 		IEEE80211_DEBUG_MGMT("received PROBE RESPONSE (%d)\n",
 				     WLAN_FC_GET_STYPE(header->frame_ctl));
 		IEEE80211_DEBUG_SCAN("Probe response\n");
-		ieee80211_process_probe_response(
+		ieee80211_process_probe_response_rtl7(
 			ieee, (struct ieee80211_probe_response *)header, stats);
 		break;
 
@@ -1355,5 +1430,5 @@
 }
 
 
-EXPORT_SYMBOL(ieee80211_rx_mgt);
-EXPORT_SYMBOL(ieee80211_rx);
+EXPORT_SYMBOL(ieee80211_rx_mgt_rtl7);
+EXPORT_SYMBOL(ieee80211_rx_rtl7);
diff -Naur rtl8187_linux_26.1010.0622.2006/ieee80211/ieee80211_softmac.c rtl8187_linux_26.1010.0622.2006_rawtx/ieee80211/ieee80211_softmac.c
--- rtl8187_linux_26.1010.0622.2006/ieee80211/ieee80211_softmac.c	2006-06-19 03:27:33.000000000 +0200
+++ rtl8187_linux_26.1010.0622.2006_rawtx/ieee80211/ieee80211_softmac.c	2008-01-30 17:38:11.000000000 +0100
@@ -1,14 +1,14 @@
 /* IEEE 802.11 SoftMAC layer
  * Copyright (c) 2005 Andrea Merello <andreamrl@tiscali.it>
  *
- * Mostly extracted from the rtl8180-sa2400 driver for the 
+ * Mostly extracted from the rtl8180-sa2400 driver for the
  * in-kernel generic ieee802.11 stack.
  *
  * Few lines might be stolen from other part of the ieee80211
  * stack. Copyright who own it's copyright
  *
  * WPA code stolen from the ipw2200 driver.
- * Copyright who own it's copyright. 
+ * Copyright who own it's copyright.
  *
  * released under the GPL
  */
@@ -20,12 +20,12 @@
 #include <linux/delay.h>
 #include <linux/version.h>
 
-short ieee80211_is_54g(struct ieee80211_network net)
+short ieee80211_is_54g_rtl7(struct ieee80211_network net)
 {
 	return ((net.rates_ex_len > 0) || (net.rates_len > 4));
 }
 
-short ieee80211_is_shortslot(struct ieee80211_network net)
+short ieee80211_is_shortslot_rtl7(struct ieee80211_network net)
 {
 	return (net.capability & WLAN_CAPABILITY_SHORT_SLOT);
 }
@@ -34,28 +34,28 @@
  * tag and the EXTENDED RATE MFIE tag if needed.
  * It encludes two bytes per tag for the tag itself and its len
  */
-unsigned int ieee80211_MFIE_rate_len(struct ieee80211_device *ieee)
+unsigned int ieee80211_MFIE_rate_len_rtl7(struct ieee80211_device *ieee)
 {
 	unsigned int rate_len = 0;
-	
+
 	if (ieee->modulation & IEEE80211_CCK_MODULATION)
 		rate_len = IEEE80211_CCK_RATE_LEN + 2;
-		
+
 	if (ieee->modulation & IEEE80211_OFDM_MODULATION)
-		
+
 		rate_len += IEEE80211_OFDM_RATE_LEN + 2;
-	
+
 	return rate_len;
 }
 
-/* pleace the MFIE rate, tag to the memory (double) poined. 
+/* pleace the MFIE rate, tag to the memory (double) poined.
  * Then it updates the pointer so that
  * it points after the new MFIE tag added.
- */  
-void ieee80211_MFIE_Brate(struct ieee80211_device *ieee, u8 **tag_p)
+ */
+void ieee80211_MFIE_Brate_rtl7(struct ieee80211_device *ieee, u8 **tag_p)
 {
-	u8 *tag = *tag_p; 
-	
+	u8 *tag = *tag_p;
+
 	if (ieee->modulation & IEEE80211_CCK_MODULATION){
 		*tag++ = MFIE_TYPE_RATES;
 		*tag++ = 4;
@@ -64,17 +64,17 @@
 		*tag++ = IEEE80211_BASIC_RATE_MASK | IEEE80211_CCK_RATE_5MB;
 		*tag++ = IEEE80211_BASIC_RATE_MASK | IEEE80211_CCK_RATE_11MB;
 	}
-	
+
 	/* We may add an option for custom rates that specific HW might support */
 	*tag_p = tag;
 }
 
-void ieee80211_MFIE_Grate(struct ieee80211_device *ieee, u8 **tag_p)
-{	
-	u8 *tag = *tag_p; 
-	
+void ieee80211_MFIE_Grate_rtl7(struct ieee80211_device *ieee, u8 **tag_p)
+{
+	u8 *tag = *tag_p;
+
 		if (ieee->modulation & IEEE80211_OFDM_MODULATION){
-		
+
 		*tag++ = MFIE_TYPE_RATES_EX;
 		*tag++ = 8;
 		*tag++ = IEEE80211_BASIC_RATE_MASK | IEEE80211_OFDM_RATE_6MB;
@@ -85,73 +85,73 @@
 		*tag++ = IEEE80211_BASIC_RATE_MASK | IEEE80211_OFDM_RATE_36MB;
 		*tag++ = IEEE80211_BASIC_RATE_MASK | IEEE80211_OFDM_RATE_48MB;
 		*tag++ = IEEE80211_BASIC_RATE_MASK | IEEE80211_OFDM_RATE_54MB;
-		
+
 	}
-	
+
 	/* We may add an option for custom rates that specific HW might support */
 	*tag_p = tag;
 }
 
-void enqueue_mgmt(struct ieee80211_device *ieee, struct sk_buff *skb)
+void enqueue_mgmt_rtl7(struct ieee80211_device *ieee, struct sk_buff *skb)
 {
 	int nh;
 	nh = (ieee->mgmt_queue_head +1) % MGMT_QUEUE_NUM;
-			
+
 /*
  * if the queue is full but we have newer frames then
  * just overwrites the oldest.
- *	
+ *
  * if (nh == ieee->mgmt_queue_tail)
  *		return -1;
- */		
+ */
 	ieee->mgmt_queue_head = nh;
 	ieee->mgmt_queue_ring[nh] = skb;
-	
+
 	//return 0;
 }
 
-struct sk_buff *dequeue_mgmt(struct ieee80211_device *ieee)
+struct sk_buff *dequeue_mgmt_rtl7(struct ieee80211_device *ieee)
 {
 	struct sk_buff *ret;
-	
+
 	if(ieee->mgmt_queue_tail == ieee->mgmt_queue_head)
 		return NULL;
-		
+
 	ret = ieee->mgmt_queue_ring[ieee->mgmt_queue_tail];
-	
-	ieee->mgmt_queue_tail = 
+
+	ieee->mgmt_queue_tail =
 		(ieee->mgmt_queue_tail+1) % MGMT_QUEUE_NUM;
-	
+
 	return ret;
 }
 
-void init_mgmt_queue(struct ieee80211_device *ieee)
+void init_mgmt_queue_rtl7(struct ieee80211_device *ieee)
 {
 	ieee->mgmt_queue_tail = ieee->mgmt_queue_head = 0;
 }
 
 
-void ieee80211_sta_wakeup(struct ieee80211_device *ieee, short nl);
+void ieee80211_sta_wakeup_rtl7(struct ieee80211_device *ieee, short nl);
 
-inline void softmac_mgmt_xmit(struct sk_buff *skb, struct ieee80211_device *ieee)
+inline void softmac_mgmt_xmit_rtl7(struct sk_buff *skb, struct ieee80211_device *ieee)
 {
 	unsigned long flags;
 	short single = ieee->softmac_features & IEEE_SOFTMAC_SINGLE_QUEUE;
 	struct ieee80211_hdr_3addr  *header=
 		(struct ieee80211_hdr_3addr  *) skb->data;
-	
-	
+
+
 	spin_lock_irqsave(&ieee->lock, flags);
-	
+
 	/* called with 2nd param 0, no mgmt lock required */
-	ieee80211_sta_wakeup(ieee,0);
-		
+	ieee80211_sta_wakeup_rtl7(ieee,0);
+
 	if(single){
-		
+
 		if(ieee->queue_stop){
-			
-			enqueue_mgmt(ieee,skb);
-		
+
+			enqueue_mgmt_rtl7(ieee,skb);
+
 		}else{
 			header->seq_ctl = cpu_to_le16(ieee->seq_ctrl << 4);
 
@@ -159,119 +159,119 @@
 				ieee->seq_ctrl = 0;
 			else
 				ieee->seq_ctrl++;
-			
+
 			/* avoid watchdog triggers */
 			ieee->dev->trans_start = jiffies;
 			ieee->softmac_data_hard_start_xmit(skb,ieee->dev,ieee->basic_rate);
 		}
-		
+
 		spin_unlock_irqrestore(&ieee->lock, flags);
 	}else{
 		spin_unlock_irqrestore(&ieee->lock, flags);
 		spin_lock_irqsave(&ieee->mgmt_tx_lock, flags);
-	
+
 		header->seq_ctl = cpu_to_le16(ieee->seq_ctrl << 4);
-	
+
 		if (ieee->seq_ctrl == 0xFFF)
 			ieee->seq_ctrl = 0;
 		else
 			ieee->seq_ctrl++;
-		
+
 		ieee->softmac_hard_start_xmit(skb,ieee->dev);
-		
+
 		spin_unlock_irqrestore(&ieee->mgmt_tx_lock, flags);
 	}
 }
 
 
-inline void softmac_ps_mgmt_xmit(struct sk_buff *skb, struct ieee80211_device *ieee)
+inline void softmac_ps_mgmt_xmit_rtl7(struct sk_buff *skb, struct ieee80211_device *ieee)
 {
-	
+
 	short single = ieee->softmac_features & IEEE_SOFTMAC_SINGLE_QUEUE;
 	struct ieee80211_hdr_3addr  *header =
 		(struct ieee80211_hdr_3addr  *) skb->data;
-	
-	
+
+
 	if(single){
-		
+
 		header->seq_ctl = cpu_to_le16(ieee->seq_ctrl << 4);
 
 		if (ieee->seq_ctrl == 0xFFF)
 			ieee->seq_ctrl = 0;
 		else
 			ieee->seq_ctrl++;
-			
+
 		/* avoid watchdog triggers */
 		ieee->dev->trans_start = jiffies;
 		ieee->softmac_data_hard_start_xmit(skb,ieee->dev,ieee->basic_rate);
-	
+
 	}else{
-		
+
 		header->seq_ctl = cpu_to_le16(ieee->seq_ctrl << 4);
-	
+
 		if (ieee->seq_ctrl == 0xFFF)
 			ieee->seq_ctrl = 0;
 		else
 			ieee->seq_ctrl++;
 
 		ieee->softmac_hard_start_xmit(skb,ieee->dev);
-		
+
 	}
 }
 
-inline struct sk_buff *ieee80211_probe_req(struct ieee80211_device *ieee)
+inline struct sk_buff *ieee80211_probe_req_rtl7(struct ieee80211_device *ieee)
 {
 	unsigned int len,rate_len;
 	u8 *tag;
 	struct sk_buff *skb;
 	struct ieee80211_probe_request *req;
-	
+
 	len = ieee->current_network.ssid_len;
-	
-	rate_len = ieee80211_MFIE_rate_len(ieee);
-	
+
+	rate_len = ieee80211_MFIE_rate_len_rtl7(ieee);
+
 	skb = dev_alloc_skb(sizeof(struct ieee80211_probe_request) +
 			    2 + len + rate_len);
-	
-	if (!skb) 
+
+	if (!skb)
 		return NULL;
-	
+
 	req = (struct ieee80211_probe_request *) skb_put(skb,sizeof(struct ieee80211_probe_request));
 	req->header.frame_ctl = cpu_to_le16(IEEE80211_STYPE_PROBE_REQ);
-	req->header.duration_id = 0; //FIXME: is this OK ? 
-	
+	req->header.duration_id = 0; //FIXME: is this OK ?
+
 	memset(req->header.addr1, 0xff, ETH_ALEN);
 	memcpy(req->header.addr2, ieee->dev->dev_addr, ETH_ALEN);
 	memset(req->header.addr3, 0xff, ETH_ALEN);
-	
+
 	tag = (u8 *) skb_put(skb,len+2+rate_len);
-	
+
 	*tag++ = MFIE_TYPE_SSID;
 	*tag++ = len;
 	memcpy(tag, ieee->current_network.ssid, len);
 	tag += len;
-	
-	ieee80211_MFIE_Brate(ieee,&tag);
-	ieee80211_MFIE_Grate(ieee,&tag);
+
+	ieee80211_MFIE_Brate_rtl7(ieee,&tag);
+	ieee80211_MFIE_Grate_rtl7(ieee,&tag);
 	return skb;
 }
 
-struct sk_buff *ieee80211_get_beacon_(struct ieee80211_device *ieee);
-void ieee80211_send_beacon(struct ieee80211_device *ieee)
+struct sk_buff *ieee80211_get_beacon__rtl7(struct ieee80211_device *ieee);
+void ieee80211_send_beacon_rtl7(struct ieee80211_device *ieee)
 {
 	struct sk_buff *skb;
-	
-	unsigned long flags;	
-	
-	skb = ieee80211_get_beacon_(ieee);
+
+	unsigned long flags;
+
+	skb = ieee80211_get_beacon__rtl7(ieee);
 	if (skb){
-		softmac_mgmt_xmit(skb, ieee);
+		softmac_mgmt_xmit_rtl7(skb, ieee);
 		ieee->softmac_stats.tx_beacons++;
 	}
 
-	ieee->beacon_timer.expires = jiffies + 
+	ieee->beacon_timer.expires = jiffies +
 		(MSECS( ieee->current_network.beacon_interval -5));
-	
+
 	spin_lock_irqsave(&ieee->beacon_lock,flags);
 	if(ieee->beacon_txing)
 		add_timer(&ieee->beacon_timer);
@@ -279,57 +279,57 @@
 }
 
 
-void ieee80211_send_beacon_cb(unsigned long _ieee)
+void ieee80211_send_beacon_cb_rtl7(unsigned long _ieee)
 {
 	struct ieee80211_device *ieee =
 		(struct ieee80211_device *) _ieee;
-	ieee80211_send_beacon(ieee);
+	ieee80211_send_beacon_rtl7(ieee);
 }
 
 
-void ieee80211_send_probe(struct ieee80211_device *ieee)
+void ieee80211_send_probe_rtl7(struct ieee80211_device *ieee)
 {
 	struct sk_buff *skb;
-	
-	skb = ieee80211_probe_req(ieee);
+
+	skb = ieee80211_probe_req_rtl7(ieee);
 	if (skb){
-		softmac_mgmt_xmit(skb, ieee);
+		softmac_mgmt_xmit_rtl7(skb, ieee);
 		ieee->softmac_stats.tx_probe_rq++;
 	}
 }
 
-void ieee80211_send_probe_requests(struct ieee80211_device *ieee)
+void ieee80211_send_probe_requests_rtl7(struct ieee80211_device *ieee)
 {
 	if (ieee->active_scan && (ieee->softmac_features & IEEE_SOFTMAC_PROBERQ)){
-		ieee80211_send_probe(ieee);
-		ieee80211_send_probe(ieee);
+		ieee80211_send_probe_rtl7(ieee);
+		ieee80211_send_probe_rtl7(ieee);
 	}
 }
 
 /* this performs syncro scan blocking the caller until all channels
- * in the allowed channel map has been checked. 
+ * in the allowed channel map has been checked.
  */
-void ieee80211_softmac_scan_syncro(struct ieee80211_device *ieee)
+void ieee80211_softmac_scan_syncro_rtl7(struct ieee80211_device *ieee)
 {
 	short ch = 0;
-        
+
 	down(&ieee->scan_sem);
-	
+
 	while(1)
 	{
-		
+
 		do{
 			ch++;
-			if (ch > MAX_CHANNEL_NUMBER) 
+			if (ch > MAX_CHANNEL_NUMBER)
 				goto out; /* scan completed */
-				
+
 		}while(!ieee->channel_map[ch]);
-	
+
 		/* this fuction can be called in two situations
 		 * 1- We have switched to ad-hoc mode and we are
 		 *    performing a complete syncro scan before conclude
-		 *    there are no interesting cell and to create a 
-		 *    new one. In this case the link state is 
+		 *    there are no interesting cell and to create a
+		 *    new one. In this case the link state is
 		 *    IEEE80211_NOLINK until we found an interesting cell.
 		 *    If so the ieee8021_new_net, called by the RX path
 		 *    will set the state to IEEE80211_LINKED, so we stop
@@ -342,24 +342,24 @@
 		 *    not filter RX frames and the channel is changing.
 		 * So the only situation in witch are interested is to check
 		 * if the state become LINKED because of the #1 situation
-		 */    
-		    
+		 */
+
 		if (ieee->state == IEEE80211_LINKED)
 			goto out;
-		
+
 		ieee->set_chan(ieee->dev, ch);
-		
-		ieee80211_send_probe_requests(ieee);
-		
+
+		ieee80211_send_probe_requests_rtl7(ieee);
+
 		/* this prevent excessive time wait when we
 		 * need to wait for a syncro scan to end..
-		 */  		
+		 */
 		if (ieee->sync_scan_hurryup)
 			goto out;
 
 
 		msleep_interruptible_rtl(IEEE80211_SOFTMAC_SCAN_TIME);
-		
+
 	}
 out:
 	ieee->sync_scan_hurryup = 0;
@@ -370,43 +370,49 @@
 void ieee80211_softmac_scan(struct ieee80211_device *ieee)
 {
 	short watchdog = 0;
-	
+
 	do{
-		ieee->current_network.channel = 
+		ieee->current_network.channel =
 			(ieee->current_network.channel + 1) % MAX_CHANNEL_NUMBER;
-		if (watchdog++ > MAX_CHANNEL_NUMBER) 
+		if (watchdog++ > MAX_CHANNEL_NUMBER)
 				return; /* no good chans */
-				
+
 	}while(!ieee->channel_map[ieee->current_network.channel]);
-		
+
 
 	schedule_work(&ieee->softmac_scan_wq);
 }
 #endif
 
-void ieee80211_softmac_scan_wq(struct ieee80211_device *ieee)
-{	
-	down(&ieee->scan_sem);
-	
+# if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20))
+void ieee80211_softmac_scan_wq_rtl7(struct work_struct *work)
+{
+	struct delayed_work *dwork = container_of(work, struct delayed_work, work);
+	struct ieee80211_device *ieee = container_of(dwork, struct ieee80211_device, softmac_scan_wq);
+#else
+void ieee80211_softmac_scan_wq_rtl7(struct ieee80211_device *ieee)
+{
+#endif
 	short watchdog = 0;
-	
+	down(&ieee->scan_sem);
+
 	do{
-		ieee->current_network.channel = 
+		ieee->current_network.channel =
 			(ieee->current_network.channel + 1) % MAX_CHANNEL_NUMBER;
-		if (watchdog++ > MAX_CHANNEL_NUMBER) 
+		if (watchdog++ > MAX_CHANNEL_NUMBER)
 				goto out; /* no good chans */
-				
+
 	}while(!ieee->channel_map[ieee->current_network.channel]);
-	
+
 	if (ieee->scanning == 0 )
 		goto out;
-	
+
 	ieee->set_chan(ieee->dev, ieee->current_network.channel);
-	ieee80211_send_probe_requests(ieee);
+	ieee80211_send_probe_requests_rtl7(ieee);
 
-#if 0	
+#if 0
 	ieee->.expires = jiffies + (IEEE80211_SOFTMAC_SCAN_TIME);
-	if (ieee->scanning == 1) 
+	if (ieee->scanning == 1)
 		add_timer(&ieee->scan_timer);
 #endif
 	queue_delayed_work(ieee->wq, &ieee->softmac_scan_wq, IEEE80211_SOFTMAC_SCAN_TIME);
@@ -419,7 +425,7 @@
 {
 	unsigned long flags;
 	struct ieee80211_device *ieee = (struct ieee80211_device *)_dev;
-	
+
 	spin_lock_irqsave(&ieee->lock, flags);
 	ieee80211_softmac_scan(ieee);
 	spin_unlock_irqrestore(&ieee->lock, flags);
@@ -427,19 +433,19 @@
 #endif
 
 
-void ieee80211_beacons_start(struct ieee80211_device *ieee)
+void ieee80211_beacons_start_rtl7(struct ieee80211_device *ieee)
 {
-	unsigned long flags;	
+	unsigned long flags;
 
 	spin_lock_irqsave(&ieee->beacon_lock,flags);
 
 	ieee->beacon_txing = 1;
-	ieee80211_send_beacon(ieee);
-	
+	ieee80211_send_beacon_rtl7(ieee);
+
 	spin_unlock_irqrestore(&ieee->beacon_lock,flags);
 }
 
-void ieee80211_beacons_stop(struct ieee80211_device *ieee)
+void ieee80211_beacons_stop_rtl7(struct ieee80211_device *ieee)
 {
 	unsigned long flags;
 
@@ -453,111 +459,111 @@
 }
 
 
-void ieee80211_stop_send_beacons(struct ieee80211_device *ieee)
+void ieee80211_stop_send_beacons_rtl7(struct ieee80211_device *ieee)
 {
 	if(ieee->stop_send_beacons)
 		ieee->stop_send_beacons(ieee->dev);
 	if (ieee->softmac_features & IEEE_SOFTMAC_BEACONS)
-		ieee80211_beacons_stop(ieee);
+		ieee80211_beacons_stop_rtl7(ieee);
 }
 
 
-void ieee80211_start_send_beacons(struct ieee80211_device *ieee)
+void ieee80211_start_send_beacons_rtl7(struct ieee80211_device *ieee)
 {
 	if(ieee->start_send_beacons)
 		ieee->start_send_beacons(ieee->dev);
 	if(ieee->softmac_features & IEEE_SOFTMAC_BEACONS)
-		ieee80211_beacons_start(ieee); 
+		ieee80211_beacons_start_rtl7(ieee);
 }
 
 
-void ieee80211_softmac_stop_scan(struct ieee80211_device *ieee)
+void ieee80211_softmac_stop_scan_rtl7(struct ieee80211_device *ieee)
 {
-//	unsigned long flags;	
-	
+//	unsigned long flags;
+
 	//ieee->sync_scan_hurryup = 1;
-	
+
 	down(&ieee->scan_sem);
 //	spin_lock_irqsave(&ieee->lock, flags);
-	
+
 	if (ieee->scanning == 1){
 		ieee->scanning = 0;
 		//del_timer_sync(&ieee->scan_timer);
 		cancel_delayed_work(&ieee->softmac_scan_wq);
 	}
-	
+
 //	spin_unlock_irqrestore(&ieee->lock, flags);
 	up(&ieee->scan_sem);
 }
 
-void ieee80211_stop_scan(struct ieee80211_device *ieee)
+void ieee80211_stop_scan_rtl7(struct ieee80211_device *ieee)
 {
 	if (ieee->softmac_features & IEEE_SOFTMAC_SCAN)
-		ieee80211_softmac_stop_scan(ieee);
+		ieee80211_softmac_stop_scan_rtl7(ieee);
 	else
 		ieee->stop_scan(ieee->dev);
 }
 
 /* called with ieee->lock held */
-void ieee80211_start_scan(struct ieee80211_device *ieee)
+void ieee80211_start_scan_rtl7(struct ieee80211_device *ieee)
 {
-	if (ieee->softmac_features & IEEE_SOFTMAC_SCAN){	
+	if (ieee->softmac_features & IEEE_SOFTMAC_SCAN){
 		if (ieee->scanning == 0){
 			ieee->scanning = 1;
 			//ieee80211_softmac_scan(ieee);
-			queue_work(ieee->wq, &ieee->softmac_scan_wq);
+			queue_delayed_work(ieee->wq, &ieee->softmac_scan_wq, 0);
 		}
 	}else
 		ieee->start_scan(ieee->dev);
-	
+
 }
 
 /* called with wx_sem held */
-void ieee80211_start_scan_syncro(struct ieee80211_device *ieee)
+void ieee80211_start_scan_syncro_rtl7(struct ieee80211_device *ieee)
 {
 	ieee->sync_scan_hurryup = 0;
-	
+
 	if (ieee->softmac_features & IEEE_SOFTMAC_SCAN)
-		ieee80211_softmac_scan_syncro(ieee);
+		ieee80211_softmac_scan_syncro_rtl7(ieee);
 	else
 		ieee->scan_syncro(ieee->dev);
-		
+
 }
 
-inline struct sk_buff *ieee80211_authentication_req(struct ieee80211_network *beacon, 
+inline struct sk_buff *ieee80211_authentication_req_rtl7(struct ieee80211_network *beacon,
 	struct ieee80211_device *ieee, int challengelen)
 {
-	struct sk_buff *skb;	
+	struct sk_buff *skb;
 	struct ieee80211_authentication *auth;
-	
-	skb = dev_alloc_skb(sizeof(struct ieee80211_authentication) + challengelen); 
-	
+
+	skb = dev_alloc_skb(sizeof(struct ieee80211_authentication) + challengelen);
+
 	if (!skb) return NULL;
-	
+
 	auth = (struct ieee80211_authentication *)
 		skb_put(skb, sizeof(struct ieee80211_authentication));
-	
+
 	auth->header.frame_ctl = IEEE80211_STYPE_AUTH;
 	if (challengelen) auth->header.frame_ctl |= IEEE80211_FCTL_WEP;
-	
+
 	auth->header.duration_id = 0x013a; //FIXME
-	
+
 	memcpy(auth->header.addr1, beacon->bssid, ETH_ALEN);
 	memcpy(auth->header.addr2, ieee->dev->dev_addr, ETH_ALEN);
 	memcpy(auth->header.addr3, beacon->bssid, ETH_ALEN);
-	
+
 	auth->algorithm = ieee->open_wep ? WLAN_AUTH_OPEN : WLAN_AUTH_SHARED_KEY;
-	
+
 	auth->transaction = cpu_to_le16(ieee->associate_seq);
 	ieee->associate_seq++;
-	
+
 	auth->status = cpu_to_le16(WLAN_STATUS_SUCCESS);
-	
+
 	return skb;
-	
+
 }
 
-static struct sk_buff* ieee80211_probe_resp(struct ieee80211_device *ieee, u8 *dest)
+static struct sk_buff* ieee80211_probe_resp_rtl7(struct ieee80211_device *ieee, u8 *dest)
 {
 	u8 *tag;
 	int beacon_size;
@@ -566,23 +572,23 @@
 	int encrypt;
 	int atim_len,erp_len;
 	struct ieee80211_crypt_data* crypt;
-	
+
 	char *ssid = ieee->current_network.ssid;
 	int ssid_len = ieee->current_network.ssid_len;
 	int rate_len = ieee->current_network.rates_len+2;
 	int rate_ex_len = ieee->current_network.rates_ex_len;
 	if(rate_ex_len > 0) rate_ex_len+=2;
-	
+
 	if(ieee->current_network.capability & WLAN_CAPABILITY_IBSS)
 		atim_len = 4;
 	else
 		atim_len = 0;
-	
-	if(ieee80211_is_54g(ieee->current_network)) 
+
+	if(ieee80211_is_54g_rtl7(ieee->current_network))
 		erp_len = 3;
 	else
 		erp_len = 0;
-	
+
 	beacon_size = sizeof(struct ieee80211_probe_response)+
 		ssid_len
 		+3 //channel
@@ -590,72 +596,72 @@
 		+rate_ex_len
 		+atim_len
 		+erp_len;
-	
+
 	skb = dev_alloc_skb(beacon_size);
-	
-	if (!skb) 
+
+	if (!skb)
 		return NULL;
-	
+
 	beacon_buf = (struct ieee80211_probe_response*) skb_put(skb, beacon_size);
-	
+
 	memcpy (beacon_buf->header.addr1, dest,ETH_ALEN);
 	memcpy (beacon_buf->header.addr2, ieee->dev->dev_addr, ETH_ALEN);
 	memcpy (beacon_buf->header.addr3, ieee->current_network.bssid, ETH_ALEN);
 
 	beacon_buf->header.duration_id = 0; //FIXME
-	beacon_buf->beacon_interval = 
+	beacon_buf->beacon_interval =
 		cpu_to_le16(ieee->current_network.beacon_interval);
-	beacon_buf->capability = 
+	beacon_buf->capability =
 		cpu_to_le16(ieee->current_network.capability & WLAN_CAPABILITY_IBSS);
-	
+
 	if(ieee->short_slot && (ieee->current_network.capability & WLAN_CAPABILITY_SHORT_SLOT))
-		cpu_to_le16((beacon_buf->capability |= WLAN_CAPABILITY_SHORT_SLOT));		
-	
+		cpu_to_le16((beacon_buf->capability |= WLAN_CAPABILITY_SHORT_SLOT));
+
 	crypt = ieee->crypt[ieee->tx_keyidx];
 
-	encrypt = ieee->host_encrypt && crypt && crypt->ops && 
+	encrypt = ieee->host_encrypt && crypt && crypt->ops &&
 		(0 == strcmp(crypt->ops->name, "WEP"));
 
-	if (encrypt)	
+	if (encrypt)
 		beacon_buf->capability |= cpu_to_le16(WLAN_CAPABILITY_PRIVACY);
-	
-		
+
+
 	beacon_buf->header.frame_ctl = cpu_to_le16(IEEE80211_STYPE_PROBE_RESP);
-	
-	beacon_buf->info_element.id = MFIE_TYPE_SSID;	
+
+	beacon_buf->info_element.id = MFIE_TYPE_SSID;
 	beacon_buf->info_element.len = ssid_len;
-	
+
 	tag = (u8*) beacon_buf->info_element.data;
-	
+
 	memcpy(tag, ssid, ssid_len);
-	
+
 	tag += ssid_len;
-	
+
 	*(tag++) = MFIE_TYPE_RATES;
-	*(tag++) = rate_len-2; 
+	*(tag++) = rate_len-2;
 	memcpy(tag,ieee->current_network.rates,rate_len-2);
 	tag+=rate_len-2;
-	
+
 	*(tag++) = MFIE_TYPE_DS_SET;
 	*(tag++) = 1;
 	*(tag++) = ieee->current_network.channel;
-	
+
 	if(atim_len){
 		*(tag++) = MFIE_TYPE_IBSS_SET;
 		*(tag++) = 2;
 		*((u16*)(tag)) = cpu_to_le16(ieee->current_network.atim_window);
 		tag+=2;
 	}
-	
+
 	if(erp_len){
 		*(tag++) = MFIE_TYPE_ERP;
 		*(tag++) = 1;
-		*(tag++) = 0; 
+		*(tag++) = 0;
 	}
-	
+
 	if(rate_ex_len){
 		*(tag++) = MFIE_TYPE_RATES_EX;
-		*(tag++) = rate_ex_len-2; 
+		*(tag++) = rate_ex_len-2;
 		memcpy(tag,ieee->current_network.rates_ex,rate_ex_len-2);
 		tag+=rate_ex_len-2;
 	}
@@ -664,208 +670,211 @@
 }
 
 
-struct sk_buff* ieee80211_assoc_resp(struct ieee80211_device *ieee, u8 *dest)
+struct sk_buff* ieee80211_assoc_resp_rtl7(struct ieee80211_device *ieee, u8 *dest)
 {
 	struct sk_buff *skb;
 	u8* tag;
-	
+
 	struct ieee80211_crypt_data* crypt;
 	struct ieee80211_assoc_response_frame *assoc;
 	short encrypt;
-	
-	unsigned int rate_len = ieee80211_MFIE_rate_len(ieee);
+
+	unsigned int rate_len = ieee80211_MFIE_rate_len_rtl7(ieee);
 	int len = sizeof(struct ieee80211_assoc_response_frame) + rate_len;
-	
-	skb = dev_alloc_skb(len); 
-	
-	if (!skb) 
+
+	skb = dev_alloc_skb(len);
+
+	if (!skb)
 		return NULL;
-	
+
 	assoc = (struct ieee80211_assoc_response_frame *)
 		skb_put(skb,sizeof(struct ieee80211_assoc_response_frame));
-	
+
 	assoc->header.frame_ctl = cpu_to_le16(IEEE80211_STYPE_ASSOC_RESP);
 	memcpy(assoc->header.addr1, dest,ETH_ALEN);
 	memcpy(assoc->header.addr3, ieee->dev->dev_addr, ETH_ALEN);
 	memcpy(assoc->header.addr2, ieee->dev->dev_addr, ETH_ALEN);
-	assoc->capability = cpu_to_le16(ieee->iw_mode == IW_MODE_MASTER ? 
+	assoc->capability = cpu_to_le16(ieee->iw_mode == IW_MODE_MASTER ?
 		WLAN_CAPABILITY_BSS : WLAN_CAPABILITY_IBSS);
-	
-		
+
+
 	if(ieee->short_slot)
 		assoc->capability |= cpu_to_le16(WLAN_CAPABILITY_SHORT_SLOT);
-		
+
 	if (ieee->host_encrypt)
 		crypt = ieee->crypt[ieee->tx_keyidx];
 	else crypt = NULL;
-	
+
 	encrypt = ( crypt && crypt->ops);
-	   
+
 	if (encrypt)
 		assoc->capability |= cpu_to_le16(WLAN_CAPABILITY_PRIVACY);
-	
+
 	assoc->status = 0;
 	assoc->aid = cpu_to_le16(ieee->assoc_id);
 	if (ieee->assoc_id == 0x2007) ieee->assoc_id=0;
 	else ieee->assoc_id++;
-	
+
 	tag = (u8*) skb_put(skb, rate_len);
-	
-	ieee80211_MFIE_Brate(ieee, &tag);
-	ieee80211_MFIE_Grate(ieee, &tag);
-	
+
+	ieee80211_MFIE_Brate_rtl7(ieee, &tag);
+	ieee80211_MFIE_Grate_rtl7(ieee, &tag);
+
 	return skb;
 }
 
-struct sk_buff* ieee80211_auth_resp(struct ieee80211_device *ieee,int status, u8 *dest)
+struct sk_buff* ieee80211_auth_resp_rtl7(struct ieee80211_device *ieee,int status, u8 *dest)
 {
 	struct sk_buff *skb;
 	struct ieee80211_authentication *auth;
-	
-	skb = dev_alloc_skb(sizeof(struct ieee80211_authentication)+1); 
-	
-	if (!skb) 
+
+	skb = dev_alloc_skb(sizeof(struct ieee80211_authentication)+1);
+
+	if (!skb)
 		return NULL;
-	
+
 	skb->len = sizeof(struct ieee80211_authentication);
-	
+
 	auth = (struct ieee80211_authentication *)skb->data;
-	
+
 	auth->status = cpu_to_le16(status);
 	auth->transaction = cpu_to_le16(2);
 	auth->algorithm = cpu_to_le16(WLAN_AUTH_OPEN);
-	
+
 	memcpy(auth->header.addr3, ieee->dev->dev_addr, ETH_ALEN);
 	memcpy(auth->header.addr2, ieee->dev->dev_addr, ETH_ALEN);
 	memcpy(auth->header.addr1, dest, ETH_ALEN);
-	auth->header.frame_ctl = cpu_to_le16(IEEE80211_STYPE_AUTH); 
+	auth->header.frame_ctl = cpu_to_le16(IEEE80211_STYPE_AUTH);
 	return skb;
-	
-	
+
+
 }
 
-struct sk_buff* ieee80211_null_func(struct ieee80211_device *ieee,short pwr)
+struct sk_buff* ieee80211_null_func_rtl7(struct ieee80211_device *ieee,short pwr)
 {
 	struct sk_buff *skb;
 	struct ieee80211_hdr_3addr* hdr;
-	
-	skb = dev_alloc_skb(sizeof(struct ieee80211_hdr_3addr)); 
-	
-	if (!skb) 
+
+	skb = dev_alloc_skb(sizeof(struct ieee80211_hdr_3addr));
+
+	if (!skb)
 		return NULL;
-	
+
 	hdr = (struct ieee80211_hdr_3addr*)skb_put(skb,sizeof(struct ieee80211_hdr_3addr));
-	
+
 	memcpy(hdr->addr1, ieee->current_network.bssid, ETH_ALEN);
 	memcpy(hdr->addr2, ieee->dev->dev_addr, ETH_ALEN);
 	memcpy(hdr->addr3, ieee->current_network.bssid, ETH_ALEN);
-	
-	hdr->frame_ctl = cpu_to_le16(IEEE80211_FTYPE_DATA | 
-		IEEE80211_STYPE_NULLFUNC | IEEE80211_FCTL_TODS | 
-		(pwr ? IEEE80211_FCTL_PM:0)); 
-	
+
+	hdr->frame_ctl = cpu_to_le16(IEEE80211_FTYPE_DATA |
+		IEEE80211_STYPE_NULLFUNC | IEEE80211_FCTL_TODS |
+		(pwr ? IEEE80211_FCTL_PM:0));
+
 	return skb;
-	
-	
+
+
 }
 
 
-void ieee80211_resp_to_assoc_rq(struct ieee80211_device *ieee, u8* dest)
+void ieee80211_resp_to_assoc_rq_rtl7(struct ieee80211_device *ieee, u8* dest)
 {
-	struct sk_buff *buf = ieee80211_assoc_resp(ieee, dest);
-	
+	struct sk_buff *buf = ieee80211_assoc_resp_rtl7(ieee, dest);
+
 	if (buf)
-		softmac_mgmt_xmit(buf, ieee);
+		softmac_mgmt_xmit_rtl7(buf, ieee);
 }
 
 
-void ieee80211_resp_to_auth(struct ieee80211_device *ieee, int s, u8* dest)
+void ieee80211_resp_to_auth_rtl7(struct ieee80211_device *ieee, int s, u8* dest)
 {
-	struct sk_buff *buf = ieee80211_auth_resp(ieee, s, dest);
-	
+	struct sk_buff *buf = ieee80211_auth_resp_rtl7(ieee, s, dest);
+
 	if (buf)
-		softmac_mgmt_xmit(buf, ieee);
+		softmac_mgmt_xmit_rtl7(buf, ieee);
 }
 
 
-void ieee80211_resp_to_probe(struct ieee80211_device *ieee, u8 *dest)
+void ieee80211_resp_to_probe_rtl7(struct ieee80211_device *ieee, u8 *dest)
 {
-	
-	struct sk_buff *buf = ieee80211_probe_resp(ieee, dest);
-	
-	if (buf) 
-		softmac_mgmt_xmit(buf, ieee);
+
+	struct sk_buff *buf = ieee80211_probe_resp_rtl7(ieee, dest);
+
+	if (buf)
+		softmac_mgmt_xmit_rtl7(buf, ieee);
 }
 
 
-inline struct sk_buff *ieee80211_association_req(struct ieee80211_network *beacon,struct ieee80211_device *ieee)
+inline struct sk_buff *ieee80211_association_req_rtl7(struct ieee80211_network *beacon,struct ieee80211_device *ieee)
 {
 	struct sk_buff *skb;
-	
+
 	struct ieee80211_assoc_request_frame *hdr;
 	u8 *tag;
-	
+
 	unsigned int wpa_len = beacon->wpa_ie_len;
-	
-	unsigned int rate_len = ieee80211_MFIE_rate_len(ieee);
-	
-	
-	
+
+	unsigned int rate_len = ieee80211_MFIE_rate_len_rtl7(ieee);
+
+
+
 	int len=sizeof(struct ieee80211_assoc_request_frame)+
 				+ beacon->ssid_len//essid tagged val
 				+ rate_len//rates tagged val
 				+ wpa_len;
-				
+
 	skb = dev_alloc_skb(len);
-	
-	if (!skb) 
+
+	if (!skb)
 		return NULL;
-	
+
 	hdr = (struct ieee80211_assoc_request_frame *)
 		skb_put(skb, sizeof(struct ieee80211_assoc_request_frame));
-	
-	
+
+
 	hdr->header.frame_ctl = IEEE80211_STYPE_ASSOC_REQ;
 	hdr->header.duration_id= 37; //FIXME
 	memcpy(hdr->header.addr1, beacon->bssid, ETH_ALEN);
 	memcpy(hdr->header.addr2, ieee->dev->dev_addr, ETH_ALEN);
 	memcpy(hdr->header.addr3, beacon->bssid, ETH_ALEN);
-	
+
 	hdr->capability = cpu_to_le16(WLAN_CAPABILITY_BSS);
-	if (beacon->capability & WLAN_CAPABILITY_PRIVACY ) 
+	if (beacon->capability & WLAN_CAPABILITY_PRIVACY )
 		hdr->capability |= cpu_to_le16(WLAN_CAPABILITY_PRIVACY);
-	
+
 	if(ieee->short_slot)
 		hdr->capability |= cpu_to_le16(WLAN_CAPABILITY_SHORT_SLOT);
-	
+
+	if(beacon->capability & WLAN_CAPABILITY_SHORT_PREAMBLE)
+		hdr->capability |= cpu_to_le16(WLAN_CAPABILITY_SHORT_PREAMBLE);
+
 	hdr->listen_interval = 0xa; //FIXME
-	
+
 	hdr->info_element.id = MFIE_TYPE_SSID;
 
 	hdr->info_element.len = beacon->ssid_len;
 	tag = skb_put(skb, beacon->ssid_len);
 	memcpy(tag, beacon->ssid, beacon->ssid_len);
-	
-	tag = skb_put(skb, rate_len); 
-	
-	ieee80211_MFIE_Brate(ieee, &tag);
-	ieee80211_MFIE_Grate(ieee, &tag);
-	
+
+	tag = skb_put(skb, rate_len);
+
+	ieee80211_MFIE_Brate_rtl7(ieee, &tag);
+	ieee80211_MFIE_Grate_rtl7(ieee, &tag);
+
 	tag = skb_put(skb,wpa_len);
-	
+
 	memcpy(tag,beacon->wpa_ie,wpa_len);
-	
+
 	return skb;
 }
 
-void ieee80211_associate_abort(struct ieee80211_device *ieee)
+void ieee80211_associate_abort_rtl7(struct ieee80211_device *ieee)
 {
-	
+
 	unsigned long flags;
 	spin_lock_irqsave(&ieee->lock, flags);
-	
+
 	ieee->associate_seq++;
-	
+
 	/* don't scan, and avoid to have the RX path possibily
 	 * try again to associate. Even do not react to AUTH or
 	 * ASSOC response. Just wait for the retry wq to be scheduled.
@@ -873,166 +882,181 @@
 	 * with, so we retry or just get back to NO_LINK and scanning
 	 */
 	if (ieee->state == IEEE80211_ASSOCIATING_AUTHENTICATING){
-		IEEE80211_DEBUG_MGMT("Authentication failed\n"); 
+		IEEE80211_DEBUG_MGMT("Authentication failed\n");
 		ieee->softmac_stats.no_auth_rs++;
 	}else{
-		IEEE80211_DEBUG_MGMT("Association failed\n"); 
+		IEEE80211_DEBUG_MGMT("Association failed\n");
 		ieee->softmac_stats.no_ass_rs++;
 	}
-		
+
 	ieee->state = IEEE80211_ASSOCIATING_RETRY;
-		
+
 	queue_delayed_work(ieee->wq, &ieee->associate_retry_wq, IEEE80211_SOFTMAC_ASSOC_RETRY_TIME);
-	
+
 	spin_unlock_irqrestore(&ieee->lock, flags);
 }
 
-void ieee80211_associate_abort_cb(unsigned long dev)
+void ieee80211_associate_abort_cb_rtl7(unsigned long dev)
 {
-	ieee80211_associate_abort((struct ieee80211_device *) dev);
+	ieee80211_associate_abort_rtl7((struct ieee80211_device *) dev);
 }
 
 
-void ieee80211_associate_step1(struct ieee80211_device *ieee)
+void ieee80211_associate_step1_rtl7(struct ieee80211_device *ieee)
 {
 	struct ieee80211_network *beacon = &ieee->current_network;
 	struct sk_buff *skb;
-	
+
 	IEEE80211_DEBUG_MGMT("Stopping scan\n");
-	
+
 	ieee->softmac_stats.tx_auth_rq++;
-	skb=ieee80211_authentication_req(beacon, ieee, 0);
-	
-	if (!skb) 
-		ieee80211_associate_abort(ieee);
-	else{ 
+	skb=ieee80211_authentication_req_rtl7(beacon, ieee, 0);
+
+	if (!skb)
+		ieee80211_associate_abort_rtl7(ieee);
+	else{
 		ieee->state = IEEE80211_ASSOCIATING_AUTHENTICATING ;
 		IEEE80211_DEBUG_MGMT("Sending authentication request\n");
-		softmac_mgmt_xmit(skb, ieee);
+		softmac_mgmt_xmit_rtl7(skb, ieee);
 		ieee->associate_timer.expires = jiffies + (HZ / 2);
 		add_timer(&ieee->associate_timer);
-	}	
+	}
 }
 
-void ieee80211_auth_challenge(struct ieee80211_device *ieee, u8 *challenge, int chlen)
+void ieee80211_auth_challenge_rtl7(struct ieee80211_device *ieee, u8 *challenge, int chlen)
 {
-	u8 *c;	
+	u8 *c;
 	struct sk_buff *skb;
 	struct ieee80211_network *beacon = &ieee->current_network;
 //	int hlen = sizeof(struct ieee80211_authentication);
-	
+
 	ieee->associate_seq++;
 	ieee->softmac_stats.tx_auth_rq++;
-	
-	skb = ieee80211_authentication_req(beacon, ieee, chlen+2);
-	if (!skb) 
-		ieee80211_associate_abort(ieee);
+
+	skb = ieee80211_authentication_req_rtl7(beacon, ieee, chlen+2);
+	if (!skb)
+		ieee80211_associate_abort_rtl7(ieee);
 	else{
 		c = skb_put(skb, chlen+2);
 		*(c++) = MFIE_TYPE_CHALLENGE;
 		*(c++) = chlen;
 		memcpy(c, challenge, chlen);
-		
+
 		IEEE80211_DEBUG_MGMT("Sending authentication challenge response\n");
-		
-		ieee80211_encrypt_fragment(ieee, skb, sizeof(struct ieee80211_hdr_3addr  ));
-			
-		softmac_mgmt_xmit(skb, ieee);
+
+		ieee80211_encrypt_fragment_rtl7(ieee, skb, sizeof(struct ieee80211_hdr_3addr  ));
+
+		softmac_mgmt_xmit_rtl7(skb, ieee);
 		ieee->associate_timer.expires = jiffies + (HZ / 2);
 		add_timer(&ieee->associate_timer);
-	}	
+	}
 	kfree(challenge);
 }
 
-void ieee80211_associate_step2(struct ieee80211_device *ieee)
+void ieee80211_associate_step2_rtl7(struct ieee80211_device *ieee)
 {
 	struct sk_buff* skb;
 	struct ieee80211_network *beacon = &ieee->current_network;
-	
+
 	del_timer_sync(&ieee->associate_timer);
-	
+
 	IEEE80211_DEBUG_MGMT("Sending association request\n");
-	
+
 	ieee->softmac_stats.tx_ass_rq++;
-	skb=ieee80211_association_req(beacon, ieee);
-	if (!skb) 
-		ieee80211_associate_abort(ieee);
+	skb=ieee80211_association_req_rtl7(beacon, ieee);
+	if (!skb)
+		ieee80211_associate_abort_rtl7(ieee);
 	else{
-		softmac_mgmt_xmit(skb, ieee);
+		softmac_mgmt_xmit_rtl7(skb, ieee);
 		ieee->associate_timer.expires = jiffies + (HZ / 2);
 		add_timer(&ieee->associate_timer);
-	}	
+	}
 }
 
-void ieee80211_associate_complete_wq(struct ieee80211_device *ieee)
+# if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20))
+void ieee80211_associate_complete_wq_rtl7(struct work_struct *work)
+{
+	struct ieee80211_device *ieee = container_of(work, struct ieee80211_device, associate_complete_wq);
+#else
+void ieee80211_associate_complete_wq_rtl7(struct ieee80211_device *ieee)
 {
+#endif
 	printk(KERN_INFO "Associated successfully\n");
-	if(ieee80211_is_54g(ieee->current_network) && 
+#if 0
+	if(ieee80211_is_54g_rtl7(ieee->current_network) &&
 		(ieee->modulation & IEEE80211_OFDM_MODULATION)){
-		
+
 		ieee->rate = 540;
 		printk(KERN_INFO"Using G rates\n");
 	}else{
 		ieee->rate = 110;
 		printk(KERN_INFO"Using B rates\n");
 	}
+#else
+	printk(KERN_INFO"Using %d MBit\n", (ieee->rate/10) );
+#endif
 	ieee->link_change(ieee->dev);
-	notify_wx_assoc_event(ieee); 
+	notify_wx_assoc_event_rtl7(ieee);
 	if (ieee->data_hard_resume)
 		ieee->data_hard_resume(ieee->dev);
 	netif_carrier_on(ieee->dev);
 }
 
-void ieee80211_associate_complete(struct ieee80211_device *ieee)
+void ieee80211_associate_complete_rtl7(struct ieee80211_device *ieee)
 {
 
 	del_timer_sync(&ieee->associate_timer);
-	
+
 	ieee->seq_ctrl = 0;
 	ieee->state = IEEE80211_LINKED;
 	IEEE80211_DEBUG_MGMT("Successfully associated\n");
-	
+
 	queue_work(ieee->wq, &ieee->associate_complete_wq);
 }
 
-void ieee80211_associate_procedure_wq(struct ieee80211_device *ieee)
+# if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20))
+void ieee80211_associate_procedure_wq_rtl7(struct work_struct *work)
 {
+	struct ieee80211_device *ieee = container_of(work, struct ieee80211_device, associate_procedure_wq);
+#else
+void ieee80211_associate_procedure_wq_rtl7(struct ieee80211_device *ieee)
+{
+#endif
 	ieee->sync_scan_hurryup = 1;
 	down(&ieee->wx_sem);
-	
 	if (ieee->data_hard_stop)
 		ieee->data_hard_stop(ieee->dev);
-	
-	ieee80211_stop_scan(ieee);
+
+	ieee80211_stop_scan_rtl7(ieee);
 	ieee->set_chan(ieee->dev, ieee->current_network.channel);
-	
+
 	ieee->associate_seq = 1;
-	ieee80211_associate_step1(ieee);
-	
+	ieee80211_associate_step1_rtl7(ieee);
+
 	up(&ieee->wx_sem);
 }
 
-inline void ieee80211_softmac_new_net(struct ieee80211_device *ieee, struct ieee80211_network *net)
+inline void ieee80211_softmac_new_net_rtl7(struct ieee80211_device *ieee, struct ieee80211_network *net)
 {
-	
+
 	u8 tmp_ssid[IW_ESSID_MAX_SIZE+1];
 	int tmp_ssid_len = 0;
-	
+
 	short apset,ssidset,ssidbroad,apmatch,ssidmatch;
-	
-	/* we are interested in new new only if we are not associated 
+
+	/* we are interested in new new only if we are not associated
 	 * and we are not associating / authenticating
 	 */
 	if (ieee->state != IEEE80211_NOLINK)
-		return; 
-		
+		return;
+
 	if ((ieee->iw_mode == IW_MODE_INFRA) && !(net->capability & WLAN_CAPABILITY_BSS))
 		return;
-	
+
 	if ((ieee->iw_mode == IW_MODE_ADHOC) && !(net->capability & WLAN_CAPABILITY_IBSS))
 		return;
 
-	
+
 	if (ieee->iw_mode == IW_MODE_INFRA || ieee->iw_mode == IW_MODE_ADHOC){
 		/* if the user specified the AP MAC, we need also the essid
 		 * This could be obtained by beacons or, if the network does not
@@ -1043,23 +1067,23 @@
 		ssidbroad =  !(net->ssid_len == 0 || net->ssid[0]== '\0');
 		apmatch = (memcmp(ieee->current_network.bssid, net->bssid, ETH_ALEN)==0);
 		ssidmatch = (0==strncmp(ieee->current_network.ssid, net->ssid, net->ssid_len));
-		
-		
-		
+
+
+
 		if (	/* if the user set the AP check if match.
 		         * if the network does not broadcast essid we check the user supplyed ANY essid
 			 * if the network does broadcast and the user does not set essid it is OK
 			 * if the network does broadcast and the user did set essid chech if essid match
 			 */
-			( apset && apmatch && 
-				((ssidset && ssidbroad && ssidmatch) || (ssidbroad && !ssidset) || (!ssidbroad && ssidset)) ) ||  
+			( apset && apmatch &&
+				((ssidset && ssidbroad && ssidmatch) || (ssidbroad && !ssidset) || (!ssidbroad && ssidset)) ) ||
 			/* if the ap is not set, check that the user set the bssid
 			 * and the network does bradcast and that those two bssid matches
-			 */ 
-			(!apset && ssidset && ssidbroad && ssidmatch) 
+			 */
+			(!apset && ssidset && ssidbroad && ssidmatch)
 			){
-			
-			
+
+
 				/* if the essid is hidden replace it with the
 				* essid provided by the user.
 				*/
@@ -1068,18 +1092,19 @@
 					tmp_ssid_len = ieee->current_network.ssid_len;
 				}
 				memcpy(&ieee->current_network, net, sizeof(struct ieee80211_network));
-				
+
 				if (!ssidbroad){
 					strncpy(ieee->current_network.ssid, tmp_ssid, IW_ESSID_MAX_SIZE);
 					ieee->current_network.ssid_len = tmp_ssid_len;
 				}
-				printk(KERN_INFO"Linking with %s\n",ieee->current_network.ssid);
-				
+				printk(KERN_INFO"Linking with \"%s\" rate: %d MBit\n",ieee->current_network.ssid, (ieee->rate/10));
+
 				if (ieee->iw_mode == IW_MODE_INFRA){
 					ieee->state = IEEE80211_ASSOCIATING;
 					queue_work(ieee->wq, &ieee->associate_procedure_wq);
 				}else{
-					if(ieee80211_is_54g(ieee->current_network) && 
+#if 0
+					if(ieee80211_is_54g_rtl7(ieee->current_network) &&
 						(ieee->modulation & IEEE80211_OFDM_MODULATION)){
 						ieee->rate = 540;
 						printk(KERN_INFO"Using G rates\n");
@@ -1087,44 +1112,45 @@
 						ieee->rate = 110;
 						printk(KERN_INFO"Using B rates\n");
 					}
+#else
+					printk(KERN_INFO"Using %d MBit\n", (ieee->rate/10) );
+#endif
 					ieee->state = IEEE80211_LINKED;
 				}
-			
+
 		}
 	}
-
 }
 
-void ieee80211_softmac_check_all_nets(struct ieee80211_device *ieee)
+void ieee80211_softmac_check_all_nets_rtl7(struct ieee80211_device *ieee)
 {
-	
+
 	unsigned long flags;
 	struct ieee80211_network *target;
-	
+
 	spin_lock_irqsave(&ieee->lock, flags);
-			
 	list_for_each_entry(target, &ieee->network_list, list) {
-		
+
 		/* if the state become different that NOLINK means
 		 * we had found what we are searching for
 		 */
-		if (ieee->state != IEEE80211_NOLINK) 
+		if (ieee->state != IEEE80211_NOLINK)
 			break;
-			
+
 		//if (ieee->scan_age == 0 || time_after(target->last_scanned + ieee->scan_age, jiffies))
-			ieee80211_softmac_new_net(ieee, target);
+			ieee80211_softmac_new_net_rtl7(ieee, target);
 	}
-	
+
 	spin_unlock_irqrestore(&ieee->lock, flags);
-	
+
 }
 
 
-static inline u16 auth_parse(struct sk_buff *skb, u8** challenge, int *chlen)
+static inline u16 auth_parse_rtl7(struct sk_buff *skb, u8** challenge, int *chlen)
 {
 	struct ieee80211_authentication *a;
 	u8 *t;
-	if (skb->len <  (sizeof(struct ieee80211_authentication)-sizeof(struct ieee80211_info_element))){ 
+	if (skb->len <  (sizeof(struct ieee80211_authentication)-sizeof(struct ieee80211_info_element))){
 		IEEE80211_DEBUG_MGMT("invalid len in auth resp: %d\n",skb->len);
 		return 0xcafe;
 	}
@@ -1132,58 +1158,58 @@
 	a = (struct ieee80211_authentication*) skb->data;
 	if(skb->len > (sizeof(struct ieee80211_authentication) +3)){
 		t = skb->data + sizeof(struct ieee80211_authentication);
-		
+
 		if(*(t++) == MFIE_TYPE_CHALLENGE){
 			*chlen = *(t++);
 			*challenge = (u8*)kmalloc(*chlen, GFP_ATOMIC);
 			memcpy(*challenge, t, *chlen);
 		}
 	}
-	
+
 	return cpu_to_le16(a->status);
-	
+
 }
 
 
-int auth_rq_parse(struct sk_buff *skb,u8* dest)
+int auth_rq_parse_rtl7(struct sk_buff *skb,u8* dest)
 {
 	struct ieee80211_authentication *a;
-	
-	if (skb->len <  (sizeof(struct ieee80211_authentication)-sizeof(struct ieee80211_info_element))){ 
-		IEEE80211_DEBUG_MGMT("invalid len in auth request: %d\n",skb->len);	
+
+	if (skb->len <  (sizeof(struct ieee80211_authentication)-sizeof(struct ieee80211_info_element))){
+		IEEE80211_DEBUG_MGMT("invalid len in auth request: %d\n",skb->len);
 		return -1;
 	}
 	a = (struct ieee80211_authentication*) skb->data;
-	
+
 	memcpy(dest,a->header.addr2, ETH_ALEN);
-	
-	if (le16_to_cpu(a->algorithm) != WLAN_AUTH_OPEN) 
+
+	if (le16_to_cpu(a->algorithm) != WLAN_AUTH_OPEN)
 		return  WLAN_STATUS_NOT_SUPPORTED_AUTH_ALG;
-	
+
 	return WLAN_STATUS_SUCCESS;
 }
 
-static short probe_rq_parse(struct ieee80211_device *ieee, struct sk_buff *skb, u8 *src)
+static short probe_rq_parse_rtl7(struct ieee80211_device *ieee, struct sk_buff *skb, u8 *src)
 {
 	u8 *tag;
 	u8 *skbend;
 	u8 *ssid=NULL;
 	u8 ssidlen = 0;
-	
+
 	struct ieee80211_hdr_3addr   *header =
 		(struct ieee80211_hdr_3addr   *) skb->data;
-	
-	if (skb->len < sizeof (struct ieee80211_hdr_3addr  )) 
+
+	if (skb->len < sizeof (struct ieee80211_hdr_3addr  ))
 		return -1; /* corrupted */
-	
+
 	memcpy(src,header->addr2, ETH_ALEN);
-	
+
 	skbend = (u8*)skb->data + skb->len;
-	
+
 	tag = skb->data + sizeof (struct ieee80211_hdr_3addr  );
-	
+
 	while (tag+1 < skbend){
-		if (*tag == 0){ 
+		if (*tag == 0){
 			ssid = tag+2;
 			ssidlen = *(tag+1);
 			break;
@@ -1192,88 +1218,88 @@
 		tag = tag + *(tag); /* point to the last data byte of the tag */
 		tag++; /* point to the next tag */
 	}
-	
+
 	//IEEE80211DMESG("Card MAC address is "MACSTR, MAC2STR(src));
 	if (ssidlen == 0) return 1;
-	
+
 	if (!ssid) return 1; /* ssid not found in tagged param */
 	return (!strncmp(ssid, ieee->current_network.ssid, ssidlen));
-		
+
 }
 
-int assoc_rq_parse(struct sk_buff *skb,u8* dest)
+int assoc_rq_parse_rtl7(struct sk_buff *skb,u8* dest)
 {
 	struct ieee80211_assoc_request_frame *a;
-	
-	if (skb->len < (sizeof(struct ieee80211_assoc_request_frame) - 
-		sizeof(struct ieee80211_info_element))) { 
-		
+
+	if (skb->len < (sizeof(struct ieee80211_assoc_request_frame) -
+		sizeof(struct ieee80211_info_element))) {
+
 		IEEE80211_DEBUG_MGMT("invalid len in auth request:%d \n", skb->len);
 		return -1;
 	}
-	
+
 	a = (struct ieee80211_assoc_request_frame*) skb->data;
-		
+
 	memcpy(dest,a->header.addr2,ETH_ALEN);
-	
+
 	return 0;
 }
 
-static inline u16 assoc_parse(struct sk_buff *skb, int *aid)
+static inline u16 assoc_parse_rtl7(struct sk_buff *skb, int *aid)
 {
 	struct ieee80211_assoc_response_frame *a;
-	if (skb->len <  sizeof(struct ieee80211_assoc_response_frame)){ 
+	if (skb->len <  sizeof(struct ieee80211_assoc_response_frame)){
 		IEEE80211_DEBUG_MGMT("invalid len in auth resp: %d\n", skb->len);
 		return 0xcafe;
 	}
-	
+
 	a = (struct ieee80211_assoc_response_frame*) skb->data;
 	*aid = le16_to_cpu(a->aid) & 0x3fff;
 	return le16_to_cpu(a->status);
 }
 
 static inline void
-ieee80211_rx_probe_rq(struct ieee80211_device *ieee, struct sk_buff *skb)
+ieee80211_rx_probe_rq_rtl7(struct ieee80211_device *ieee, struct sk_buff *skb)
 {
 	u8 dest[ETH_ALEN];
-	
+
 	//IEEE80211DMESG("Rx probe");
 	ieee->softmac_stats.rx_probe_rq++;
 	//DMESG("Dest is "MACSTR, MAC2STR(dest));
-	if (probe_rq_parse(ieee, skb, dest)){
+	if (probe_rq_parse_rtl7(ieee, skb, dest)){
 		//IEEE80211DMESG("Was for me!");
 		ieee->softmac_stats.tx_probe_rs++;
-		ieee80211_resp_to_probe(ieee, dest);
+		ieee80211_resp_to_probe_rtl7(ieee, dest);
 	}
 }
 
 static inline void
-ieee80211_rx_auth_rq(struct ieee80211_device *ieee, struct sk_buff *skb)
+ieee80211_rx_auth_rq_rtl7(struct ieee80211_device *ieee, struct sk_buff *skb)
 {
 	u8 dest[ETH_ALEN];
 	int status;
 	//IEEE80211DMESG("Rx probe");
 	ieee->softmac_stats.rx_auth_rq++;
-	
-	if ((status = auth_rq_parse(skb, dest))!= -1){
-		ieee80211_resp_to_auth(ieee, status, dest);
+
+	if ((status = auth_rq_parse_rtl7(skb, dest))!= -1){
+		ieee80211_resp_to_auth_rtl7(ieee, status, dest);
 	}
 	//DMESG("Dest is "MACSTR, MAC2STR(dest));
-	
+
 }
 
 static inline void
-ieee80211_rx_assoc_rq(struct ieee80211_device *ieee, struct sk_buff *skb)
+ieee80211_rx_assoc_rq_rtl7(struct ieee80211_device *ieee, struct sk_buff *skb)
 {
-	
+
 	u8 dest[ETH_ALEN];
 	//unsigned long flags;
-	
+
 	ieee->softmac_stats.rx_ass_rq++;
-	if (assoc_rq_parse(skb,dest) != -1){
-		ieee80211_resp_to_assoc_rq(ieee, dest);
+	if (assoc_rq_parse_rtl7(skb,dest) != -1){
+		ieee80211_resp_to_assoc_rq_rtl7(ieee, dest);
 	}
-	
+
 	printk(KERN_INFO"New client associated: "MAC_FMT"\n", MAC_ARG(dest));
 	//FIXME
 	#if 0
@@ -1285,25 +1311,25 @@
 
 
 
-void ieee80211_sta_ps_send_null_frame(struct ieee80211_device *ieee, short pwr)
+void ieee80211_sta_ps_send_null_frame_rtl7(struct ieee80211_device *ieee, short pwr)
 {
-	
-	struct sk_buff *buf = ieee80211_null_func(ieee, pwr);
-	
+
+	struct sk_buff *buf = ieee80211_null_func_rtl7(ieee, pwr);
+
 	if (buf)
-		softmac_ps_mgmt_xmit(buf, ieee);
+		softmac_ps_mgmt_xmit_rtl7(buf, ieee);
 
-} 
+}
 
 
-short ieee80211_sta_ps_sleep(struct ieee80211_device *ieee, u32 *time_h, u32 *time_l)
-{	
+short ieee80211_sta_ps_sleep_rtl7(struct ieee80211_device *ieee, u32 *time_h, u32 *time_l)
+{
 	int timeout = ieee->ps_timeout;
 	u8 dtim;
 	/*if(ieee->ps == IEEE80211_PS_DISABLED ||
-		ieee->iw_mode != IW_MODE_INFRA || 
+		ieee->iw_mode != IW_MODE_INFRA ||
 		ieee->state != IEEE80211_LINKED)
-		
+
 		return 0;
 	*/
 	dtim = ieee->current_network.dtim_data;
@@ -1312,133 +1338,133 @@
 		return 0;
 	//printk("VALID\n");
 	ieee->current_network.dtim_data = IEEE80211_DTIM_INVALID;
-		
+
 	if(dtim & ((IEEE80211_DTIM_UCAST | IEEE80211_DTIM_MBCAST)& ieee->ps))
 		return 2;
-	
+
 	if(!time_after(jiffies, ieee->dev->trans_start + MSECS(timeout)))
 		return 0;
-	
+
 	if(!time_after(jiffies, ieee->last_rx_ps_time + MSECS(timeout)))
 		return 0;
-	
+
 	if((ieee->softmac_features & IEEE_SOFTMAC_SINGLE_QUEUE ) &&
 		(ieee->mgmt_queue_tail != ieee->mgmt_queue_head))
 		return 0;
-	
+
 	if(time_l){
-		*time_l = ieee->current_network.last_dtim_sta_time[0] 
-			+ (ieee->current_network.beacon_interval 
+		*time_l = ieee->current_network.last_dtim_sta_time[0]
+			+ (ieee->current_network.beacon_interval
 			* ieee->current_network.dtim_period) * 1000;
 	}
-	
+
 	if(time_h){
 		*time_h = ieee->current_network.last_dtim_sta_time[1];
 		if(time_l && *time_l < ieee->current_network.last_dtim_sta_time[0])
 			*time_h += 1;
 	}
-	
+
 	return 1;
-	
-	
+
+
 }
 
-inline void ieee80211_sta_ps(struct ieee80211_device *ieee)
+inline void ieee80211_sta_ps_rtl7(struct ieee80211_device *ieee)
 {
 
 	u32 th,tl;
 	short sleep;
-	
+
 	unsigned long flags,flags2;
-	
+
 	spin_lock_irqsave(&ieee->lock, flags);
-	
+
 	if((ieee->ps == IEEE80211_PS_DISABLED ||
-		ieee->iw_mode != IW_MODE_INFRA || 
+		ieee->iw_mode != IW_MODE_INFRA ||
 		ieee->state != IEEE80211_LINKED)){
-		
-		#warning CHECK_LOCK_HERE
+
+//		#warning CHECK_LOCK_HERE
 		spin_lock_irqsave(&ieee->mgmt_tx_lock, flags2);
-		
-		ieee80211_sta_wakeup(ieee, 1);	
-		
+
+		ieee80211_sta_wakeup_rtl7(ieee, 1);
+		printk(KERN_WARNING "wakeup 1!\n" );
 		spin_unlock_irqrestore(&ieee->mgmt_tx_lock, flags2);
 	}
-	
-	sleep = ieee80211_sta_ps_sleep(ieee,&th, &tl);
+
+	sleep = ieee80211_sta_ps_sleep_rtl7(ieee,&th, &tl);
 	/* 2 wake, 1 sleep, 0 do nothing */
 	if(sleep == 0)
 		goto out;
-	
+
 	if(sleep == 1){
-	
+
 		if(ieee->sta_sleep == 1)
 			ieee->enter_sleep_state(ieee->dev,th,tl);
-		
+
 		else if(ieee->sta_sleep == 0){
 		//	printk("send null 1\n");
 			spin_lock_irqsave(&ieee->mgmt_tx_lock, flags2);
-			
+
 			if(ieee->ps_is_queue_empty(ieee->dev)){
-				
-			
+
+
 				ieee->sta_sleep = 2;
-				
+
 				ieee->ps_request_tx_ack(ieee->dev);
-				
-				ieee80211_sta_ps_send_null_frame(ieee,1);
-				
+
+				ieee80211_sta_ps_send_null_frame_rtl7(ieee,1);
+
 				ieee->ps_th = th;
 				ieee->ps_tl = tl;
-			}		
+			}
 			spin_unlock_irqrestore(&ieee->mgmt_tx_lock, flags2);
-			
+
 		}
-		
-		
+
+
 	}else if(sleep == 2){
-#warning CHECK_LOCK_HERE
+// #warning CHECK_LOCK_HERE
 		spin_lock_irqsave(&ieee->mgmt_tx_lock, flags2);
-			
-		ieee80211_sta_wakeup(ieee,1);
-		
+
+		ieee80211_sta_wakeup_rtl7(ieee,1);
+		printk(KERN_WARNING "wakeup 2!\n" );
 		spin_unlock_irqrestore(&ieee->mgmt_tx_lock, flags2);
 	}
 
-out:	
+out:
 	spin_unlock_irqrestore(&ieee->lock, flags);
-	
+
 }
 
-void ieee80211_sta_wakeup(struct ieee80211_device *ieee, short nl)
+void ieee80211_sta_wakeup_rtl7(struct ieee80211_device *ieee, short nl)
 {
 	if(ieee->sta_sleep == 0){
 		if(nl){
 			printk("Warning: driver is probably failing to report TX ps error\n");
 			ieee->ps_request_tx_ack(ieee->dev);
-			ieee80211_sta_ps_send_null_frame(ieee, 0);
+			ieee80211_sta_ps_send_null_frame_rtl7(ieee, 0);
 		}
 		return;
-		
+
 	}
-	
-	if(ieee->sta_sleep == 1) 
+
+	if(ieee->sta_sleep == 1)
 		ieee->sta_wake_up(ieee->dev);
-		
+
 	ieee->sta_sleep = 0;
-	
+
 	if(nl){
 		ieee->ps_request_tx_ack(ieee->dev);
-		ieee80211_sta_ps_send_null_frame(ieee, 0);
+		ieee80211_sta_ps_send_null_frame_rtl7(ieee, 0);
 	}
 }
 
-void ieee80211_ps_tx_ack(struct ieee80211_device *ieee, short success)
+void ieee80211_ps_tx_ack_rtl7(struct ieee80211_device *ieee, short success)
 {
 	unsigned long flags,flags2;
-	
+
 	spin_lock_irqsave(&ieee->lock, flags);
-	
+
 	if(ieee->sta_sleep == 2){
 		/* Null frame with PS bit set */
 		if(success){
@@ -1451,10 +1477,10 @@
 	}
 	/* 21112005 - tx again null without PS bit if lost */
 	else {
-	
+
 		if((ieee->sta_sleep == 0) && !success){
 			spin_lock_irqsave(&ieee->mgmt_tx_lock, flags2);
-			ieee80211_sta_ps_send_null_frame(ieee, 0);
+			ieee80211_sta_ps_send_null_frame_rtl7(ieee, 0);
 			spin_unlock_irqrestore(&ieee->mgmt_tx_lock, flags2);
 		}
 	}
@@ -1462,129 +1488,132 @@
 }
 
 inline int
-ieee80211_rx_frame_softmac(struct ieee80211_device *ieee, struct sk_buff *skb,
+ieee80211_rx_frame_softmac_rtl7(struct ieee80211_device *ieee, struct sk_buff *skb,
 			struct ieee80211_rx_stats *rx_stats, u16 type,
 			u16 stype)
 {
 	struct ieee80211_hdr_3addr *header;
-	header = (struct ieee80211_hdr_3addr *) skb->data;
 	u16 errcode;
 	u8* challenge;
 	int chlen;
 	int aid;
-	
+
+	chlen = 0;
+
+	header = (struct ieee80211_hdr_3addr *) skb->data;
+
 	if(!ieee->proto_started)
 		return 0;
-	
+
 	if(ieee->sta_sleep || (ieee->ps != IEEE80211_PS_DISABLED &&
-		ieee->iw_mode == IW_MODE_INFRA && 
+		ieee->iw_mode == IW_MODE_INFRA &&
 		ieee->state == IEEE80211_LINKED))
-	
+
 		tasklet_schedule(&ieee->ps_task);
-				
+
 	if(WLAN_FC_GET_STYPE(header->frame_ctl) != IEEE80211_STYPE_PROBE_RESP &&
 		WLAN_FC_GET_STYPE(header->frame_ctl) != IEEE80211_STYPE_BEACON)
 		ieee->last_rx_ps_time = jiffies;
-		
+
 	switch (WLAN_FC_GET_STYPE(header->frame_ctl)) {
-	
+
 		case IEEE80211_STYPE_ASSOC_RESP:
 		case IEEE80211_STYPE_REASSOC_RESP:
-		
+
 			IEEE80211_DEBUG_MGMT("received [RE]ASSOCIATION RESPONSE (%d)\n",
 					WLAN_FC_GET_STYPE(header->frame_ctl));
 			if ((ieee->softmac_features & IEEE_SOFTMAC_ASSOCIATE) &&
-				ieee->state == IEEE80211_ASSOCIATING_AUTHENTICATED && 
+				ieee->state == IEEE80211_ASSOCIATING_AUTHENTICATED &&
 				ieee->iw_mode == IW_MODE_INFRA){
-				if (0 == (errcode=assoc_parse(skb, &aid))){
-					
+				if (0 == (errcode=assoc_parse_rtl7(skb, &aid))){
+
 					ieee->state=IEEE80211_LINKED;
 					ieee->assoc_id = aid;
 					ieee->softmac_stats.rx_ass_ok++;
-					
-					ieee80211_associate_complete(ieee);
+
+					ieee80211_associate_complete_rtl7(ieee);
 				}else{
 					ieee->softmac_stats.rx_ass_err++;
 					IEEE80211_DEBUG_MGMT(
 						"Association response status code 0x%x\n",
 						errcode);
-					ieee80211_associate_abort(ieee); 
+					ieee80211_associate_abort_rtl7(ieee);
 				}
 			}
 			break;
-		
+
 		case IEEE80211_STYPE_ASSOC_REQ:
 		case IEEE80211_STYPE_REASSOC_REQ:
-		
+
 			if ((ieee->softmac_features & IEEE_SOFTMAC_ASSOCIATE) &&
 				ieee->iw_mode == IW_MODE_MASTER)
-					
-				ieee80211_rx_assoc_rq(ieee, skb);
+
+				ieee80211_rx_assoc_rq_rtl7(ieee, skb);
 			break;
-			
+
 		case IEEE80211_STYPE_AUTH:
-		
+
 			if (ieee->softmac_features & IEEE_SOFTMAC_ASSOCIATE){
-				if (ieee->state == IEEE80211_ASSOCIATING_AUTHENTICATING && 
+				if (ieee->state == IEEE80211_ASSOCIATING_AUTHENTICATING &&
 				ieee->iw_mode == IW_MODE_INFRA){
-			
+
 						IEEE80211_DEBUG_MGMT("Received authentication response");
-						
-						if (0 == (errcode=auth_parse(skb, &challenge, &chlen))){
+
+						if (0 == (errcode=auth_parse_rtl7(skb, &challenge, &chlen))){
 							if(ieee->open_wep || !challenge){
 								ieee->state = IEEE80211_ASSOCIATING_AUTHENTICATED;
 								ieee->softmac_stats.rx_auth_rs_ok++;
-								
-								ieee80211_associate_step2(ieee);
+
+								ieee80211_associate_step2_rtl7(ieee);
 							}else{
-								ieee80211_auth_challenge(ieee, challenge, chlen);
+								ieee80211_auth_challenge_rtl7(ieee, challenge, chlen);
 							}
 						}else{
 							ieee->softmac_stats.rx_auth_rs_err++;
 							IEEE80211_DEBUG_MGMT("Authentication respose status code 0x%x",errcode);
-							ieee80211_associate_abort(ieee);
+							ieee80211_associate_abort_rtl7(ieee);
 						}
-						
+
 					}else if (ieee->iw_mode == IW_MODE_MASTER){
-						ieee80211_rx_auth_rq(ieee, skb);
+						ieee80211_rx_auth_rq_rtl7(ieee, skb);
 					}
 				}
 			break;
-				
+
 		case IEEE80211_STYPE_PROBE_REQ:
-		
-			if ((ieee->softmac_features & IEEE_SOFTMAC_PROBERS) && 
-				((ieee->iw_mode == IW_MODE_ADHOC || 
+
+			if ((ieee->softmac_features & IEEE_SOFTMAC_PROBERS) &&
+				((ieee->iw_mode == IW_MODE_ADHOC ||
 				ieee->iw_mode == IW_MODE_MASTER) &&
 				ieee->state == IEEE80211_LINKED))
-				
-				ieee80211_rx_probe_rq(ieee, skb);
+
+				ieee80211_rx_probe_rq_rtl7(ieee, skb);
 			break;
-			
+
 		case IEEE80211_STYPE_DISASSOC:
 		case IEEE80211_STYPE_DEAUTH:
-			/* FIXME for now repeat all the association procedure 
+			/* FIXME for now repeat all the association procedure
 			* both for disassociation and deauthentication
 			*/
 			if ((ieee->softmac_features & IEEE_SOFTMAC_ASSOCIATE) &&
-				ieee->state == IEEE80211_LINKED && 
+				ieee->state == IEEE80211_LINKED &&
 				ieee->iw_mode == IW_MODE_INFRA){
-				
+
 				ieee->state = IEEE80211_ASSOCIATING;
 				ieee->softmac_stats.reassoc++;
-				
-				notify_wx_assoc_event(ieee);
-								
+
+				notify_wx_assoc_event_rtl7(ieee);
+
 				queue_work(ieee->wq, &ieee->associate_procedure_wq);
 			}
-			
+
 			break;
-		
-		default: 
+
+		default:
 			return -1;
 			break;
 	}
-	
+
 	//dev_kfree_skb_any(skb);
 	return 0;
 }
@@ -1602,21 +1631,21 @@
  * This might be useful if each fragment need it's own
  * descriptor, thus just keep a total free memory > than
  * the max fragmentation treshold is not enought.. If the
- * ieee802.11 stack passed a TXB struct then you needed  
- * to keep N free descriptors where 
+ * ieee802.11 stack passed a TXB struct then you needed
+ * to keep N free descriptors where
  * N = MAX_PACKET_SIZE / MIN_FRAG_TRESHOLD
  * In this way you need just one and the 802.11 stack
- * will take care of buffering fragments and pass them to 
+ * will take care of buffering fragments and pass them to
  * to the driver later, when it wakes the queue.
- */ 
- 
-void ieee80211_softmac_xmit(struct ieee80211_txb *txb, struct ieee80211_device *ieee)
+ */
+
+void ieee80211_softmac_xmit_rtl7(struct ieee80211_txb *txb, struct ieee80211_device *ieee)
 {
-	
-	
+
+
 	unsigned long flags;
 	int  i;
-	
+
 	spin_lock_irqsave(&ieee->lock,flags);
 	#if 0
 	if(ieee->queue_stop){
@@ -1627,13 +1656,13 @@
 		err = 1;
 		goto exit;
 	}
-	
+
 	ieee->stats.tx_bytes+=skb->len;
-	
-	
+
+
 	txb=ieee80211_skb_to_txb(ieee,skb);
-	
-	
+
+
 	if(txb==NULL){
 		IEEE80211DMESG("WW: IEEE stack failed to provide txb");
 		//dev_kfree_skb_any(skb);
@@ -1641,12 +1670,12 @@
 		goto exit;
 	}
 	#endif
-	
+
 	/* called with 2nd parm 0, no tx mgmt lock required */
-	ieee80211_sta_wakeup(ieee,0);
+	ieee80211_sta_wakeup_rtl7(ieee,0);
 
 	for(i = 0; i < txb->nr_frags; i++) {
-	
+
 		if (ieee->queue_stop){
 			ieee->tx_pending.txb = txb;
 			ieee->tx_pending.frag = i;
@@ -1658,29 +1687,29 @@
 				//(i+1)<txb->nr_frags);
 			ieee->stats.tx_packets++;
 			ieee->stats.tx_bytes += txb->fragments[i]->len;
-			ieee->dev->trans_start = jiffies; 
+			ieee->dev->trans_start = jiffies;
 		}
-	}	
-	
-	ieee80211_txb_free(txb);
-	
+	}
+
+	ieee80211_txb_free_rtl7(txb);
+
 	exit:
 	spin_unlock_irqrestore(&ieee->lock,flags);
-	
+
 }
 
 /* called with ieee->lock acquired */
-void ieee80211_resume_tx(struct ieee80211_device *ieee)
+void ieee80211_resume_tx_rtl7(struct ieee80211_device *ieee)
 {
 	int i;
 	for(i = ieee->tx_pending.frag; i < ieee->tx_pending.txb->nr_frags; i++) {
-		
+
 		if (ieee->queue_stop){
 			ieee->tx_pending.frag = i;
 			return;
 		}else{
-		
-			ieee->softmac_data_hard_start_xmit( 
+
+			ieee->softmac_data_hard_start_xmit(
 				ieee->tx_pending.txb->fragments[i],
 				ieee->dev,ieee->rate);
 				//(i+1)<ieee->tx_pending.txb->nr_frags);
@@ -1688,21 +1717,21 @@
 			ieee->dev->trans_start = jiffies;
 		}
 	}
-	
-	
-	ieee80211_txb_free(ieee->tx_pending.txb);
+
+
+	ieee80211_txb_free_rtl7(ieee->tx_pending.txb);
 	ieee->tx_pending.txb = NULL;
 }
 
 
-void ieee80211_reset_queue(struct ieee80211_device *ieee)
+void ieee80211_reset_queue_rtl7(struct ieee80211_device *ieee)
 {
 	unsigned long flags;
-	
+
 	spin_lock_irqsave(&ieee->lock,flags);
-	init_mgmt_queue(ieee);
+	init_mgmt_queue_rtl7(ieee);
 	if (ieee->tx_pending.txb){
-		ieee80211_txb_free(ieee->tx_pending.txb);
+		ieee80211_txb_free_rtl7(ieee->tx_pending.txb);
 		ieee->tx_pending.txb = NULL;
 	}
 	ieee->queue_stop = 0;
@@ -1710,23 +1739,23 @@
 
 }
 
-void ieee80211_wake_queue(struct ieee80211_device *ieee)
+void ieee80211_wake_queue_rtl7(struct ieee80211_device *ieee)
 {
 
 	unsigned long flags;
 	struct sk_buff *skb;
 	struct ieee80211_hdr_3addr  *header;
-	
+
 	spin_lock_irqsave(&ieee->lock,flags);
 	if (! ieee->queue_stop) goto exit;
-	
+
 	ieee->queue_stop = 0;
-	
+
 	if(ieee->softmac_features & IEEE_SOFTMAC_SINGLE_QUEUE){
-		while (!ieee->queue_stop && (skb = dequeue_mgmt(ieee))){
-			
+		while (!ieee->queue_stop && (skb = dequeue_mgmt_rtl7(ieee))){
+
 			header = (struct ieee80211_hdr_3addr  *) skb->data;
-			
+
 			header->seq_ctl = cpu_to_le16(ieee->seq_ctrl << 4);
 
 			if (ieee->seq_ctrl == 0xFFF)
@@ -1738,19 +1767,19 @@
 		}
 	}
 	if (!ieee->queue_stop && ieee->tx_pending.txb)
-		ieee80211_resume_tx(ieee);
-	
+		ieee80211_resume_tx_rtl7(ieee);
+
 	if (!ieee->queue_stop && netif_queue_stopped(ieee->dev)){
 		ieee->softmac_stats.swtxawake++;
 		netif_wake_queue(ieee->dev);
 	}
-	
+
 exit :
 	spin_unlock_irqrestore(&ieee->lock,flags);
 }
 
 
-void ieee80211_stop_queue(struct ieee80211_device *ieee)
+void ieee80211_stop_queue_rtl7(struct ieee80211_device *ieee)
 {
 	//unsigned long flags;
 	//spin_lock_irqsave(&ieee->lock,flags);
@@ -1761,81 +1790,88 @@
 	}
 	ieee->queue_stop = 1;
 	//spin_unlock_irqrestore(&ieee->lock,flags);
-	
+
 }
 
 
-inline void ieee80211_randomize_cell(struct ieee80211_device *ieee)
+inline void ieee80211_randomize_cell_rtl7(struct ieee80211_device *ieee)
 {
-	
+
 	get_random_bytes(ieee->current_network.bssid, ETH_ALEN);
-	
+
 	/* an IBSS cell address must have the two less significant
-	 * bits of the first byte = 2 
+	 * bits of the first byte = 2
 	 */
 	ieee->current_network.bssid[0] &= ~0x01;
 	ieee->current_network.bssid[0] |= 0x02;
 }
 
 /* called in user context only */
-void ieee80211_start_master_bss(struct ieee80211_device *ieee)
+void ieee80211_start_master_bss_rtl7(struct ieee80211_device *ieee)
 {
 	ieee->assoc_id = 1;
-	
+
 	if (ieee->current_network.ssid_len == 0){
-		strncpy(ieee->current_network.ssid, 
+		strncpy(ieee->current_network.ssid,
 			IEEE80211_DEFAULT_TX_ESSID,
 			IW_ESSID_MAX_SIZE);
-			
+
 		ieee->current_network.ssid_len = strlen(IEEE80211_DEFAULT_TX_ESSID);
 		ieee->ssid_set = 1;
 	}
-	
+
 	memcpy(ieee->current_network.bssid, ieee->dev->dev_addr, ETH_ALEN);
-	 
+
 	ieee->set_chan(ieee->dev, ieee->current_network.channel);
 	ieee->state = IEEE80211_LINKED;
 	ieee->link_change(ieee->dev);
-	notify_wx_assoc_event(ieee);
-	
+	notify_wx_assoc_event_rtl7(ieee);
+
 	if (ieee->data_hard_resume)
 		ieee->data_hard_resume(ieee->dev);
-	
+
 	netif_carrier_on(ieee->dev);
 }
 
-void ieee80211_start_monitor_mode(struct ieee80211_device *ieee)
+void ieee80211_start_monitor_mode_rtl7(struct ieee80211_device *ieee)
 {
 	if(ieee->raw_tx){
-		
+
 		if (ieee->data_hard_resume)
 			ieee->data_hard_resume(ieee->dev);
-	
+
 		netif_carrier_on(ieee->dev);
 	}
 }
-void ieee80211_start_ibss_wq(struct ieee80211_device *ieee)
+
+# if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20))
+void ieee80211_start_ibss_wq_rtl7(struct work_struct *work)
+{
+	struct ieee80211_device *ieee = container_of(work, struct ieee80211_device, start_ibss_wq);
+#else
+void ieee80211_start_ibss_wq_rtl7(struct ieee80211_device *ieee)
 {
-	
+#endif
+
 	/* iwconfig mode ad-hoc will schedule this and return
 	 * on the other hand this will block further iwconfig SET
 	 * operations because of the wx_sem hold.
 	 * Anyway some most set operations set a flag to speed-up
-	 * (abort) this wq (when syncro scanning) before sleeping 
+	 * (abort) this wq (when syncro scanning) before sleeping
 	 * on the semaphore
 	 */
-	
+
 	down(&ieee->wx_sem);
-	
+
 	if (ieee->current_network.ssid_len == 0){
 		strcpy(ieee->current_network.ssid,IEEE80211_DEFAULT_TX_ESSID);
 		ieee->current_network.ssid_len = strlen(IEEE80211_DEFAULT_TX_ESSID);
 		ieee->ssid_set = 1;
-	} 
-	
+	}
+
 	/* check if we have this cell in our network list */
-	ieee80211_softmac_check_all_nets(ieee);
-	
+	ieee80211_softmac_check_all_nets_rtl7(ieee);
+
 	/* if not then the state is not linked. Maybe the user swithced to
 	 * ad-hoc mode just after being in monitor mode, or just after
 	 * being very few time in managed mode (so the card have had no
@@ -1851,29 +1887,29 @@
 	 * associated.
 	 */
 	if (ieee->state == IEEE80211_NOLINK)
-		ieee80211_start_scan_syncro(ieee);
+		ieee80211_start_scan_syncro_rtl7(ieee);
 
 	/* the network definitively is not here.. create a new cell */
 	if (ieee->state == IEEE80211_NOLINK){
-		printk("creating new IBSS cell\n"); 
+		printk("creating new IBSS cell\n");
 		if(!ieee->wap_set)
-			ieee80211_randomize_cell(ieee);
-		
+			ieee80211_randomize_cell_rtl7(ieee);
+
 		if(ieee->modulation & IEEE80211_CCK_MODULATION){
-		
+
 			ieee->current_network.rates_len = 4;
-			
+
 			ieee->current_network.rates[0] = IEEE80211_BASIC_RATE_MASK | IEEE80211_CCK_RATE_1MB;
 			ieee->current_network.rates[1] = IEEE80211_BASIC_RATE_MASK | IEEE80211_CCK_RATE_2MB;
 			ieee->current_network.rates[2] = IEEE80211_BASIC_RATE_MASK | IEEE80211_CCK_RATE_5MB;
 			ieee->current_network.rates[3] = IEEE80211_BASIC_RATE_MASK | IEEE80211_CCK_RATE_11MB;
-				
+
 		}else
 			ieee->current_network.rates_len = 0;
-		
+
 		if(ieee->modulation & IEEE80211_OFDM_MODULATION){
 			ieee->current_network.rates_ex_len = 8;
-			
+
 			ieee->current_network.rates_ex[0] = IEEE80211_BASIC_RATE_MASK | IEEE80211_OFDM_RATE_6MB;
 			ieee->current_network.rates_ex[1] = IEEE80211_BASIC_RATE_MASK | IEEE80211_OFDM_RATE_9MB;
 			ieee->current_network.rates_ex[2] = IEEE80211_BASIC_RATE_MASK | IEEE80211_OFDM_RATE_12MB;
@@ -1882,44 +1918,44 @@
 			ieee->current_network.rates_ex[5] = IEEE80211_BASIC_RATE_MASK | IEEE80211_OFDM_RATE_36MB;
 			ieee->current_network.rates_ex[6] = IEEE80211_BASIC_RATE_MASK | IEEE80211_OFDM_RATE_48MB;
 			ieee->current_network.rates_ex[7] = IEEE80211_BASIC_RATE_MASK | IEEE80211_OFDM_RATE_54MB;
-			
-			ieee->rate = 540;
+
+//			ieee->rate = 540;
 		}else{
 			ieee->current_network.rates_ex_len = 0;
-			ieee->rate = 110;
+//			ieee->rate = 110;
 		}
-	
+
 		ieee->current_network.atim_window = 0;
 		ieee->current_network.capability = WLAN_CAPABILITY_IBSS;
 		if(ieee->short_slot)
 			ieee->current_network.capability |= WLAN_CAPABILITY_SHORT_SLOT;
-				 
+
 	}
-	
+
 	ieee->state = IEEE80211_LINKED;
-		
+
 	ieee->set_chan(ieee->dev, ieee->current_network.channel);
 	ieee->link_change(ieee->dev);
-	
-	notify_wx_assoc_event(ieee);
-	
-	ieee80211_start_send_beacons(ieee);
-	
+
+	notify_wx_assoc_event_rtl7(ieee);
+
+	ieee80211_start_send_beacons_rtl7(ieee);
+
 	if (ieee->data_hard_resume)
 		ieee->data_hard_resume(ieee->dev);
-	
+
 	netif_carrier_on(ieee->dev);
-	
+
 	up(&ieee->wx_sem);
 }
 
-inline void ieee80211_start_ibss(struct ieee80211_device *ieee)
+inline void ieee80211_start_ibss_rtl7(struct ieee80211_device *ieee)
 {
 	queue_work(ieee->wq, &ieee->start_ibss_wq);
 }
 
 /* this is called only in user context, with wx_sem held */
-void ieee80211_start_bss(struct ieee80211_device *ieee)
+void ieee80211_start_bss_rtl7(struct ieee80211_device *ieee)
 {
 	unsigned long flags;
 	/* check if we have already found the net we
@@ -1927,8 +1963,8 @@
 	 * if not (we are disassociated and we are not
 	 * in associating / authenticating phase) start the background scanning.
 	 */
-	ieee80211_softmac_check_all_nets(ieee);
-	
+	ieee80211_softmac_check_all_nets_rtl7(ieee);
+
 	/* ensure no-one start an associating process (thus setting
 	 * the ieee->state to ieee80211_ASSOCIATING) while we
 	 * have just cheked it and we are going to enable scan.
@@ -1937,41 +1973,49 @@
 	 * the rx path), so we cannot be in the middle of such function
 	 */
 	spin_lock_irqsave(&ieee->lock, flags);
-	
 	if (ieee->state == IEEE80211_NOLINK)
-		ieee80211_start_scan(ieee);
-	
+		ieee80211_start_scan_rtl7(ieee);
+
 	spin_unlock_irqrestore(&ieee->lock, flags);
 }
 
 /* called only in userspace context */
-void ieee80211_disassociate(struct ieee80211_device *ieee)
+void ieee80211_disassociate_rtl7(struct ieee80211_device *ieee)
 {
 	netif_carrier_off(ieee->dev);
-	
+
 	if (ieee->softmac_features & IEEE_SOFTMAC_TX_QUEUE)
-			ieee80211_reset_queue(ieee);
-	
+			ieee80211_reset_queue_rtl7(ieee);
+
 	if (ieee->data_hard_stop)
 			ieee->data_hard_stop(ieee->dev);
-	
+
 	ieee->state = IEEE80211_NOLINK;
 	ieee->link_change(ieee->dev);
-	notify_wx_assoc_event(ieee);
-	
+	notify_wx_assoc_event_rtl7(ieee);
+
 }
-void ieee80211_associate_retry_wq(struct ieee80211_device *ieee)
+
+# if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20))
+void ieee80211_associate_retry_wq_rtl7(struct work_struct *work)
+{
+	struct delayed_work *dwork = container_of(work, struct delayed_work, work);
+	struct ieee80211_device *ieee = container_of(dwork, struct ieee80211_device, associate_retry_wq);
+#else
+void ieee80211_associate_retry_wq_rtl7(struct ieee80211_device *ieee)
 {
+#endif
 	unsigned long flags;
-	
+
 	down(&ieee->wx_sem);
+
 	if(!ieee->proto_started)
 		goto exit;
-		
+
 	if(ieee->state != IEEE80211_ASSOCIATING_RETRY)
 		goto exit;
-		
-	/* until we do not set the state to IEEE80211_NOLINK 
+
+	/* until we do not set the state to IEEE80211_NOLINK
 	* there are no possibility to have someone else trying
 	* to start an association procdure (we get here with
 	* ieee->state = IEEE80211_ASSOCIATING).
@@ -1981,122 +2025,120 @@
 	* RX path works with ieee->lock held so there are no
 	* problems. If we are still disassociated then start a scan.
 	* the lock here is necessary to ensure no one try to start
-	* an association procedure when we have just checked the 
+	* an association procedure when we have just checked the
 	* state and we are going to start the scan.
 	*/
 	ieee->state = IEEE80211_NOLINK;
 
-	ieee80211_softmac_check_all_nets(ieee);
-	
+	ieee80211_softmac_check_all_nets_rtl7(ieee);
+
 	spin_lock_irqsave(&ieee->lock, flags);
-	
+
 	if(ieee->state == IEEE80211_NOLINK)
-		ieee80211_start_scan(ieee);
-	
+		ieee80211_start_scan_rtl7(ieee);
+
 	spin_unlock_irqrestore(&ieee->lock, flags);
 
 exit:
 	up(&ieee->wx_sem);
 }
 
-struct sk_buff *ieee80211_get_beacon_(struct ieee80211_device *ieee)
+struct sk_buff *ieee80211_get_beacon__rtl7(struct ieee80211_device *ieee)
 {
 	u8 broadcast_addr[] = {0xff,0xff,0xff,0xff,0xff,0xff};
-	
+
 	struct sk_buff *skb;
 	struct ieee80211_probe_response *b;
-	
-	skb = ieee80211_probe_resp(ieee, broadcast_addr);
-	
-	if (!skb) 
+
+	skb = ieee80211_probe_resp_rtl7(ieee, broadcast_addr);
+
+	if (!skb)
 		return NULL;
-	
+
 	b = (struct ieee80211_probe_response *) skb->data;
 	b->header.frame_ctl = cpu_to_le16(IEEE80211_STYPE_BEACON);
-		
+
 	return skb;
-	
+
 }
 
-struct sk_buff *ieee80211_get_beacon(struct ieee80211_device *ieee)
+struct sk_buff *ieee80211_get_beacon_rtl7(struct ieee80211_device *ieee)
 {
 	struct sk_buff *skb;
 	struct ieee80211_probe_response *b;
-	
-	skb = ieee80211_get_beacon_(ieee);
-	if(!skb) 
+
+	skb = ieee80211_get_beacon__rtl7(ieee);
+	if(!skb)
 		return NULL;
-		
-	b = (struct ieee80211_probe_response *) skb->data;	
+
+	b = (struct ieee80211_probe_response *) skb->data;
 	b->header.seq_ctrl = cpu_to_le16(ieee->seq_ctrl << 4);
-	
+
 	if (ieee->seq_ctrl == 0xFFF)
 		ieee->seq_ctrl = 0;
 	else
 		ieee->seq_ctrl++;
-	
+
 	return skb;
 }
 
-void ieee80211_softmac_stop_protocol(struct ieee80211_device *ieee)
+void ieee80211_softmac_stop_protocol_rtl7(struct ieee80211_device *ieee)
 {
 	ieee->sync_scan_hurryup = 1;
 	down(&ieee->wx_sem);
-	ieee80211_stop_protocol(ieee);
+
+	ieee80211_stop_protocol_rtl7(ieee);
 	up(&ieee->wx_sem);
 }
 
 
-void ieee80211_stop_protocol(struct ieee80211_device *ieee)
+void ieee80211_stop_protocol_rtl7(struct ieee80211_device *ieee)
 {
 	if (!ieee->proto_started)
 		return;
-	
+
 	ieee->proto_started = 0;
-	
-	ieee80211_stop_send_beacons(ieee);
-	
+
+	ieee80211_stop_send_beacons_rtl7(ieee);
+
 	del_timer_sync(&ieee->associate_timer);
-	cancel_delayed_work(&ieee->associate_retry_wq);	
-	
-	ieee80211_stop_scan(ieee);
+	cancel_delayed_work(&ieee->associate_retry_wq);
+
+	ieee80211_stop_scan_rtl7(ieee);
 
-	ieee80211_disassociate(ieee);
+	ieee80211_disassociate_rtl7(ieee);
 }
 
-void ieee80211_softmac_start_protocol(struct ieee80211_device *ieee)
+void ieee80211_softmac_start_protocol_rtl7(struct ieee80211_device *ieee)
 {
 	ieee->sync_scan_hurryup = 0;
 	down(&ieee->wx_sem);
-	ieee80211_start_protocol(ieee);
+	ieee80211_start_protocol_rtl7(ieee);
 	up(&ieee->wx_sem);
 }
 
-void ieee80211_start_protocol(struct ieee80211_device *ieee)
+void ieee80211_start_protocol_rtl7(struct ieee80211_device *ieee)
 {
 	short ch = 0;
-	
 	if (ieee->proto_started)
 		return;
-		
+
 	ieee->proto_started = 1;
-	
+
 	if (ieee->current_network.channel == 0){
 		do{
 			ch++;
-			if (ch > MAX_CHANNEL_NUMBER) 
+			if (ch > MAX_CHANNEL_NUMBER)
 				return; /* no channel found */
-				
+
 		}while(!ieee->channel_map[ch]);
-		
+
 		ieee->current_network.channel = ch;
 	}
-	
+
 	if (ieee->current_network.beacon_interval == 0)
 		ieee->current_network.beacon_interval = 100;
-	
 	ieee->set_chan(ieee->dev,ieee->current_network.channel);
-	
 	ieee->last_seq_num = -1;
 	ieee->last_frag_num = -1;
 	ieee->last_packet_time = 0;
@@ -2107,30 +2149,27 @@
 	 * attempts does not fail just because the user provide the essid
 	 * and the nic is still checking for the AP MAC ??
 	 */
-	
+
 	if (ieee->iw_mode == IW_MODE_INFRA)
-		ieee80211_start_bss(ieee);
-		
+		ieee80211_start_bss_rtl7(ieee);
 	else if (ieee->iw_mode == IW_MODE_ADHOC)
-		ieee80211_start_ibss(ieee);
-		
+		ieee80211_start_ibss_rtl7(ieee);
 	else if (ieee->iw_mode == IW_MODE_MASTER)
-		ieee80211_start_master_bss(ieee);
-		
+		ieee80211_start_master_bss_rtl7(ieee);
 	else if(ieee->iw_mode == IW_MODE_MONITOR)
-		ieee80211_start_monitor_mode(ieee);	
+		ieee80211_start_monitor_mode_rtl7(ieee);
 }
 
 
 #define DRV_NAME  "Ieee80211"
-void ieee80211_softmac_init(struct ieee80211_device *ieee)
+void ieee80211_softmac_init_rtl7(struct ieee80211_device *ieee)
 {
 	memset(&ieee->current_network, 0, sizeof(struct ieee80211_network));
-	
+
 	ieee->state = IEEE80211_NOLINK;
 	ieee->sync_scan_hurryup = 0;
 	ieee->seq_ctrl = 0;
-	
+
 	ieee->assoc_id = 0;
 	ieee->queue_stop = 0;
 	ieee->scanning = 0;
@@ -2142,66 +2181,75 @@
 	ieee->rate = 3;
 	ieee->ps = IEEE80211_PS_DISABLED;
 	ieee->sta_sleep = 0;
-	
-	init_mgmt_queue(ieee);
+
+	init_mgmt_queue_rtl7(ieee);
 #if 0
 	init_timer(&ieee->scan_timer);
 	ieee->scan_timer.data = (unsigned long)ieee;
 	ieee->scan_timer.function = ieee80211_softmac_scan_cb;
 #endif
 	ieee->tx_pending.txb = NULL;
-	
+
 	init_timer(&ieee->associate_timer);
 	ieee->associate_timer.data = (unsigned long)ieee;
-	ieee->associate_timer.function = ieee80211_associate_abort_cb;
+	ieee->associate_timer.function = ieee80211_associate_abort_cb_rtl7;
 
 	init_timer(&ieee->beacon_timer);
 	ieee->beacon_timer.data = (unsigned long) ieee;
-	ieee->beacon_timer.function = ieee80211_send_beacon_cb;
-	
+	ieee->beacon_timer.function = ieee80211_send_beacon_cb_rtl7;
+
 #ifdef PF_SYNCTHREAD
 	ieee->wq = create_workqueue(DRV_NAME,0);
-#else	
+#else
 	ieee->wq = create_workqueue(DRV_NAME);
 #endif
-	
-	INIT_WORK(&ieee->start_ibss_wq,(void(*)(void*)) ieee80211_start_ibss_wq,ieee);
-	INIT_WORK(&ieee->associate_retry_wq,(void(*)(void*)) ieee80211_associate_retry_wq,ieee);
-	INIT_WORK(&ieee->associate_complete_wq,(void(*)(void*)) ieee80211_associate_complete_wq,ieee);
-	INIT_WORK(&ieee->associate_procedure_wq,(void(*)(void*)) ieee80211_associate_procedure_wq,ieee);
-	INIT_WORK(&ieee->softmac_scan_wq,(void(*)(void*)) ieee80211_softmac_scan_wq,ieee);
-	INIT_WORK(&ieee->wx_sync_scan_wq,(void(*)(void*)) ieee80211_wx_sync_scan_wq,ieee);
-	
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,20)
+	INIT_WORK(&ieee->start_ibss_wq,(void(*)(void*)) ieee80211_start_ibss_wq_rtl7,ieee);
+	INIT_WORK(&ieee->associate_retry_wq,(void(*)(void*)) ieee80211_associate_retry_wq_rtl7,ieee);
+	INIT_WORK(&ieee->associate_complete_wq,(void(*)(void*)) ieee80211_associate_complete_wq_rtl7,ieee);
+	INIT_WORK(&ieee->associate_procedure_wq,(void(*)(void*)) ieee80211_associate_procedure_wq_rtl7,ieee);
+	INIT_WORK(&ieee->softmac_scan_wq,(void(*)(void*)) ieee80211_softmac_scan_wq_rtl7,ieee);
+	INIT_WORK(&ieee->wx_sync_scan_wq,(void(*)(void*)) ieee80211_wx_sync_scan_wq_rtl7,ieee);
+#else
+	INIT_WORK(&ieee->start_ibss_wq, ieee80211_start_ibss_wq_rtl7);
+	INIT_DELAYED_WORK(&ieee->associate_retry_wq, ieee80211_associate_retry_wq_rtl7);
+	INIT_WORK(&ieee->associate_complete_wq, ieee80211_associate_complete_wq_rtl7);
+	INIT_WORK(&ieee->associate_procedure_wq, ieee80211_associate_procedure_wq_rtl7);
+	INIT_DELAYED_WORK(&ieee->softmac_scan_wq, ieee80211_softmac_scan_wq_rtl7);
+	INIT_WORK(&ieee->wx_sync_scan_wq, ieee80211_wx_sync_scan_wq_rtl7);
+#endif
+
 	sema_init(&ieee->wx_sem, 1);
 	sema_init(&ieee->scan_sem, 1);
-	
+
 	spin_lock_init(&ieee->mgmt_tx_lock);
 	spin_lock_init(&ieee->beacon_lock);
-	
+
 	tasklet_init(&ieee->ps_task,
-	     (void(*)(unsigned long)) ieee80211_sta_ps,
+	     (void(*)(unsigned long)) ieee80211_sta_ps_rtl7,
 	     (unsigned long)ieee);
 
 }
 
-void ieee80211_softmac_free(struct ieee80211_device *ieee)
+void ieee80211_softmac_free_rtl7(struct ieee80211_device *ieee)
 {
 	down(&ieee->wx_sem);
-	
+
 	del_timer_sync(&ieee->associate_timer);
 	cancel_delayed_work(&ieee->associate_retry_wq);
 	destroy_workqueue(ieee->wq);
-	
+
 	up(&ieee->wx_sem);
 }
 
-/******************************************************** 
+/********************************************************
  * Start of WPA code.                                   *
  * this is stolen from the ipw2200 driver               *
  ********************************************************/
 
- 
-static int ieee80211_wpa_enable(struct ieee80211_device *ieee, int value)
+
+static int ieee80211_wpa_enable_rtl7(struct ieee80211_device *ieee, int value)
 {
 	/* This is called when wpa_supplicant loads and closes the driver
 	 * interface. */
@@ -2210,19 +2258,19 @@
 	return 0;
 }
 
- 
-void ieee80211_wpa_assoc_frame(struct ieee80211_device *ieee, char *wpa_ie, int wpa_ie_len)
+
+void ieee80211_wpa_assoc_frame_rtl7(struct ieee80211_device *ieee, char *wpa_ie, int wpa_ie_len)
 {
 	/* make sure WPA is enabled */
-	ieee80211_wpa_enable(ieee, 1);
+	ieee80211_wpa_enable_rtl7(ieee, 1);
 
-	ieee80211_disassociate(ieee);
+	ieee80211_disassociate_rtl7(ieee);
 }
 
 
-static int ieee80211_wpa_mlme(struct ieee80211_device *ieee, int command, int reason)
+static int ieee80211_wpa_mlme_rtl7(struct ieee80211_device *ieee, int command, int reason)
 {
-	
+
 	int ret = 0;
 
 	switch (command) {
@@ -2231,7 +2279,7 @@
 		break;
 
 	case IEEE_MLME_STA_DISASSOC:
-		ieee80211_disassociate(ieee);
+		ieee80211_disassociate_rtl7(ieee);
 		break;
 
 	default:
@@ -2243,7 +2291,7 @@
 }
 
 
-static int ieee80211_wpa_set_wpa_ie(struct ieee80211_device *ieee,
+static int ieee80211_wpa_set_wpa_ie_rtl7(struct ieee80211_device *ieee,
 			      struct ieee_param *param, int plen)
 {
 	u8 *buf;
@@ -2267,16 +2315,16 @@
 		ieee->wpa_ie_len = 0;
 	}
 
-	ieee80211_wpa_assoc_frame(ieee, ieee->wpa_ie, ieee->wpa_ie_len);
+	ieee80211_wpa_assoc_frame_rtl7(ieee, ieee->wpa_ie, ieee->wpa_ie_len);
 	return 0;
 }
 
 #define AUTH_ALG_OPEN_SYSTEM			0x1
 #define AUTH_ALG_SHARED_KEY			0x2
 
-static int ieee80211_wpa_set_auth_algs(struct ieee80211_device *ieee, int value)
+static int ieee80211_wpa_set_auth_algs_rtl7(struct ieee80211_device *ieee, int value)
 {
-	
+
 	struct ieee80211_security sec = {
 		.flags = SEC_AUTH_MODE,
 	};
@@ -2300,13 +2348,13 @@
 
 
 
-static int ieee80211_wpa_set_param(struct ieee80211_device *ieee, u8 name, u32 value)
+static int ieee80211_wpa_set_param_rtl7(struct ieee80211_device *ieee, u8 name, u32 value)
 {
 	int ret=0;
 
 	switch (name) {
 	case IEEE_PARAM_WPA_ENABLED:
-		ret = ieee80211_wpa_enable(ieee, value);
+		ret = ieee80211_wpa_enable_rtl7(ieee, value);
 		break;
 
 	case IEEE_PARAM_TKIP_COUNTERMEASURES:
@@ -2351,7 +2399,7 @@
 		break;
 
 	case IEEE_PARAM_AUTH_ALGS:
-		ret = ieee80211_wpa_set_auth_algs(ieee, value);
+		ret = ieee80211_wpa_set_auth_algs_rtl7(ieee, value);
 		break;
 
 	case IEEE_PARAM_IEEE_802_1X:
@@ -2368,11 +2416,11 @@
 
 /* implementation borrowed from hostap driver */
 
-static int ieee80211_wpa_set_encryption(struct ieee80211_device *ieee,
+static int ieee80211_wpa_set_encryption_rtl7(struct ieee80211_device *ieee,
 				  struct ieee_param *param, int param_len)
 {
 	int ret = 0;
-	
+
 	struct ieee80211_crypto_ops *ops;
 	struct ieee80211_crypt_data **crypt;
 
@@ -2407,7 +2455,7 @@
 			//sec.encrypt = 0;
 			sec.level = SEC_LEVEL_0;
 			sec.flags |= SEC_ENABLED | SEC_LEVEL;
-			ieee80211_crypt_delayed_deinit(ieee, crypt);
+			ieee80211_crypt_delayed_deinit_rtl7(ieee, crypt);
 		}
 		goto done;
 	}
@@ -2421,16 +2469,16 @@
 	    strcmp(param->u.crypt.alg, "TKIP"))
 		goto skip_host_crypt;
 
-	ops = ieee80211_get_crypto_ops(param->u.crypt.alg);
+	ops = ieee80211_get_crypto_ops_rtl7(param->u.crypt.alg);
 	if (ops == NULL && strcmp(param->u.crypt.alg, "WEP") == 0) {
-		request_module("ieee80211_crypt_wep");
-		ops = ieee80211_get_crypto_ops(param->u.crypt.alg);
+		request_module("ieee80211_crypt_wep_rtl");
+		ops = ieee80211_get_crypto_ops_rtl7(param->u.crypt.alg);
 	} else if (ops == NULL && strcmp(param->u.crypt.alg, "TKIP") == 0) {
-		request_module("ieee80211_crypt_tkip");
-		ops = ieee80211_get_crypto_ops(param->u.crypt.alg);
+		request_module("ieee80211_crypt_tkip_rtl");
+		ops = ieee80211_get_crypto_ops_rtl7(param->u.crypt.alg);
 	} else if (ops == NULL && strcmp(param->u.crypt.alg, "CCMP") == 0) {
-		request_module("ieee80211_crypt_ccmp");
-		ops = ieee80211_get_crypto_ops(param->u.crypt.alg);
+		request_module("ieee80211_crypt_ccmp_rtl");
+		ops = ieee80211_get_crypto_ops_rtl7(param->u.crypt.alg);
 	}
 	if (ops == NULL) {
 		printk("unknown crypto alg '%s'\n", param->u.crypt.alg);
@@ -2442,7 +2490,7 @@
 	if (*crypt == NULL || (*crypt)->ops != ops) {
 		struct ieee80211_crypt_data *new_crypt;
 
-		ieee80211_crypt_delayed_deinit(ieee, crypt);
+		ieee80211_crypt_delayed_deinit_rtl7(ieee, crypt);
 
 		new_crypt = (struct ieee80211_crypt_data *)
 			kmalloc(sizeof(*new_crypt), GFP_KERNEL);
@@ -2525,7 +2573,7 @@
 
 
 
-int ieee80211_wpa_supplicant_ioctl(struct ieee80211_device *ieee, struct iw_point *p)
+int ieee80211_wpa_supplicant_ioctl_rtl7(struct ieee80211_device *ieee, struct iw_point *p)
 {
 	struct ieee_param *param;
 	int ret=0;
@@ -2537,7 +2585,7 @@
 		ret = -EINVAL;
 		goto out;
 	}
-	
+
 	param = (struct ieee_param *)kmalloc(p->length, GFP_KERNEL);
 	if (param == NULL){
 		ret = -ENOMEM;
@@ -2552,20 +2600,20 @@
 	switch (param->cmd) {
 
 	case IEEE_CMD_SET_WPA_PARAM:
-		ret = ieee80211_wpa_set_param(ieee, param->u.wpa_param.name,
+		ret = ieee80211_wpa_set_param_rtl7(ieee, param->u.wpa_param.name,
 					param->u.wpa_param.value);
 		break;
 
 	case IEEE_CMD_SET_WPA_IE:
-		ret = ieee80211_wpa_set_wpa_ie(ieee, param, p->length);
+		ret = ieee80211_wpa_set_wpa_ie_rtl7(ieee, param, p->length);
 		break;
 
 	case IEEE_CMD_SET_ENCRYPTION:
-		ret = ieee80211_wpa_set_encryption(ieee, param, p->length);
+		ret = ieee80211_wpa_set_encryption_rtl7(ieee, param, p->length);
 		break;
 
 	case IEEE_CMD_MLME:
-		ret = ieee80211_wpa_mlme(ieee, param->u.mlme.command,
+		ret = ieee80211_wpa_mlme_rtl7(ieee, param->u.mlme.command,
 				   param->u.mlme.reason_code);
 		break;
 
@@ -2581,11 +2629,11 @@
 	kfree(param);
 out:
 	up(&ieee->wx_sem);
-	
+
 	return ret;
 }
 
-void notify_wx_assoc_event(struct ieee80211_device *ieee)
+void notify_wx_assoc_event_rtl7(struct ieee80211_device *ieee)
 {
 	union iwreq_data wrqu;
 	wrqu.ap_addr.sa_family = ARPHRD_ETHER;
@@ -2597,14 +2645,14 @@
 }
 
 
-EXPORT_SYMBOL(ieee80211_get_beacon);
-EXPORT_SYMBOL(ieee80211_wake_queue);
-EXPORT_SYMBOL(ieee80211_stop_queue);
-EXPORT_SYMBOL(ieee80211_reset_queue);
-EXPORT_SYMBOL(ieee80211_softmac_stop_protocol);
-EXPORT_SYMBOL(ieee80211_softmac_start_protocol);
-EXPORT_SYMBOL(ieee80211_is_shortslot);
-EXPORT_SYMBOL(ieee80211_is_54g);
-EXPORT_SYMBOL(ieee80211_wpa_supplicant_ioctl);
-EXPORT_SYMBOL(ieee80211_ps_tx_ack);
-//EXPORT_SYMBOL(ieee80211_sta_ps_send_null_frame);
+EXPORT_SYMBOL(ieee80211_get_beacon_rtl7);
+EXPORT_SYMBOL(ieee80211_wake_queue_rtl7);
+EXPORT_SYMBOL(ieee80211_stop_queue_rtl7);
+EXPORT_SYMBOL(ieee80211_reset_queue_rtl7);
+EXPORT_SYMBOL(ieee80211_softmac_stop_protocol_rtl7);
+EXPORT_SYMBOL(ieee80211_softmac_start_protocol_rtl7);
+EXPORT_SYMBOL(ieee80211_is_shortslot_rtl7);
+EXPORT_SYMBOL(ieee80211_is_54g_rtl7);
+EXPORT_SYMBOL(ieee80211_wpa_supplicant_ioctl_rtl7);
+EXPORT_SYMBOL(ieee80211_ps_tx_ack_rtl7);
+//EXPORT_SYMBOL(ieee80211_sta_ps_send_null_frame_rtl7);
diff -Naur rtl8187_linux_26.1010.0622.2006/ieee80211/ieee80211_softmac_wx.c rtl8187_linux_26.1010.0622.2006_rawtx/ieee80211/ieee80211_softmac_wx.c
--- rtl8187_linux_26.1010.0622.2006/ieee80211/ieee80211_softmac_wx.c	2006-06-06 04:57:54.000000000 +0200
+++ rtl8187_linux_26.1010.0622.2006_rawtx/ieee80211/ieee80211_softmac_wx.c	2008-01-30 17:38:11.000000000 +0100
@@ -1,7 +1,7 @@
 /* IEEE 802.11 SoftMAC layer
  * Copyright (c) 2005 Andrea Merello <andreamrl@tiscali.it>
  *
- * Mostly extracted from the rtl8180-sa2400 driver for the 
+ * Mostly extracted from the rtl8180-sa2400 driver for the
  * in-kernel generic ieee802.11 stack.
  *
  * Some pieces of code might be stolen from ipw2100 driver
@@ -18,23 +18,23 @@
 
 /* FIXME: add A freqs */
 
-const long ieee80211_wlan_frequencies[] = {  
-	2412, 2417, 2422, 2427, 
-	2432, 2437, 2442, 2447, 
-	2452, 2457, 2462, 2467, 
-	2472, 2484  
+const long ieee80211_wlan_frequencies_rtl7[] = {
+	2412, 2417, 2422, 2427,
+	2432, 2437, 2442, 2447,
+	2452, 2457, 2462, 2467,
+	2472, 2484
 };
 
 
-int ieee80211_wx_set_freq(struct ieee80211_device *ieee, struct iw_request_info *a,
+int ieee80211_wx_set_freq_rtl7(struct ieee80211_device *ieee, struct iw_request_info *a,
 			     union iwreq_data *wrqu, char *b)
 {
 	int ret;
 	struct iw_freq *fwrq = & wrqu->freq;
 
 	down(&ieee->wx_sem);
-	
-	if(ieee->iw_mode == IW_MODE_INFRA){ 
+
+	if(ieee->iw_mode == IW_MODE_INFRA){
 		ret = -EOPNOTSUPP;
 		goto out;
 	}
@@ -45,31 +45,31 @@
 		     fwrq->m <= (int) 2.487e8)) {
 			int f = fwrq->m / 100000;
 			int c = 0;
-			
-			while ((c < 14) && (f != ieee80211_wlan_frequencies[c]))
+
+			while ((c < 14) && (f != ieee80211_wlan_frequencies_rtl7[c]))
 				c++;
-			
+
 			/* hack to fall through */
 			fwrq->e = 0;
 			fwrq->m = c + 1;
 		}
 	}
-	
-	if (fwrq->e > 0 || fwrq->m > 14 || fwrq->m < 1 ){ 
+
+	if (fwrq->e > 0 || fwrq->m > 14 || fwrq->m < 1 ){
 		ret = -EOPNOTSUPP;
 		goto out;
-	
+
 	}else { /* Set the channel */
-		
-		
+
+
 		ieee->current_network.channel = fwrq->m;
 		ieee->set_chan(ieee->dev, ieee->current_network.channel);
-		
+
 		if(ieee->iw_mode == IW_MODE_ADHOC || ieee->iw_mode == IW_MODE_MASTER)
 			if(ieee->state == IEEE80211_LINKED){
-			
-			ieee80211_stop_send_beacons(ieee);
-			ieee80211_start_send_beacons(ieee);
+
+			ieee80211_stop_send_beacons_rtl7(ieee);
+			ieee80211_start_send_beacons_rtl7(ieee);
 			}
 	}
 
@@ -80,7 +80,7 @@
 }
 
 
-int ieee80211_wx_get_freq(struct ieee80211_device *ieee,
+int ieee80211_wx_get_freq_rtl7(struct ieee80211_device *ieee,
 			     struct iw_request_info *a,
 			     union iwreq_data *wrqu, char *b)
 {
@@ -88,110 +88,110 @@
 
 	if (ieee->current_network.channel == 0)
 		return -1;
-	
+
 	fwrq->m = ieee->current_network.channel;
 	fwrq->e = 0;
-	
+
 	return 0;
 }
 
-int ieee80211_wx_get_wap(struct ieee80211_device *ieee, 
-			    struct iw_request_info *info, 
+int ieee80211_wx_get_wap_rtl7(struct ieee80211_device *ieee,
+			    struct iw_request_info *info,
 			    union iwreq_data *wrqu, char *extra)
 {
-	unsigned long flags;	
-	
+	unsigned long flags;
+
 	wrqu->ap_addr.sa_family = ARPHRD_ETHER;
-	
+
 	if (ieee->iw_mode == IW_MODE_MONITOR)
 		return -1;
-	
+
 	/* We want avoid to give to the user inconsistent infos*/
 	spin_lock_irqsave(&ieee->lock, flags);
-	
-	if (ieee->state != IEEE80211_LINKED && 
+
+	if (ieee->state != IEEE80211_LINKED &&
 		ieee->state != IEEE80211_LINKED_SCANNING &&
 		ieee->wap_set == 0)
-		
+
 		memset(wrqu->ap_addr.sa_data, 0, ETH_ALEN);
 	else
-		memcpy(wrqu->ap_addr.sa_data, 
+		memcpy(wrqu->ap_addr.sa_data,
 		       ieee->current_network.bssid, ETH_ALEN);
-	
+
 	spin_unlock_irqrestore(&ieee->lock, flags);
-	
+
 	return 0;
 }
 
 
-int ieee80211_wx_set_wap(struct ieee80211_device *ieee,
+int ieee80211_wx_set_wap_rtl7(struct ieee80211_device *ieee,
 			 struct iw_request_info *info,
 			 union iwreq_data *awrq,
 			 char *extra)
 {
-	
+
 	int ret = 0;
 	u8 zero[] = {0,0,0,0,0,0};
 	unsigned long flags;
-	
+
+	struct sockaddr *temp = NULL;
 	short ifup = ieee->proto_started;//dev->flags & IFF_UP;
-	
+
 	ieee->sync_scan_hurryup = 1;
-	
+
 	down(&ieee->wx_sem);
-	
-	struct sockaddr *temp = (struct sockaddr *)awrq;
-	
+
+	temp = (struct sockaddr *)awrq;
 	/* use ifconfig hw ether */
 	if (ieee->iw_mode == IW_MODE_MASTER){
 		ret = -1;
 		goto out;
 	}
-	
+
 	if (temp->sa_family != ARPHRD_ETHER){
 		ret = -EINVAL;
 		goto out;
 	}
-	
+
 	if (ifup)
-		ieee80211_stop_protocol(ieee);
-	
+		ieee80211_stop_protocol_rtl7(ieee);
+
 	/* just to avoid to give inconsistent infos in the
-	 * get wx method. not really needed otherwise 
+	 * get wx method. not really needed otherwise
 	 */
 	spin_lock_irqsave(&ieee->lock, flags);
-	
-	memcpy(ieee->current_network.bssid, temp->sa_data, ETH_ALEN); 
+
+	memcpy(ieee->current_network.bssid, temp->sa_data, ETH_ALEN);
 	ieee->wap_set = memcmp(temp->sa_data, zero,ETH_ALEN)!=0;
-	
+
 	spin_unlock_irqrestore(&ieee->lock, flags);
-	
+
 	if (ifup)
-		ieee80211_start_protocol(ieee);
-	
+		ieee80211_start_protocol_rtl7(ieee);
+
 out:
 	up(&ieee->wx_sem);
 	return ret;
 }
-	
- int ieee80211_wx_get_essid(struct ieee80211_device *ieee, struct iw_request_info *a,union iwreq_data *wrqu,char *b)
+
+ int ieee80211_wx_get_essid_rtl7(struct ieee80211_device *ieee, struct iw_request_info *a,union iwreq_data *wrqu,char *b)
 {
 	int len,ret = 0;
 	unsigned long flags;
-	
+
 	if (ieee->iw_mode == IW_MODE_MONITOR)
 		return -1;
-	
-	/* We want avoid to give to the user inconsistent infos*/	
+
+	/* We want avoid to give to the user inconsistent infos*/
 	spin_lock_irqsave(&ieee->lock, flags);
-	
+
 	if (ieee->current_network.ssid[0] == '\0' ||
-		ieee->current_network.ssid_len == 0){ 
+		ieee->current_network.ssid_len == 0){
 		ret = -1;
 		goto out;
 	}
-	
-	if (ieee->state != IEEE80211_LINKED && 
+
+	if (ieee->state != IEEE80211_LINKED &&
 		ieee->state != IEEE80211_LINKED_SCANNING &&
 		ieee->ssid_set == 0){
 		ret = -1;
@@ -204,59 +204,76 @@
 
 out:
 	spin_unlock_irqrestore(&ieee->lock, flags);
-	
+
 	return ret;
-	
+
 }
 
-int ieee80211_wx_set_rate(struct ieee80211_device *ieee, 
+int ieee80211_wx_set_rate_rtl7(struct ieee80211_device *ieee,
 			     struct iw_request_info *info,
 			     union iwreq_data *wrqu, char *extra)
 {
 
 	u32 target_rate = wrqu->bitrate.value;
-	
+
 	ieee->rate = target_rate/100000;
 	//FIXME: we might want to limit rate also in management protocols.
-	return 0; 
+	return 0;
 }
 
 
 
-int ieee80211_wx_get_rate(struct ieee80211_device *ieee, 
-			     struct iw_request_info *info, 
+int ieee80211_wx_get_rate_rtl7(struct ieee80211_device *ieee,
+			     struct iw_request_info *info,
 			     union iwreq_data *wrqu, char *extra)
 {
-	
+
 	wrqu->bitrate.value = ieee->rate * 100000;
-	
+
 	return 0;
 }
 
-int ieee80211_wx_set_mode(struct ieee80211_device *ieee, struct iw_request_info *a,
+int ieee80211_wx_set_mode_rtl7(struct ieee80211_device *ieee, struct iw_request_info *a,
 			     union iwreq_data *wrqu, char *b)
 {
-	
+	short prev = ieee->raw_tx;
+
 	ieee->sync_scan_hurryup = 1;
-	
+
 	down(&ieee->wx_sem);
-	
+
 	if (wrqu->mode == ieee->iw_mode)
 		goto out;
-	
+
 	if (wrqu->mode == IW_MODE_MONITOR){
-	
-		ieee->dev->type = ARPHRD_IEEE80211;
+		ieee->dev->type = ARPHRD_IEEE80211_PRISM;
 	}else{
 		ieee->dev->type = ARPHRD_ETHER;
 	}
-	
+
 	if (!ieee->proto_started){
 		ieee->iw_mode = wrqu->mode;
 	}else{
-		ieee80211_stop_protocol(ieee);
+		ieee80211_stop_protocol_rtl7(ieee);
 		ieee->iw_mode = wrqu->mode;
-		ieee80211_start_protocol(ieee);
+		ieee80211_start_protocol_rtl7(ieee);
+	}
+
+	if(ieee->iw_mode == IW_MODE_MONITOR)
+	{
+		ieee->raw_tx = 1;
+		if(prev == 0 && ieee->raw_tx){
+			if (ieee->data_hard_resume)
+				ieee->data_hard_resume(ieee->dev);
+
+			netif_carrier_on(ieee->dev);
+		}
+
+		netif_carrier_on(ieee->dev);
+	}
+	else
+	{
+		ieee->raw_tx = 0;
 	}
 
 out:
@@ -264,120 +281,132 @@
 	return 0;
 }
 
-void ieee80211_wx_sync_scan_wq(struct ieee80211_device *ieee)
+# if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20))
+void ieee80211_wx_sync_scan_wq_rtl7(struct work_struct *work)
 {
+	struct ieee80211_device *ieee = container_of(work, struct ieee80211_device, wx_sync_scan_wq);
+#else
+void ieee80211_wx_sync_scan_wq_rtl7(struct ieee80211_device *ieee)
+{
+#endif
 	short chan;
 
 	chan = ieee->current_network.channel;
-	
+
 	netif_carrier_off(ieee->dev);
-	
+
 	if (ieee->data_hard_stop)
 		ieee->data_hard_stop(ieee->dev);
-	
-	ieee80211_stop_send_beacons(ieee);
-		
+
+	ieee80211_stop_send_beacons_rtl7(ieee);
+
 	ieee->state = IEEE80211_LINKED_SCANNING;
 	ieee->link_change(ieee->dev);
-	
-	ieee80211_start_scan_syncro(ieee);
-	
+
+	ieee80211_start_scan_syncro_rtl7(ieee);
+
 	ieee->set_chan(ieee->dev, chan);
-	
+
 	ieee->state = IEEE80211_LINKED;
 	ieee->link_change(ieee->dev);
-	
+
 	if (ieee->data_hard_resume)
 		ieee->data_hard_resume(ieee->dev);
-	
+
 	if(ieee->iw_mode == IW_MODE_ADHOC || ieee->iw_mode == IW_MODE_MASTER)
-		ieee80211_start_send_beacons(ieee);
-	
+		ieee80211_start_send_beacons_rtl7(ieee);
+
 	netif_carrier_on(ieee->dev);
-	
+
 	up(&ieee->wx_sem);
-	
+
 }
 
-int ieee80211_wx_set_scan(struct ieee80211_device *ieee, struct iw_request_info *a,
+int ieee80211_wx_set_scan_rtl7(struct ieee80211_device *ieee, struct iw_request_info *a,
 			     union iwreq_data *wrqu, char *b)
 {
 	int ret = 0;
-	
+
 	down(&ieee->wx_sem);
-	
-	if (ieee->iw_mode == IW_MODE_MONITOR || !(ieee->proto_started)){ 
+
+	if (ieee->iw_mode == IW_MODE_MONITOR || !(ieee->proto_started)){
 		ret = -1;
 		goto out;
 	}
-	
+
 	if ( ieee->state == IEEE80211_LINKED){
 		queue_work(ieee->wq, &ieee->wx_sync_scan_wq);
 		/* intentionally forget to up sem */
 		return 0;
 	}
-		
+
 out:
 	up(&ieee->wx_sem);
 	return ret;
 }
 
-int ieee80211_wx_set_essid(struct ieee80211_device *ieee, 
+int ieee80211_wx_set_essid_rtl7(struct ieee80211_device *ieee,
 			      struct iw_request_info *a,
 			      union iwreq_data *wrqu, char *extra)
 {
-	
+
 	int ret=0,len;
 	short proto_started;
 	unsigned long flags;
-	
+
 	ieee->sync_scan_hurryup = 1;
-	
+
 	down(&ieee->wx_sem);
-	
+
 	proto_started = ieee->proto_started;
-	
+
 	if (wrqu->essid.length > IW_ESSID_MAX_SIZE){
 		ret= -E2BIG;
 		goto out;
 	}
-	
+
 	if (ieee->iw_mode == IW_MODE_MONITOR){
 		ret= -1;
 		goto out;
 	}
-	
+
 	if(proto_started)
-		ieee80211_stop_protocol(ieee);
-	
+		ieee80211_stop_protocol_rtl7(ieee);
+
 	/* this is just to be sure that the GET wx callback
 	 * has consisten infos. not needed otherwise
 	 */
 	spin_lock_irqsave(&ieee->lock, flags);
-	
+
 	if (wrqu->essid.flags && wrqu->essid.length) {
+#if WIRELESS_EXT > 20
+		len = min((int)wrqu->essid.length, IW_ESSID_MAX_SIZE);
+#else
 		len = ((wrqu->essid.length-1) < IW_ESSID_MAX_SIZE) ? (wrqu->essid.length-1) : IW_ESSID_MAX_SIZE;
-		
+#endif
+
 		strncpy(ieee->current_network.ssid, extra, len);
 		ieee->current_network.ssid_len = len;
 		ieee->ssid_set = 1;
 	}
-	else{ 
+	else{
 		ieee->ssid_set = 0;
 		ieee->current_network.ssid[0] = '\0';
 		ieee->current_network.ssid_len = 0;
 	}
-	
+
 	spin_unlock_irqrestore(&ieee->lock, flags);
-	
+
 	if (proto_started)
-		ieee80211_start_protocol(ieee);
+		ieee80211_start_protocol_rtl7(ieee);
 out:
 	up(&ieee->wx_sem);
+
+
 	return ret;
 }
 
- int ieee80211_wx_get_mode(struct ieee80211_device *ieee, struct iw_request_info *a,
+ int ieee80211_wx_get_mode_rtl7(struct ieee80211_device *ieee, struct iw_request_info *a,
 			     union iwreq_data *wrqu, char *b)
 {
 
@@ -385,23 +414,23 @@
 	return 0;
 }
 
- int ieee80211_wx_set_rawtx(struct ieee80211_device *ieee, 
-			       struct iw_request_info *info, 
+ int ieee80211_wx_set_rawtx_rtl7(struct ieee80211_device *ieee,
+			       struct iw_request_info *info,
 			       union iwreq_data *wrqu, char *extra)
 {
-	
+
 	int *parms = (int *)extra;
 	int enable = (parms[0] > 0);
 	short prev = ieee->raw_tx;
 
 	down(&ieee->wx_sem);
-	
-	if(enable) 
+
+	if(enable)
 		ieee->raw_tx = 1;
-	else 
+	else
 		ieee->raw_tx = 0;
 
-	printk(KERN_INFO"raw TX is %s\n", 
+	printk(KERN_INFO"raw TX is %s\n",
 	      ieee->raw_tx ? "enabled" : "disabled");
 
 	if(ieee->iw_mode == IW_MODE_MONITOR)
@@ -409,21 +438,21 @@
 		if(prev == 0 && ieee->raw_tx){
 			if (ieee->data_hard_resume)
 				ieee->data_hard_resume(ieee->dev);
-	
-			netif_carrier_on(ieee->dev);	
+
+			netif_carrier_on(ieee->dev);
 		}
-		
+
 		if(prev && ieee->raw_tx == 1)
-			netif_carrier_off(ieee->dev); 
+			netif_carrier_off(ieee->dev);
 	}
-	
+
 	up(&ieee->wx_sem);
-	
+
 	return 0;
 }
- 
-int ieee80211_wx_get_name(struct ieee80211_device *ieee, 
-			     struct iw_request_info *info, 
+
+int ieee80211_wx_get_name_rtl7(struct ieee80211_device *ieee,
+			     struct iw_request_info *info,
 			     union iwreq_data *wrqu, char *extra)
 {
 	strcpy(wrqu->name, "802.11");
@@ -433,20 +462,20 @@
 			strcat(wrqu->name, "/g");
 	}else if(ieee->modulation & IEEE80211_OFDM_MODULATION)
 		strcat(wrqu->name, "g");
-	
-	if((ieee->state == IEEE80211_LINKED) || 
+
+	if((ieee->state == IEEE80211_LINKED) ||
 		(ieee->state == IEEE80211_LINKED_SCANNING))
 		strcat(wrqu->name," linked");
 	else if(ieee->state != IEEE80211_NOLINK)
 		strcat(wrqu->name," link..");
-	
-	
+
+
 	return 0;
 }
 
 
 /* this is mostly stolen from hostap */
-int ieee80211_wx_set_power(struct ieee80211_device *ieee,
+int ieee80211_wx_set_power_rtl7(struct ieee80211_device *ieee,
 				 struct iw_request_info *info,
 				 union iwreq_data *wrqu, char *extra)
 {
@@ -457,50 +486,50 @@
 		(!ieee->ps_request_tx_ack) ||
 		(!ieee->enter_sleep_state) ||
 		(!ieee->ps_is_queue_empty)){
-		
+
 		printk("ERROR. PS mode is tryied to be use but\
-driver missed a callback\n\n");	
-	
+driver missed a callback\n\n");
+
 		return -1;
 	}
-	
+
 	down(&ieee->wx_sem);
-	
+
 	if (wrqu->power.disabled){
 		ieee->ps = IEEE80211_PS_DISABLED;
-		
+
 		goto exit;
 	}
 	switch (wrqu->power.flags & IW_POWER_MODE) {
 	case IW_POWER_UNICAST_R:
 		ieee->ps = IEEE80211_PS_UNICAST;
-		
+
 		break;
 	case IW_POWER_ALL_R:
-		ieee->ps = IEEE80211_PS_UNICAST | IEEE80211_PS_MBCAST;	
+		ieee->ps = IEEE80211_PS_UNICAST | IEEE80211_PS_MBCAST;
 		break;
-		
+
 	case IW_POWER_ON:
 		ieee->ps = IEEE80211_PS_DISABLED;
 		break;
-		
+
 	default:
 		ret = -EINVAL;
 		goto exit;
 	}
 
 	if (wrqu->power.flags & IW_POWER_TIMEOUT) {
-				      
+
 		ieee->ps_timeout = wrqu->power.value / 1000;
 		printk("Timeout %d\n",ieee->ps_timeout);
 	}
-	
+
 	if (wrqu->power.flags & IW_POWER_PERIOD) {
-		
+
 		ret = -EOPNOTSUPP;
 		goto exit;
 		//wrq->value / 1024;
-		
+
 	}
 exit:
 	up(&ieee->wx_sem);
@@ -509,15 +538,15 @@
 }
 
 /* this is stolen from hostap */
-int ieee80211_wx_get_power(struct ieee80211_device *ieee,
+int ieee80211_wx_get_power_rtl7(struct ieee80211_device *ieee,
 				 struct iw_request_info *info,
 				 union iwreq_data *wrqu, char *extra)
 {
 	int ret =0;
-	
+
 	down(&ieee->wx_sem);
-	
-	if(ieee->ps == IEEE80211_PS_DISABLED){	
+
+	if(ieee->ps == IEEE80211_PS_DISABLED){
 		wrqu->power.disabled = 1;
 		goto exit;
 	}
@@ -547,19 +576,19 @@
 
 }
 
-EXPORT_SYMBOL(ieee80211_wx_get_essid);
-EXPORT_SYMBOL(ieee80211_wx_set_essid);
-EXPORT_SYMBOL(ieee80211_wx_set_rate);
-EXPORT_SYMBOL(ieee80211_wx_get_rate);
-EXPORT_SYMBOL(ieee80211_wx_set_wap);
-EXPORT_SYMBOL(ieee80211_wx_get_wap);
-EXPORT_SYMBOL(ieee80211_wx_set_mode);
-EXPORT_SYMBOL(ieee80211_wx_get_mode);
-EXPORT_SYMBOL(ieee80211_wx_set_scan);
-EXPORT_SYMBOL(ieee80211_wx_get_freq);
-EXPORT_SYMBOL(ieee80211_wx_set_freq);
-EXPORT_SYMBOL(ieee80211_wx_set_rawtx);
-EXPORT_SYMBOL(ieee80211_wx_get_name);
-EXPORT_SYMBOL(ieee80211_wx_set_power);
-EXPORT_SYMBOL(ieee80211_wx_get_power);
-EXPORT_SYMBOL(ieee80211_wlan_frequencies);
+EXPORT_SYMBOL(ieee80211_wx_get_essid_rtl7);
+EXPORT_SYMBOL(ieee80211_wx_set_essid_rtl7);
+EXPORT_SYMBOL(ieee80211_wx_set_rate_rtl7);
+EXPORT_SYMBOL(ieee80211_wx_get_rate_rtl7);
+EXPORT_SYMBOL(ieee80211_wx_set_wap_rtl7);
+EXPORT_SYMBOL(ieee80211_wx_get_wap_rtl7);
+EXPORT_SYMBOL(ieee80211_wx_set_mode_rtl7);
+EXPORT_SYMBOL(ieee80211_wx_get_mode_rtl7);
+EXPORT_SYMBOL(ieee80211_wx_set_scan_rtl7);
+EXPORT_SYMBOL(ieee80211_wx_get_freq_rtl7);
+EXPORT_SYMBOL(ieee80211_wx_set_freq_rtl7);
+EXPORT_SYMBOL(ieee80211_wx_set_rawtx_rtl7);
+EXPORT_SYMBOL(ieee80211_wx_get_name_rtl7);
+EXPORT_SYMBOL(ieee80211_wx_set_power_rtl7);
+EXPORT_SYMBOL(ieee80211_wx_get_power_rtl7);
+EXPORT_SYMBOL(ieee80211_wlan_frequencies_rtl7);
diff -Naur rtl8187_linux_26.1010.0622.2006/ieee80211/ieee80211_tx.c rtl8187_linux_26.1010.0622.2006_rawtx/ieee80211/ieee80211_tx.c
--- rtl8187_linux_26.1010.0622.2006/ieee80211/ieee80211_tx.c	2006-06-06 04:57:54.000000000 +0200
+++ rtl8187_linux_26.1010.0622.2006_rawtx/ieee80211/ieee80211_tx.c	2008-01-30 17:38:11.000000000 +0100
@@ -24,15 +24,14 @@
 
 ******************************************************************************
 
-  Few modifications for Realtek's Wi-Fi drivers by 
+  Few modifications for Realtek's Wi-Fi drivers by
   Andrea Merello <andreamrl@tiscali.it>
-  
-  A special thanks goes to Realtek for their support ! 
+
+  A special thanks goes to Realtek for their support !
 
 ******************************************************************************/
 
 #include <linux/compiler.h>
-#include <linux/config.h>
 #include <linux/errno.h>
 #include <linux/if_arp.h>
 #include <linux/in6.h>
@@ -52,6 +51,12 @@
 #include <linux/etherdevice.h>
 #include <asm/uaccess.h>
 
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19))
+#include <linux/config.h>
+#else
+#include <linux/autoconf.h>
+#endif
+
 #include "ieee80211.h"
 
 
@@ -155,7 +160,7 @@
 static u8 P802_1H_OUI[P80211_OUI_LEN] = { 0x00, 0x00, 0xf8 };
 static u8 RFC1042_OUI[P80211_OUI_LEN] = { 0x00, 0x00, 0x00 };
 
-static inline int ieee80211_put_snap(u8 *data, u16 h_proto)
+static inline int ieee80211_put_snap_rtl7(u8 *data, u16 h_proto)
 {
 	struct ieee80211_snap_hdr *snap;
 	u8 *oui;
@@ -178,7 +183,7 @@
 	return SNAP_SIZE + sizeof(u16);
 }
 
-int ieee80211_encrypt_fragment(
+int ieee80211_encrypt_fragment_rtl7(
 	struct ieee80211_device *ieee,
 	struct sk_buff *frag,
 	int hdr_len)
@@ -225,7 +230,7 @@
 }
 
 
-void ieee80211_txb_free(struct ieee80211_txb *txb) {
+void ieee80211_txb_free_rtl7(struct ieee80211_txb *txb) {
 	int i;
 	if (unlikely(!txb))
 		return;
@@ -235,7 +240,7 @@
 	kfree(txb);
 }
 
-struct ieee80211_txb *ieee80211_alloc_txb(int nr_frags, int txb_size,
+struct ieee80211_txb *ieee80211_alloc_txb_rtl7(int nr_frags, int txb_size,
 					  int gfp_mask)
 {
 	struct ieee80211_txb *txb;
@@ -267,7 +272,7 @@
 }
 
 /* SKBs are added to the ieee->tx_queue. */
-int ieee80211_xmit(struct sk_buff *skb,
+int ieee80211_xmit_rtl7(struct sk_buff *skb,
 		   struct net_device *dev)
 {
 	struct ieee80211_device *ieee = netdev_priv(dev);
@@ -299,27 +304,27 @@
 	}
 
 	if(likely(ieee->raw_tx == 0)){
-	
+
 		if (unlikely(skb->len < SNAP_SIZE + sizeof(u16))) {
 			printk(KERN_WARNING "%s: skb too small (%d).\n",
 			ieee->dev->name, skb->len);
 			goto success;
 		}
-	
-		
+
+
 		ether_type = ntohs(((struct ethhdr *)skb->data)->h_proto);
-	
+
 		crypt = ieee->crypt[ieee->tx_keyidx];
-	
+
 		encrypt = !(ether_type == ETH_P_PAE && ieee->ieee802_1x) &&
 			ieee->host_encrypt && crypt && crypt->ops;
-	
+
 		if (!encrypt && ieee->ieee802_1x &&
 		ieee->drop_unencrypted && ether_type != ETH_P_PAE) {
 			stats->tx_dropped++;
 			goto success;
 		}
-	
+
 	#ifdef CONFIG_IEEE80211_DEBUG
 		if (crypt && !encrypt && ether_type == ETH_P_PAE) {
 			struct eapol *eap = (struct eapol *)(skb->data +
@@ -328,23 +333,23 @@
 				eap_get_type(eap->type));
 		}
 	#endif
-	
+
 		/* Save source and destination addresses */
 		memcpy(&dest, skb->data, ETH_ALEN);
 		memcpy(&src, skb->data+ETH_ALEN, ETH_ALEN);
-	
+
 		/* Advance the SKB to the start of the payload */
 		skb_pull(skb, sizeof(struct ethhdr));
-	
+
 		/* Determine total amount of storage required for TXB packets */
 		bytes = skb->len + SNAP_SIZE + sizeof(u16);
-	
+
 		if (encrypt)
 			fc = IEEE80211_FTYPE_DATA | IEEE80211_STYPE_DATA |
 				IEEE80211_FCTL_WEP;
 		else
 			fc = IEEE80211_FTYPE_DATA | IEEE80211_STYPE_DATA;
-	
+
 		if (ieee->iw_mode == IW_MODE_INFRA) {
 			fc |= IEEE80211_FCTL_TODS;
 			/* To DS: Addr1 = BSSID, Addr2 = SA,
@@ -360,9 +365,9 @@
 			memcpy(&header.addr3, ieee->current_network.bssid, ETH_ALEN);
 		}
 		header.frame_ctl = cpu_to_le16(fc);
-		
+
 		hdr_len = IEEE80211_3ADDR_LEN;
-	
+
 		/* Determine fragmentation size based on destination (multicast
 		* and broadcast are not fragmented) */
 		if (is_multicast_ether_addr(dest) ||
@@ -370,7 +375,7 @@
 			frag_size = MAX_FRAG_THRESHOLD;
 		else
 			frag_size = ieee->fts;
-	
+
 		/* Determine amount of payload per fragment.  Regardless of if
 		* this stack is providing the full 802.11 header, one will
 		* eventually be affixed to this fragment -- so we must account for
@@ -379,12 +384,12 @@
 		if (ieee->config &
 		(CFG_IEEE80211_COMPUTE_FCS | CFG_IEEE80211_RESERVE_FCS))
 			bytes_per_frag -= IEEE80211_FCS_LEN;
-	
+
 		/* Each fragment may need to have room for encryptiong pre/postfix */
 		if (encrypt)
 			bytes_per_frag -= crypt->ops->extra_prefix_len +
 				crypt->ops->extra_postfix_len;
-	
+
 		/* Number of fragments is the total bytes_per_frag /
 		* payload_per_fragment */
 		nr_frags = bytes / bytes_per_frag;
@@ -393,11 +398,11 @@
 			nr_frags++;
 		else
 			bytes_last_frag = bytes_per_frag;
-	
+
 		/* When we allocate the TXB we allocate enough space for the reserve
 		* and full fragment bytes (bytes_per_frag doesn't include prefix,
 		* postfix, header, FCS, etc.) */
-		txb = ieee80211_alloc_txb(nr_frags, frag_size, GFP_ATOMIC);
+		txb = ieee80211_alloc_txb_rtl7(nr_frags, frag_size, GFP_ATOMIC);
 		if (unlikely(!txb)) {
 			printk(KERN_WARNING "%s: Could not allocate TXB\n",
 			ieee->dev->name);
@@ -405,93 +410,94 @@
 		}
 		txb->encrypted = encrypt;
 		txb->payload_size = bytes;
-	
+
 		for (i = 0; i < nr_frags; i++) {
 			skb_frag = txb->fragments[i];
-	
+
 			if (encrypt)
 				skb_reserve(skb_frag, crypt->ops->extra_prefix_len);
-	
+
 			frag_hdr = (struct ieee80211_hdr *)skb_put(skb_frag, hdr_len);
 			memcpy(frag_hdr, &header, hdr_len);
-	
+
 			/* If this is not the last fragment, then add the MOREFRAGS
 			* bit to the frame control */
 			if (i != nr_frags - 1) {
 				frag_hdr->frame_ctl = cpu_to_le16(
 					fc | IEEE80211_FCTL_MOREFRAGS);
 				bytes = bytes_per_frag;
-		
+
 			} else {
 				/* The last fragment takes the remaining length */
 				bytes = bytes_last_frag;
 			}
-			
+
 			frag_hdr->seq_ctl = cpu_to_le16(ieee->seq_ctrl<<4 | i);
-			
-			
+
+
 			/* Put a SNAP header on the first fragment */
 			if (i == 0) {
-				ieee80211_put_snap(
+				ieee80211_put_snap_rtl7(
 					skb_put(skb_frag, SNAP_SIZE + sizeof(u16)),
 					ether_type);
 				bytes -= SNAP_SIZE + sizeof(u16);
 			}
-	
+
 			memcpy(skb_put(skb_frag, bytes), skb->data, bytes);
-	
+
 			/* Advance the SKB... */
 			skb_pull(skb, bytes);
-	
+
 			/* Encryption routine will move the header forward in order
 			* to insert the IV between the header and the payload */
 			if (encrypt)
-				ieee80211_encrypt_fragment(ieee, skb_frag, hdr_len);
+				ieee80211_encrypt_fragment_rtl7(ieee, skb_frag, hdr_len);
 			if (ieee->config &
 			(CFG_IEEE80211_COMPUTE_FCS | CFG_IEEE80211_RESERVE_FCS))
 				skb_put(skb_frag, 4);
 		}
-		// Advance sequence number in data frame. 
+		// Advance sequence number in data frame.
 		if (ieee->seq_ctrl == 0xFFF)
 			ieee->seq_ctrl = 0;
 		else
 			ieee->seq_ctrl++;
 		//---
 	}else{
-		if (unlikely(skb->len < sizeof(struct ieee80211_hdr_3addr))) {
+//		if (unlikely(skb->len < sizeof(struct ieee80211_hdr_3addr))) {
+		if (unlikely(skb->len < 14)) {
 			printk(KERN_WARNING "%s: skb too small (%d).\n",
 			ieee->dev->name, skb->len);
 			goto success;
 		}
-	
-		txb = ieee80211_alloc_txb(1, skb->len, GFP_ATOMIC);
+
+		txb = ieee80211_alloc_txb_rtl7(1, skb->len, GFP_ATOMIC);
 		if(!txb){
 			printk(KERN_WARNING "%s: Could not allocate TXB\n",
 			ieee->dev->name);
 			goto failed;
 		}
-		
+
 		txb->encrypted = 0;
 		txb->payload_size = skb->len;
 		memcpy(skb_put(txb->fragments[0],skb->len), skb->data, skb->len);
-	}	
+	}
 
  success:
 	spin_unlock_irqrestore(&ieee->lock, flags);
 	dev_kfree_skb_any(skb);
 	if (txb) {
 		if (ieee->softmac_features & IEEE_SOFTMAC_TX_QUEUE){
-			ieee80211_softmac_xmit(txb, ieee);
+			ieee80211_softmac_xmit_rtl7(txb, ieee);
 		}else{
 			if ((*ieee->hard_start_xmit)(txb, dev) == 0) {
 				stats->tx_packets++;
 				stats->tx_bytes += txb->payload_size;
 				return 0;
 			}
-			ieee80211_txb_free(txb);
+			ieee80211_txb_free_rtl7(txb);
 		}
-		
-		
+
+
 	}
 
 	return 0;
@@ -504,4 +510,4 @@
 
 }
 
-EXPORT_SYMBOL(ieee80211_txb_free);
+EXPORT_SYMBOL(ieee80211_txb_free_rtl7);
diff -Naur rtl8187_linux_26.1010.0622.2006/ieee80211/ieee80211_wx.c rtl8187_linux_26.1010.0622.2006_rawtx/ieee80211/ieee80211_wx.c
--- rtl8187_linux_26.1010.0622.2006/ieee80211/ieee80211_wx.c	2006-06-06 04:57:56.000000000 +0200
+++ rtl8187_linux_26.1010.0622.2006_rawtx/ieee80211/ieee80211_wx.c	2008-01-30 17:38:11.000000000 +0100
@@ -40,7 +40,7 @@
 };
 
 #define MAX_CUSTOM_LEN 64
-static inline char *ipw2100_translate_scan(struct ieee80211_device *ieee,
+static inline char *ipw2100_translate_scan_rtl7(struct ieee80211_device *ieee,
  					   char *start, char *stop,
 					   struct ieee80211_network *network)
 {
@@ -207,7 +207,7 @@
 	return start;
 }
 
-int ieee80211_wx_get_scan(struct ieee80211_device *ieee,
+int ieee80211_wx_get_scan_rtl7(struct ieee80211_device *ieee,
 			  struct iw_request_info *info,
 			  union iwreq_data *wrqu, char *extra)
 {
@@ -220,13 +220,14 @@
 
 	IEEE80211_DEBUG_WX("Getting scan\n");
 	down(&ieee->wx_sem);
+	printk("GOT WX GET SCAN WX_SEM LOCK");
 	spin_lock_irqsave(&ieee->lock, flags);
 
 	list_for_each_entry(network, &ieee->network_list, list) {
 		i++;
 		if (ieee->scan_age == 0 ||
 		    time_after(network->last_scanned + ieee->scan_age, jiffies))
-			ev = ipw2100_translate_scan(ieee, ev, stop, network);
+			ev = ipw2100_translate_scan_rtl7(ieee, ev, stop, network);
 		else
 			IEEE80211_DEBUG_SCAN(
 				"Not showing network '%s ("
@@ -247,7 +248,7 @@
 	return 0;
 }
 
-int ieee80211_wx_set_encode(struct ieee80211_device *ieee,
+int ieee80211_wx_set_encode_rtl7(struct ieee80211_device *ieee,
 			    struct iw_request_info *info,
 			    union iwreq_data *wrqu, char *keybuf)
 {
@@ -259,6 +260,9 @@
 	int i, key, key_provided, len;
 	struct ieee80211_crypt_data **crypt;
 
+	if (erq->flags & IW_ENCODE_RESTRICTED)
+		return -EINVAL;
+
 	IEEE80211_DEBUG_WX("SET_ENCODE\n");
 
 	key = erq->flags & IW_ENCODE_INDEX;
@@ -281,7 +285,7 @@
 		if (key_provided && *crypt) {
 			IEEE80211_DEBUG_WX("Disabling encryption on key %d.\n",
 					   key);
-			ieee80211_crypt_delayed_deinit(ieee, crypt);
+			ieee80211_crypt_delayed_deinit_rtl7(ieee, crypt);
 		} else
 			IEEE80211_DEBUG_WX("Disabling encryption.\n");
 
@@ -291,7 +295,7 @@
 			if (ieee->crypt[i] != NULL) {
 				if (key_provided)
 					break;
-				ieee80211_crypt_delayed_deinit(
+				ieee80211_crypt_delayed_deinit_rtl7(
 					ieee, &ieee->crypt[i]);
 			}
 		}
@@ -314,7 +318,7 @@
 	    strcmp((*crypt)->ops->name, "WEP") != 0) {
 		/* changing to use WEP; deinit previously used algorithm
 		 * on this key */
-		ieee80211_crypt_delayed_deinit(ieee, crypt);
+		ieee80211_crypt_delayed_deinit_rtl7(ieee, crypt);
 	}
 
 	if (*crypt == NULL) {
@@ -326,10 +330,10 @@
 		if (new_crypt == NULL)
 			return -ENOMEM;
 		memset(new_crypt, 0, sizeof(struct ieee80211_crypt_data));
-		new_crypt->ops = ieee80211_get_crypto_ops("WEP");
+		new_crypt->ops = ieee80211_get_crypto_ops_rtl7("WEP");
 		if (!new_crypt->ops) {
-			request_module("ieee80211_crypt_wep");
-			new_crypt->ops = ieee80211_get_crypto_ops("WEP");
+			request_module("ieee80211_crypt_wep_rtl");
+			new_crypt->ops = ieee80211_get_crypto_ops_rtl7("WEP");
 		}
 
 		if (new_crypt->ops && try_module_get(new_crypt->ops->owner))
@@ -340,7 +344,7 @@
 			new_crypt = NULL;
 
 			printk(KERN_WARNING "%s: could not initialize WEP: "
-			       "load module ieee80211_crypt_wep\n",
+			       "load module ieee80211_crypt_wep_rtl\n",
 			       dev->name);
 			return -EOPNOTSUPP;
 		}
@@ -418,7 +422,7 @@
 	return 0;
 }
 
-int ieee80211_wx_get_encode(struct ieee80211_device *ieee,
+int ieee80211_wx_get_encode_rtl7(struct ieee80211_device *ieee,
 			    struct iw_request_info *info,
 			    union iwreq_data *wrqu, char *keybuf)
 {
@@ -430,7 +434,7 @@
 
 	if(ieee->iw_mode == IW_MODE_MONITOR)
 		return -1;
-	
+
 	key = erq->flags & IW_ENCODE_INDEX;
 	if (key) {
 		if (key > WEP_KEYS)
@@ -470,6 +474,6 @@
 }
 
 
-EXPORT_SYMBOL(ieee80211_wx_get_scan);
-EXPORT_SYMBOL(ieee80211_wx_set_encode);
-EXPORT_SYMBOL(ieee80211_wx_get_encode);
+EXPORT_SYMBOL(ieee80211_wx_get_scan_rtl7);
+EXPORT_SYMBOL(ieee80211_wx_set_encode_rtl7);
+EXPORT_SYMBOL(ieee80211_wx_get_encode_rtl7);
diff -Naur rtl8187_linux_26.1010.0622.2006/ieee80211/Makefile rtl8187_linux_26.1010.0622.2006_rawtx/ieee80211/Makefile
--- rtl8187_linux_26.1010.0622.2006/ieee80211/Makefile	2006-06-06 04:57:54.000000000 +0200
+++ rtl8187_linux_26.1010.0622.2006_rawtx/ieee80211/Makefile	2008-01-30 17:38:11.000000000 +0100
@@ -17,6 +17,7 @@
 KVER  := $(shell uname -r)
 KSRC := /lib/modules/$(KVER)/build
 INSTALL_PREFIX :=
+PWD = $(shell pwd)
 
 all: modules
 
diff -Naur rtl8187_linux_26.1010.0622.2006/ieee80211/Modules.symvers rtl8187_linux_26.1010.0622.2006_rawtx/ieee80211/Modules.symvers
--- rtl8187_linux_26.1010.0622.2006/ieee80211/Modules.symvers	2006-06-06 04:57:56.000000000 +0200
+++ rtl8187_linux_26.1010.0622.2006_rawtx/ieee80211/Modules.symvers	1970-01-01 01:00:00.000000000 +0100
@@ -1,43 +0,0 @@
-0x232e7944	ieee80211_wlan_frequencies	/home/woo/rtl8187_linuxdrv_FC2_V1.1_Src/ieee80211/ieee80211-rtl
-0xaeae102f	free_ieee80211_rtl	/usr/rtl8187_linux_2.6_05312006/ieee80211/ieee80211-rtl
-0x279e265f	ieee80211_crypt_deinit_handler	net/ieee80211/ieee80211_crypt
-0xc2411d91	ieee80211_stop_queue	/home/woo/rtl8187_linuxdrv_FC2_V1.1_Src/ieee80211/ieee80211-rtl
-0x6ece20e1	ieee80211_wx_get_name_rtl	/usr/rtl8187_linux_2.6_05312006/ieee80211/ieee80211-rtl
-0x5d3847ff	ieee80211_rx_rtl	/home/woo/rtl8187_linuxdrv_FC2_V1.1_Src/ieee80211/ieee80211-rtl
-0x18612027	ieee80211_wx_get_scan_rtl	/home/woo/rtl8187_linuxdrv_FC2_V1.1_Src/ieee80211/ieee80211-rtl
-0xa0e03ce1	ieee80211_wx_get_name	/home/woo/rtl8187_linuxdrv_FC2_V1.1_Src/ieee80211/ieee80211-rtl
-0xee25f349	ieee80211_wx_get_mode	/home/woo/rtl8187_linuxdrv_FC2_V1.1_Src/ieee80211/ieee80211-rtl
-0x86013c3d	ieee80211_wx_set_mode	/home/woo/rtl8187_linuxdrv_FC2_V1.1_Src/ieee80211/ieee80211-rtl
-0x04493cc0	ieee80211_wx_get_rate	/home/woo/rtl8187_linuxdrv_FC2_V1.1_Src/ieee80211/ieee80211-rtl
-0x6c6df3b4	ieee80211_wx_set_rate	/home/woo/rtl8187_linuxdrv_FC2_V1.1_Src/ieee80211/ieee80211-rtl
-0x82caec02	ieee80211_crypt_deinit_entries	net/ieee80211/ieee80211_crypt
-0x347945bf	ieee80211_wx_get_power	/home/woo/rtl8187_linuxdrv_FC2_V1.1_Src/ieee80211/ieee80211-rtl
-0x6379d455	ieee80211_wx_set_power	/home/woo/rtl8187_linuxdrv_FC2_V1.1_Src/ieee80211/ieee80211-rtl
-0xae62ed59	ieee80211_wx_set_scan	/home/woo/rtl8187_linuxdrv_FC2_V1.1_Src/ieee80211/ieee80211-rtl
-0x6621e172	ieee80211_wx_set_freq	/home/woo/rtl8187_linuxdrv_FC2_V1.1_Src/ieee80211/ieee80211-rtl
-0x0e052e06	ieee80211_wx_get_freq	/home/woo/rtl8187_linuxdrv_FC2_V1.1_Src/ieee80211/ieee80211-rtl
-0x283f9f5d	ieee80211_unregister_crypto_ops	net/ieee80211/ieee80211_crypt
-0x9da79aac	ieee80211_is_shortslot	/home/woo/rtl8187_linuxdrv_FC2_V1.1_Src/ieee80211/ieee80211-rtl
-0x666032dc	ieee80211_wx_get_wap	/home/woo/rtl8187_linuxdrv_FC2_V1.1_Src/ieee80211/ieee80211-rtl
-0x9f1cbe0e	ieee80211_wx_set_wap	/home/woo/rtl8187_linuxdrv_FC2_V1.1_Src/ieee80211/ieee80211-rtl
-0x73d1d341	ieee80211_wx_set_rawtx	/home/woo/rtl8187_linuxdrv_FC2_V1.1_Src/ieee80211/ieee80211-rtl
-0x2c714184	ieee80211_is_54g	/home/woo/rtl8187_linuxdrv_FC2_V1.1_Src/ieee80211/ieee80211-rtl
-0x6892d598	ieee80211_wpa_supplicant_ioctl	/home/woo/rtl8187_linuxdrv_FC2_V1.1_Src/ieee80211/ieee80211-rtl
-0xc062f1f5	ieee80211_ps_tx_ack	/home/woo/rtl8187_linuxdrv_FC2_V1.1_Src/ieee80211/ieee80211-rtl
-0x55534906	ieee80211_get_beacon	/home/woo/rtl8187_linuxdrv_FC2_V1.1_Src/ieee80211/ieee80211-rtl
-0xe2679638	ieee80211_crypt_delayed_deinit	net/ieee80211/ieee80211_crypt
-0x3a0456bc	free_ieee80211	net/ieee80211/ieee80211
-0x7e1ef2c8	ieee80211_wake_queue	/home/woo/rtl8187_linuxdrv_FC2_V1.1_Src/ieee80211/ieee80211-rtl
-0xc1b81e9f	ieee80211_register_crypto_ops	net/ieee80211/ieee80211_crypt
-0x3f795a39	alloc_ieee80211	net/ieee80211/ieee80211
-0x89803c23	ieee80211_get_crypto_ops	net/ieee80211/ieee80211_crypt
-0xc6caf2a4	ieee80211_txb_free	net/ieee80211/ieee80211
-0x49c1422c	ieee80211_rx_mgt	net/ieee80211/ieee80211
-0xbf2b4ebd	alloc_ieee80211_rtl	/usr/rtl8187_linux_2.6_05312006/ieee80211/ieee80211-rtl
-0xd155f7b8	ieee80211_softmac_stop_protocol	/home/woo/rtl8187_linuxdrv_FC2_V1.1_Src/ieee80211/ieee80211-rtl
-0x9ce2dcde	ieee80211_softmac_start_protocol	/home/woo/rtl8187_linuxdrv_FC2_V1.1_Src/ieee80211/ieee80211-rtl
-0x00d74bba	ieee80211_wx_get_encode_rtl	/home/woo/rtl8187_linuxdrv_FC2_V1.1_Src/ieee80211/ieee80211-rtl
-0x92b5d996	ieee80211_wx_set_encode_rtl	/home/woo/rtl8187_linuxdrv_FC2_V1.1_Src/ieee80211/ieee80211-rtl
-0x2ac9bf95	ieee80211_wx_set_essid	/home/woo/rtl8187_linuxdrv_FC2_V1.1_Src/ieee80211/ieee80211-rtl
-0x7dc92e7f	ieee80211_wx_get_essid	/home/woo/rtl8187_linuxdrv_FC2_V1.1_Src/ieee80211/ieee80211-rtl
-0xd04740ca	ieee80211_reset_queue	/home/woo/rtl8187_linuxdrv_FC2_V1.1_Src/ieee80211/ieee80211-rtl
diff -Naur rtl8187_linux_26.1010.0622.2006/ieee80211/.tmp_versions/ieee80211_crypt_ccmp-rtl.mod rtl8187_linux_26.1010.0622.2006_rawtx/ieee80211/.tmp_versions/ieee80211_crypt_ccmp-rtl.mod
--- rtl8187_linux_26.1010.0622.2006/ieee80211/.tmp_versions/ieee80211_crypt_ccmp-rtl.mod	2006-06-06 04:57:54.000000000 +0200
+++ rtl8187_linux_26.1010.0622.2006_rawtx/ieee80211/.tmp_versions/ieee80211_crypt_ccmp-rtl.mod	2008-02-22 15:33:07.000000000 +0100
@@ -1,2 +1,2 @@
-/usr/rtl8187_linux_2.6_06012006/ieee80211/ieee80211_crypt_ccmp-rtl.ko
-/usr/rtl8187_linux_2.6_06012006/ieee80211/ieee80211_crypt_ccmp.o
+/home/pete/rtl8187_linux_26.1010.0622.2006_rawtx/ieee80211/ieee80211_crypt_ccmp-rtl.ko
+/home/pete/rtl8187_linux_26.1010.0622.2006_rawtx/ieee80211/ieee80211_crypt_ccmp.o
diff -Naur rtl8187_linux_26.1010.0622.2006/ieee80211/.tmp_versions/ieee80211_crypt-rtl.mod rtl8187_linux_26.1010.0622.2006_rawtx/ieee80211/.tmp_versions/ieee80211_crypt-rtl.mod
--- rtl8187_linux_26.1010.0622.2006/ieee80211/.tmp_versions/ieee80211_crypt-rtl.mod	2006-06-06 04:57:54.000000000 +0200
+++ rtl8187_linux_26.1010.0622.2006_rawtx/ieee80211/.tmp_versions/ieee80211_crypt-rtl.mod	2008-02-22 15:33:07.000000000 +0100
@@ -1,2 +1,2 @@
-/usr/rtl8187_linux_2.6_06012006/ieee80211/ieee80211_crypt-rtl.ko
-/usr/rtl8187_linux_2.6_06012006/ieee80211/ieee80211_crypt.o
+/home/pete/rtl8187_linux_26.1010.0622.2006_rawtx/ieee80211/ieee80211_crypt-rtl.ko
+/home/pete/rtl8187_linux_26.1010.0622.2006_rawtx/ieee80211/ieee80211_crypt.o
diff -Naur rtl8187_linux_26.1010.0622.2006/ieee80211/.tmp_versions/ieee80211_crypt_tkip-rtl.mod rtl8187_linux_26.1010.0622.2006_rawtx/ieee80211/.tmp_versions/ieee80211_crypt_tkip-rtl.mod
--- rtl8187_linux_26.1010.0622.2006/ieee80211/.tmp_versions/ieee80211_crypt_tkip-rtl.mod	2006-06-06 04:57:54.000000000 +0200
+++ rtl8187_linux_26.1010.0622.2006_rawtx/ieee80211/.tmp_versions/ieee80211_crypt_tkip-rtl.mod	2008-02-22 15:33:07.000000000 +0100
@@ -1,2 +1,2 @@
-/usr/rtl8187_linux_2.6_06012006/ieee80211/ieee80211_crypt_tkip-rtl.ko
-/usr/rtl8187_linux_2.6_06012006/ieee80211/ieee80211_crypt_tkip.o
+/home/pete/rtl8187_linux_26.1010.0622.2006_rawtx/ieee80211/ieee80211_crypt_tkip-rtl.ko
+/home/pete/rtl8187_linux_26.1010.0622.2006_rawtx/ieee80211/ieee80211_crypt_tkip.o
diff -Naur rtl8187_linux_26.1010.0622.2006/ieee80211/.tmp_versions/ieee80211_crypt_wep-rtl.mod rtl8187_linux_26.1010.0622.2006_rawtx/ieee80211/.tmp_versions/ieee80211_crypt_wep-rtl.mod
--- rtl8187_linux_26.1010.0622.2006/ieee80211/.tmp_versions/ieee80211_crypt_wep-rtl.mod	2006-06-06 04:57:54.000000000 +0200
+++ rtl8187_linux_26.1010.0622.2006_rawtx/ieee80211/.tmp_versions/ieee80211_crypt_wep-rtl.mod	2008-02-22 15:33:07.000000000 +0100
@@ -1,2 +1,2 @@
-/usr/rtl8187_linux_2.6_06012006/ieee80211/ieee80211_crypt_wep-rtl.ko
-/usr/rtl8187_linux_2.6_06012006/ieee80211/ieee80211_crypt_wep.o
+/home/pete/rtl8187_linux_26.1010.0622.2006_rawtx/ieee80211/ieee80211_crypt_wep-rtl.ko
+/home/pete/rtl8187_linux_26.1010.0622.2006_rawtx/ieee80211/ieee80211_crypt_wep.o
diff -Naur rtl8187_linux_26.1010.0622.2006/ieee80211/.tmp_versions/ieee80211-rtl.mod rtl8187_linux_26.1010.0622.2006_rawtx/ieee80211/.tmp_versions/ieee80211-rtl.mod
--- rtl8187_linux_26.1010.0622.2006/ieee80211/.tmp_versions/ieee80211-rtl.mod	2006-06-06 04:57:54.000000000 +0200
+++ rtl8187_linux_26.1010.0622.2006_rawtx/ieee80211/.tmp_versions/ieee80211-rtl.mod	2008-02-22 15:33:07.000000000 +0100
@@ -1,2 +1,2 @@
-/usr/rtl8187_linux_2.6_06012006/ieee80211/ieee80211-rtl.ko
-/usr/rtl8187_linux_2.6_06012006/ieee80211/ieee80211_softmac.o /usr/rtl8187_linux_2.6_06012006/ieee80211/ieee80211_rx.o /usr/rtl8187_linux_2.6_06012006/ieee80211/ieee80211_tx.o /usr/rtl8187_linux_2.6_06012006/ieee80211/ieee80211_wx.o /usr/rtl8187_linux_2.6_06012006/ieee80211/ieee80211_module.o /usr/rtl8187_linux_2.6_06012006/ieee80211/ieee80211_softmac_wx.o
+/home/pete/rtl8187_linux_26.1010.0622.2006_rawtx/ieee80211/ieee80211-rtl.ko
+/home/pete/rtl8187_linux_26.1010.0622.2006_rawtx/ieee80211/ieee80211_softmac.o /home/pete/rtl8187_linux_26.1010.0622.2006_rawtx/ieee80211/ieee80211_rx.o /home/pete/rtl8187_linux_26.1010.0622.2006_rawtx/ieee80211/ieee80211_tx.o /home/pete/rtl8187_linux_26.1010.0622.2006_rawtx/ieee80211/ieee80211_wx.o /home/pete/rtl8187_linux_26.1010.0622.2006_rawtx/ieee80211/ieee80211_module.o /home/pete/rtl8187_linux_26.1010.0622.2006_rawtx/ieee80211/ieee80211_softmac_wx.o
diff -Naur rtl8187_linux_26.1010.0622.2006/makedrv~ rtl8187_linux_26.1010.0622.2006_rawtx/makedrv~
--- rtl8187_linux_26.1010.0622.2006/makedrv~	2006-09-05 07:21:10.000000000 +0200
+++ rtl8187_linux_26.1010.0622.2006_rawtx/makedrv~	1970-01-01 01:00:00.000000000 +0100
@@ -1,13 +0,0 @@
-#!/bin/sh
-
-#tar -zxvf stack.tar.gz
-#tar -zxvf drv.tar.gz
-cd ieee80211
-make clean
-make
-cd ../beta-8187
-make clean
-make
-cd ..
-
-
diff -Naur rtl8187_linux_26.1010.0622.2006/Makefile rtl8187_linux_26.1010.0622.2006_rawtx/Makefile
--- rtl8187_linux_26.1010.0622.2006/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ rtl8187_linux_26.1010.0622.2006_rawtx/Makefile	2008-01-30 17:39:29.000000000 +0100
@@ -0,0 +1,38 @@
+prefix        = /lib/modules/$(shell uname -r)/kernel/drivers/net/wireless
+r8187dir      = $(prefix)/rtl8187
+ieeedir       = $(prefix)/rtl_ieee80211
+
+default: all
+
+all:
+	-rm -f ieee80211/Module.symvers 2>/dev/null
+	-rm -f ieee80211/Modules.symvers 2>/dev/null
+	$(MAKE) -C ieee80211 $(@)
+	-chmod +x symvers
+	-./symvers
+	$(MAKE) -C beta-8187 $(@)
+
+install:
+	install -d $(ieeedir)
+	install -d $(r8187dir)
+	install -m 644 ./ieee80211/*.ko $(ieeedir)
+	install -m 644 ./beta-8187/*.ko $(r8187dir)
+	-depmod -ae
+
+uninstall:
+	-rm -f $(ieeedir)/ieee80211-rtl.ko
+	-rm -f $(ieeedir)/ieee80211_crypt-rtl.ko
+	-rm -f $(ieeedir)/ieee80211_crypt_ccmp-rtl.ko
+	-rm -f $(ieeedir)/ieee80211_crypt_tkip-rtl.ko
+	-rm -f $(ieeedir)/ieee80211_crypt_wep-rtl.ko
+	-rm -f $(r8187dir)/r8187.ko
+	-rm -fr $(ieeedir)
+	-rm -fr $(r8187dir)
+	-depmod -ae
+
+clean:
+	$(MAKE) -C ieee80211 $(@)
+	$(MAKE) -C beta-8187 $(@)
+
+distclean: clean
+
diff -Naur rtl8187_linux_26.1010.0622.2006/ReadMe.txt~ rtl8187_linux_26.1010.0622.2006_rawtx/ReadMe.txt~
--- rtl8187_linux_26.1010.0622.2006/ReadMe.txt~	2006-06-06 10:58:00.000000000 +0200
+++ rtl8187_linux_26.1010.0622.2006_rawtx/ReadMe.txt~	1970-01-01 01:00:00.000000000 +0100
@@ -1,129 +0,0 @@
-Release Date: 2006-01-13, ver 1.1
-RTL8187 Linux driver version 1.1
-
-   --This driver supports RealTek RTL8187 Wireless LAN driver for 
-     Fedora Core 2/3/4/5, Debian 3.1, Mandrake 10.2/Mandriva 2006, 
-     SUSE 9.3/10.1/10.2, Gentoo 3.1, etc.
-   - Support Client mode for either infrastructure or adhoc mode
-   - Support WEP and WPAPSK connection
-
-< Component >
-The driver is composed of several parts:
-	1. Module source code
-	  stack.tar.gz
-	  drv.tar.gz
-	
-	2. Script ot build the modules
-	  makedrv
-
-	3. Script to load/unload modules
-	  wlan0up
-	  wlan0down 
-
-	4. Script and configuration for DHCP
- 	  wlan0dhcp
-	  ifcfg-wlan0
-	4. Supplicant source code:
-	  wpa_supplicant-0.4.9.tar.gz
-
-	5. Example of supplicant configuration file:
-	  wpa1.conf
-
-< Installation >
-Runing the scripts can finish all operations of building up modules 
-from the source code and start the nic.
-	1. Build up the drivers from the source code
-	  ./makedrv
-
-	2. load the driver module to kernel and start up nic
-	  ./wlan0up
-
-< Set wireless lan MIBs >
-This driver uses Wireless Extension as an interface allowing you to set
-Wireless LAN specific parameters.
-
-Current driver supports "iwlist" to show the device status of nic
-        iwlist wlan0 [parameters]
-where
-        parameter explaination      	[parameters]    
-        -----------------------     	-------------   
-        Show available chan and freq	freq / channel  
-        Show and Scan BSS and IBSS 	scan[ning]          
-        Show supported bit-rate         rate / bit[rate]        
-        Show Power Management mode      power             
-
-For example:
-	iwlist wlan0 channel
-	iwlist wlan0 scan
-	iwlist wlan0 rate
-	iwlist wlan0 power
-
-Driver also supports "iwconfig", manipulate driver private ioctls, to set
-MIBs.
-
-	iwconfig wlan0 [parameters] [val]
-where
-	parameter explaination      [parameters]        [val] constraints
-        -----------------------     -------------        ------------------
-        Connect to AP by address    ap              	[mac_addr]
-        Set the essid, join (I)BSS  essid             	[essid]
-        Set operation mode          mode                {Managed|Ad-hoc}
-        Set keys and security mode  key/enc[ryption]    {N|open|restricted|off}
-
-For example:
-	iwconfig wlan0 ap XX:XX:XX:XX:XX:XX
-	iwconfig wlan0 essid "ap_name"
-	iwconfig wlan0 mode Ad-hoc
-	iwconfig wlan0 mode essid "name" mode Ad-hoc
-	iwconfig wlan0 key 0123456789 [2] open
-	iwconfig wlan0 key off
-	iwconfig wlan0 key restricted [3] 0123456789
-
-< Getting IP address >
-After start up the nic, the network needs to obtain an IP address before
-transmit/receive data.
-This can be done by setting the static IP via "ifconfig wlan0 IP_ADDRESS"
-command, or using DHCP.
-
-If using DHCP, setting steps is as below:
-	(1)connect to an AP via "iwconfig" settings
-		iwconfig wlan0 essid [name]	or
-		iwconfig wlan0 ap XX:XX:XX:XX:XX:XX
-
-	(2)run the script which run the dhclient
-		./wlan0dhcp
-		
-< WPAPSK >
-WPA_SUPPLICANT help the network to communicate under the protection of WPAPSK
-mechanism
-	
-	(1)Unpack source code of WPA supplicant:
-	  tar -zxvf wpa_supplicant-0.4.9.tar.gz
-	  cd wpa_supplicant-0.4.9
-	
-	(2)Create .config file:
-	  cp defconfig .config
-	
-	(3)Edit .config file, uncomment the following line:
-	  #CONFIG_DRIVER_IPW=y.
-		
-	(4)Build WPA supplicant:
-	  make
-		
-	(5)Edit wpa_supplicant.conf to set up SSID and its passphrase.
-	  For example, the following setting in "wpa1.conf" means SSID 
-          to join is "BufAG54_Ch6" and its passphrase is "87654321".
-	  network={
-			ssid="BufAG54_Ch6"
-			proto=WPA
-			key_mgmt=WPA-PSK
-			pairwise=CCMP TKIP
-			group=CCMP TKIP WEP104 WEP40
-			psk="87654321"
-			priority=2
-		  }
-
-	(6)Execute WPA supplicant (Assume 8187 and related modules had been
-           loaded):
-	  ./wpa_supplicant -D ipw -c wpa1.conf -i wlan0 &
-
diff -Naur rtl8187_linux_26.1010.0622.2006/symvers rtl8187_linux_26.1010.0622.2006_rawtx/symvers
--- rtl8187_linux_26.1010.0622.2006/symvers	1970-01-01 01:00:00.000000000 +0100
+++ rtl8187_linux_26.1010.0622.2006_rawtx/symvers	2008-01-30 17:38:11.000000000 +0100
@@ -0,0 +1,25 @@
+#!/bin/sh
+
+cd beta-8187
+
+if [ -e Module.symvers ]
+then
+	rm Module.symvers
+fi
+
+if [ -e Modules.symvers ]
+then
+	rm Modules.symvers
+fi
+
+if [ -e ../ieee80211/Module.symvers ]
+then
+	ln -sf ../ieee80211/Module.symvers ./
+fi
+
+if [ -e ../ieee80211/Modules.symvers ]
+then
+	ln -sf ../ieee80211/Modules.symvers ./
+fi
+
+cd ..
diff -Naur rtl8187_linux_26.1010.0622.2006/wlan0rmv rtl8187_linux_26.1010.0622.2006_rawtx/wlan0rmv
--- rtl8187_linux_26.1010.0622.2006/wlan0rmv	2006-09-05 07:21:10.000000000 +0200
+++ rtl8187_linux_26.1010.0622.2006_rawtx/wlan0rmv	2008-01-30 17:38:11.000000000 +0100
@@ -1,5 +1,9 @@
 #!/bin/bash
 
-rmmod r8180
-rmmod ieee80211_r8180
-rmmod ieee80211_crypt_r8180
+rmmod rtl8187 2>/dev/null
+rmmod r8187 2>/dev/null
+rmmod ieee80211_rtl 2>/dev/null
+rmmod ieee80211_crypt_ccmp_rtl 2>/dev/null
+rmmod ieee80211_crypt_tkip_rtl 2>/dev/null
+rmmod ieee80211_crypt_wep_rtl 2>/dev/null
+rmmod ieee80211_crypt_rtl 2>/dev/null
